



# #2 객체 생성과 파괴



## 생성자 대신 정적 팩터리 메서드를 고려하라

- 클래스는 생성자와 별도로 자신의 인스턴스를 반환하는 정적 팩터리 메서드를 제공할 수 있음

**장점**

1. 생성자와 다르게 해당 인스턴스 생성에 대한 메서드 이름을 가질 수 있음 <- 객체의 특성 묘사 가능 
2. 호출될 때마다 인스턴스를 생성하지는 않아도 됨. 미리 만들어둔 인스턴스를 캐싱해서 재활용할 수 있음
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있음 이로 인해 유연성 증가
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있음. 반환 타입의 하위 이기만하면 어떤 클래스의 객체를 반환하든 상관 없음 유연성 증가
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 됨 

**단점**

1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없음
2. 정적 팩터리 메서드는 프로그래머가 찾기 어려움

**정적 팩터리 명명 방식**

- from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환
- of: 여러 매개변수를 받아서 적합한 타입의 인스턴스를 반환
- valueOf: from과 of의 더 자세한 버전
- instance, getInstance: 매개변수로 명시한 인스턴스를 반환하지만 같은 인스턴스임을 보장하지는 않음
- create, newInstance: getInstrance와 비슷하지만 매번 새로운 인스턴스를 반환함을 보장
- getType: getInstrance와 같지만 Type으로 반환할 객체타입 명시함
- newType: newInstance와 같지만 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 씀. Type으로 반환할 객체타입을 명시함
- type: getType과 newType의 간결한 버전

**핵심**

- 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋음 그렇다고 하더라도 정적 팩터리를 사용하는게 유리한 경우가 더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고칠것



## 생성자 매개변수가 많다면 빌더를 고려하라

- 이전에 정적 팩터리와 생성자에는 선택적 매개변수가 많을 때 적절히 대응하기 어려움
- 생성자 오버로딩을 통해서 점증적 생성자 패턴도 쓸 수는 있지만 매개변수가 많아지면 클라이언트 코드를 작성하거나 읽는게 쉽지 않음
- 이때 빌더패턴을 고려할 수 있음
- 빌더 패턴은 파이썬과 스칼라에 있는 명명된 선택적 매개변수를 흉내낸 것임
- 빌더 패턴은 계층적으로 설계도니 크래스와 함께 사용하기 좋음
- 빌더 패턴을 사용하면 매우 유연하게 대처 가능하나 생성하는데 비용이 듦 그래도 빌더 사용할 것

**핵심**

- 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는게 더 낫다.



## private 생성자나 열거 타입으로 싱글턴임을 보증하라

- 싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말함
- 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있음 싱글턴을 가짜 mock으로 대체할 수 없기 때문임
- 정적 팩터리 방식이나 public 필드 방식으로 싱글턴을 구현할 수 있음

**public 필드 방식 장점**

1. 해당 클래스가 싱글턴임이 api 명백히 드러남 
2. 간결함

**정적 팩터리 방식의 장점**

1. api를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있음
2. 유일한 인스턴스를 반환하던 팩터리 메서드가 호출하는 스레드별로 다른 인스턴스를 넘겨주게 할 수 있음
3. 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있음
4. 정적 팩터리의 메서드 참조를 sppplier로 사용할 수 있음

- 추가적으로 원소가 하나인 열거 타입을 선언하는 방법도 있음 대부분의 상황에서는 원소가 하나뿐인 열거 타입으로 싱글턴을 만드는게 가장 좋은 방법임

## 인스턴스화를 막으려거든 private 생성자를 사용하라

- 정적 멤버, 메서드만 갖고 있는 유틸리티 클래스는 기본생성자가 있다는 사실을 인지할 것
- 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없음. 상속해서 만들면 됨
- private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있음

## 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적절하지 않음
- 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식으로 유연하게 해결 가능함
- 클래스가 조금이라도 동작에 변경이 있을 경우 팩터리 느낌으로 객체를 설계할 것

**핵심**

- 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다. 이 자원들을 클래스가 직접 만들게 해서도 안된다. 대신 필요한 자원을 생성자에 넘겨주자. 의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 가져온다.

## 불필요한 객체 생성을 피하라

- 똑같은 기능의 객체를 매번 생성하는 것 보다 객체 하나를 재사용하는게 나을 때가 많음
- 예를 들어 String을 리터럴로 생성하는것과 객체로 생성하는것은 큰 차이임 스트링은 불변이고 스트링풀에 캐싱하기때문에 리터럴로 사용할 것
- String.matches에서 사용하는 Pattern 인스턴스는 한번 사용 이후 바로 가비지 컬렉션의 정리 대상임
- 의도하지 않은 오토박싱이 숨어있지 않도록 할 것

## 다쓴 객체 참조를 해제하라

- 가비지 컬렉션 언어는 의도치 않게 객체를 살려두는 메모리 누수를 찾기가 아주 까다로움
- 객체 참조 하나를 살려두면 여기에 엮인 모든 객체는 가비지 컬렉터가 회수 불가함
- 해당 참조를 다 썼을 때 null 처리 하면 됨. 예를 들어 stack의 pop()같은 경우
- null처리를 통해 추가적으로 이상한 접근까지 제어할 수 있음 NPE
- 그러나 모든 참조에 null을 두는것에 혈안두지말것 객체 참조를 null처리하는 일은 예외적인 경우여야 함
- 일반적으로 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야함
- 캐시 역시 메모리 누수를 일으키는 주범임
- 캐시를 사용할때는 이 캐시된 값의 범위를 지정하기 어려우므로 LinkedHashMap을 통해 LRU를 구현하는 방법을 생각할 것
- 콜백이나 이벤트 리스너도 마찬가지로 계속 쌓일 수 있음 <- WeakHashMap 을 알아볼 것

**핵심**

- 메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있음 이런 누수는 철저한 코드 리뷰느 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 함 그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요함 

## Finalizer와 Cleaner 사용을 피하라

- 자바는 두가지 객체 소멸자 중 finalizer는 예측 불가하고 상황에 따라 위험할 수 있음
- clear 역시 finalizer 보다는 덜 위험하지만 여전히 예측 불가하고 느리고 일반적으로 불필요함
- 자바에서는 try-with-resources와 try-finally를 사용해 해결함
- 그냥 절대 둘다 사용하지 말것

**핵심**

- cleaner는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 생각하고 이런 경우라도 불확실성과 성능 저하에 주의해야함

## try-finally 보다는 try-with-resources를 사용할 것

- 사용후 close해야 하는 객체가 있다면 자바 7에서 나온 try-with-resource를 적극 권장함
- 이 객체들은 반드시 AutoCloseable을 구현해야함

**핵심**

- 꼭 회수해야 하는 자원을 다룰 때는 try-finall 말고 try-with-resources를 사용할 것. 예외는 없고 코드는 더욱 짧고 분명해지고 만들어지는 예외 정보도 훨씬 유용함







# #3 모든 객체의 공통 메서드



## equals는 일반 규약을 지켜 재정의하라

**equals를 재정의 안해도 되는 상황**

1. 각 인스턴스가 본질적으로 고유함
2. 인스턴스의 논리적 동치성을 검사할 일이 없음
3. 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞음
4. 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없음

- equals는 객체 식별성이 아니라 논리적 동치성을 확인해야 하는데 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의 되지 않았을 때임 주로 값 클래스들이 여기에 해당함
- 값 클래스라도 같은 값을 가진 인스턴스가 만들어지지 않음을 보장한다면 필요없음

**equals의 일반 규약**

1. 반사성: null이 아닌 모든 참조 값 x에 대해 x.equals(x) 는 true
2. 대칭성: null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)가 true면 y.equals(x)도 true
3. 추이성: null이 아닌 모든 참조 값 x,y,z에 대해 x.equals(y)가 true면 y.equals(z)이면 x.equals(z)도 true
4. 일관성: null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)는 항상 같은값
5. null-아님: null이 아닌 모든 참조 값 x에 대해 x.equals(null)은 false임

<br>

- 반사성은 단순히 객체는 자기 자신과 같아야 한다는 뜻
- 대칭성은 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 함
- equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응하는지 알 수 없음
- 추이성은 첫번째 객체와 두번째 객체와 같고 두번째 객체와 세번째 객체가 같다면 첫번째와 세번째도 같아야 한다는 뜻
- 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않음!!
- 일관성은 두 객체가 같다면 영원히 같아야 함
- 불변이든 가변이든 equals 의 판단에 신뢰할 수 없는 자원이 끼어 들게 해서는 안됨
- null 검사보다 instanceof 검사가 나음

**양질의 equals 메서드 구현 방법**

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인함
2. instanceof 연산자로 입력이 올바른 타입인지 확인함
3. 입력을 올바른 타입으로 형 변환함
4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사함

- 프리미티브 타입은 ==연산자로 비교하고 참조타입은 equals로 메서드로, float과 double은 compare로 비교할 것
- null을 정상값으로 취급하는 참조 타입 필드는 Object.equals를 사용해서 NPE를 방지할 것
- equals를 사용할때는 가급적 다를 가능성이 크거나 비교하는데 비용이 싼 필드를 먼저 비교할 것

**마지막 주의사항**

1. equals를 재정의할 땐 hashCode도 반드시 재정의할 것
2. 너무 복잡하게 해결하지 말고 필드드르이 동치성만 검사해도 equals 규약을 어렵지 않게 지킬 수 있음
3. equals를 다 구현했다면 대칭적, 추이성, 일관성 세가지만 자문할 것
4. 반드시 Object.equals를 구현할 것. 다른 타입을 리턴하는 건 버그의 요소임 @Override 권장

- 구글의 AutoValue을 권장함

**핵심**

- 꼭 필요한 경우가 아니면 equals를 재정의하지 말자. 많은 경우에 Object의 equals가 원하는 비교를 정확히 수행해준다. 재정의해야 할 때는 그 클래스의 핵심 필드 모두 빠짐 없이 다섯 가지 규약을 확실이 지켜가며 비교해야 한다.

## equals를 재정의하려거든 hashCode도 재정의하라

- equals를 재정의한 클래스 모두에서 hashCode도 재저으이해야 함
- hashcode 일반 규약을 어기면 HashMap, HashSet같은 자료구조에서 문제가 됨

> **Object 명세**
>
> - equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashcode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야함 단 애플리케이션이 재실행되면 달라져도 상관 없음
> - equals가 두 객체를 같다고 판단했다면 두 객체의 hashcode는 똑같은 값을 반환해야함
> - equals가 두 객체를 다르다고 판단했더라도 두 객체의 hashcode가 서로 다른 값을 반환할 필요는 없음 단 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아짐

- hashCode 재정의를 잘못했을때 크게 문제가 되는 조항은 두 번째임 즉 논리적으로 같은 객체는 같은 해시코드를 반환해야함
- 같은 값을 갖는 인스턴스와 객체 타입이라도 hashCode를 구현하지 않으면 Object.hashCode는 다른 객체로 인식하게 함
- 좋은 해시함수는 서로 다른 인스턴스에 다른 해시코드를 반환함

**좋은 hashCode 함수를 작성하는 간단한 요령**

은 책에 있음

- 다른 필드로부터 계산해 낼 수 있는 필드는 모두 무시해도 되고 equals 비교에 사용되지 않은 필드는 반드시 제외해야함
- 해시충돌에 대한 라이브러리는 구아바 참고할 것
- Objects 클래스의 정적메서드 hash를 사용하면 속도는 조금 느리지만 좋은 해시함수로 사용가능함 성능에 민감하지 않다면 사용 가능
- 클래스가 불변이고 해시코드를 계산하는 비용이 크다면 매번 새로 계산하기 보다는 캐싱하는 방식을 고려할 것
- 성능을 높인다고 해시코드를 계산할 때 핵심 필드를 생략해서는 안됨
- hashCode가 반환하는 값의 생성 규칙을 api 사용자에게 자세히 공표하지 말것

**핵심**

- equals를 재정의할 때는 hashCode도 반드시 재정의해야 한다. 그렇지 않으면 프로그램이 제대로 동작하지 않을 것이다. 재정의한 hashCode는 Object의 API문서에 기술된 일반 규약을 따라야 하며, 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 한다. 이렇게 구현하기가 어렵지는 않지만 조금 따분한 일임 ㄱ구글의 AutoValue 를 통해 자동으로 생성하는걸 권장함

## toString을 항상 재정의하라 

- toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고 그 클래스를 사용한 시스템은 디버깅하기 쉬움
- toString은 그 객체가 가진 주요 정보를 모두 반환하는게 좋음
- toString의 포맷을 명시하든 아니든 의도는 명확히 밝혀야함
- 포맷 명시 여부와 상관 없이 toString이 반환한 값에 포함된 정보를 얻어올 수 있는 api를 제공하자
- 포맷이 변경되어도 클라이언트에 영향이 없도록 명세할 것

**핵심**

- 모든 구체 클래스에서 Object의 toString을 재정의하자. 상위 클래스에서 이미 알맞게 재정의한 경우는 예외다. toString을 재정의한 클래스는 사용하기도 즐겁고 그 클래스를 사용한 시스템을 디버깅하기 쉽게 해준다. toString은 해당 객체에 관한 명확하고 유용한 정보를 읽기 좋은 형태로 반환해야 한다.

## clone 재정의는 주의해서 진행하라

- Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스지만 잘 설계되지 않았음 하지만 널리 사용되고 있으니 숙지할 것
- Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며 사용자는 당연히 복제가 제대로 이뤄지리라 기대함 그러나 만약 A <- B 상황에서 B가 super.clone을 했을 경우 B의 인스턴스 복사가 아닌 A인스턴스 복사를 하게됨 주의할 것 <- final 의 경우 상속이 불가하기때문에 안전하게 사용하면 됨
- Object의 clone은 Object를 반환하지만 clone을 재정의해서 다음과 같은 형태로 사용할 것

```java
@Override
public PhoneNumber clone() {
	try {
		return (PhoneNumber) super.clone();
	}catch (CloneNotSupportedException e) {
		throw new AssertionError(); // 일어날 수 없는 일
	}
}
```

- 이런 방식으로 클라이언트에게 형변환 하지 않아도 되게끔 해줄 것
- 만약 clone 하는 객체가 가변 인스턴스 변수를 갖고 있다면 반드시 clone 내부에 재귀적으로 해당 가변 인스턴스를 복제해줄 것!
- 만약 clone 하는 객체가 불변 인스턴스 변수를 갖고 있다면 복제가 불가능할 수 있음 (공유 불가능하다면)
- 가변객체가 연결리스트라면 재귀함수로 deepCopy 하는것 보다 일반 for가 오버플로에 더 안전함
- clone 하는 객체의 내부 인스턴스 참조를 잘 확인해서 적절하게 구현해야함..!
- 모두 요약하면 Cloneable을 구현한 모든 클래스는 clone을 재정의해야함 이때 접근 제한자는 public, 반환 타입은 클래스 자신으로 변경할 것 그리고 이 메서드는 가장 먼저 super.clone을 호출한 후 필요한 필드를 전부 적절히 수정함!
- clone을 구현하지 않아도 복사 생성자와 복사 팩터리라는 더 나은 객체 복사 방식을 제공할 수 있음 가능하면 이 방법이 가장 좋음

**핵심**

Cloneable이 몰고 온 모든 문제를 되지퓨어봤을 때, 새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안되며, 새로운 클래스도 이를 구현해서는 안됨. final 클래스라면 Cloneable을 구현해도 위험이 크지 않지만 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용해야 함 기본 원칙은 복제 기능은 생성자와 팩터리를 이용하는게 최고라는것 단 배열만은 clone 메서드 방식이 가장 깔끔한 이 규칭의 합당한 예외임 

## Comparable을 구현할지 고려하라



- compareTo는 이 객체가 주어진 객체보다 작으면 음의 정수, 같으면 0, 크면 양의정수를 반환함 비교 불가면 ClassCastException을 던짐
- Comparable을 구현하는 것만으로도 굉장한 이득을 볼 수 있음
- eqauls의 규약이랑 매우 비슷해서 반사성, 대칭성, 추이성을 모두 충족해야함
- 만약 A <- B 상황일때 A가 Comparable을 구현했다면 B에서 인스턴스 변수를 추가하면 규약에 어긋나기 때문에 이런 환경에서는 B를 독립적으로 두고 A 인스턴스 변수를 갖도록 구성할 것
- 재미있는 예로 HashSet 인스턴스에서 new BigDecimal("1.0")과  new BigDecimal("1.00")은 두개가 들어가지만 TreeSet에서는 한개만 들어감 TreeSet 같은 정렬 컬렉션은 동치성을 비교할때 equals 대신 compareTo를 사용하기 때문임
- 보통 방식된 기본 타입 클래스들에 추가된 compare를 사용해서 순서비교를 하고 관계연산자인 <와 >를 직접 사용하지 말 것
- 클래스에 핵심 필드가 여러개라면 가장 중요한것 부터 비교할 것
- Comparator 를 람다를 사용한 선언형으로 사용
- 값의 차 같은것을 사용하지 말것 오버플로나 언더플로 우려

**핵심**

- 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여 그 인스턴스들을 쉽게 정렬하고 검색하고 비교 기능을 제공하는 컬렉션과 어우러지도록 해야 한다. compareTo 메서드에서 필드의 값을 비교할 때 <와 > 연산자는 쓰지 말아야 한다. 그 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare  메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.



# #4 클래스와 인터페이스

## 클래스와 멤버의 접근 권한을 최소화 하라

- 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐임
- 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨 구현과 api를 깔끔히 분리함 오직 api로만 통신하며 서로 내부는 신경쓰지 않음

**정보 은닉의 장점(캡슐화)**

1. 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발 가능
2. 시스템 관리 비용을 낮춤. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고 다른 컴포넌트로 교체하는 부담도 적음
3. 정보 은닉 자체가 성능을 높여주지는 않지만 성능 최적화에 도움을 줌. 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있기 때문
4. 소프트웨어 재사용성을 높임 결합도가 낮기 때문
5. 큰 시스템을 제작하는 난이도를 낮춰줌 시스템 전체가 아직 완성되지 않은 상태에서도 개발 컴포넌트의 동작을 검증할 수 있음

<br>

- 자바에서는 클래스, 인터페이스, 멤버의 접근성에 접근 제한자를 잘 사용하는 것이 정보 은닉의 핵심임
- 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 함
- public으로 배포하는순간 그 클래스는 영원히 관리해줘야만 함
- 모든 멤버 변수도 가능하면 접근 가능성을 좁혀줄 것
- 테스트만을 위해 클래스 인터페이스 멤버를 공개 api로 만들면 안됨 package-private 까지는 가능
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 함
- public 가변 필드를 갖는 클래스는 일반적으로 스레드 unsafe임
- 예외적으로 꼭 필요한 상수라면 public static final 필드로 공개해도 됨 <- 반드시 기본 타입이나 불변 객체를 참조해야함
- 길이가 0이 아닌 배열은 모두 변경 가능하니 주의
- 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 절대절대 안됨
- 배열을 반드시 공개하려면 private static final 로 배열 필드를 바꾸고 이것을 제공하는 스태틱 메서드인

```java
public static final Thing[] value() {
	return {private static 타입 배열}.clone() <- 방어적복사
}

//또는 

pulbic static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList({private static 타입 배열}))
```

- 클라이언트가 무엇을 원하느냐를 판단할 것
- 자바9에 추가된 모듈 시스템이라는 개념이 있지만 keep...

**핵심**

- 프로그램 요소의 접근성은 가능한 한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 public API를 설계하자 그 외에는 클래스 인터페이스 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 한다. public 클래스는 상수용 public static ifnal 필드 외에는 어떠한 public 필드도 가져서는 안된다. public static final 필드가 참조하는 객체가 불변인지 확인하라.



## public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

- public 클래스는 private로 멤버변수를 감싸고 이에 접근하는 getter/setter를 적용하는게 옳다
- 하지만 package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다해도 하등의 문제가 없다.
- public 클래스의 필드가 불변이라도 노출 금지

**핵심**

- public 클래스는 절대 가변 필드를 직접 노출해서는 안됨 불변 필드라면 노출해도 덜 위험하지만 완전히 안심 불가능 하지만 package-private 클래스나 private 중첩 클래스는 종종 필드를 노출하는 편이 나을 때가 있음

## 변경 가능성을 최소화하라

- 불변 클래스란 간단히 말해 그 인스턴스의 내부 값을 수정할 수 없는 클래스임
- 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 수간까지 절대 달라지지 않음 String, 프리미티브 타입, BigInteger, BigDecimal이 여기에 속함
- 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉽고 오류도 적고 안전함

**불변 클래스의 규칙**

1. 객체의 상태를 변경하는 메서드를 제공하지 않음
2. 클래스를 확장할 수 없게함 상속을 막음 (또다른 방법으로 모든 생성자를 private 레벨로 잡고 정적 팩터리 메서드를 제공하면 됨)
3. 모든 필드를 final로 선언 
4. 모든 필드를 private으로 선언
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 함

<br>

- 불변객체는 자신의 상태를 변경하지 않음 불변객체는 단순하고 생성된 시점의 상태를 파괴될 때까지 보관함
- 불변객체는 가변적인 부분이 없기 때문에 스레드 safe함
- 불변객체를 한번 만들면 최대한 재사용할 것 (내생각이지만 플라이웨이트 패턴  ..?)
- 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유 가능
- 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많음
- 좋은 예로 불변객체는 map의 키, set의 원소로 사용하기 좋음
- 불변 객체는 그 자체로 실패 원자성을 제공함 <- 메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태여야 함
- 단점은 값이 다르면 반드시 독립된 객체로 만들어야 함
- getter가 있다고 반드시 setter를 넣지 말 것 클래스는 꼭 필요한 경우가 아니라면 불변이다
- 모든 클래스를 불변으로 만들수는 없고 불변으로 만들 수 없는 클래스라도 변경 부분은 최소한으로 줄이자
- 다른 합당한 이유가 없다면 모든 필드는 private final 이어야 함
- 새엇ㅇ자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야함 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 공개하면 안됨
- 인스턴스 초기화 메서드도 복잡하기만하고 성능 이점 없음 새로 생성하는게 나음



## 상속보다는 컴포지션을 사용하라

- 메서드호출과 달리 상속은 캡슐화를 깨트림 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있고 하위 클래스에 문제가 생길 수 있음 
- 여러가지 문제가 있는데 피하는 방법은 기존 클래스를 확장하는 대신 새로운 클래스로 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하면 됨
- 이런 방법을 컴포지션이라고함 새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출 해 그 결과를 반환함 이 방식을 전달이라고하고 메서드를 전달 메서드라고 함
- 상속은 반드시 하위 클래스가 상위 크래스의 진짜 하위 타입인 상황에서만 써야함 이 외에는 컴포지션을 사용한 래퍼클래스를 활용할 것
- 래퍼클래스의 단점은 콜백 프레임워크에서를 제외하고 거의 없음
- 컴포지션을 써야할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴임

**핵심**

- 상속은 강력하지만 캡슐화를 해친다는 문제가 있음 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야함 is-a 관계일 때도 안심할 수 만은 없는게 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있음. 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용할 것 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱. 래퍼 클래스는 하위 클래스보다 견고하고 강력함

## 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

- 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 함 상속용 클래스는 재정의 할 수 있는 메서들을 내부적으로 어떻게 이용하는지 문서로 남겨야 함 
- 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있음
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일함
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야함
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안됨
- clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안됨
- 클래스를 상속용으로 설계하려면 엄청난 노력과 클래스 내부 제약이 있음
- 상속용으로 설계하지 않은 클래스는 상속을 금지시킬 것

**핵심**

- 상속용 클래스를 설계하기란 결코 만만치 않음. 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야하고 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 함 그러지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있음 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있음 그러니 클래스를 확장해야 할 이유가 떠오르지 ㅇ낳으면 상속을 금지시킬것 상속을 금지하려면 클래스슬 final로 선언하거나 정적 팩터리 메서드 제공





## 추상 클래스보다는 인터페이스를 우선하라

- 추상 클래스 방식은 새로운 타입을 정의하는데 커다란 제약이 있음 인터페이스는 impleament를 통해 구현하면 끝이지만 추상클래스는 계층구조에서 조상이어야하고 새로 추가된 추상클래스가 있다면 모든 자손이 이를 상속하게 됨 
- 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있음
- 인터페이스는 믹스인 정의가 가능하지만 추상클래스는 불가함
- 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있음
- 인터페이스는 기능을 향상 시키는 안전하고 강력한 수단이 됨
- 골격 구현 클래스의 아름다움은 추상 클래스처럼 구현을 도와주는 동시에 추상 클래스로 타입을 정의할 때 따라오는 심각한 제약에서는 자유로움
- 공격 구현 클래스를 사용해볼것 ex Collections

**핵심**

- 일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합함 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법을 꼭 고려해볼 것 골격 구현은 가능한 한 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋음 가능한 한이라고 한 이유는 인터페이스에 걸려 있는 구현상의 제약 때문에 골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 때문



## 인터페이스는 구현하는 쪽을 생각해 설계하라

- 자바7 이전에는 기존 인터페이스를 깨트리지 않고 메서드를 추가하는 방법이 없었으나 자바 8에서는 디폴트 메서드를 통해 메서드를 추가할 수 있음 하지만 최대한 범용적으로 설계해야함
- 디폴트 메서드는 기존 구현체에 런타임 오류를 일으킬 수 있음 따라서 기존 인터페이스에 디폴트 메서드를 추가하는 것은 최대한 피해야함
- 디폴트 메서드가 있더라도 인터페이스를 설계할때는 최대한 신중하게 할 것
- 인터페이스를 릴리스한 후라도 결함을 수정하는게 가능한 경우가 있지만 절대 그 가능성에 기대하면 아노딤



## 인터페이스는 타입을 정의하는 용도만 사용하라

- 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것임 인터페이스는 오직 이용도로만 사용해야함
- 상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예임

**핵심**

- 인터페이스는 타입을 정의하는 용도로만 사용해야 함. 상수 공개용 수단으로 사용하지 말것.



## 태그 달린 클래스보다는 클래스 계층구조를 활용하라

- 태그 달린 클래스는 장황하고 오류를 내기 쉽고 비효율적임
- 클래스 계층구조를 활용한 서브타이핑을 사용할 것 태그 달린 클래스는 클래스 계층구조를 어설프게 흉내내기만 함
- 가장 먼저 계층구조의 루트가 도리 추상 클래스를 정의하고 태그 값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언함
- 모든 하위에서 사용하는 필드도 전부 루트 클래스로 옮김
- 태그에 따라 달라지는 메서드도 전부 루트 클래스로 옮김
- 루트 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의함

**핵심**

- 태그 달린 클래스를 써야 하는 상황은 거의 없음. 새로운 클래스를 작성하는데 태그 필드가 등장한다면 태그를 없애고 계층구조로 대체하는 방법을 생각해 볼 것. 기존 클래스가 태그 필드를 사용하고 있다면 계층 구조로 리팩터링 하는걸 고민해 볼 것



## 멤버 클래스는 되도록 static으로 만들라

- 중첩클래스란 다른 클래스안에 정의된 클래스임 이 클래스는 자신을 감싸는 클래스 내부에서만 사용해야함
- 중첩클래스의 종류는 정적 멤버 클래스, 멤버클래스, 익명 클래스, 지역 클래스 총 네가지임
- 정적 클래스는 다른 클래스 안에 선언되고 바깥 클래스의 private 멤버에도 접근할 수 있는 점만 제외하고 일반 클래스와 동일함
- 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결됨 
- 비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없음 따라서 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 함
- 비정적 멤버 클래스는 보통 어댑터 패턴에서 많이 사용함
- 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들것
- private 정적 멤버 클래스는 바깥 클래스가 표현하는 객체의 한 부분을 나타낼 때 사용함

**핵심**

- 중첩 클래스에는 네가지가 있고 각각 쓰임이 다름 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 멤버 클래스로 만듬
- 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적, 그렇지 않으면 정적으로 만들 것, 중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 익명 클래스로 만들어도 좋음 아니라면 지역클래스로 만들 것



## 톱레벨 클래스는 한 파일에 하나만 담으라

- 컴파일러에게 어느 소스파일을 먼저 건네느냐에 따라 동작이 달라짐으로 바로잡아야함
- 해결책은 간단하게 톱레벨 클래스들을 서로 다른 소스 파일로 분리하면 됨
- 굳이 톱레벨로 만들어 한 파일에 담고 싶다면 정적 멤버 클래스로 만드는 선택도 있음

**핵심**

- 소스 파일 하나에는 반드시 톱레벨 클래스를 하나만 담자 이 규칙만 따르면 컴파일러가 한 클래스에 대한 정의를 여러개 만들어 내는 일은 사라짐 소스 파일을 어떤 순서로 컴파일하든 바이너리 파일이나 프로그램의 동작이 달라지는 일은 결코 일어나지 않을 것









## 

