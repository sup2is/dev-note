



# #2 객체 생성과 파괴



## 생성자 대신 정적 팩터리 메서드를 고려하라

- 클래스는 생성자와 별도로 자신의 인스턴스를 반환하는 정적 팩터리 메서드를 제공할 수 있음

**장점**

1. 생성자와 다르게 해당 인스턴스 생성에 대한 메서드 이름을 가질 수 있음 <- 객체의 특성 묘사 가능 
2. 호출될 때마다 인스턴스를 생성하지는 않아도 됨. 미리 만들어둔 인스턴스를 캐싱해서 재활용할 수 있음
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있음 이로 인해 유연성 증가
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있음. 반환 타입의 하위 이기만하면 어떤 클래스의 객체를 반환하든 상관 없음 유연성 증가
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 됨 

**단점**

1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없음
2. 정적 팩터리 메서드는 프로그래머가 찾기 어려움

**정적 팩터리 명명 방식**

- from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환
- of: 여러 매개변수를 받아서 적합한 타입의 인스턴스를 반환
- valueOf: from과 of의 더 자세한 버전
- instance, getInstance: 매개변수로 명시한 인스턴스를 반환하지만 같은 인스턴스임을 보장하지는 않음
- create, newInstance: getInstrance와 비슷하지만 매번 새로운 인스턴스를 반환함을 보장
- getType: getInstrance와 같지만 Type으로 반환할 객체타입 명시함
- newType: newInstance와 같지만 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 씀. Type으로 반환할 객체타입을 명시함
- type: getType과 newType의 간결한 버전

**핵심**

- 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋음 그렇다고 하더라도 정적 팩터리를 사용하는게 유리한 경우가 더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고칠것



## 생성자 매개변수가 많다면 빌더를 고려하라

- 이전에 정적 팩터리와 생성자에는 선택적 매개변수가 많을 때 적절히 대응하기 어려움
- 생성자 오버로딩을 통해서 점증적 생성자 패턴도 쓸 수는 있지만 매개변수가 많아지면 클라이언트 코드를 작성하거나 읽는게 쉽지 않음
- 이때 빌더패턴을 고려할 수 있음
- 빌더 패턴은 파이썬과 스칼라에 있는 명명된 선택적 매개변수를 흉내낸 것임
- 빌더 패턴은 계층적으로 설계도니 크래스와 함께 사용하기 좋음
- 빌더 패턴을 사용하면 매우 유연하게 대처 가능하나 생성하는데 비용이 듦 그래도 빌더 사용할 것

**핵심**

- 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는게 더 낫다.



## private 생성자나 열거 타입으로 싱글턴임을 보증하라

- 싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말함
- 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있음 싱글턴을 가짜 mock으로 대체할 수 없기 때문임
- 정적 팩터리 방식이나 public 필드 방식으로 싱글턴을 구현할 수 있음

**public 필드 방식 장점**

1. 해당 클래스가 싱글턴임이 api 명백히 드러남 
2. 간결함

**정적 팩터리 방식의 장점**

1. api를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있음
2. 유일한 인스턴스를 반환하던 팩터리 메서드가 호출하는 스레드별로 다른 인스턴스를 넘겨주게 할 수 있음
3. 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있음
4. 정적 팩터리의 메서드 참조를 sppplier로 사용할 수 있음

- 추가적으로 원소가 하나인 열거 타입을 선언하는 방법도 있음 대부분의 상황에서는 원소가 하나뿐인 열거 타입으로 싱글턴을 만드는게 가장 좋은 방법임

## 인스턴스화를 막으려거든 private 생성자를 사용하라

- 정적 멤버, 메서드만 갖고 있는 유틸리티 클래스는 기본생성자가 있다는 사실을 인지할 것
- 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없음. 상속해서 만들면 됨
- private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있음

## 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적절하지 않음
- 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식으로 유연하게 해결 가능함
- 클래스가 조금이라도 동작에 변경이 있을 경우 팩터리 느낌으로 객체를 설계할 것

**핵심**

- 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다. 이 자원들을 클래스가 직접 만들게 해서도 안된다. 대신 필요한 자원을 생성자에 넘겨주자. 의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 가져온다.

## 불필요한 객체 생성을 피하라

- 똑같은 기능의 객체를 매번 생성하는 것 보다 객체 하나를 재사용하는게 나을 때가 많음
- 예를 들어 String을 리터럴로 생성하는것과 객체로 생성하는것은 큰 차이임 스트링은 불변이고 스트링풀에 캐싱하기때문에 리터럴로 사용할 것
- String.matches에서 사용하는 Pattern 인스턴스는 한번 사용 이후 바로 가비지 컬렉션의 정리 대상임
- 의도하지 않은 오토박싱이 숨어있지 않도록 할 것

## 다쓴 객체 참조를 해제하라

- 가비지 컬렉션 언어는 의도치 않게 객체를 살려두는 메모리 누수를 찾기가 아주 까다로움
- 객체 참조 하나를 살려두면 여기에 엮인 모든 객체는 가비지 컬렉터가 회수 불가함
- 해당 참조를 다 썼을 때 null 처리 하면 됨. 예를 들어 stack의 pop()같은 경우
- null처리를 통해 추가적으로 이상한 접근까지 제어할 수 있음 NPE
- 그러나 모든 참조에 null을 두는것에 혈안두지말것 객체 참조를 null처리하는 일은 예외적인 경우여야 함
- 일반적으로 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야함
- 캐시 역시 메모리 누수를 일으키는 주범임
- 캐시를 사용할때는 이 캐시된 값의 범위를 지정하기 어려우므로 LinkedHashMap을 통해 LRU를 구현하는 방법을 생각할 것
- 콜백이나 이벤트 리스너도 마찬가지로 계속 쌓일 수 있음 <- WeakHashMap 을 알아볼 것

**핵심**

- 메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있음 이런 누수는 철저한 코드 리뷰느 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 함 그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요함 

## Finalizer와 Cleaner 사용을 피하라

- 자바는 두가지 객체 소멸자 중 finalizer는 예측 불가하고 상황에 따라 위험할 수 있음
- clear 역시 finalizer 보다는 덜 위험하지만 여전히 예측 불가하고 느리고 일반적으로 불필요함
- 자바에서는 try-with-resources와 try-finally를 사용해 해결함
- 그냥 절대 둘다 사용하지 말것

**핵심**

- cleaner는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 생각하고 이런 경우라도 불확실성과 성능 저하에 주의해야함

## try-finally 보다는 try-with-resources를 사용할 것

- 사용후 close해야 하는 객체가 있다면 자바 7에서 나온 try-with-resource를 적극 권장함
- 이 객체들은 반드시 AutoCloseable을 구현해야함

**핵심**

- 꼭 회수해야 하는 자원을 다룰 때는 try-finall 말고 try-with-resources를 사용할 것. 예외는 없고 코드는 더욱 짧고 분명해지고 만들어지는 예외 정보도 훨씬 유용함







# #3 모든 객체의 공통 메서드



## equals는 일반 규약을 지켜 재정의하라

**equals를 재정의 안해도 되는 상황**

1. 각 인스턴스가 본질적으로 고유함
2. 인스턴스의 논리적 동치성을 검사할 일이 없음
3. 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞음
4. 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없음

- equals는 객체 식별성이 아니라 논리적 동치성을 확인해야 하는데 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의 되지 않았을 때임 주로 값 클래스들이 여기에 해당함
- 값 클래스라도 같은 값을 가진 인스턴스가 만들어지지 않음을 보장한다면 필요없음

**equals의 일반 규약**

1. 반사성: null이 아닌 모든 참조 값 x에 대해 x.equals(x) 는 true
2. 대칭성: null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)가 true면 y.equals(x)도 true
3. 추이성: null이 아닌 모든 참조 값 x,y,z에 대해 x.equals(y)가 true면 y.equals(z)이면 x.equals(z)도 true
4. 일관성: null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)는 항상 같은값
5. null-아님: null이 아닌 모든 참조 값 x에 대해 x.equals(null)은 false임

<br>

- 반사성은 단순히 객체는 자기 자신과 같아야 한다는 뜻
- 대칭성은 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 함
- equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응하는지 알 수 없음
- 추이성은 첫번째 객체와 두번째 객체와 같고 두번째 객체와 세번째 객체가 같다면 첫번째와 세번째도 같아야 한다는 뜻
- 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않음!!
- 일관성은 두 객체가 같다면 영원히 같아야 함
- 불변이든 가변이든 equals 의 판단에 신뢰할 수 없는 자원이 끼어 들게 해서는 안됨
- null 검사보다 instanceof 검사가 나음

**양질의 equals 메서드 구현 방법**

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인함
2. instanceof 연산자로 입력이 올바른 타입인지 확인함
3. 입력을 올바른 타입으로 형 변환함
4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사함

- 프리미티브 타입은 ==연산자로 비교하고 참조타입은 equals로 메서드로, float과 double은 compare로 비교할 것
- null을 정상값으로 취급하는 참조 타입 필드는 Object.equals를 사용해서 NPE를 방지할 것
- equals를 사용할때는 가급적 다를 가능성이 크거나 비교하는데 비용이 싼 필드를 먼저 비교할 것

**마지막 주의사항**

1. equals를 재정의할 땐 hashCode도 반드시 재정의할 것
2. 너무 복잡하게 해결하지 말고 필드드르이 동치성만 검사해도 equals 규약을 어렵지 않게 지킬 수 있음
3. equals를 다 구현했다면 대칭적, 추이성, 일관성 세가지만 자문할 것
4. 반드시 Object.equals를 구현할 것. 다른 타입을 리턴하는 건 버그의 요소임 @Override 권장

- 구글의 AutoValue을 권장함

**핵심**

- 꼭 필요한 경우가 아니면 equals를 재정의하지 말자. 많은 경우에 Object의 equals가 원하는 비교를 정확히 수행해준다. 재정의해야 할 때는 그 클래스의 핵심 필드 모두 빠짐 없이 다섯 가지 규약을 확실이 지켜가며 비교해야 한다.

## equals를 재정의하려거든 hashCode도 재정의하라

- equals를 재정의한 클래스 모두에서 hashCode도 재저으이해야 함
- hashcode 일반 규약을 어기면 HashMap, HashSet같은 자료구조에서 문제가 됨

> **Object 명세**
>
> - equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashcode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야함 단 애플리케이션이 재실행되면 달라져도 상관 없음
> - equals가 두 객체를 같다고 판단했다면 두 객체의 hashcode는 똑같은 값을 반환해야함
> - equals가 두 객체를 다르다고 판단했더라도 두 객체의 hashcode가 서로 다른 값을 반환할 필요는 없음 단 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아짐

- hashCode 재정의를 잘못했을때 크게 문제가 되는 조항은 두 번째임 즉 논리적으로 같은 객체는 같은 해시코드를 반환해야함
- 같은 값을 갖는 인스턴스와 객체 타입이라도 hashCode를 구현하지 않으면 Object.hashCode는 다른 객체로 인식하게 함
- 좋은 해시함수는 서로 다른 인스턴스에 다른 해시코드를 반환함

**좋은 hashCode 함수를 작성하는 간단한 요령**

은 책에 있음

- 다른 필드로부터 계산해 낼 수 있는 필드는 모두 무시해도 되고 equals 비교에 사용되지 않은 필드는 반드시 제외해야함
- 해시충돌에 대한 라이브러리는 구아바 참고할 것
- Objects 클래스의 정적메서드 hash를 사용하면 속도는 조금 느리지만 좋은 해시함수로 사용가능함 성능에 민감하지 않다면 사용 가능
- 클래스가 불변이고 해시코드를 계산하는 비용이 크다면 매번 새로 계산하기 보다는 캐싱하는 방식을 고려할 것
- 성능을 높인다고 해시코드를 계산할 때 핵심 필드를 생략해서는 안됨
- hashCode가 반환하는 값의 생성 규칙을 api 사용자에게 자세히 공표하지 말것

**핵심**

- equals를 재정의할 때는 hashCode도 반드시 재정의해야 한다. 그렇지 않으면 프로그램이 제대로 동작하지 않을 것이다. 재정의한 hashCode는 Object의 API문서에 기술된 일반 규약을 따라야 하며, 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 한다. 이렇게 구현하기가 어렵지는 않지만 조금 따분한 일임 ㄱ구글의 AutoValue 를 통해 자동으로 생성하는걸 권장함

## toString을 항상 재정의하라 

- toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고 그 클래스를 사용한 시스템은 디버깅하기 쉬움
- toString은 그 객체가 가진 주요 정보를 모두 반환하는게 좋음
- toString의 포맷을 명시하든 아니든 의도는 명확히 밝혀야함
- 포맷 명시 여부와 상관 없이 toString이 반환한 값에 포함된 정보를 얻어올 수 있는 api를 제공하자
- 포맷이 변경되어도 클라이언트에 영향이 없도록 명세할 것

**핵심**

- 모든 구체 클래스에서 Object의 toString을 재정의하자. 상위 클래스에서 이미 알맞게 재정의한 경우는 예외다. toString을 재정의한 클래스는 사용하기도 즐겁고 그 클래스를 사용한 시스템을 디버깅하기 쉽게 해준다. toString은 해당 객체에 관한 명확하고 유용한 정보를 읽기 좋은 형태로 반환해야 한다.

## clone 재정의는 주의해서 진행하라

- Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스지만 잘 설계되지 않았음 하지만 널리 사용되고 있으니 숙지할 것
- Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며 사용자는 당연히 복제가 제대로 이뤄지리라 기대함 그러나 만약 A <- B 상황에서 B가 super.clone을 했을 경우 B의 인스턴스 복사가 아닌 A인스턴스 복사를 하게됨 주의할 것 <- final 의 경우 상속이 불가하기때문에 안전하게 사용하면 됨
- Object의 clone은 Object를 반환하지만 clone을 재정의해서 다음과 같은 형태로 사용할 것

```java
@Override
public PhoneNumber clone() {
	try {
		return (PhoneNumber) super.clone();
	}catch (CloneNotSupportedException e) {
		throw new AssertionError(); // 일어날 수 없는 일
	}
}
```

- 이런 방식으로 클라이언트에게 형변환 하지 않아도 되게끔 해줄 것
- 만약 clone 하는 객체가 가변 인스턴스 변수를 갖고 있다면 반드시 clone 내부에 재귀적으로 해당 가변 인스턴스를 복제해줄 것!
- 만약 clone 하는 객체가 불변 인스턴스 변수를 갖고 있다면 복제가 불가능할 수 있음 (공유 불가능하다면)
- 가변객체가 연결리스트라면 재귀함수로 deepCopy 하는것 보다 일반 for가 오버플로에 더 안전함
- clone 하는 객체의 내부 인스턴스 참조를 잘 확인해서 적절하게 구현해야함..!
- 모두 요약하면 Cloneable을 구현한 모든 클래스는 clone을 재정의해야함 이때 접근 제한자는 public, 반환 타입은 클래스 자신으로 변경할 것 그리고 이 메서드는 가장 먼저 super.clone을 호출한 후 필요한 필드를 전부 적절히 수정함!
- clone을 구현하지 않아도 복사 생성자와 복사 팩터리라는 더 나은 객체 복사 방식을 제공할 수 있음 가능하면 이 방법이 가장 좋음

**핵심**

Cloneable이 몰고 온 모든 문제를 되지퓨어봤을 때, 새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안되며, 새로운 클래스도 이를 구현해서는 안됨. final 클래스라면 Cloneable을 구현해도 위험이 크지 않지만 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용해야 함 기본 원칙은 복제 기능은 생성자와 팩터리를 이용하는게 최고라는것 단 배열만은 clone 메서드 방식이 가장 깔끔한 이 규칭의 합당한 예외임 

## Comparable을 구현할지 고려하라



- compareTo는 이 객체가 주어진 객체보다 작으면 음의 정수, 같으면 0, 크면 양의정수를 반환함 비교 불가면 ClassCastException을 던짐
- Comparable을 구현하는 것만으로도 굉장한 이득을 볼 수 있음
- eqauls의 규약이랑 매우 비슷해서 반사성, 대칭성, 추이성을 모두 충족해야함
- 만약 A <- B 상황일때 A가 Comparable을 구현했다면 B에서 인스턴스 변수를 추가하면 규약에 어긋나기 때문에 이런 환경에서는 B를 독립적으로 두고 A 인스턴스 변수를 갖도록 구성할 것
- 재미있는 예로 HashSet 인스턴스에서 new BigDecimal("1.0")과  new BigDecimal("1.00")은 두개가 들어가지만 TreeSet에서는 한개만 들어감 TreeSet 같은 정렬 컬렉션은 동치성을 비교할때 equals 대신 compareTo를 사용하기 때문임
- 보통 방식된 기본 타입 클래스들에 추가된 compare를 사용해서 순서비교를 하고 관계연산자인 <와 >를 직접 사용하지 말 것
- 클래스에 핵심 필드가 여러개라면 가장 중요한것 부터 비교할 것
- Comparator 를 람다를 사용한 선언형으로 사용
- 값의 차 같은것을 사용하지 말것 오버플로나 언더플로 우려

**핵심**

- 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여 그 인스턴스들을 쉽게 정렬하고 검색하고 비교 기능을 제공하는 컬렉션과 어우러지도록 해야 한다. compareTo 메서드에서 필드의 값을 비교할 때 <와 > 연산자는 쓰지 말아야 한다. 그 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare  메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.



# #4 클래스와 인터페이스

## 클래스와 멤버의 접근 권한을 최소화 하라

- 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐임
- 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨 구현과 api를 깔끔히 분리함 오직 api로만 통신하며 서로 내부는 신경쓰지 않음

**정보 은닉의 장점(캡슐화)**

1. 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발 가능
2. 시스템 관리 비용을 낮춤. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고 다른 컴포넌트로 교체하는 부담도 적음
3. 정보 은닉 자체가 성능을 높여주지는 않지만 성능 최적화에 도움을 줌. 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있기 때문
4. 소프트웨어 재사용성을 높임 결합도가 낮기 때문
5. 큰 시스템을 제작하는 난이도를 낮춰줌 시스템 전체가 아직 완성되지 않은 상태에서도 개발 컴포넌트의 동작을 검증할 수 있음

<br>

- 자바에서는 클래스, 인터페이스, 멤버의 접근성에 접근 제한자를 잘 사용하는 것이 정보 은닉의 핵심임
- 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 함
- public으로 배포하는순간 그 클래스는 영원히 관리해줘야만 함
- 모든 멤버 변수도 가능하면 접근 가능성을 좁혀줄 것
- 테스트만을 위해 클래스 인터페이스 멤버를 공개 api로 만들면 안됨 package-private 까지는 가능
- public 클래스의 인스턴스 필드는 되도록 public이 아니어야 함
- public 가변 필드를 갖는 클래스는 일반적으로 스레드 unsafe임
- 예외적으로 꼭 필요한 상수라면 public static final 필드로 공개해도 됨 <- 반드시 기본 타입이나 불변 객체를 참조해야함
- 길이가 0이 아닌 배열은 모두 변경 가능하니 주의
- 클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 절대절대 안됨
- 배열을 반드시 공개하려면 private static final 로 배열 필드를 바꾸고 이것을 제공하는 스태틱 메서드인

```java
public static final Thing[] value() {
	return {private static 타입 배열}.clone() <- 방어적복사
}

//또는 

pulbic static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList({private static 타입 배열}))
```

- 클라이언트가 무엇을 원하느냐를 판단할 것
- 자바9에 추가된 모듈 시스템이라는 개념이 있지만 keep...

**핵심**

- 프로그램 요소의 접근성은 가능한 한 최소한으로 하라. 꼭 필요한 것만 골라 최소한의 public API를 설계하자 그 외에는 클래스 인터페이스 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 한다. public 클래스는 상수용 public static ifnal 필드 외에는 어떠한 public 필드도 가져서는 안된다. public static final 필드가 참조하는 객체가 불변인지 확인하라.



## public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

- public 클래스는 private로 멤버변수를 감싸고 이에 접근하는 getter/setter를 적용하는게 옳다
- 하지만 package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다해도 하등의 문제가 없다.
- public 클래스의 필드가 불변이라도 노출 금지

**핵심**

- public 클래스는 절대 가변 필드를 직접 노출해서는 안됨 불변 필드라면 노출해도 덜 위험하지만 완전히 안심 불가능 하지만 package-private 클래스나 private 중첩 클래스는 종종 필드를 노출하는 편이 나을 때가 있음

## 변경 가능성을 최소화하라

- 불변 클래스란 간단히 말해 그 인스턴스의 내부 값을 수정할 수 없는 클래스임
- 불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 수간까지 절대 달라지지 않음 String, 프리미티브 타입, BigInteger, BigDecimal이 여기에 속함
- 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉽고 오류도 적고 안전함

**불변 클래스의 규칙**

1. 객체의 상태를 변경하는 메서드를 제공하지 않음
2. 클래스를 확장할 수 없게함 상속을 막음 (또다른 방법으로 모든 생성자를 private 레벨로 잡고 정적 팩터리 메서드를 제공하면 됨)
3. 모든 필드를 final로 선언 
4. 모든 필드를 private으로 선언
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 함

<br>

- 불변객체는 자신의 상태를 변경하지 않음 불변객체는 단순하고 생성된 시점의 상태를 파괴될 때까지 보관함
- 불변객체는 가변적인 부분이 없기 때문에 스레드 safe함
- 불변객체를 한번 만들면 최대한 재사용할 것 (내생각이지만 플라이웨이트 패턴  ..?)
- 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유 가능
- 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많음
- 좋은 예로 불변객체는 map의 키, set의 원소로 사용하기 좋음
- 불변 객체는 그 자체로 실패 원자성을 제공함 <- 메서드에서 예외가 발생한 후에도 그 객체는 여전히 유효한 상태여야 함
- 단점은 값이 다르면 반드시 독립된 객체로 만들어야 함
- getter가 있다고 반드시 setter를 넣지 말 것 클래스는 꼭 필요한 경우가 아니라면 불변이다
- 모든 클래스를 불변으로 만들수는 없고 불변으로 만들 수 없는 클래스라도 변경 부분은 최소한으로 줄이자
- 다른 합당한 이유가 없다면 모든 필드는 private final 이어야 함
- 새엇ㅇ자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야함 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 공개하면 안됨
- 인스턴스 초기화 메서드도 복잡하기만하고 성능 이점 없음 새로 생성하는게 나음



## 상속보다는 컴포지션을 사용하라

- 메서드호출과 달리 상속은 캡슐화를 깨트림 상위 클래스는 릴리스마다 내부 구현이 달라질 수 있고 하위 클래스에 문제가 생길 수 있음 
- 여러가지 문제가 있는데 피하는 방법은 기존 클래스를 확장하는 대신 새로운 클래스로 만들고 private 필드로 기존 클래스의 인스턴스를 참조하게 하면 됨
- 이런 방법을 컴포지션이라고함 새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출 해 그 결과를 반환함 이 방식을 전달이라고하고 메서드를 전달 메서드라고 함
- 상속은 반드시 하위 클래스가 상위 크래스의 진짜 하위 타입인 상황에서만 써야함 이 외에는 컴포지션을 사용한 래퍼클래스를 활용할 것
- 래퍼클래스의 단점은 콜백 프레임워크에서를 제외하고 거의 없음
- 컴포지션을 써야할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴임

**핵심**

- 상속은 강력하지만 캡슐화를 해친다는 문제가 있음 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야함 is-a 관계일 때도 안심할 수 만은 없는게 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있음. 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용할 것 특히 래퍼 클래스로 구현할 적당한 인터페이스가 있다면 더욱. 래퍼 클래스는 하위 클래스보다 견고하고 강력함

## 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

- 메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 함 상속용 클래스는 재정의 할 수 있는 메서들을 내부적으로 어떻게 이용하는지 문서로 남겨야 함 
- 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있음
- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일함
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야함
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안됨
- clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안됨
- 클래스를 상속용으로 설계하려면 엄청난 노력과 클래스 내부 제약이 있음
- 상속용으로 설계하지 않은 클래스는 상속을 금지시킬 것

**핵심**

- 상속용 클래스를 설계하기란 결코 만만치 않음. 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야하고 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 함 그러지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있음 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있음 그러니 클래스를 확장해야 할 이유가 떠오르지 ㅇ낳으면 상속을 금지시킬것 상속을 금지하려면 클래스슬 final로 선언하거나 정적 팩터리 메서드 제공





## 추상 클래스보다는 인터페이스를 우선하라

- 추상 클래스 방식은 새로운 타입을 정의하는데 커다란 제약이 있음 인터페이스는 impleament를 통해 구현하면 끝이지만 추상클래스는 계층구조에서 조상이어야하고 새로 추가된 추상클래스가 있다면 모든 자손이 이를 상속하게 됨 
- 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있음
- 인터페이스는 믹스인 정의가 가능하지만 추상클래스는 불가함
- 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있음
- 인터페이스는 기능을 향상 시키는 안전하고 강력한 수단이 됨
- 골격 구현 클래스의 아름다움은 추상 클래스처럼 구현을 도와주는 동시에 추상 클래스로 타입을 정의할 때 따라오는 심각한 제약에서는 자유로움
- 공격 구현 클래스를 사용해볼것 ex Collections

**핵심**

- 일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합함 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법을 꼭 고려해볼 것 골격 구현은 가능한 한 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋음 가능한 한이라고 한 이유는 인터페이스에 걸려 있는 구현상의 제약 때문에 골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 때문



## 인터페이스는 구현하는 쪽을 생각해 설계하라

- 자바7 이전에는 기존 인터페이스를 깨트리지 않고 메서드를 추가하는 방법이 없었으나 자바 8에서는 디폴트 메서드를 통해 메서드를 추가할 수 있음 하지만 최대한 범용적으로 설계해야함
- 디폴트 메서드는 기존 구현체에 런타임 오류를 일으킬 수 있음 따라서 기존 인터페이스에 디폴트 메서드를 추가하는 것은 최대한 피해야함
- 디폴트 메서드가 있더라도 인터페이스를 설계할때는 최대한 신중하게 할 것
- 인터페이스를 릴리스한 후라도 결함을 수정하는게 가능한 경우가 있지만 절대 그 가능성에 기대하면 아노딤



## 인터페이스는 타입을 정의하는 용도만 사용하라

- 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것임 인터페이스는 오직 이용도로만 사용해야함
- 상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예임

**핵심**

- 인터페이스는 타입을 정의하는 용도로만 사용해야 함. 상수 공개용 수단으로 사용하지 말것.



## 태그 달린 클래스보다는 클래스 계층구조를 활용하라

- 태그 달린 클래스는 장황하고 오류를 내기 쉽고 비효율적임
- 클래스 계층구조를 활용한 서브타이핑을 사용할 것 태그 달린 클래스는 클래스 계층구조를 어설프게 흉내내기만 함
- 가장 먼저 계층구조의 루트가 도리 추상 클래스를 정의하고 태그 값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언함
- 모든 하위에서 사용하는 필드도 전부 루트 클래스로 옮김
- 태그에 따라 달라지는 메서드도 전부 루트 클래스로 옮김
- 루트 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의함

**핵심**

- 태그 달린 클래스를 써야 하는 상황은 거의 없음. 새로운 클래스를 작성하는데 태그 필드가 등장한다면 태그를 없애고 계층구조로 대체하는 방법을 생각해 볼 것. 기존 클래스가 태그 필드를 사용하고 있다면 계층 구조로 리팩터링 하는걸 고민해 볼 것



## 멤버 클래스는 되도록 static으로 만들라

- 중첩클래스란 다른 클래스안에 정의된 클래스임 이 클래스는 자신을 감싸는 클래스 내부에서만 사용해야함
- 중첩클래스의 종류는 정적 멤버 클래스, 멤버클래스, 익명 클래스, 지역 클래스 총 네가지임
- 정적 클래스는 다른 클래스 안에 선언되고 바깥 클래스의 private 멤버에도 접근할 수 있는 점만 제외하고 일반 클래스와 동일함
- 비정적 멤버 클래스의 인스턴스는 바깥 클래스의 인스턴스와 암묵적으로 연결됨 
- 비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없음 따라서 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 함
- 비정적 멤버 클래스는 보통 어댑터 패턴에서 많이 사용함
- 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들것
- private 정적 멤버 클래스는 바깥 클래스가 표현하는 객체의 한 부분을 나타낼 때 사용함

**핵심**

- 중첩 클래스에는 네가지가 있고 각각 쓰임이 다름 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 멤버 클래스로 만듬
- 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적, 그렇지 않으면 정적으로 만들 것, 중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 익명 클래스로 만들어도 좋음 아니라면 지역클래스로 만들 것



## 톱레벨 클래스는 한 파일에 하나만 담으라

- 컴파일러에게 어느 소스파일을 먼저 건네느냐에 따라 동작이 달라짐으로 바로잡아야함
- 해결책은 간단하게 톱레벨 클래스들을 서로 다른 소스 파일로 분리하면 됨
- 굳이 톱레벨로 만들어 한 파일에 담고 싶다면 정적 멤버 클래스로 만드는 선택도 있음

**핵심**

- 소스 파일 하나에는 반드시 톱레벨 클래스를 하나만 담자 이 규칙만 따르면 컴파일러가 한 클래스에 대한 정의를 여러개 만들어 내는 일은 사라짐 소스 파일을 어떤 순서로 컴파일하든 바이너리 파일이나 프로그램의 동작이 달라지는 일은 결코 일어나지 않을 것





# #5 제네릭

## Raw 타입은 사용하지 말라

- 클래스와 인터페이스 선언에 타입 파라미터가 쓰이면 이를 제네릭 클래스 또는 제네릭 인터페이스라고 함
- 로타입이란 제네릭타입에서 타입 파라미터를 사용하지 않을 때
- 컴파일타임에서 오류를 잡을 수 없고 잘못된 타입으로 캐스팅시 런타임 오류가 날 수 있음
- List와 `List<Object>` 는 다름 단순 List는 제네릭 타입에서 완전히 제외된 것이고 `List<Object>`는  모든 타입을 받는다 일 뿐임
- 제네릭타입을 쓰고싶지만 넘어오는 타입을 모를때는 ? 와일드 카드를 쓸 것
- class 리터럴에는 로타입을 써야함 ex :List.class
- instanceof 도 로타입을 써야함 

**핵심**

- 로 타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안됨. 로 타입은 제네릭이 도입되기 이전 코드와 호환성을 위해 제공될 뿐이고 빠르게 훑어보자면 `Set<Object>`는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입이, `Set<?>` 은 모종의 타입 객체만 저장할 수 있는 와일드카드 타입임 로타입은 안전하지 않음





## 비검사 경고를 제거하라

- 할 수 있는 한 모든 비검사 경고를 제거할 것 제거한다면 타입 안전성이 보장됨
- 경고를 제거할 수는 없지만 타입 안전하다고 확신이 가능하다면 @SuppressWarnings("unchecked")를 달아 경고를 숨길것
- @SuppressWarnings은 가능한 좁은 범위에서 사용하고 절대적으로 클레스레벨은 피할것
- @SuppressWarnings 애너테이션을 사용할 때면 그 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야 함

**핵심**

- 비검사 경고는 중요하니 무시하지 말 것, 모든 비검사 경고는 런타임에 에러를 일으킬 수 있는 잠재적 가능성을 뜻하니 최선을 다해 제거할 것 경고를 없앨 방법을 찾지 못했다면 그 코드가 타입 안전함을 증명하고 @SuppressWarnings을 사용해서 숨긴 뒤 주석을 달아 놓을 것





## 배열보다는 리스트를 사용하라

- 배열과 제네릭 타입에는 중요한 차이가 두가지 있음 배열은 공변임 상위 타입이 있으면 함께변하지만 제네릭은 불공변임
- 배열에서는 그 실수를 런타임에서 확인할 수 있지만 리스트를 사용하면 컴파일 타임에 잡을 수 있음
- 제네릭 배열은 제네릭타입으로 선언할 수 없음 <- 타입 안정성 때문
- 타입안전성을 보장하는 제네릭을 사용할 것

**핵심**

- 배열과 제네릭에는 매우 다른 타입 규칙이 적용됨. 배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가 소거됨. 그 결과 배열은 런타임에는 타입 안전하지만 컴파일타임에는 그렇지 않고 제네릭은 반대임 둘을 섞어 쓰다가 만약 컴파일 오류나 경고를 난다면 배열을 리스트로 바꾸는 것을 적용해볼 것





## 이왕이면 제네릭 타입으로 만들어라



**핵심**

- 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 아전하고 쓰기 편함 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 할 것 그렇게 하려면 제네릭 타입으로 만들어야할 경우가 많음 기존 타입 중 제네릭이었어야 하는 게있다면 제네릭 타입으로 변경할 것 기존 클라이언트에는 아무 영향을 주지 않으면서 새로운 사용자를 훨씬 편하게 해주는 길임



## 이왕이면 제네릭 메서드로 만들어라

- 타입 매개변수 목록은 메서드의 제한자와 반환 타입 사이에 옴
- 재귀적 한정 타입으로 타입매개변수의 범위를 지정할 수 있음

**핵심**

- 제네릭 타입과 마찬가지로 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기도 쉬움 타입과 마찬가지로 메서드도 형변환 없이 사용할 수 있는 편이 좋으며, 많은 경우 그렇게하려면 제네릭 메서드가 되어야함. 역시 타입과 마찬가지로, 형변환을 해줘야 하는 기존 메서드는 제네릭하게 만들자. 기존 클라이언트는 그대로 둔 채 새로운 사용자의 삶을 훨씬 편하게 만들어 줄 것이다.



## 한정적 와일드카드를 사용해 api 유연성을 높이라

- 매개변수화 타입은 불공변이다. 즉 서로 다른 타입 Type1과 Type2가 있을때 `List<Type1>`은 `List<Type2>`의 하위 타입도 상위 타입도 아니다.
- `List<Object>` `List<String>` 도 마찬가지임 서로 관계 없음 불공변!
- 때로는 불공변보다 조금 더 유연한 방식이 필요함
- 불공변보다 아주 조금 유연하게 동작하려면 한정적 와일드카드를 사용해서 api의 유연성을 높일 수 있음
- 유연성을 극대화하려면 원소의 생산자나 소비자용 입력 매개변수에 와일드카드 타입을 사용하라
- 입력 매개변수가 생산자와 소비자 역할을 동시에 한다면 와일드카드 타입을 써도 좋을 게 없음
- 와일드 카드 공식: 펙스(PECS): producer-extends, consumer-super
- 클래스 사용자가 와일드카드 타입을 신경 써야 한다면 그 api에 무슨 문제가 있을 가능성이 큼
- 메서드 선언에 타입 매개변수가 한번만 나오면 와일드 카드로 대체하라

**핵심**

- 조금 복잡하더라도 와일드카드 타입을 적용하면 api가 훨씬 유연해진다 그러니 널리 쓰일 라이브러리를 작성한다면 반드시 와일드카드 타입을 적절히 사용해줘야 한다. pecs 공식을 기억하자 생산자는 extends를 소비자는 super를 사용한다. Comparable과 Comparator는 모두 소비자라는 사실도 잊지 말 것!



## 제네릭과 가변인수를 함께 쓸 때는 신중하라

- 제네릭과 가변인수를 혼용하면 타입 안전성이 깨지게 됨
- @SafeVarargs 애너테이션은 메서드 작성자가 그 메서드가 타입 안전함을 보장하는 장치임
- 메서드가 varargs 매개변수 배열에 아무것도 저장하지 않고 그 배열의 참조가 밖으로 노출되지 않는다면 타입 안전함
- 안전한 제네릭이나 매개변수화 타입의 varargs 매개변수를 받는 모든 메서드에 @SafeVarars를 달것

**핵심**

- 가변인수와 제네릭은 궁합이 좋지 않다. 가변인수 기능은 배열을 노출하여 추상화가 완벽하지 못하고, 배열과 제네릭의 타입 규칙이 서로 다르기 때문임. 제네릭 varargs 매개변수는 타입 안전하지는 않지만 허요됨. 메서드에 제네릭 varargs 매개변수르 사용하고자 한다면, 먼저 그 메서드가 타입 안전한지 확인한 다음 @SafeVarargs 애너테이션을 달아 사용하는데 불편함을 없게끔 할 것



## 타입 안전 이종 컨테이너를 고려하라

- `Map<Class<?>, Object>` 형식으로 사용하면 이종 컨테이너의 기능을 누릴 수 있음 여러개의 다른 인스턴스 타입을 담는 map

**핵심**

- 컬렉션 api로 대표되는 일반적인 제네릭 형태에서는 한 컨테이너가 다룰 수 있는 타입 매개변수의 수가 고정되어 있음. 하지만 컨테이너 자체가 아닌 키를 타입 매개변수로 바꾸면 이런 제약이 없는 타입 안전 이종 컨테이너를 만들 수 있음 타입 안전 이종 컨테이너는 Class를 키로 쓰며, 이런식으로 쓰이는 Class 객체를 타입 토큰이라고 함 또한 직접 구현한 키 타입도 쓸 수 있음 





# #6열거 타입과 애너테이션

## int 상수 대신 열거 타입을 사용하라

- 열거 타입은 일정 개수의 상수 값을 정의한 다음 그 외의 값은 허용하지 않는 타입임
- public static final int ... 같은 정수 열거 패턴은 매우 구림
- 자바의 열거타입은 완전한 형태의 클래스라서 강력함
- 열거타입 자체는 클래스이며 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개함
- 열거타입은 인스턴스가 한개밖에 안만들어짐 <- 싱글턴?
- 컴파일타임에 안전성보장 가능
- 임의의 메서드나 필드를 추가할 수 있고 임의의 인터페이스를 구현하게 할 수도 있음
- 열거 타입 상수 각각을 특정 데이터와 연관지으려면 생서아젱서 데이터를 받아 인스턴스 필드에 저장하면 됨
- 열거 타입을 선언한 클래스 혹은 그 패키지에서만 유용한 기능은 private이나 package-private 메서드로 구현해야 함
- 열거타입에서 상수를 제거한다고하더라도 직접 그참조를 갖고 있지 않은 이상 전혀 상관없음 갖고있다고 하더라도 다시 컴파일할때 참조하는 줄에서 컴파일오류가 발생함
- 열거 타입에 상수별 메서드 구현을 쓸 수 있음
- 상수별 메서드 구현에서는 열거 타입 상수끼리 코드를 공유하기 어렵다는 단점이 있음
- switch 문은 열거 타입의 상수별 동작을 구현하는데 적합하지 않음 하지만 기존 열거 타입에 상수별 동작을 혼합해 넣을 때는 switch 문이 좋은 선택이 될 수 있음
- 필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항사 열거 타입을 사용할 것
- 열거 타입에 정의된 상수 개수가 영원히 고정 불변일 필요는 없음

**핵심**

- 열거 타입은 확실히 정수 상수보다 뛰어남. 더 읽기 쉽고 안전하고 강력함. 대다수 열거 타입이 명시적 생성자나 메서드 없이 쓰이지만 각 상수를 특정 데이터와 연결짓거나  상수마다 다르게 동작하게 할 때는 필요함. 드물게는 하나의 메서드가 상수별로 다르게 동작해야 할 때도 있음. 이런 열거 타입에서는 switch 문 대신 상수별 메서드 구현을 사용할 것. 열거 타입 상수 일부가 같은 동작을 공유한다면 전략 열거 타입 패턴을 사용하자.

## ordinal 메서드 대신 인스턴스 필드를 사용하라

- 대부분의 열거 타입 상수는 자연스럽게 하나의 정수값에 대응되고 모든 열거타입은 해당 상수가 그 열거타입에서 몇번째위치인지를 반환하는 ordinal이라는 메서드를 제공함
- 그냥 쓰지말것 유지보수가 너무힘들어짐

## 비트 필드 대신 EnumSet을 사용하라

- enumset 클래스는 열거 타입 상수의 값으로 구성된 집합을 효과적으로 표현해줌
- Set을 완벽히 구현하며 타입 안전하고 다른 어떤 Set 구현체와도 함께 사용할 수 있음

**핵심**

- 열거할 수 있는 타입을 한데 모아 집합 형태로 사용한다고 해도 비트 필드를 사용할 이유는 없음. EnumSet 클래스가 비트 필드 수준의 명료함과성능을 제공하고 아이템 34에서 설명한 열거 타입의 장점까지 선사하기 때문임 Enumset의 유일한 단점이라면 불변 EnumSet을 만들수 없다는 것. 자바 11까지 안됨

## ordinal 인덱싱 대신 EnumMap을 사용하라

- 배열이나 리스트에서 원소를 꺼낼 때 ordinal 메서드로 인덱스를 얻지말고 EnumMap을 사용할것 
- EnumMap은 그 내부에서 배열을 사용하기 때문임 내부 구현 방식을 안으로 숨겨서 Map의 타입 안정성과 배열의 성능을 모두 얻어낼 수 있음

**핵심**ㅊ무ㅁ

- 배열의 인덱스를 얻기 위해 ordinal을 쓰는 것은 일반적으로 좋지 않으니 대신 EnumMap을 사용하라

## 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라

- 열거타입의 확장이 필요하면 인터페이스로 선언해서 구현체를 만들것
- 열거 타입 끼리 구현을 상속할 수는 없음

**핵심**

- 열거 타입 자체는 확장할 수 없지만 인터페이스와 그 인터페이스를 구현하는 기본 열거 타입을 함께 사용해 같은 효과를 낼 수 있다. 이렇게 하면 클라이언트는 이인터페이스를 구현해 자신만의 열거 타입을 만들 수 있다. 그리고 api가 인터페이스 기반으로 작성되었다면 기본 열거 타입의 인스턴스가 쓰이는 모든 곳을 새로 확장한 열거 타입의 인스턴스로 대체해 사용할 수 있다.

## 명명 패턴보다 애너테이션을 사용하라

- 명명 패턴의 예로 junit 3에서는 모든 메서드가 test로 시작했어야함 그다지 안좋은 패턴임 이런 경우 애너테이션을 사용하면 됨
- 애너테이션으로 할 수 있는 일을 명명 패턴으로 처리할 이유는 없음

## @Override 애너테이션을 일관되게 사용하라

- @Override를 일관되게 사용하면 악명 높은 버거들을 예방해 줌
- 상위 클래스의 메서드를 재정의하려는 모든 메서드에 @Override 에너테이션을 달자.

**핵심**

- 재정의한 모든 메서드에 @Override 애너테이션을 의식적으로 달면 여러분이 실수했을 때 컴파일러가 바로 알려줄 것이다. 예외는 한가지 뿐이다. 구체 클래스에서 상위 클래스의 추상 매서드를 재정의한 경우엔 이 애너테이션을 달지 않아도 되지만 그냥 달것

## 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

- 아무 메서드도 담고 있지 않고 단지 자신을 구현하는 클래스가 특정 속성 가짐을 표시해주는 인터페이스를 마커 인터페이스라고 함 ex Serializable
- 마커 인터페이스는 두가지 면에서 마커 애너테이션 보다 나음
- 첫째, 마커 인터페이스는 이를 구현한 클래스들의 인스턴스들을 구분하는 타입으로 쓸 수 있으나 마커 애너테이션은 그렇지 않음
- 둘째,마커 인터페이스가 나은 점 두 번째는 적용 대상을 더 정밀하게 지정할 수 있다는 것임
- 반대로 마커 인터페이스의 장점은 거대한 에너테이션 시스템의 지원을 받는다는 점
- 마킹이 된 객체를 매개변수로 받는 메서드를 작성할 일이 있으면 마커 인터페이스를 쓰는게 맞음 아니라면 마커 애너테이션

**핵심**

- 마커 인터페이스와 마커 애너테이션은 각자의 쓰임이 있다. 새로 추가하는 메서드 없이 단지 타입 정의가 목표라면 마커 인터페이스를 선택하자. 클래스나 인터페이스 외의 프로그램 요소에 마킹해야 하거나, 애너테이션을 적극 활용하는 프레임워크의 일부로 그 마커를 편입시키고자 한다면 마커 애너테이션이 올바른 선택이다. 적용 대상이 ElementType.TYPE인 마커 애너테이션을 작성하고 있다면 잠시 여유를 갖고 정말 애너테이션으로 구현하는게 옳은지 마커 인터페이스가 낫지는 않을지 고민해보자.





# #7 람다와 스트림

## 익명 클래스보다는 람다를 사용하라

- 타입을 명시해야 코드가 더 명확할 때만 제외하고는 람다의 모든 매개변수 타입은 생략하자.
- 람다는 이름이 없고 문서화도 못한다. 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 함 한줄, 길어야 세줄임
- 람다에서 this는 자기자신이 아니라 바깥 인스턴스를 가르킴
- 람다를 직렬화 하는 일은 극히 삼가야함

**핵심**

- 자바가 8로 판올리되면서 작은 함수 객체를 구현하는데 적합한 람다가 도입되었다. 익명 클래스는 타입의 인스턴스를 만들때만 사용하라. 람다는 작은 함수 객체를 아주 쉽게 표현할 수 있어 함수형 프로그래밍의 지표를 열었다.

## 람다보다는 메서드 참조를 사용하라

- 람다가 익명 클래스보다 나은 점 중에서 가장 큰 특징은 간결함임 그러나 람다보다 더 간결한 메서드 참조가 있음
- 람다로 할 수 없다면 메서드참조로도 할 수 없음

**핵심**

- 메서드 참조는 람다의 간단명료한 대안이 될 수 잇다. 메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고 그렇지 않을때만 람다를 사용하라

## 표준 함수형 인터페이스를 사용하라

- 필요한 용도에 맞는게 있다면 직접 구현하지 말고 표준 함수형 인터페이스를 활용할 것. java.util.function에 미리 작성된거 ..
- Operator는 인수가 1개인 UnaryOperator와 2개인 BinaryOperator로 나뉘며 반환값과 인수의 타입이 같은 함수
- Prdeicate는 인수 하나를 받아 boolean을 반환
- Function은 인수와 반환타입이 다름
- Supplier는 인수를 받지 않고 반환 또는 제공하는 함수
- Consumer는 인수를 받고 반환값은 없는 함수
- 기본 인터페이스는 가본타입 int, long, double로 각 3개씩 변형되어서 생김
- 표준 함수형 인터페이스에 박싱된 기본 타입을 넣어 사용하지는 말자
- 정말 없을때만 직접 작성할 것
- 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용할 것

**핵심**

- 이제 자바도 람다를 지원한다. 여러분도 지금부터는 api를 설계할 때 람다도 염두에 두어야 한다는 뜻이다. 입력값과 반환값에 함수형 인터페이스 타입을 활용하라. 보통은 java.util.function 패키지의 표준 함수형 인터페이스를 사용하는 것이 가장 좋은 선택이다. 단 흔치는 않지만 직접 새로운 함수형 인터페이스를 만들어 쓰는 편이 나을수도 있음을 잊지 말자.

## 스트림은 주의해서 사용하라

- 스트림 api는 다량의 데이터 처리 작업을 돕고자 자바 8에 추가됨
- 유한 스트림 무한스트림, 스트림 파이프라인
- 스트림 파이프라인은 소스 스트림에서 시작해 종단연산으로 끝나고 중간연산이 하나 이상 있음
- 스트림 파이프라인은 지연 평가됨 평가는 종단연산이 호출될 때 이뤄지며 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않음
- 기본적으로 스트림 파이프라인은 순차적으로 실행됨
- 병렬로 실행했을때 효과를 볼 수 있는 상황은 많지 않음
- 스트림을 과용하면 프로그램이 읽거나 유지보수하기 어려워짐
- char 타입은 스트림 사용 X
- 기존 코드는 스트림을 사용하도록 리팩터링하되 새 코드가 더 나아 보일때만 반영할 것
- 스트림을 적용하기 좋은 후보
  - 원소들의 시퀀스를 일관되게 변환함
  - 원소들의 시퀀스를 필터링함
  - 원소들의 시퀀스를 하나의 연산을 사용해 결합함
  - 원소들의 시퀀스를 컬렉션에 모음
  - 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾음
- 스트림을 반환하는 메서드 명은 복수형으로

**핵심**

- 스트림을 사용해야 멋지게 처리할 수 있는 일이 있고 반복 방식이 더 알맞는 일도 있음 그리고 수많은 작업이 이 둘을 조합했을 때 가장 멋지게 해결됨. 어느 쪽을 선택하는 확고부동한 규칙은 없지만 참고할 만한 지침정도가 있는데 스트림과 반복을 둘다 구현하고 더 나은 쪽을 택할것.

## 스트림에서는 부작용 없는 함수를 사용하라

- 스트림에서 forEach 연산은 스트림 계산 결과를 보고할 때만 사용하고 계산하는데는 쓰지 말자.

**핵심**

- 스트림 파이프라인 프로그래밍의 핵심은 부작용 없는 함수 객체에 있다. 스트림뿐 아니라 스트림 관련 객체에 건네지는 모든 함수 객체가 부작용이 없어야 한다. 종단 연산 중 forEach는 스트림이 수행한 계산 결과를 보고할 때만 이용해야 한다. 계산 자체에는 이용하지 말자. 스트림을 올바로 사용하려면 수집기를 잘알아둬야 한다. 가장 중요한 수집기 팩터리는 toList, toSet, toMap groupingBy, joining이다.

## 반환 타입으로는 스트림보다 컬렉션이 낫다

- 스트림은 반복을 지원하지 않음
- api를 스트림으로 반환하게하면 클라이언트에서 반복하기 까다로움
- 원소 시퀀스를 반환하는 공개 api의 반환 타입에는 collection이나 그 하위 타입을 쓰는게 일반적으로 최선임

**핵심**

- 원소 시퀀스를 반환하는 메서드를 작성할 때는, 이를 스트림으로 처리하기를 원하는 사용자와 반복으로 처리하길 원하는 사용자가 모두 있을 수 있음을 떠올리고, 양쪽을 다 만족시켜러 노력하자. 컬렉션을 반환할 수 있다면 그렇게 하라. 반환 전부터 이미 원소들을 컬렉션에 담아 관리하고 있거나 컬렉션을 하나 더 만들어도 될 정도로 원소 개수가 적다면 ArrayList같은 표준 컬렉션에 담아 반환하라. 그렇지 않으면 앞서의 멱집합 예처럼 전용 컬렉션을 구현할지 고민하라. 컬렉션을 반환하는게 불과능하면 스트림과 Iterable중 더 자연스러운 것을 반환하라. 만약 나중에 Stream 인터페이스가 Iterable을 지원하도록 자바가 수정된다면 , 그때는 안심하고 스트림을 반환하면 될것이다.

## 스트림 병렬화는 주의해서 적용하라

- 데이터소스가 Stream.iterate거나 중간 연산으로 limit을 쓰면 파이프라인 병렬화로는 성능 개선을 기대할 수 없음
- 대체로 스트림의 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap, 의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋음
- 이 자료구조의 공통점은 원소들을 순차적으로 실행할 때의 참조 지역성이 뛰어나다는 것
- 스트림을 잘못 병렬화하면 응답 불가를 포함해 성능이 나빠질 뿐만 아니라 결과 자체가 잘못되거나 예상 못한 동작이 발생할 수 있음 <- 안전실패
- 변경 전후로 반드시 성능 테스트를 할 것

**핵심**

- 계산도 올바로 수행하고 성능도 빨라질 거라는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말라. 스트림을 잘못 병렬화하면 프로그램을 오동작하게 하거나 성능을 급격히 떨어뜨린다. 병렬화하는 편이 낫다고 믿더라도, 수정 후의 코드가 여전히 정확한지 확인하고 운영 환경과 유사한 조건에서 수행해보며 성능지표를 유심히 관찰하라. 그래서 계산도 정확하고 성능도 좋아졌음이 확실해졌을 때 오직 그럴 때만 병렬화 버전 코드를 운영 코드에 반영하라.

## 

# #8 메서드

## 매개변수가 유효한지 검사하라

- 자바7에 추가된 java.util.Objects.requireNonNull 메서드는 유연하고 사용하기도 편함 더이상 null검사를 수동으로 하지 말 것

**핵심**

- 메서드나 생성자를 작성할 때면 그 매개변수들에 어떤 제약이 있을지 생각해야 함. 그 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야 함 이런 습관을 반드시 기르도록 하자. 그 노력은 유효성 검사가 실제 오류를 처음 걸러낼 때 충분히 보상받을 것이다.

## 적시에 방어적 복사본을 만들라

- 클라이언트가 불변식을 깨뜨리려 혈안이 되어 있다고 가정하고 방어적으로 프로그래밍 해야 함
- Date는 낡은 api이니 새로운 코드를 작성할 때는 더이상 사용하면 안된다. Date는 가변임
- 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사 해야 한다.
- 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고 이 복사본으로 유효성을 검사한 점에 주목하자.
- 매개변수가 제3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용하면 안됨
- 접근자 메서드에는 가변 필드의 방어적 복사본을 반환하면 됨
- 클래스가 불변이든 가변이든 가변인 내부 객체를 클라이언트에 반환할때는 심사숙고할 것 길이가 1 이상인 배열은 무조건 가변임 방어적 복사본 만들것

**핵심**

- 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 구성요소가 가변이라면 그 요소는 반드시 방어적으로 복사해야 한다. 복사 비용이 너무 크거나 클라이언트가 그 요소를 잘못 수정할 일이 없음을 신뢰한다면 방어적 복사를 수행하는 대신 해당 구성요소를 수정했을 때의 책임이 클라이언트에 있음을 문서에 명시하도록 하자.

## 메서드 시그니처를 신중히 설계하라

- 메서드 이름을 신중히 짓자, 이해할수있고 일관되게, 남들이 하는것처럼 
- 편의 메서드를 너무 많이 만들지 말자. 유지보수 힘들어짐
- 매개변수 목록은 짧게 유지하자. 4개이하가 제일 좋음 같은 타입의 매개변수가 여러개가 나오는 경우가 특히 해로움
  - 여러 메서드로 쪼갤 것
  - 매개변수 여러 개를 묶어주는 도우미 클래스를 만드는 것 잇따른 매개변수 몇개를 독립된 하나의 개념으로 볼 수 있을 때 추천하는 기법 임
  - 빌더패턴을 메서드 호출에 응용 매개변수가 많은데 일부는 생략해도 괜찮을때
- 매개변수 타입으로는 클래스보다 인터페이스가 낫다. 더 상위 타입으로 받을 것
- 단순히 boolean 리턴값을 사용하는것은 예외지만 boolean보다는 원소 두개를 가진 enum타입으로 리턴하는게 더 나음



## 다중 정의는 신중히 사용하라

- 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택됨
- 다중정의된 메서드 사이에서는 객체의 런타임 타입은 전혀 중요하지 않고 선택은 컴파일타임에 오직 매개변수의 컴파일탐 타입에 의해 이루어짐
- 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자.
- 다중정의하는 대신 메서드 이름을 다르게 지어주는 방법도 있음
- 생성자는 정잭 팩터리라는 대안을 활용할 수 있는 경우가 많음
- 메서드를 다중정의할 때 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안된다.
- 다중정의 메서드가 기능이 똑같다면 신경쓸게 없음

**핵심**

- 프로그래밍 언어가 다중정의를 허용한다고 해서 다중정의를 꼭 활용하란 뜻은 아니다. 일반적으로 매개변수 수가 같을 때는 다중정의를 피하는게 좋다. 상황에 따라, 특히 생성자라면 이 조언을 따르기가 불가능할 수 있다. 그럴 때는 헷갈릴 만한 매개변수는 형변환하여 정확한 다중정의 메서드가 선택되도록 해야 한다. 이것이 불가능하면, 예컨대 기존 클래스를 수정해 새로운 인터페이스를 구현해야 할 때는 같은 객체를 입력받는 다중 정의 메서드드들이 모두 동일하게 동작하도록 만들어야 함. 그렇지 못하며 ㄴ프로그래머들은 다중정의된 메서드나 생성자를 효과적으로 사용하지 못할 것이고, 의도대로 동작하지 않는 이유를 이해하지도 못함

## 가변 인수는 신중히 사용하라

- 인수 0개를 받을 수 있도록 설계하는건 좋은 방법이 아님
- 1개이상을 받고싶을때는 매개변수를 두개받도록해서 첫번째 파라미터를 반드시 컴파일타임에 넣을 수 있도록 할 것

**핵심**

- 인수 개수가 일정하지 않은 메서드를 정의해야 한다면 가변 인수가 반드시 필요함. 메서드를 정의할 때 필수 매개변수는 가변인수 앞에 두고, 가변인수를 사용할 때는 성능 문제까지 고려할 것

## null이 아닌, 빈 컬렉션이나 배열을 반환하라

- 빈컬렉션을 반환하다고 하더라도 성능차이도 없고 새로 할당하지 않고도 반환시킬 수 있음

**핵심**

- null이 아닌 빈 컬렉션이나 배열을 반환하라. null을 반환하는 api는 사용하기어렵고 오류 처리 코드도 늘어난다. 그렇다고 성능ㅇ ㅣ좋은것도 아니다.

## 옵셔널 반환은 신중히 하라

- 옵셔널을 반환하는 메서드에서는 절대 null을 반환하지 말자
- 옵셔널은 검사 예외와 취지가 비슷하다.
- 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 감사면 안됨
- 박신된 기본타입을 담은 옵셔널을 반환하는 일은 없도록 하자.
- 옵셔널을 컬렉션의 키, 값, 원소나 배열의 원소로 사용하는게 적절한 상황은 거의 없음

**핵심**

- 값을 반환하지 못할 가능성이 있고, 호출할 때마다 반환값이 없을 가능성을 염두에 둬야하는 메서드라면 옵셔널을 반환해야 할 상황일 수 있다. 하지만 옵셔널 반환에는 성능저하가 뒤따르니, 성능에 민감한 메서드라면 null을 반환하거나 예외를 던지는 편이 나을 수 있다. 그리고 옵셔널을 반환값 이외의 용도로 쓰는 경우는 매우 드물다.

## 공개된 api 요소에는 항상 문서화 주석을 사용하라

- 공개된 api를 올바로 문서화하려면 공개된 모든 클래스, 인터페이스, 메서드, 필드 선언에 문서화 주석을 달아야 함
- 한 클래스 안에서 요약 설명이 똑같은 멤버가 둘 이상이면 안된다.
- 제네릭 타입이나 제네릭 메서드를 문서화할 때는 모든 타입 매개변수에 주석을 달아야 한다.
- 열거타입도 마찬가지
- 애너테이션 타입을 문서화할 때는 멤버들에도 모두 주석을 달아야 함
- 클래스 혹은 정적 메서드가 스레드 안전하든 그렇지 안든 스레드 안전 수준을 반드시 api 설명에 포함해야 함



# #9 일반적인 프로그래밍 원칙

## 지역변수의 범위를 최소화 하라

- 지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아짐
- 지역변수의 범위를 줄이는 가장 강력한 기법은 가장 처음 쓰일 때 선언하기임
- 거의 모든 지역변수는 선언과 동시에 초기화 해야 함 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야함
- 단순 순회는 foreach, 작업이 필요하면 for로
- 지역변수의 최소화는 메서드를 작게 유지하고 한가지 기능에 집중하는 것

## 전통적인 for문보다는 for-each를 사용하라

- for-each를 사용할 수 없는 상황
  - 파괴적인필터링: 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove를 호출해야 함 자바 8부터는 Collection의 removeIf 메서드를 사용해 컬렉션을 명시적으로 순회하는 일을 피할 수 있음
  - 변형: 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 함
  - 병렬반복: 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 함

**핵심**

- 전통적인 for문과 비교했을 때 for-each 문은 명료하고, 유연하고, 버그를 예방해 줌, 성능저하도 없음. 가능한 모든 곳에서 for문이 아닌 for-each를 사용할 것



## 라이브러리를 익히고 사용하라

- 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머 들의 경험을 활용할 수 있음
- ThreadLocalRandom을 사용할 것
- 따로 노력하지 않아도 성능이 지속해서 개선됨
- 기능도 점점 많아짐
- java.lang, java.util, java.io와 그 하위 패키지들에는 익숙해져야 함
- 멀티스레드는 java.util.concurrent를 주목
- 우선은 라이브러리를 사용해 볼 것

**핵심**

- 바퀴를 다시 발명하지 말자. 아주 특별한 나만의 기능이 아니라면 누군가 이미 라이브러리 형태로 구현해놓았을 가능성이 크다. 그런 라이브러리가 있다면 쓰면 된다. 있는지 잘 모르겠다면 찾아보라. 일반적으로 라이브러리으 ㅣ코드는 여러분이 직접 작성한 것보다 품질이 좋고 점차 개선될 가능성이 크다. 코드 품질에도 규모의 경제가 적용된다. 라이브러리 코드는 개발자 각자가 작성하는 것보다 주목을 훨씬 많이 받으므로 코드 품질도 그만큼 높아진다.



## 정확한 답이 필요하다면 float와 double은 피하라

- 금융 계산에는 BigDecimal, int 혹은 long을 사용해야 함

**핵심**

- 정확한 답이 필요한 계산에는 float나 double을 피하라. 소수점 추적은 시스템에 맡기고 코딩 시의 불편함이나 성능 저하를 신경쓰지 않겠다면 BigDecimal을 사용하라. BigDecimal이 제공하는 여덟가지 반올림 모드를 이용하여 반올림을 완벽히 제어할 수 있다. 법으로 정해진 반올림을 수행해야 하는 비즈니스 계산에서 아주 편리한 기능이다. 반면 성능이 중요하고 소수점을 직접 추적할 수 있고 숫자가 너무 크지 않다면 int나 long을 사용하라. 



## 박싱된 기본 타입보다는 기본 타입을 사용하라

- 같은 값이 아니라 객체를 비교할때 박싱타입은 값이아니라 참조를 비교함
- 거의 예외 없이 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다. null 참조를 언박싱할 경우 NPE 발생
- 박싱타입은 컬렉션의 키, 값으로 씀

**핵심**

- 기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하라. 기본 타입은 간단하고 빠르다. 박싱된 기본 타입을 써야 한다면 주의를 기울이자. 오토박싱이 박싱된 기본 타입을 사용할 때의 번거로움을 줄여주지만 그 위험까지 없애주지는 않음. 두 박싱된 기본 타입을 == 연산자로 비교한다면 식별성 비교가 이뤄지는데 원하는 결과가 아닐 수 있고 언박싱 과정에서 npe 발생 가능 기본 타입으 박싱하는 작업은 필요 없는 객체를 생성하는 부작용을 나을 수 있음



## 다른 타입이 적절하다면 문자열 사용을 피하라

- 문자열은 다른 값 타입을 대신하기에 적합하지 않음
- 문자열은 열거 타입을 대신하기에 적합하지 않다.
- 문자열은 혼합 타입을 대신하기에 적합하지 않다.
- 이런게 필요할 경우 클래스로 생성할 것

**핵심**

- 더 적합한 데이터 타입이 있거나 새로 작성할 수 있다면 문자열을 쓰고 싶은 유혹을 뿌리쳐라. 문자열은 잘못 사용하면 번거롭고, 덜 유연하고, 느리고, 오류 가능성도 크다. 문자열을 잘못 사용하는 흔한 예로는 기본 타입, 열거 타입, 혼합 타입이 있다.



## 문자열 연결은 느리니 주의하라

- 문자열 연결 연산자로 문자열n개를 잇는 시간은 n2에 비례함
- StringBuilder를 사용할 것



## 객체는 인터페이스를 사용해 참조하라

- 적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.
- 인터페이스 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해짐
- 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 함
- 적합한 인터페이스가 없다면 클래스 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 클래스 타입으로 사용하자.

## 리플렉션보다는 인터페이스를 사용하라

- 리플렉션의 단점
  - 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없음
  - 리플렉션을 이용하면 코드가 지저분하고 장황해짐
  - 성능이 떨어짐
- 리플렉션은 아주 제한도니 형태로만 사용할때 그단점을 피하고 이점만 취할 수 있음
- 리플렉션은 인스턴스 생성에만 쓰고 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자

**핵심**

- 리플렉션은 복잡한 특수 시스템을 개발할 때 필요한 강력한 기능이지만 단점도 많음. 컴파일타임에는 알 수 없는 클래스를 사용하는 프로그램을 작성한다면 리플렉션을 사용해야 할것임 단 되도록 객체 생성에만 사용하고 생성한 객체를 이용할 때는 적절한 인터페이스나 컴파일타임에 알 수 있는 상위 클래스로 형변환해 사용해야 함

## 네티이브 메서드는 신중히 사용하라

- 성능을 개선할 목적으로 네이티브 메서드를 사용하는 것은 거의 권장하지 않음



## 최적화는 신중희 하라

- 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다.
- 자그마한 효율성은 모두 잊자 섣부른 최적화가 만악의 근원이다.
- 최적화 할 때는 다음 두 규칙을 따르라. 첫번째 하지 마라, 두번째, 아직 하지마라. 다시말해 오나벽히 명백하고 최적화되지 않은 해법을 찾을 때까지는 하지 마라.
- 빠른 프로그램보다는 좋은 프로그램을 작성하라
- 설계단계에서 성능을 염두해 둘 것
- 성능을 제한하는 설계를 피할 것
- api를 설계할 때 성능에 주는 영향을 고려하라

**핵심**

- 빠른 프로그램을 작성하려 안달나지 말자. 좋은 프로그램을 작성하다 보면 성능은 따라온다. 하지만 시스템을 설계할 때 특히 api, 네트워크 프로토콜, 영구 저장용 데이터 포맷을 설계할 때는 성능을 염두에 두어야 한다. 시스템 구현을 완료했다면 이제 성능을 측정해보라. 충분히 빠르면 그것으로 끝이다. 그렇지 않다면 프로파일러를 사용해 문제의 원인이 되는 지점을 찾아 최적화를 수행하라. 가장 먼저 어떤 알고리즘을 사용했는지를 살펴보자. 알고리즘을 잘못 골랐다면 다른 저수준 최적화는 아무리 해봐야 소용이 없다. 만족할 때까지 이 과정을 반복하고 모든 변경 후에느 ㄴ성능 측정을 하라 

## 일반적으로 통용되는 명명 규칙을 따르라

- 표준 명명 규칙을 체화하여 자연스럽게 베어나돌고 하자. 철자 규칙은 직관적이라 모호한 부분이 적은 데 반해, 문법 규칙은 더복잡하고 느슨하다. 오랫동안 따라온 규칙과 충돌한다면 그 규칙을 맹종해서는 안된다.



# #10 예외

## 예외는 진짜 예외 상황에만 사용하라

- 예외는 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안된다.
- 잘 설계된 api라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다.

**핵심**

- 예외는 예외 상황에서 슬 의도로 설계되었다. 정상적인 제어 흐름에서 사용해서는 안되며, 이를 프로그래머에게 강요하는 api를 만들어서도 안된다.

## 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

- 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라.
- 프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자.
- 우리가 구현하는 모둔 비검사 throwable은 모두 RuntimeException의 하위 클래스이어야 함

**핵심**

- 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자. 확실하지 않다면 비검사 예외를 던지자. 검사 예외도 아니고 런타임 예외도 아닌 throwable은 정의하지도 말자. 검사 예외라면 필요한 정보를 알려주는 메서드도 제공하자.

## 필요 없는 검사 예외 사용은 피하라

- 검사예외를 회피하는 가장 쉬운 기술은 적절한 결과 타입을 담은 옵셔널을 반환하는 것
- 검사 예외를 던지는것 대신 빈 옵셔널을 반환하면 됨

**핵심**

- 꼭 필요한 곳에서만 사용한다면 검사 예외는 프로그램의 안정성을 높여주지만, 남용하면 쓰기 고통스러운 api를 낳는다. api 호출자가 예외 상황에서복구할 방법이 없다면 비검사 예외르 던지자 복구가 가능하고 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자. 복구가 가능하고 호출자가 그 처리를 해주길바란다면, 우선 옵셔널을 반환해도 될지 고민하자. 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자

## 표준 예외를 사용하라

- Exception, Runtimeexception, Throwable, Error는 직접 재사용하지 말고 IllegalArgumentException, IllegalStateException, UnsupportedOperationException 등등 표준 예외를 사용할 것
- 인수값이 무엇이었든 어차피 실패했을거라면 IllegalStateException을 그렇지 않으면 IllegalArgumentException

## 추상화 수준에 맞는 예외를 던지라

- 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다. <- 예외 번역
- 무턱대고 예외를 전파하는 것보다 예외 번역이 우수한 방법이지만 그렇다고 남영하면 곤란함

**핵심**

- 아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 사우이 계츠에 그대로 노출하기 곤란하다면 예외 번역을 사용하라. 이때 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다.

## 메서드가 던지는 모든 예외를 문서화하라

- 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화 하자.
- 메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자.
- 한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 클래스 설명에 추가하는 방법도 있음

**핵심**

- 메서드가 던질 가능성이 있는 모든 예외를 문서화하라. 검사 예외든 비검사 예외든, 추상 메서드든 구체 메서드든 모두 마찬가지다. 문서화에는 자바독의 @throws 태그를 사용하면 됨. 검사 예외만 메서드선언의 throws문에 일일이 선언하고 비검사 예외는 메서드선언에는 기입하지 말자. 발생가능한 예외를 문서로 남기지 않으면 다른 사람이 그 클래스나 인터페이스를 효과적으로 사용하기 어렵거나 심지어 불가능할 수도 있다.



## 예외의 상세 메시지에 실패 관련 정보를 담으라

- 실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야 함



## 가능한 한 실패 원자적으로 만들라

- 호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 함





# #11 동시성

## 공유중인 가변 데이터는 동기화해 사용하라

- synchronized 키워드는 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장함
- 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있음
- 동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.
- 쓰기메서드와 읽기 메서드 모두 동기화되지 않으면 동작을 보장하지 않음
- volatile 한정자는 배타적 수행과는 상관없지만 항상 가증 최근에 기록된 값을 읽게 됨을 보장함, 주의해서 사용할 것
- 가변 데이터는 단일 스레드에서만 쓰도록 하자

**핵심**

- 여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화 해야 한다. 동기화하지 않으면 한 스레드가 수행한 변경을 다른 스레드가 보지 못할수도 있다. 공유되는 가변 데이터를 동기화하는 데 실패하면 응답 불가 상태에 빠지거나 안전 실패로 이어질 수 있다. 이는 디버깅 난이도가 가장 높은 문제에 속한다. 간헐적이거나 특정 타이밍에만 발생할 수도 있고, VM에 따라 현상이 달라지기도 한다. 배타적 실행은 필요 없고 스레드끼리의 통신만 필요하다면 volatile 한정자만으로 동기화할 수 있다. 다만 올바로 사용하기가 까다롭다.



## 과도한 동기화는 피하라

- 응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안된다.
- 예를들어 동기화 메서드 안에 재정의 가능한 메서드를 호출하면 안됨 클라이언트가 넘긴 함수 객체 포함
- 기본 규칙은 동기화 영역에서는 가능한 한 일을 적게하는 것
- 멀티코어가 일반화된 오늘날, 과도한 동기화가 초래하는 진짜 비용은 락을 얻는데 드는 cpu 시간이 아니고 경쟁하느라 낭비하느 ㄴ시간, 증 병렬로 실행할 기회를 잃고, 모든 코어가 메모리를 일관되게 보기 위한 지연시간이 진짜 비용임
- 가변클래스는 동기화를 전혀 하지 말고 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하거나 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들 것

**핵심**

- 교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자. 일반화해 이야기하면 동기화 여역 안에서의 작업은 최소한으로 줄이자. 가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자. 멀티코어 세상인 지금은 과도한 동기화를 피하는게 과거 어느때보다 중요하다. 합당한 이유가 있을때만 내부에서 동기화하고 동기화했는지여부를 문서에 명확히 밝히자

## 스레드보다는 실행자, 태스크, 스트림을 애용하라

- 실행자 서비스의 주요 기능
  - 특정 태스크가 완료되기를 기다린다
  - 태스크 모음 중 아무것 하나 혹은 모든 태스크가 완료되기를 기다린다.
  - 실행자 서비스가 종료하기를 기다린다.
  - 완료된 태스크들의 결과를 차례로 받는다.
  - 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다.
- 작업 큐를 손수 만드는 일은 삼가야 하고 스레드를 직접 다루는 것도 일반적으로 삼가야 함
- 



