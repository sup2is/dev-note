



# #2 객체 생성과 파괴



## 생성자 대신 정적 팩터리 메서드를 고려하라

- 클래스는 생성자와 별도로 자신의 인스턴스를 반환하는 정적 팩터리 메서드를 제공할 수 있음

**장점**

1. 생성자와 다르게 해당 인스턴스 생성에 대한 메서드 이름을 가질 수 있음 <- 객체의 특성 묘사 가능 
2. 호출될 때마다 인스턴스를 생성하지는 않아도 됨. 미리 만들어둔 인스턴스를 캐싱해서 재활용할 수 있음
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있음 이로 인해 유연성 증가
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있음. 반환 타입의 하위 이기만하면 어떤 클래스의 객체를 반환하든 상관 없음 유연성 증가
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 됨 

**단점**

1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없음
2. 정적 팩터리 메서드는 프로그래머가 찾기 어려움

**정적 팩터리 명명 방식**

- from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환
- of: 여러 매개변수를 받아서 적합한 타입의 인스턴스를 반환
- valueOf: from과 of의 더 자세한 버전
- instance, getInstance: 매개변수로 명시한 인스턴스를 반환하지만 같은 인스턴스임을 보장하지는 않음
- create, newInstance: getInstrance와 비슷하지만 매번 새로운 인스턴스를 반환함을 보장
- getType: getInstrance와 같지만 Type으로 반환할 객체타입 명시함
- newType: newInstance와 같지만 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 씀. Type으로 반환할 객체타입을 명시함
- type: getType과 newType의 간결한 버전

**핵심**

- 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋음 그렇다고 하더라도 정적 팩터리를 사용하는게 유리한 경우가 더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고칠것



## 생성자 매개변수가 많다면 빌더를 고려하라

- 이전에 정적 팩터리와 생성자에는 선택적 매개변수가 많을 때 적절히 대응하기 어려움
- 생성자 오버로딩을 통해서 점증적 생성자 패턴도 쓸 수는 있지만 매개변수가 많아지면 클라이언트 코드를 작성하거나 읽는게 쉽지 않음
- 이때 빌더패턴을 고려할 수 있음
- 빌더 패턴은 파이썬과 스칼라에 있는 명명된 선택적 매개변수를 흉내낸 것임
- 빌더 패턴은 계층적으로 설계도니 크래스와 함께 사용하기 좋음
- 빌더 패턴을 사용하면 매우 유연하게 대처 가능하나 생성하는데 비용이 듦 그래도 빌더 사용할 것

**핵심**

- 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는게 더 낫다.



## private 생성자나 열거 타입으로 싱글턴임을 보증하라

- 싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말함
- 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있음 싱글턴을 가짜 mock으로 대체할 수 없기 때문임
- 정적 팩터리 방식이나 public 필드 방식으로 싱글턴을 구현할 수 있음

**public 필드 방식 장점**

1. 해당 클래스가 싱글턴임이 api 명백히 드러남 
2. 간결함

**정적 팩터리 방식의 장점**

1. api를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있음
2. 유일한 인스턴스를 반환하던 팩터리 메서드가 호출하는 스레드별로 다른 인스턴스를 넘겨주게 할 수 있음
3. 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있음
4. 정적 팩터리의 메서드 참조를 sppplier로 사용할 수 있음

- 추가적으로 원소가 하나인 열거 타입을 선언하는 방법도 있음 대부분의 상황에서는 원소가 하나뿐인 열거 타입으로 싱글턴을 만드는게 가장 좋은 방법임

## 인스턴스화를 막으려거든 private 생성자를 사용하라

- 정적 멤버, 메서드만 갖고 있는 유틸리티 클래스는 기본생성자가 있다는 사실을 인지할 것
- 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없음. 상속해서 만들면 됨
- private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있음

## 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적절하지 않음
- 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식으로 유연하게 해결 가능함
- 클래스가 조금이라도 동작에 변경이 있을 경우 팩터리 느낌으로 객체를 설계할 것

**핵심**

- 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다. 이 자원들을 클래스가 직접 만들게 해서도 안된다. 대신 필요한 자원을 생성자에 넘겨주자. 의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 가져온다.

## 불필요한 객체 생성을 피하라

- 똑같은 기능의 객체를 매번 생성하는 것 보다 객체 하나를 재사용하는게 나을 때가 많음
- 예를 들어 String을 리터럴로 생성하는것과 객체로 생성하는것은 큰 차이임 스트링은 불변이고 스트링풀에 캐싱하기때문에 리터럴로 사용할 것
- String.matches에서 사용하는 Pattern 인스턴스는 한번 사용 이후 바로 가비지 컬렉션의 정리 대상임
- 의도하지 않은 오토박싱이 숨어있지 않도록 할 것

## 다쓴 객체 참조를 해제하라

- 가비지 컬렉션 언어는 의도치 않게 객체를 살려두는 메모리 누수를 찾기가 아주 까다로움
- 객체 참조 하나를 살려두면 여기에 엮인 모든 객체는 가비지 컬렉터가 회수 불가함
- 해당 참조를 다 썼을 때 null 처리 하면 됨. 예를 들어 stack의 pop()같은 경우
- null처리를 통해 추가적으로 이상한 접근까지 제어할 수 있음 NPE
- 그러나 모든 참조에 null을 두는것에 혈안두지말것 객체 참조를 null처리하는 일은 예외적인 경우여야 함
- 일반적으로 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야함
- 캐시 역시 메모리 누수를 일으키는 주범임
- 캐시를 사용할때는 이 캐시된 값의 범위를 지정하기 어려우므로 LinkedHashMap을 통해 LRU를 구현하는 방법을 생각할 것
- 콜백이나 이벤트 리스너도 마찬가지로 계속 쌓일 수 있음 <- WeakHashMap 을 알아볼 것

**핵심**

- 메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있음 이런 누수는 철저한 코드 리뷰느 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 함 그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요함 

## Finalizer와 Cleaner 사용을 피하라

- 자바는 두가지 객체 소멸자 중 finalizer는 예측 불가하고 상황에 따라 위험할 수 있음
- clear 역시 finalizer 보다는 덜 위험하지만 여전히 예측 불가하고 느리고 일반적으로 불필요함
- 자바에서는 try-with-resources와 try-finally를 사용해 해결함
- 그냥 절대 둘다 사용하지 말것

**핵심**

- cleaner는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 생각하고 이런 경우라도 불확실성과 성능 저하에 주의해야함

## try-finally 보다는 try-with-resources를 사용할 것

- 사용후 close해야 하는 객체가 있다면 자바 7에서 나온 try-with-resource를 적극 권장함
- 이 객체들은 반드시 AutoCloseable을 구현해야함

**핵심**

- 꼭 회수해야 하는 자원을 다룰 때는 try-finall 말고 try-with-resources를 사용할 것. 예외는 없고 코드는 더욱 짧고 분명해지고 만들어지는 예외 정보도 훨씬 유용함











## 

