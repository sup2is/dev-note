



# #2 객체 생성과 파괴



## 생성자 대신 정적 팩터리 메서드를 고려하라

- 클래스는 생성자와 별도로 자신의 인스턴스를 반환하는 정적 팩터리 메서드를 제공할 수 있음

**장점**

1. 생성자와 다르게 해당 인스턴스 생성에 대한 메서드 이름을 가질 수 있음 <- 객체의 특성 묘사 가능 
2. 호출될 때마다 인스턴스를 생성하지는 않아도 됨. 미리 만들어둔 인스턴스를 캐싱해서 재활용할 수 있음
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있음 이로 인해 유연성 증가
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있음. 반환 타입의 하위 이기만하면 어떤 클래스의 객체를 반환하든 상관 없음 유연성 증가
5. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 됨 

**단점**

1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없음
2. 정적 팩터리 메서드는 프로그래머가 찾기 어려움

**정적 팩터리 명명 방식**

- from: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환
- of: 여러 매개변수를 받아서 적합한 타입의 인스턴스를 반환
- valueOf: from과 of의 더 자세한 버전
- instance, getInstance: 매개변수로 명시한 인스턴스를 반환하지만 같은 인스턴스임을 보장하지는 않음
- create, newInstance: getInstrance와 비슷하지만 매번 새로운 인스턴스를 반환함을 보장
- getType: getInstrance와 같지만 Type으로 반환할 객체타입 명시함
- newType: newInstance와 같지만 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 씀. Type으로 반환할 객체타입을 명시함
- type: getType과 newType의 간결한 버전

**핵심**

- 정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 상대적인 장단점을 이해하고 사용하는 것이 좋음 그렇다고 하더라도 정적 팩터리를 사용하는게 유리한 경우가 더 많으므로 무작정 public 생성자를 제공하던 습관이 있다면 고칠것



## 생성자 매개변수가 많다면 빌더를 고려하라

- 이전에 정적 팩터리와 생성자에는 선택적 매개변수가 많을 때 적절히 대응하기 어려움
- 생성자 오버로딩을 통해서 점증적 생성자 패턴도 쓸 수는 있지만 매개변수가 많아지면 클라이언트 코드를 작성하거나 읽는게 쉽지 않음
- 이때 빌더패턴을 고려할 수 있음
- 빌더 패턴은 파이썬과 스칼라에 있는 명명된 선택적 매개변수를 흉내낸 것임
- 빌더 패턴은 계층적으로 설계도니 크래스와 함께 사용하기 좋음
- 빌더 패턴을 사용하면 매우 유연하게 대처 가능하나 생성하는데 비용이 듦 그래도 빌더 사용할 것

**핵심**

- 생성자나 정적 팩터리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는게 더 낫다.



## private 생성자나 열거 타입으로 싱글턴임을 보증하라

- 싱글턴이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말함
- 클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있음 싱글턴을 가짜 mock으로 대체할 수 없기 때문임
- 정적 팩터리 방식이나 public 필드 방식으로 싱글턴을 구현할 수 있음

**public 필드 방식 장점**

1. 해당 클래스가 싱글턴임이 api 명백히 드러남 
2. 간결함

**정적 팩터리 방식의 장점**

1. api를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있음
2. 유일한 인스턴스를 반환하던 팩터리 메서드가 호출하는 스레드별로 다른 인스턴스를 넘겨주게 할 수 있음
3. 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있음
4. 정적 팩터리의 메서드 참조를 sppplier로 사용할 수 있음

- 추가적으로 원소가 하나인 열거 타입을 선언하는 방법도 있음 대부분의 상황에서는 원소가 하나뿐인 열거 타입으로 싱글턴을 만드는게 가장 좋은 방법임

## 인스턴스화를 막으려거든 private 생성자를 사용하라

- 정적 멤버, 메서드만 갖고 있는 유틸리티 클래스는 기본생성자가 있다는 사실을 인지할 것
- 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없음. 상속해서 만들면 됨
- private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있음

## 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적절하지 않음
- 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식으로 유연하게 해결 가능함
- 클래스가 조금이라도 동작에 변경이 있을 경우 팩터리 느낌으로 객체를 설계할 것

**핵심**

- 클래스가 내부적으로 하나 이상의 자원에 의존하고, 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다. 이 자원들을 클래스가 직접 만들게 해서도 안된다. 대신 필요한 자원을 생성자에 넘겨주자. 의존 객체 주입이라 하는 이 기법은 클래스의 유연성, 재사용성, 테스트 용이성을 가져온다.

## 불필요한 객체 생성을 피하라

- 똑같은 기능의 객체를 매번 생성하는 것 보다 객체 하나를 재사용하는게 나을 때가 많음
- 예를 들어 String을 리터럴로 생성하는것과 객체로 생성하는것은 큰 차이임 스트링은 불변이고 스트링풀에 캐싱하기때문에 리터럴로 사용할 것
- String.matches에서 사용하는 Pattern 인스턴스는 한번 사용 이후 바로 가비지 컬렉션의 정리 대상임
- 의도하지 않은 오토박싱이 숨어있지 않도록 할 것

## 다쓴 객체 참조를 해제하라

- 가비지 컬렉션 언어는 의도치 않게 객체를 살려두는 메모리 누수를 찾기가 아주 까다로움
- 객체 참조 하나를 살려두면 여기에 엮인 모든 객체는 가비지 컬렉터가 회수 불가함
- 해당 참조를 다 썼을 때 null 처리 하면 됨. 예를 들어 stack의 pop()같은 경우
- null처리를 통해 추가적으로 이상한 접근까지 제어할 수 있음 NPE
- 그러나 모든 참조에 null을 두는것에 혈안두지말것 객체 참조를 null처리하는 일은 예외적인 경우여야 함
- 일반적으로 자기 메모리를 직접 관리하는 클래스라면 프로그래머는 항시 메모리 누수에 주의해야함
- 캐시 역시 메모리 누수를 일으키는 주범임
- 캐시를 사용할때는 이 캐시된 값의 범위를 지정하기 어려우므로 LinkedHashMap을 통해 LRU를 구현하는 방법을 생각할 것
- 콜백이나 이벤트 리스너도 마찬가지로 계속 쌓일 수 있음 <- WeakHashMap 을 알아볼 것

**핵심**

- 메모리 누수는 겉으로 잘 드러나지 않아 시스템에 수년간 잠복하는 사례도 있음 이런 누수는 철저한 코드 리뷰느 힙 프로파일러 같은 디버깅 도구를 동원해야만 발견되기도 함 그래서 이런 종류의 문제는 예방법을 익혀두는 것이 매우 중요함 

## Finalizer와 Cleaner 사용을 피하라

- 자바는 두가지 객체 소멸자 중 finalizer는 예측 불가하고 상황에 따라 위험할 수 있음
- clear 역시 finalizer 보다는 덜 위험하지만 여전히 예측 불가하고 느리고 일반적으로 불필요함
- 자바에서는 try-with-resources와 try-finally를 사용해 해결함
- 그냥 절대 둘다 사용하지 말것

**핵심**

- cleaner는 안전망 역할이나 중요하지 않은 네이티브 자원 회수용으로만 생각하고 이런 경우라도 불확실성과 성능 저하에 주의해야함

## try-finally 보다는 try-with-resources를 사용할 것

- 사용후 close해야 하는 객체가 있다면 자바 7에서 나온 try-with-resource를 적극 권장함
- 이 객체들은 반드시 AutoCloseable을 구현해야함

**핵심**

- 꼭 회수해야 하는 자원을 다룰 때는 try-finall 말고 try-with-resources를 사용할 것. 예외는 없고 코드는 더욱 짧고 분명해지고 만들어지는 예외 정보도 훨씬 유용함







# #3 모든 객체의 공통 메서드



## equals는 일반 규약을 지켜 재정의하라

**equals를 재정의 안해도 되는 상황**

1. 각 인스턴스가 본질적으로 고유함
2. 인스턴스의 논리적 동치성을 검사할 일이 없음
3. 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞음
4. 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없음

- equals는 객체 식별성이 아니라 논리적 동치성을 확인해야 하는데 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의 되지 않았을 때임 주로 값 클래스들이 여기에 해당함
- 값 클래스라도 같은 값을 가진 인스턴스가 만들어지지 않음을 보장한다면 필요없음

**equals의 일반 규약**

1. 반사성: null이 아닌 모든 참조 값 x에 대해 x.equals(x) 는 true
2. 대칭성: null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)가 true면 y.equals(x)도 true
3. 추이성: null이 아닌 모든 참조 값 x,y,z에 대해 x.equals(y)가 true면 y.equals(z)이면 x.equals(z)도 true
4. 일관성: null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)는 항상 같은값
5. null-아님: null이 아닌 모든 참조 값 x에 대해 x.equals(null)은 false임

<br>

- 반사성은 단순히 객체는 자기 자신과 같아야 한다는 뜻
- 대칭성은 두 객체는 서로에 대한 동치 여부에 똑같이 답해야 함
- equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응하는지 알 수 없음
- 추이성은 첫번째 객체와 두번째 객체와 같고 두번째 객체와 세번째 객체가 같다면 첫번째와 세번째도 같아야 한다는 뜻
- 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않음!!
- 일관성은 두 객체가 같다면 영원히 같아야 함
- 불변이든 가변이든 equals 의 판단에 신뢰할 수 없는 자원이 끼어 들게 해서는 안됨
- null 검사보다 instanceof 검사가 나음

**양질의 equals 메서드 구현 방법**

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인함
2. instanceof 연산자로 입력이 올바른 타입인지 확인함
3. 입력을 올바른 타입으로 형 변환함
4. 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사함

- 프리미티브 타입은 ==연산자로 비교하고 참조타입은 equals로 메서드로, float과 double은 compare로 비교할 것
- null을 정상값으로 취급하는 참조 타입 필드는 Object.equals를 사용해서 NPE를 방지할 것
- equals를 사용할때는 가급적 다를 가능성이 크거나 비교하는데 비용이 싼 필드를 먼저 비교할 것

**마지막 주의사항**

1. equals를 재정의할 땐 hashCode도 반드시 재정의할 것
2. 너무 복잡하게 해결하지 말고 필드드르이 동치성만 검사해도 equals 규약을 어렵지 않게 지킬 수 있음
3. equals를 다 구현했다면 대칭적, 추이성, 일관성 세가지만 자문할 것
4. 반드시 Object.equals를 구현할 것. 다른 타입을 리턴하는 건 버그의 요소임 @Override 권장

- 구글의 AutoValue을 권장함

**핵심**

- 꼭 필요한 경우가 아니면 equals를 재정의하지 말자. 많은 경우에 Object의 equals가 원하는 비교를 정확히 수행해준다. 재정의해야 할 때는 그 클래스의 핵심 필드 모두 빠짐 없이 다섯 가지 규약을 확실이 지켜가며 비교해야 한다.

## equals를 재정의하려거든 hashCode도 재정의하라

- equals를 재정의한 클래스 모두에서 hashCode도 재저으이해야 함
- hashcode 일반 규약을 어기면 HashMap, HashSet같은 자료구조에서 문제가 됨

> **Object 명세**
>
> - equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashcode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야함 단 애플리케이션이 재실행되면 달라져도 상관 없음
> - equals가 두 객체를 같다고 판단했다면 두 객체의 hashcode는 똑같은 값을 반환해야함
> - equals가 두 객체를 다르다고 판단했더라도 두 객체의 hashcode가 서로 다른 값을 반환할 필요는 없음 단 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아짐

- hashCode 재정의를 잘못했을때 크게 문제가 되는 조항은 두 번째임 즉 논리적으로 같은 객체는 같은 해시코드를 반환해야함
- 같은 값을 갖는 인스턴스와 객체 타입이라도 hashCode를 구현하지 않으면 Object.hashCode는 다른 객체로 인식하게 함
- 좋은 해시함수는 서로 다른 인스턴스에 다른 해시코드를 반환함

**좋은 hashCode 함수를 작성하는 간단한 요령**

은 책에 있음

- 다른 필드로부터 계산해 낼 수 있는 필드는 모두 무시해도 되고 equals 비교에 사용되지 않은 필드는 반드시 제외해야함
- 해시충돌에 대한 라이브러리는 구아바 참고할 것
- Objects 클래스의 정적메서드 hash를 사용하면 속도는 조금 느리지만 좋은 해시함수로 사용가능함 성능에 민감하지 않다면 사용 가능
- 클래스가 불변이고 해시코드를 계산하는 비용이 크다면 매번 새로 계산하기 보다는 캐싱하는 방식을 고려할 것
- 성능을 높인다고 해시코드를 계산할 때 핵심 필드를 생략해서는 안됨
- hashCode가 반환하는 값의 생성 규칙을 api 사용자에게 자세히 공표하지 말것

**핵심**

- equals를 재정의할 때는 hashCode도 반드시 재정의해야 한다. 그렇지 않으면 프로그램이 제대로 동작하지 않을 것이다. 재정의한 hashCode는 Object의 API문서에 기술된 일반 규약을 따라야 하며, 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 한다. 이렇게 구현하기가 어렵지는 않지만 조금 따분한 일임 ㄱ구글의 AutoValue 를 통해 자동으로 생성하는걸 권장함

## toString을 항상 재정의하라 

- toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고 그 클래스를 사용한 시스템은 디버깅하기 쉬움
- toString은 그 객체가 가진 주요 정보를 모두 반환하는게 좋음
- toString의 포맷을 명시하든 아니든 의도는 명확히 밝혀야함
- 포맷 명시 여부와 상관 없이 toString이 반환한 값에 포함된 정보를 얻어올 수 있는 api를 제공하자
- 포맷이 변경되어도 클라이언트에 영향이 없도록 명세할 것

**핵심**

- 모든 구체 클래스에서 Object의 toString을 재정의하자. 상위 클래스에서 이미 알맞게 재정의한 경우는 예외다. toString을 재정의한 클래스는 사용하기도 즐겁고 그 클래스를 사용한 시스템을 디버깅하기 쉽게 해준다. toString은 해당 객체에 관한 명확하고 유용한 정보를 읽기 좋은 형태로 반환해야 한다.

## clone 재정의는 주의해서 진행하라

- Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스지만 잘 설계되지 않았음 하지만 널리 사용되고 있으니 숙지할 것
- Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며 사용자는 당연히 복제가 제대로 이뤄지리라 기대함 그러나 만약 A <- B 상황에서 B가 super.clone을 했을 경우 B의 인스턴스 복사가 아닌 A인스턴스 복사를 하게됨 주의할 것 <- final 의 경우 상속이 불가하기때문에 안전하게 사용하면 됨
- Object의 clone은 Object를 반환하지만 clone을 재정의해서 다음과 같은 형태로 사용할 것

```java
@Override
public PhoneNumber clone() {
	try {
		return (PhoneNumber) super.clone();
	}catch (CloneNotSupportedException e) {
		throw new AssertionError(); // 일어날 수 없는 일
	}
}
```

- 이런 방식으로 클라이언트에게 형변환 하지 않아도 되게끔 해줄 것
- 만약 clone 하는 객체가 가변 인스턴스 변수를 갖고 있다면 반드시 clone 내부에 재귀적으로 해당 가변 인스턴스를 복제해줄 것!
- 만약 clone 하는 객체가 불변 인스턴스 변수를 갖고 있다면 복제가 불가능할 수 있음 (공유 불가능하다면)
- 가변객체가 연결리스트라면 재귀함수로 deepCopy 하는것 보다 일반 for가 오버플로에 더 안전함
- clone 하는 객체의 내부 인스턴스 참조를 잘 확인해서 적절하게 구현해야함..!
- 모두 요약하면 Cloneable을 구현한 모든 클래스는 clone을 재정의해야함 이때 접근 제한자는 public, 반환 타입은 클래스 자신으로 변경할 것 그리고 이 메서드는 가장 먼저 super.clone을 호출한 후 필요한 필드를 전부 적절히 수정함!
- clone을 구현하지 않아도 복사 생성자와 복사 팩터리라는 더 나은 객체 복사 방식을 제공할 수 있음 가능하면 이 방법이 가장 좋음

**핵심**

Cloneable이 몰고 온 모든 문제를 되지퓨어봤을 때, 새로운 인터페이스를 만들 때는 절대 Cloneable을 확장해서는 안되며, 새로운 클래스도 이를 구현해서는 안됨. final 클래스라면 Cloneable을 구현해도 위험이 크지 않지만 성능 최적화 관점에서 검토한 후 별다른 문제가 없을 때만 드물게 허용해야 함 기본 원칙은 복제 기능은 생성자와 팩터리를 이용하는게 최고라는것 단 배열만은 clone 메서드 방식이 가장 깔끔한 이 규칭의 합당한 예외임 

## Comparable을 구현할지 고려하라



- compareTo는 이 객체가 주어진 객체보다 작으면 음의 정수, 같으면 0, 크면 양의정수를 반환함 비교 불가면 ClassCastException을 던짐
- Comparable을 구현하는 것만으로도 굉장한 이득을 볼 수 있음
- eqauls의 규약이랑 매우 비슷해서 반사성, 대칭성, 추이성을 모두 충족해야함
- 만약 A <- B 상황일때 A가 Comparable을 구현했다면 B에서 인스턴스 변수를 추가하면 규약에 어긋나기 때문에 이런 환경에서는 B를 독립적으로 두고 A 인스턴스 변수를 갖도록 구성할 것
- 재미있는 예로 HashSet 인스턴스에서 new BigDecimal("1.0")과  new BigDecimal("1.00")은 두개가 들어가지만 TreeSet에서는 한개만 들어감 TreeSet 같은 정렬 컬렉션은 동치성을 비교할때 equals 대신 compareTo를 사용하기 때문임
- 보통 방식된 기본 타입 클래스들에 추가된 compare를 사용해서 순서비교를 하고 관계연산자인 <와 >를 직접 사용하지 말 것
- 클래스에 핵심 필드가 여러개라면 가장 중요한것 부터 비교할 것
- Comparator 를 람다를 사용한 선언형으로 사용
- 값의 차 같은것을 사용하지 말것 오버플로나 언더플로 우려

**핵심**

- 순서를 고려해야 하는 값 클래스를 작성한다면 꼭 Comparable 인터페이스를 구현하여 그 인스턴스들을 쉽게 정렬하고 검색하고 비교 기능을 제공하는 컬렉션과 어우러지도록 해야 한다. compareTo 메서드에서 필드의 값을 비교할 때 <와 > 연산자는 쓰지 말아야 한다. 그 대신 박싱된 기본 타입 클래스가 제공하는 정적 compare  메서드나 Comparator 인터페이스가 제공하는 비교자 생성 메서드를 사용하자.
- 





## 

