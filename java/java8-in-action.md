









# #2 동적 파라미터화 코드 전달하기



- 동작 파라미터화를 이용하면 자주 바뀌는 요구사항에 효과적으로 대응할 수 있음
- 동작 파라미터화란 아직은 어떻게 시행할 것인지 결정하지 않은 코드 블록을 의미함

## 변화하는 요구사항에 대응하기

- 변화하는 요구사항에 대응하기 위해서는 파라미터를 직접 추가하는 방식 보다는 동작파라미터화를 이용해서 유연성을 얻어야함

## 동작 파라미터화

- predicate interface를 작성해서 동작여부에 대한 인터페이스를 작성하고 메서드에 predicate interface 타입의 파라미터를 통해 인터페이스로 해결하는 방법 이것을 strategy design pattern 이라고 부름
- 사용자는 변화하는 요구사항에 따라 미리 작성한 인터페이스를 구현한 클래스타입을 전달함으로써 의존성을 낮출 수 있음

```java
interface MyPredicate {
	boolean test();
}


class MyPredicateImpl implements MyPredicate {
	@Override
	boolean test ...
}




...
    
   
    
public void test(MyPredicate predicate) {
    if(predicate.test()) {
        ...
    }
}

```

- predicate interface 한개의 파라미터로 다양한 동작을 구성할 수 있다.



## 복잡한 과정 간소화 

- interface를 작성하고 그 interface를 구현하는 클래스를 만드는 일은 상당히 번거로운 작업임
- 익명클래스로 구현할 수 있음

### 익명 클래스

- interface를 직접 new 연산자로 구현했을때 익명클래스로 구현할 수 있는데 여전히 코드가 장황함
- 익명클래스는 자바 8의 람다로 해결 가능

### 람다 표현식 사용



```java
interface MyPredicate {
	boolean test(int value);
}


class MyPredicateImpl implements MyPredicate {
	@Override
	boolean test (int value) {...}
}


public void some(int value, MyPredicate predicate) {
    if(predicate.test(value)) {
        ...
    }
}


//실제 사용(익명클래스)
Object someObj = test(value, new MyPredicate() {
    	//익명클래스로 구현
    	@Override
		boolean test (int value) {...}
	}
);

//실제 사용(람다 표현식)
Object someObj = test(value, (value) -> ... )


```

- 기존에 Comparator, Runnable 역시 람다로 사용할 수 있다.

## 요약

- 동작 파라미터화에서는 메서드 내부적으로 다양한 동작을 수행할 수 있도록 코드를 메서드 인수로 전달함
- 동작 파라미터화를 이용하면 벼노하하는 요구사항에 더 잘 대응할 수 있는 코드를 구현할 수 이고 나중에 엔지니어링 비용을 줄일 수 있음
- 코드 전달 기법을 이용하면 동작을 메서드의 인수로 전달할 수 있음 자바 8에서는 람다를 사용함



# #3 람다 표현식

## 람다란 무엇인가?

- 람다 표현식은 메서드로 전달할 수 있는 익명 함수를 단순화 한 것
- 람다의 특징
  - 익명: 보토으이 메서드와 달리 이름이 없으므로 익명이라 표현함. 구현해야 할 코드에 대한 걱정거리가 줄어듬
  - 함수: 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 함 하지만 메서드의 기능을 포함했음
  - 전달: 람다 표현식을 메서드 인수로 전달하거나 변수로 저장 가능
  - 간결성: 익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없음
- 람다는 세가지로 구분됨
  - 람다 파라미터: 실제 interface 타입의 파라미터
  - 화살표: 파라미터와 바디를 구분자
  - 람다의 바디: 실제 메서드의 몸체
- 함수형 인터페이스에서 사용가능



### 함수형 인터페이스

- 함수형 인터페이스는 오직 하나의 추상메서드만 갖고 있음
- java에서는 @FunctionalInterface 어노테이션을 사용해서 이 인터페이스가 한개의 추상메서드만 있을것을 보장할 수 있음
- 대표적으로 Comparator, Runnable 등이 있음
- 디폴스메서드가 있더라도 추상메서드가 한개라면 함수형 인터페이스임

```java
Runaable r1 = () -> System.out.println("hello world")	
```

## 람다 활용: 실행 어라운드 패턴

- 자원처리에 사용하는 순환패턴은 자원을 열고 처리한다음에 자원을 닫는 순서로 이루어짐
- 실제 자원을 처리하는 코드를설정과 정리 두 과정이 둘러싸는 형태를 갖는것을 실행 어라운드 패턴이라고함
- 람다를 사용해서 실행어라운드패턴을 조금 더 효율적으로 작성할 수 있음







```

```



## 함수형 인터페이스 사용

- 함수형 인터페이스의  메서드 시그니처를 함수 디스크럽터라고함
- 우리가 작성한 MyPredicate 같은것을 java.util.function 패키지에서 지원하고 있음

### Predicate

- boolean test(T t);

### Consumer

- void accept(T t);

### Function

- R apply(T t);
- T타입의 인수를 받아서 R타입으로 변환시킴



- 굉장히 많은 타입의 함수형 인터페이스를 java.util.function 에서 제공하고 있음



## 형식 검사, 형식 추론, 제약

### 형식 검사

- 람다가 사용되는 컨텍스트를 이용해서 람다의 형식 추론이 가능함

### 같은 람다, 다른 함수형 인터페이스

- 같은 람다 표현식이라도 다른 함수형 인터페이스에 할당될 수 있음

### 형식 추론



## 메서드 레퍼런스

### 요약

- 메서드명 앞에 :: 구분자를 사용해서 메서드 참조를 사용할 수 있음
- 람다에게 메서드 명을 직접적으로 전달시킴



**메서드 레퍼런스를 만드는 방법**

1. 정적 메서드 레퍼런스
   - 예를들어 Integer의 parseInt는 Integer:parseInt 로 표현 가능
2. 다양한 형식의 인스턴스 메서드 레퍼런스
   - 예를들으 String의 length 메서드는 String::length로 표현 가능
3. 기존 객체의 인스턴스 메서드 레퍼런스
   - 예를 들어 Transaction 객체를 할당받은 expensiveTransaction 지역 변수가 있고 Transaction 객체에는 getValue 메서드가 있다면 이를 expensiveTrasaction::getValue로 사용가능



## 생성자 레퍼런스

- ClassName::new 처럼 new 를 통해서 생성자의 레퍼런스를 만들 수 있음



## 람다 표현식을 조합할 수 있는 유용한 메서드

- 함수형인터페이스를 조합해서 더 커다란 함수형 인터페이스를 작성할 수 있음

### Prediacate 조합

- negate(), and(), or() 세가지 메서드를 통해서 or, and, 반전에 대해서 확장 가능

### Function 조합

- andThen(), compose() 를 사용해서 확장 가능



# #4 스트림 소개

## 스트림이란 무엇인가?

- 스트림을 이용하면 선언형으로 컬렉션 데이터를 처리할 수 있음
- 멀티스레드 코드를 이용하지 않아도 병렬 스트림 으로 데이터를 병렬 처리할 수 있음
- 자바 8의 스트림 api의 특징
  - 선언형: 더 간결하고 가독성이 좋아짐
  - 조립 가능: 유연성이 좋아짐
  - 병렬화: 성능이 좋아짐

## 스트림 시작하기

- java 8의 컬렉션에서는 스트림을 반환하는 stream이라는 메서드가 추가됨(java.util.stream.Strema 참고)
- 스트림이란 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소로 정의 가능

**연속된 요소**

- 컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이루어진 연소고딘 값 집합의 인터페이스를 제공함
- 컬렉션은 자료구조이므로 시간,공간의 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이루지만 스트림은 filter,sorted,map 처럼 표현 계산식이 주를 이룸
- 즉 컬렉션의 주제는 데이터고 스트림의 주제는 계산임

**소스**

- 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비함
- 정렬된 컬렉션으로 스트림을 만들면 정렬을 유지한다.

**데이터 처리 연산**

- 스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원함
- filter, map, reduce, find, match, sort 등
- 순차적 또는 병렬로 실행 가능

**파이프 라이닝**

- 대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록스트림 자신을 반환함 그 덕분에 레이지, 쇼트서킷 같은 최적화도 얻을 수 있음
- 데이터 질의와 비슷함 from -> on -> join -> where  ...

**내부 반복**

- 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원함



## 스트림과 컬렉션

- 자바의 컬렉션과 스트림 모두 시퀀셜한 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공
- 데이터를 언제 계산하느냐가 스트림과 컬렉션의 가장 큰 차이
- 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장함 즉 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야함
- 스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조
- 스트림과 컬렉션으로 무한대의 소수를 가진다고 가정했을때 컬렉션은 영원히 무한대의 소수를 계산하기때문에 무한루프에 빠지게된다.

### 딱 한번만 탐색 가능

- 반복자와 마찬가지로 스트림도 단 한번만 탐색 가능

### 외부 반복과 내부 반복

- 컬렉션을 사용하면 사용자가 직접 요소를 반복하는데 이를 외부 반복이라고 함
- 반면 스트림 라이브러리는 반복을 알아서 처리하고 결과 스트림 값을 어딘가에 저장해주는 내부 반복을 사용함
- 내부 반복을 이용하면 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있음
- 스트림 라이브러리의 내부 반복은 데이터 표현과 하드웨어를 활용한 병렬성 구현을 자동으로 선택함

## 스트림 연산

- 연결할 수 있는 스트림 연산을 중간 연산이라고 하며 스트림을 닫는 연산을 최종 연산이라고 함

### 중간 연산

- filter , sorted 같은 중간 연산은 다른 스트림을 반환함
- 중간연산의 중요한 특징은 단말연 산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다는 것임 lazy 함

### 최종 연산

### 스트림 이용하기

- 스트림 이용 과정은 다음의 세가지로 요약됨
  1. 질의를 수행할 데이터 소스
  2. 스트림 파이프라인을 구성할 중간 연산 연결
  3. 스트림 파이프라인을 실행하고 결과를 만들 최종 연산

## 요약

- 스트림은 소스에서 추출된 연속 요소로, 데이터 처리 연산을 지원함
- 스트림은 내부 반복을 지원함, 내부 반복은 filter, map, sorted 등의 연산으로 반복을 추상화함
- 스트림에는 중간 연산과 최종 연산이 있음
- filter와 map처럼 스트림을 반환하면서 다른 연산과 연결될 수 있는 연산을 중간 연산이라고 함. 중간 연산을 이용해서 파이프라인을 구성할 수 있지만 중간 연산으로는 어떤 결과도 생성 불가
- forEach난 conut 처럼 스트림 파이프라인을 처리해서 스트림이 아닌 결과를 반환하는 연산을 최종 연산이라고함
- 스트림의 요소는 요청할 때만 계산됨









































