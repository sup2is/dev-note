# 자바의 정석







# #1 자바를 시작하기 전에

# #2 변수

# #3 연산자

# #4 조건문과 반복문

- 때로는 같은 문장을 반복해서 수행하거나 조건에 따라 문장을 건너뛰어야함
- 프로그램의 흐름을 바꾸는 역할을 하는 문장들을 제어문이라고함
  - 조건문: 조건에 따라 다른 문장이 수행되도록 함
  - 반복문: 특정 문자들을 반복해서 수행함

## 조건문 - if, switch

- 조건문은 if문과 switch문이 있음
- 주로 if문이 사용되지만 많은 조건을 처리할 경우 switch문이 효율적임

### if문

- 가장 기본적인 조건문
- 만일 조건식이 true이면 괄호 안의 문장들을 수행하라 라는 의미로 해석하면 됨

```java
if (조건식) {
	// 조건식이 true일때 수행될 문장들을 적는다.
}
```

- 조건식의 결과가 false라면 괄호 안의 문장들이 실행되지 않음
- 비교연산자와 `&&` 또는  `||` 와 같은 논리 연산자로 여러 조건들을 추가할 수 있음
- 자바에서의 조건식 결과는 반드시 true 또는 false
- 조건문의 블록(괄호)에는 보통 여러 문장을 넣지만 한 문장만 있다면 괄호를 생략하고 한줄로 쓸 수 있음

```java
if(score < 60) println("합격")
```



### if-else문

- if문의 변형구조
- if문의 조건이 false라면 else 블럭의 문장을 수행함

```java
if (조건식) {
	// 조건식이 true일때 수행될 문장들을 적는다.
} else {
	// 조건식이 false일때 수행될 문장들을 적는다.
}
```

- if-else문은 true or false이기때문에 반드시 어느 한 블록은 실행되는 구조

### if-else if문

- true 또는 false이 아닌 처리해야할 경우의 수가 셋 이상인 경우엔 if - else - if 문을 사용하면 됨

```java
if (조건식1) {
	// 조건식1이 true일때 수행될 문장들을 적는다.
} else if (조건식2) {
	// 조건식2가 true일때 수행될 문장들을 적는다.
} else if (조건식n) {
  // 조건식n이 true일때 수행될 문장들을 적는다.
} else { // <- 맨 마지막 else는 생략 가능
  // 위의 어느 조건도 만족하지 않을 때 수행될 문장들을 적는다. 
}
```

### 중첩 if문

- if문의 블럭 내에 또 다른 if문을 포함시키는 것이 가능한데 이것을 중첩 if문이라 부름
- 중첩의 횟수는 거의 제한이 없음

```java
if (조건식1) {

	if (조건식2) {
		// 조건식1과 조건식2가 모두 true일때 수행될 문장들을 적는다.
  } else {
    // 조건식1이 true이고 조건식2가 false일때 수행될 문장들을 적는다.
  }

} else {
  // 조건식1이 false일 때 수행되는 문장들을 적는다.
}
```

- 중첩시에 괄호 생략 또는 들여쓰기에 주의해야함

### switch문

- if- else if  의 조건식이 많아지면 복잡해지고 여러 개의 조건식을 계산해야하므로 성능상 좋지 않음
- switch문은 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있고 표현도 간결하므로 알아보기 쉬움
- 처리해야할 조건수의 수가 많다면 switch문이 좋음
- switch문 동작 방법
  - 조건식을 계산한다.
  - 조건식의 결과와 일치하는 case문으로 이동한다.
  - 이후의 문장들을 수행한다.
  - break문이나 switch문의 끝을 만나면 switch문 전체를 빠져나간다.

```java
switch (조건식) {
	case 값1 :
		//조건식의 결과가 값1과 같을 경우 수행될 문장들
		break;
	case 값2 :
		//조건식의 결과가 값2과 같을 경우 수행될 문장들
		break;
	default :
  	//조건식의 결과와 일치하는 case문이 없을 때 수행될 문장들
}
```

- break를 만나지 않으면 순서대로 모든 문장들을 수행하기 때문에 빼먹지 말아야하지만 경우에 따라서 고의적으로 break문을 생략하는 경우도 있음

```java
switch (level) {
	case 3 :
		//삭제권한
	case 2 :
		//쓰기권한
	case 1 :
		//읽기권한
}
```

- switch문의 제약 조건
  - switch 문의 조건식 결과는 정수 또는 문자열이어야함
  - case문의 값은 정수, 상수 또는 문자열만 가능하며, 중복되지 않아야함
- switch문 역시 중첩이 가능함



## 반복문 - for, while, do-while

- 반복문은 어떤 작업이 반복적으로 수행도되록 할 때 사용
- 반복문의 종류는 for문, while문, do - while문이 있음
- do - while문은 최소한 한번은 수행될 것이 보장되는 것이 특징
- 반복문은 주어진 조건을 만족하는 동안 블록안의 문장들을 반복적으로 수행함
- for문은 주로 반복 횟수를 알고 있을 때 사용함

### for문

- 반복 횟수를 알고 있을 때 적합함

```java
for (int i = 1; i <= 5; i ++) {
	//반복 내용
}

...

for (초기화;조건식;증감식) {
	//반복 내용
}
```

- for문의 구조와 실행 순서
  1. 초기화
  2. 조건식
  3. 수행될문장
  4. 증감식 (2번으로 반복)

- 조건식을 잘못 작성하면 블럭내의 문장이 한 번도 수행되지 않거나 무한반복에 빠지기 쉬우므로 주의해야함
- 초기화 또는 증감식에도 두문장을 하나로 연결해서 쓸 수 있음

```java
for (int i = 1, j = 5; i <= 5; i ++, j --) {
	//반복 내용
}
```

- 아래와 같이 초기화, 조건식, 증감식을 전부 제거하면 무한반복문이됨

```java
for (;;) {
	//반복 내용
}
```

- for문도 중첩이 가능함
- jdk1.5부터 배열과 컬렉션에 저장된 요소에 접근할 때 기존보다 편리한 방법으로 처리할 수 있도록 향상된 for문이 추가됨

```java
for (int value : arr) {
	//반복 내용
}

for (타입 변수명 : 배열 또는 컬렉션) {
	//반복 내용
}
```



### while문

- while문은 조건식이 true이고 조건식이 false가 될 때까지 블럭 내의 문장을 반복함

```java
while (조건식) {
	//반복 내용
}
```

- 초기화나 증감식이 필요하지 않은 경우라면 while문이 적합함
- while문의 무한반복, 무한 반복문은 반드시 특정 조건을 만족하면 벗어나도록 해야 함

```
while (true) {
	//반복 내용
}
```

### do-while문

- while문의 변형으로 기본적인 구조는 while문과 같으나 조건식과 블럭의 순서를 바꿔놓은것

```
do {
	//반복 내용
} while (조건식);
```

- do 블록을 최소한 한번은 실행을 보장함

### break문

- break문은 자신이 포함된 가장 가까운 반복문을 벗어남
- 주로 if문과 함꼐 사용되어 특정 조건을 만족하면 반복문을 벗어나도록 함

```java
while (true) {
	//반복 내용
	if(조건식) {
		break;
	}
}
```



### continue문

- 반복이 진행되는 도중애 continue문을 만나면 다음 반복으로 넘어감
- continue문은 반복문 전체를 벗어나지 않고 다음 반복을 계속 수행한다는 점이 break문과 다름
- 주로 if문과 함꼐 사용되어 특정 조건을 만족하면 다음 반복으로 넘어가도록 사용함

```java
while (true) {
	//반복 내용
	if(조건식) {
		continue;
	}
}
```



### 이름 붙은 반복문

- break문은 근접한 단 하나의 반복문만 벗어날 수 있기 때문에, 여러 개의 반복문이 중첩된 경우에는 break문으로 중첩 반복문을 완전히 벗어날 수 없음
- 반복문에 이름을 붙이고 break문과 continue문에 이름을 지정해줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너 뛸 수 있음

```java
loop : for (int i = 1; i <= 5; i ++) {
  for (int j = 1; j <= 5; j ++) {
		if (조건식) {
			break loop;
			continue loop;
		}
  }
}
```





# #5 배열

# #6 객체지향 프로그래밍 1

# #7 객체지향 프로그래밍 2



# #8 예외처리(Exception Handling)

## 예외처리(Exception Handling)

### 프로그램 오류

- 프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있음
- 이를 발생 시점에 따라 컴파일에러와 런타임에러로 나눌 수 있음 + 논리적에러 (물건의 재고가 음수)
  - 컴파일 에러 : 컴파일 시에 발생하는 에러
  - 런타임 에러 : 실행 시에 발생하는 에러
  - 논리적 에러 : 실행은 되지만, 의도와 다르게 동작하는 것
- 자바에서는 런타임에서 발생할 수 있는 프로그램 오류를 Error(에러)와 Exception(예외) 두가지로 구분했음
- Error는 OOM이나 StackOverFlowError와 같이 일단 발생하면 복구할 수 없는 심각한 오류
- Exception은 발생하더라도 수습될 수 있는 비교적 덜 심각한 것
- Error가 발생하면 프로그램의 비정상적인 종료를 막을 길이 없지만 예외는 발생하더라도 프로그래머가 이에 대한 적절한 코드를 미리 작성해 놓음으로써 프로그램의 비정상적인 종료를 막을 수 있음
  - Error: 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
  - Exception: 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류

### 예외 클래스의 계층구조

![](https://user-images.githubusercontent.com/30790184/109766400-74d49100-7c39-11eb-93b8-3cd169c44c2f.png)

- RuntimeException하위 클래스들은 프로그래머의 실수에 의해서 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊음 ex: ArrayIndexOutOfBoundsException, NPE, etc...

### 예외 처리하기 try-catch문

- 예외처리란 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것임
- 예외처리의 목적은 예외의 발생으로 인한 실행 중인 갑작스런 비정상 종료를 막고, 정상적인 실행 상태를 유지할 수 있도록 하는 것
- 발생한 예외를 처리하지 못하면 프로그램은 비정상적으로 종료되고 처리되지 못한 예외는 jvm의 예외처리기(UncaughtExceptionHandler)가 받아서 예외의 원인을 화면에 출력함

> UncaughtExceptionHandler는 기본적으로 스택 트레이스를 프린트함 기본 구현체는 ThreadGroup 클래스
>
> ```java
> /**
>  * Called by the Java Virtual Machine when a thread in this
>  * thread group stops because of an uncaught exception, and the thread
>  * does not have a specific {@link Thread.UncaughtExceptionHandler}
>  * installed.
>  */
>     public void uncaughtException(Thread t, Throwable e) {
>         if (parent != null) {
>             parent.uncaughtException(t, e);
>         } else {
>             Thread.UncaughtExceptionHandler ueh =
>                 Thread.getDefaultUncaughtExceptionHandler();
>             if (ueh != null) {
>                 ueh.uncaughtException(t, e);
>             } else if (!(e instanceof ThreadDeath)) {
>                 System.err.print("Exception in thread \""
>                                  + t.getName() + "\" ");
>                 e.printStackTrace(System.err);
>             }
>         }
>     }
> ```
>
> setDefaultUncaughtExceptionHandler()로 커스텀 UncaughtExceptionHandler을 thread에 셋팅할 수 있음
>
> Thread.setDefaultUncaughtExceptionHandler()
>
> ```java
> public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
>     SecurityManager sm = System.getSecurityManager();
>     if (sm != null) {
>         sm.checkPermission(
>             new RuntimePermission("setDefaultUncaughtExceptionHandler")
>                 );
>     }
> 
>      defaultUncaughtExceptionHandler = eh;
>  }
> ```

- 예외를 처리하기 위해서는 try-catch문을 사용함

```java
try {
	// 예외가 발생할 가능성이 있는 문장들을 넣음
} catch (Exception1 e1) {
	// Exception1이 발생했을 경우 이를 처리하기 위한 문장을 넣음
} catch (Exception2 e2) {
  // Exception2이 발생했을 경우 이를 처리하기 위한 문장을 넣음
}
```

- 하나의 try 블럭과 n개의 catch 블럭이 올 수 있음
- 이 중 발생한 예외의 종류와 일치하는 단 한개의 catch 블럭만 수행됨
- 발생한 예외의 종류와 일치하는 catch블럭이 없으면 예외는 처리되지 않음
- 여러개의 catch문에 참조변수명은 겹치면 안됨

### try-catch문에서의 흐름

- try 블럭 내에서 예외가 발생한 경우.
  - 발생한 예외와 일치하는 catch블럭이 있는지 확인함
  - 일치하는 catch 블럭을 찾게 되면, 그 catch 블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행함. 만일 일치하는 catch 블럭을 찾지 못하면 예외는 처리되지 못함
- try 블럭 내에서 예외가 발생하지 않은 경우.
  - catch블럭을 거치지 않고 try-catch문을 빠져나가서 수행을 계속함
- try 블럭에 포함시킬 코드의 범위를 잘 선택해야함

### 예외의 발생과 catch 블럭

- 예외가 발생하면 발생한 예외에 해당하는 클래스의 인스턴스가 만들어짐
- 첫번째 catch 블록부터 차례대로 내려가면서 catch에 선언된 예외와 생성된 예외 클래스의 인스턴스에 instanceof연산자를 이용해서 검사 결과가 true인 catch 블록을 만날때까지 하향식으로 검사함
- 검사 결과가 전부 false라면 예외는 처리되지 않음
- 모든 예외 클래스는 Exception 클래스의 자손이므로 catch 블럭의 괄호에 Exception 클래스 타입의 참조 변수를 선언해 놓으면 어떤 종류의 예외가 발생하더라도 catch 가능
- 예외가 발생했을 때 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨 있음 
  - getMessage() : 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있음
  - printStackTrace() : 예외발생 당시 호출스택에 있었던 메서드의 정보와 예외 메시지를 화면에 출력

- jdk 1.7부터 다음과 같이 멀티 catch블럭을 사용할 수 있음

```java
try {

} catch (ExceptionA | ExceptionB e) {
	e.printStackTrace();
}
```

- | 기호로 연결된 예외 클래스가 조상-자손관계라면 컴파일에러 발생
- 멀티 catch에서의 특정 ExceptionA.methodA는 호출 불가( instaceof로 한번 묶으면 사용 가능 ), e 변수는 final

### 예외 발생시키기

- 키워드 throw를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있음

```java
Exception e = new Exception();
throw e;
```

- 컴파일러가 예외처리를 확인하지 않은 RuntimeException 클래스들은 Unchecked 예외라하고 컴파일러가 예외처리를 확인한다면Checked Exception 예외라고함

### 메서드에 예외 선언하기

- 예외를 처리하는 또다른 방법으로 throws를 사용할 수 있음

```java
void method() thorws Exception1, Exception2, ... ExceptionN {

}
```

- 발생할 수 있는 예외를 적어두면 메서드를 사용하려는 사람이 메서드의 선언부를 보았을 때, 어떤 예외들이 처리되어야하는지 쉽게 알 수 있음
- 일반적으로 RuntimeException 클래스들은 적지 않음
- throws는 자신을 호출한 메서드에게 예외를 전달하는 것 어디선가는 try-catch로 예외를 처리해야함
- 맨 마지막에 있는 main메서드에서도 예외가 처리되지 않으면 프로그램이 종료됨

### finally블럭

- finally 블럭은 예외의 발생 여부에 상관 없이 실행되어야 할 코드를 포함시킬 목적으로 사용됨(optional)

```java
try {
	// 예외가 발생할 가능성이 있는 문장들을 넣음
} catch (Exception e){
	// 예외 처리를 위한 문장을 적음
} finally {
	// 예외의 발생여부에 관계없이 항상 수행되어야하는 문장들을 넣음
}
```



> finally를 사용하는 Main클래스와 bytecode
>
> ```java
> public class Main {
> 
>     public static void main(String[] args) {
> 
>         try {
>             throw new RuntimeException();
>         } catch (Exception e) {
>             e.printStackTrace();
>         } finally {
>             System.out.println("finally");
>         }
>     }
> }
> ```
>
> ```
>  0 new #7 <java/lang/RuntimeException>
>  3 dup
>  4 invokespecial #9 <java/lang/RuntimeException.<init> : ()V>
>  7 athrow
>  8 astore_1
>  9 aload_1
> 10 invokevirtual #12 <java/lang/Exception.printStackTrace : ()V>
> 13 getstatic #15 <java/lang/System.out : Ljava/io/PrintStream;>
> 16 ldc #21 <finally>
> 18 invokevirtual #23 <java/io/PrintStream.println : (Ljava/lang/String;)V>
> 21 goto 35 (+14)
> 24 astore_2
> 25 getstatic #15 <java/lang/System.out : Ljava/io/PrintStream;>
> 28 ldc #21 <finally>
> 30 invokevirtual #23 <java/io/PrintStream.println : (Ljava/lang/String;)V>
> 33 aload_2
> 34 athrow
> 35 return
> 
> ```



### 자동 자원 반환 -try-with-resources문

- 주로 입출력에 사용되는 클래스 중에서는 사용한 후에 꼭 닫아줘야하는것들이 있는데 이때 try-with-resources를 사용하면 됨

```java
//일반 try-catch-finally

try {
  FileInputStream fis = new FileInputStream("data.dat")
  DataInputStream dis = new DataInputStream(fis)
} catch (Exception e) {
	
} finally {
  try {
    if(dis != null) {
      dis.close();
    }
  } catch (IOException ie) {
    
  }
}


//try-with-resources
try(FileInputStream fis = new FileInputStream("data.dat");
    DataInputStream dis = new DataInputStream("data.dat")) {

} catch (Exception e) {

}
```

- try-with-resources를 사용하면 자동으로 close()가 호출됨
- try-with-resources에의해 자동으로 객체의 close()가 호출될 수 있으려면 클래스가 AutoCloseable이라는 인터페이스를 구현한 것이어야만 함
- close() 내부에서 예외가 발생했다면 supressed(억제된) 이라는 의미의 머리말과 함께 출력됨



### 사용자정의 예외 만들기

- 프로그래머가 새로운 예외 클래스를 정의하여 사용할 수 있음

```java
class MyException extends Exception {
	MyException(String msg)() {
		super(msg);
	}
}
```

- unchecked예외 또는 checked예외를 상속받아 예외처리 여부를 선택하게 할 수 있음

### 예외 되던지기(exception re-throwing)

- 예외를 처리하고 인위적으로 다시 발생시킬 수 있음
- 이 방법은 하나의 예외에 대해서 예외가 발생한 메서드와 이를 호출한 메서드 양쪽 모두에서 처리해줘야 할 작업이 있을 때 사용됨

```java
class ExceptionEx {
	public static void main(String[] args) {
		try {
			method1();
		} catch (Exception e) {
		}
	}
	
	static void method1() throws Exception {
		try {
			throw new Exception();
		} else {
			throw e; //<= 예외 재발생
		}
	}
}
```

- 메서드 return 시그니처가 void가 아니라면 catch에서도 리턴을 해야하지만 예외 되던지기의 경우 return문을 대신할 수 있음.

  

### 연결된 예외(chained exception)

- 예외를 연결시켜서 한 예외가 다른 예외를 발생시킬수도 있음

```java
try {
	startInstall();
	copyFiles();
} catch (SpaceException e) {
	InstallException ie = new InstallException("설치중 예외 발생");
	ie.initCause(e);
	throw ie;
}
```

- 예외를 연결시키는 이유는 여러가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위해서이고 checked예외를 한번 감싸서 unchecked예외로 던져서 예외처리를 선택적으로 하도록 할 수 있음





# #9 java.lang 패키지와 유용한 클래스

# #10 날짜와 시간 & 형식화

# #11 컬렉션 프레임웍

# #12 제네릭, 열거형, 애너테이션

## 제네릭스(Generics)

### 제네릭이란?

- 제네릭은 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능임
- 객체의 타입을 컴파일시에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거로움이 줄어듦

### 제네릭 클래스의 선언

```java
class Box<T>
	T item;
	
	void setItem(T item) {
		this.item = item;
	}
	T getItem() {
		return item;
	}
```

- 타입변수는 의미있게 사용하면됨 ex Key Value경우 <K, V>
- 기호의 종류만 다를 뿐 임의의 참조형 타입을 의미한다는 개념만 이해하면됨

```java
Box<String> b = new Box<>();
b.setItem("ABS");
```

- 제네릭클래스에 타입을 지정하지 않을 수 있지만 컴파일러가 경고를 표시함
- 추가적으로 제네릭클래스에 타입을 지정하지 않으면 T 타입은 Object 타입으로 사용됨 따라서 실제 사용시에 형변환해줘야함

```java
Box b = new Box(); //컴파일 경고
b.setItem("ABS"); 
```

- 타입 매개변수에 타입을 지정하는 것을 '제네릭 타입 호출'이라하고 지정된 타입을  '매개변수화된 타입' 이라함
- 모든 객체에 동일하게 동작해야하는 static 멤버 타입에는 T 변수를 사용할 수 없음 그 이유는 모든 클래스에게 동일하게 제공되어야하지만 이 T 변수는 런타임에 확정되기 때문에 불가능함
- 제네릭 배열 타입의 참조변수를 선언하는 것은 가능하지만 new T[10]와 같은 형태로 배열을 생성하는 것은 안됨 new는 컴파일 시점에 타입T가 뭔지 정확히 알아야하기 때문.
- 위와 같은 맥락으로 instanceof 연산자도 T타입을 피연산자로 사용할 수 없음



### 제네릭 클래스의 객체 생성과 사용

- 참조변수와 생성자에 대입된 타입이 일치해야함

```java
Box<Apple> appleBox = new Box<Apple>();
Box<Apple> appleBox = new Box<Grape>(); // 에러
```

- 아래와 같이 제네릭 클래스 타입이 상속 관계에 있고 대입된 타입이 같은 것은 괜찮음

```java
Box<Apple> appleBox = new FruitBox<Apple>();
```

- jdk 7부터 추정이 가능한 경우 타입을 생략 가능

```java
Box<Apple> appleBox = new Box<>();
```

- `Box<T>`에 item을 추가할때는 T타입과 다른 타입의 객체는 추가할 수 없음

### 제한된 제네릭 클래스

- 다음과 같이 제네릭 타입에 `extends` 를 사용하면 특정 타입의 자손들만 대입할 수 있게 제한할 수 있음

```java
class FruitBox<T extneds Fruit> {
	ArrayList<T> list = new ArrayList<T>();
}
```

- 인터페이스더라도 `extends` 키워드를 사용함
- 다중 바운드타입은 아래와같이 `&` 로 묶을 수 있음

```java
class FruitBox<T extends Fruit & Eatable> { ... }
```

### 와일드카드

- 와일드카드가 필요한 경우

```java
class FruitBox<T extends Fruit> extends Box<T> {}


class Juicer {
	static Juice makeJuice(FruitBox<Fruit> box) {
		for(Fruit f : box.getList()) {
			//do something .. 
		}
	}
}

FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<Apple>();

Juicer.makeJuice(fruitBox);
Juicer.makeJuice(appleBox); //에러

```

- 제네릭 타입은 컴파일러가 컴파일할때만 사용하고 제거해버리기 때문에 제네릭타입이 다른것만으로 오버로딩이 성립되지 않음
- 추가적으로 메서드 중복 등과 같은 문제

```java

class Juicer {
	static Juice makeJuice(FruitBox<Fruit> box) {
		for(Fruit f : box.getList()) {
			//do something .. 
		}
	}
  
	static Juice makeJuice(FruitBox<Apple> box) { //메서드 오버로딩 실패
		for(Fruit f : box.getList()) {
			//do something .. 
		}
	}
}
```

- 이런 경우에 와일드카드 `?` 를 사용하면 됨
  - `<? extends T>` 와일드 카드의 상한 제한. T와 그 자손들만 가능
  - `<? super T>` 와일드 카드의 하한 제한. T와 그 조상들만 가능
  - `<?>` 제한 없음. 모든 타입이 가능함 `<? extends Object>` 와 동일함

```java
class Juicer {
	static Juice makeJuice(FruitBox<? extends Fruit> box) {
		for(Fruit f : box.getList()) {
			//do something .. 
		}
	}
}

FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<Apple>();

Juicer.makeJuice(fruitBox);
Juicer.makeJuice(appleBox);
```



### 제네릭 메서드

- 메서드의 선언부에 제네릭 타입이 선언된 메서드를 제네릭 메서드라함.

```java
static <T> void sort(List<T> list, Comparator<? super T> c)
```

- 제네릭 클래스에 정의된 타입 매개변수와 제네릭 메서드에 정의된 타입 매개변수는 전혀 별개의 것임. 같은 타입 문자 T를 사용해도 같은 것이 아니라는것에 주의해야함

```java
class FruitBox<T> {
	static <T> void sort(List<T> list, Comparator<? super T> c) {
		
	}
}
```

- 메서드에 선언된 제네릭 타입은 지역 변수를 선언한 것과 같다고 생각하면 이해하기 쉬움
- 아래와 같은 경우에 제네릭 메서드를 사용할 수 있음

```java
static void fromArrayToCollection(Object[] a, Collection<?> c) {
    for (Object o : a) { 
        c.add(o); // compile-time error
    }
}

static <T> void fromArrayToCollection(T[] a, Collection<T> c) {
    for (T o : a) {
        c.add(o); // Correct
    }
}
```



```java
class Juicer {
	static Juice makeJuice(FruitBox<? extends Fruit> box) {
		for(Fruit f : box.getList()) {
			//do something .. 
		}
	}
}

//제네릭 메서드
class Juicer {
	static <T extends Fruit> Juice makeJuice(FruitBox<T> box) {
		for(Fruit f : box.getList()) {
			//do something .. 
		}
	}
}


FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<Apple>();

Juicer.<Fruit>makeJuice(fruitBox);
Juicer.<Apple>makeJuice(appleBox);

//대부분의 경우 컴파일러가 타입을 추정해서 아래와 같이 생략된 형태로 사용 가능
Juicer.makeJuice(fruitBox);
Juicer.makeJuice(appleBox);


```

- 제네릭 메서드 호출시 대입된 타입 생략이 불가능할 경우 아래와 같이 참조변수나 클래스 이름을 생략할 수 없음
- Collections.sort 메서드

```java
public static <T extends Comparable<? super T>> void sort(List<T> list) {
	list.sort(null);
}
```

### 제네릭 타입의 형변환

### 제네릭 타입의 제거

## 열거형(enums)

### 열거형이란?

- 열거형은 서로 관련된 상수를 편리하게 선언하기 위한 것으로 여러 상수를 정의할 때 사용하면 유용함
- jdk1.5부터 추가
- 자바의 열거형은 c언어의 열거형보다 더 향상된 것으로 열거형이 갖는 값뿐만 아니라 타입도 관리하기 떄문에 보다 논리적인 오류를 줄일 수 있음
- C언어에서는 타입이 달라도 값이 같으면 조건식 결과가 true이었으나 자바의 열걸형은 타입에 안전한 열거형이라서 실제 값이 같아도 타입이 다르면 컴파일 에러가 발생함
- 상수의 값이 바뀌면 해당 상수를 참조하는 모든 소스를 다시 컴파일해야 하지만 열거형 상수를 사용하면 기존의 소스를 다시 컴파일하지 않아도됨

### 열거형의 정의와 사용

- 다음과 같이 열거형을 정의함

```java
enum 열거형이름 {
	상수명1, 상수명2 ... 
}
```

- 사용방법은 열거형이름.상수명1, 열거형이름.상수명2 형태로 사용함
- 열거형 상수간의 비교에는 `==` 사용이 가능함 but 비교연산자는 불가능. 하지만 compareTo()는 비교연산자도 사용이 가능함
- 열거형에 정의된 모든 상수를 출력하려면 다음과 같이 사용하면 됨

```java
Direction[] dArr = Direction.values();

for(Direction d : dArr) {
	...
}
```

- enum의 기타 메서드

| `protected Object`             | `**[clone](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html#clone())**()`Throws CloneNotSupportedException. |
| ------------------------------ | ------------------------------------------------------------ |
| `String`                       | `**[name](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html#name())**()`Returns the name of this enum constant, exactly as declared in its enum declaration. |
| `int`                          | `**[ordinal](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html#ordinal())**()`Returns the ordinal of this enumeration constant (its position in its enum declaration, where the initial constant is assigned an ordinal of zero). |
| `static <T extends Enum<T>> T` | `**[valueOf](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html#valueOf(java.lang.Class, java.lang.String))**(Class<T> enumType, String name)`Returns the enum constant of the specified enum type with the specified name. |

- 열거형에는 abstract, final 을 사용할 수 없음



### 열거형에 멤버 추가하기

- Enum클래스에 정의된 ordinal()이 열거형 상수가 정의된 순서를 반환하지만, 이 값을 열거형 상수의 값으로 사용하지 않는 것이 좋음

> ordinal()을 사용하지 말아야하는 이유
>
> 

- 열거형 상수의 값을 열거형 상수 이름 옆에 괄호()안에 넣어주면됨

```java
enum Direction {
	EAST(1), SOUTH(5), WEST(-1), NORTH(10);
  
  private final int value;
  Direction(int value) {this.value = value;}
  
}
```

- 지정된 값을 저장할 수 있는 인스턴스 변수와 생성자를 새로 추가해주어야함
- 열거형의 객체를 생성할수는 없음. 기본적으로 열거형의 생성자는 제어자가 묵시적으로 private임

> 열거형의 생성자가 private인 이유
>
> 

- 필요에따라 열거형 상수에 여러 값을 지정할 수 있지만 그에 맞게 인스턴스 변수와 생성자 등을 새로 추가해주어야함
- 열거형에 추상 메서드를 선언하면 각 열거형 상수가 이추상 메서드를 반드시 구현해야함

> 열거형에 추상메서드를 구현했을때 실제 컴파일된 모습



### 열거형의 이해

```java
enum Diriection {EAST, SOUTH, WEST, NORTH}
```

- 열거형 상수 하나하나가 Direction 객체임
- 위 문장을 클래스로 정의하면 다음과 같음

```java
class Direction {
	static final Direction EAST = new Direction("EAST");
	static final Direction SOUTH = new Direction("SOUTH");
	static final Direction WEST = new Direction("WEST");
	static final Direction NORTH = new Direction("NORTH");

  private String name;
  
  private Direction(String name) {
    this.name = name;
  }
}
```

- Direction 클래스의 static 상수의 값은 객체의 주소이고 이 값은 바뀌지 않는 값이기때문에 `==`로 비교가 가능한 것
- 모든 열거형은 추상 클래스 Enum의 자손이기때문에 Enum을 흉내내어 MyEnum을 작성하면 다음과 같음

```java
abstract class MyEnum<T extends MyEnum<T>> implements Comparable<T> {
  static int id = 0;
  
  int ordinal;
  String name = "";
  
  public int ordinal() {return ordinal};
  
  MyEnum(String name) {
    this.name = name;
    ordinal = id++;
  }
  public int compareTo(T t) {
    return ordinal - t.ordinal();
  }
  
}
```





## 애너테이션(annotation)

### 애너테이션이란?

### 표준 애너테이션

### 메타 애너테이션

### 애너테이션 타입 정의하기































