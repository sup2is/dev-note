# 자바의 정석







# #1 자바를 시작하기 전에

# #2 변수

# #3 연산자

# #4 조건문과 반복문

- 때로는 같은 문장을 반복해서 수행하거나 조건에 따라 문장을 건너뛰어야함
- 프로그램의 흐름을 바꾸는 역할을 하는 문장들을 제어문이라고함
  - 조건문: 조건에 따라 다른 문장이 수행되도록 함
  - 반복문: 특정 문자들을 반복해서 수행함

## 조건문 - if, switch

- 조건문은 if문과 switch문이 있음
- 주로 if문이 사용되지만 많은 조건을 처리할 경우 switch문이 효율적임

### if문

- 가장 기본적인 조건문
- 만일 조건식이 true이면 괄호 안의 문장들을 수행하라 라는 의미로 해석하면 됨

```java
if (조건식) {
	// 조건식이 true일때 수행될 문장들을 적는다.
}
```

- 조건식의 결과가 false라면 괄호 안의 문장들이 실행되지 않음
- 비교연산자와 `&&` 또는  `||` 와 같은 논리 연산자로 여러 조건들을 추가할 수 있음
- 자바에서의 조건식 결과는 반드시 true 또는 false
- 조건문의 블록(괄호)에는 보통 여러 문장을 넣지만 한 문장만 있다면 괄호를 생략하고 한줄로 쓸 수 있음

```java
if(score < 60) println("합격")
```



### if-else문

- if문의 변형구조
- if문의 조건이 false라면 else 블럭의 문장을 수행함

```java
if (조건식) {
	// 조건식이 true일때 수행될 문장들을 적는다.
} else {
	// 조건식이 false일때 수행될 문장들을 적는다.
}
```

- if-else문은 true or false이기때문에 반드시 어느 한 블록은 실행되는 구조

### if-else if문

- true 또는 false이 아닌 처리해야할 경우의 수가 셋 이상인 경우엔 if - else - if 문을 사용하면 됨

```java
if (조건식1) {
	// 조건식1이 true일때 수행될 문장들을 적는다.
} else if (조건식2) {
	// 조건식2가 true일때 수행될 문장들을 적는다.
} else if (조건식n) {
  // 조건식n이 true일때 수행될 문장들을 적는다.
} else { // <- 맨 마지막 else는 생략 가능
  // 위의 어느 조건도 만족하지 않을 때 수행될 문장들을 적는다. 
}
```

### 중첩 if문

- if문의 블럭 내에 또 다른 if문을 포함시키는 것이 가능한데 이것을 중첩 if문이라 부름
- 중첩의 횟수는 거의 제한이 없음

```java
if (조건식1) {

	if (조건식2) {
		// 조건식1과 조건식2가 모두 true일때 수행될 문장들을 적는다.
  } else {
    // 조건식1이 true이고 조건식2가 false일때 수행될 문장들을 적는다.
  }

} else {
  // 조건식1이 false일 때 수행되는 문장들을 적는다.
}
```

- 중첩시에 괄호 생략 또는 들여쓰기에 주의해야함

### switch문

- if- else if  의 조건식이 많아지면 복잡해지고 여러 개의 조건식을 계산해야하므로 성능상 좋지 않음
- switch문은 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있고 표현도 간결하므로 알아보기 쉬움
- 처리해야할 조건수의 수가 많다면 switch문이 좋음
- switch문 동작 방법
  - 조건식을 계산한다.
  - 조건식의 결과와 일치하는 case문으로 이동한다.
  - 이후의 문장들을 수행한다.
  - break문이나 switch문의 끝을 만나면 switch문 전체를 빠져나간다.

```java
switch (조건식) {
	case 값1 :
		//조건식의 결과가 값1과 같을 경우 수행될 문장들
		break;
	case 값2 :
		//조건식의 결과가 값2과 같을 경우 수행될 문장들
		break;
	default :
  	//조건식의 결과와 일치하는 case문이 없을 때 수행될 문장들
}
```

- break를 만나지 않으면 순서대로 모든 문장들을 수행하기 때문에 빼먹지 말아야하지만 경우에 따라서 고의적으로 break문을 생략하는 경우도 있음

```java
switch (level) {
	case 3 :
		//삭제권한
	case 2 :
		//쓰기권한
	case 1 :
		//읽기권한
}
```

- switch문의 제약 조건
  - switch 문의 조건식 결과는 정수 또는 문자열이어야함
  - case문의 값은 정수, 상수 또는 문자열만 가능하며, 중복되지 않아야함
- switch문 역시 중첩이 가능함



## 반복문 - for, while, do-while

- 반복문은 어떤 작업이 반복적으로 수행도되록 할 때 사용
- 반복문의 종류는 for문, while문, do - while문이 있음
- do - while문은 최소한 한번은 수행될 것이 보장되는 것이 특징
- 반복문은 주어진 조건을 만족하는 동안 블록안의 문장들을 반복적으로 수행함
- for문은 주로 반복 횟수를 알고 있을 때 사용함

### for문

- 반복 횟수를 알고 있을 때 적합함

```java
for (int i = 1; i <= 5; i ++) {
	//반복 내용
}

...

for (초기화;조건식;증감식) {
	//반복 내용
}
```

- for문의 구조와 실행 순서
  1. 초기화
  2. 조건식
  3. 수행될문장
  4. 증감식 (2번으로 반복)

- 조건식을 잘못 작성하면 블럭내의 문장이 한 번도 수행되지 않거나 무한반복에 빠지기 쉬우므로 주의해야함
- 초기화 또는 증감식에도 두문장을 하나로 연결해서 쓸 수 있음

```java
for (int i = 1, j = 5; i <= 5; i ++, j --) {
	//반복 내용
}
```

- 아래와 같이 초기화, 조건식, 증감식을 전부 제거하면 무한반복문이됨

```java
for (;;) {
	//반복 내용
}
```

- for문도 중첩이 가능함
- jdk1.5부터 배열과 컬렉션에 저장된 요소에 접근할 때 기존보다 편리한 방법으로 처리할 수 있도록 향상된 for문이 추가됨

```java
for (int value : arr) {
	//반복 내용
}

for (타입 변수명 : 배열 또는 컬렉션) {
	//반복 내용
}
```



### while문

- while문은 조건식이 true이고 조건식이 false가 될 때까지 블럭 내의 문장을 반복함

```java
while (조건식) {
	//반복 내용
}
```

- 초기화나 증감식이 필요하지 않은 경우라면 while문이 적합함
- while문의 무한반복, 무한 반복문은 반드시 특정 조건을 만족하면 벗어나도록 해야 함

```
while (true) {
	//반복 내용
}
```

### do-while문

- while문의 변형으로 기본적인 구조는 while문과 같으나 조건식과 블럭의 순서를 바꿔놓은것

```
do {
	//반복 내용
} while (조건식);
```

- do 블록을 최소한 한번은 실행을 보장함

### break문

- break문은 자신이 포함된 가장 가까운 반복문을 벗어남
- 주로 if문과 함꼐 사용되어 특정 조건을 만족하면 반복문을 벗어나도록 함

```java
while (true) {
	//반복 내용
	if(조건식) {
		break;
	}
}
```



### continue문

- 반복이 진행되는 도중애 continue문을 만나면 다음 반복으로 넘어감
- continue문은 반복문 전체를 벗어나지 않고 다음 반복을 계속 수행한다는 점이 break문과 다름
- 주로 if문과 함꼐 사용되어 특정 조건을 만족하면 다음 반복으로 넘어가도록 사용함

```java
while (true) {
	//반복 내용
	if(조건식) {
		continue;
	}
}
```



### 이름 붙은 반복문

- break문은 근접한 단 하나의 반복문만 벗어날 수 있기 때문에, 여러 개의 반복문이 중첩된 경우에는 break문으로 중첩 반복문을 완전히 벗어날 수 없음
- 반복문에 이름을 붙이고 break문과 continue문에 이름을 지정해줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너 뛸 수 있음

```java
loop : for (int i = 1; i <= 5; i ++) {
  for (int j = 1; j <= 5; j ++) {
		if (조건식) {
			break loop;
			continue loop;
		}
  }
}
```





# #5 배열

# #6 객체지향 프로그래밍 1

# #7 객체지향 프로그래밍 2



# #8 예외처리(Exception Handling)

## 예외처리(Exception Handling)

### 프로그램 오류

- 프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있음
- 이를 발생 시점에 따라 컴파일에러와 런타임에러로 나눌 수 있음 + 논리적에러 (물건의 재고가 음수)
  - 컴파일 에러 : 컴파일 시에 발생하는 에러
  - 런타임 에러 : 실행 시에 발생하는 에러
  - 논리적 에러 : 실행은 되지만, 의도와 다르게 동작하는 것
- 자바에서는 런타임에서 발생할 수 있는 프로그램 오류를 Error(에러)와 Exception(예외) 두가지로 구분했음
- Error는 OOM이나 StackOverFlowError와 같이 일단 발생하면 복구할 수 없는 심각한 오류
- Exception은 발생하더라도 수습될 수 있는 비교적 덜 심각한 것
- Error가 발생하면 프로그램의 비정상적인 종료를 막을 길이 없지만 예외는 발생하더라도 프로그래머가 이에 대한 적절한 코드를 미리 작성해 놓음으로써 프로그램의 비정상적인 종료를 막을 수 있음
  - Error: 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
  - Exception: 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류

### 예외 클래스의 계층구조

![](https://user-images.githubusercontent.com/30790184/109766400-74d49100-7c39-11eb-93b8-3cd169c44c2f.png)

- 모든 예외의 최고 조상은 Exception 클래스
- RuntimeException하위 클래스들은 프로그래머의 실수에 의해서 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊음 ex: ArrayIndexOutOfBoundsException, NPE, etc...

### 예외 처리하기 try-catch문

- 예외처리란 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것임
- 예외처리의 목적은 예외의 발생으로 인한 실행 중인 갑작스런 비정상 종료를 막고, 정상적인 실행 상태를 유지할 수 있도록 하는 것
- 발생한 예외를 처리하지 못하면 프로그램은 비정상적으로 종료되고 처리되지 못한 예외는 jvm의 예외처리기가 받아서 예외의 원인을 화면에 출력함
- 예외를 처리하기 위해서는 try-catch문을 사용함

```java
try {
	// 예외가 발생할 가능성이 있는 문장들을 넣음
} catch (Exception1 e1) {
	// Exception1이 발생했을 경우 이를 처리하기 위한 문장을 넣음
} catch (Exception2 e2) {
  // Exception2이 발생했을 경우 이를 처리하기 위한 문장을 넣음
}
```

- 하나의 try 블럭과 n개의 catch 블럭이 올 수 있음
- 이 중 발생한 예외의 종류와 일치하는 단 한개의 catch 블럭만 수행됨
- 발생한 예외의 종류와 일치하는 catch블럭이 없으면 예외는 처리되지 않음
- 여러개의 catch문에 참조변수명은 겹치면 안됨

### try-catch문에서의 흐름

- try 블럭 내에서 예외가 발생한 경우.
  - 발생한 예외와 일치하는 catch블럭이 있는지 확인함
  - 일치하는 catch 블럭을 찾게 되면, 그 catch 블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행함. 만일 일치하는 catch 블럭을 찾지 못하면 예외는 처리되지 못함
- try 블럭 내에서 예외가 발생하지 않은 경우.
  - catch블럭을 거치지 않고 try-catch문을 빠져나가서 수행을 계속함
- try 블럭에 포함시킬 코드의 범위를 잘 선택해야함

### 예외의 발생과 catch 블럭

- 예외가 발생하면 발생한 예외에 해당하는 클래스의 인스턴스가 만들어짐
- 첫번째 catch 블록부터 차례대로 내려가면서 catch에 선언된 예외와 생성된 예외 클래스의 인스턴스에 instanceof연산자를 이용해서 검사 결과가 true인 catch 블록을 만날때까지 하향식으로 검사함
- 검사 결과가 전부 false라면 예외는 처리되지 않음
- 모든 예외 클래스는 Exception 클래스의 자손이므로 catch 블럭의 괄호에 Exception 클래스 타입의 참조 변수를 선언해 놓으면 어떤 종류의 예외가 발생하더라도 catch 가능
- 예외가 발생했을 때 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨 있음 
  - getMessage() : 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있음
  - printStackTrace() : 예외발생 당시 호출스택에 있었던 메서드의 정보와 예외 메시지를 화면에 출력

- jdk 1.7부터 다음과 같이 멀티 catch블럭을 사용할 수 있음

```java
try {

} catch (ExceptionA | ExceptionB e) {
	e.printStackTrace();
}
```

- | 기호로 연결된 예외 클래스가 조상-자손관계라면 컴파일에러 발생
- 멀티 catch에서의 특정 ExceptionA.methodA는 호출 불가( instaceof로 한번 묶으면 사용 가능 ), e 변수는 final

### 예외 발생시키기

- 키워드 throw를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있음

```java
Exception e = new Exception();
throw e;
```

- 컴파일러가 예외처리를 확인하지 않은 RuntimeException 클래스들은 Unchecked 예외라하고 컴파일러가 예외처리를 확인한다면Checked Exception 예외라고함

### 메서드에 예외 선언하기

- 예외를 처리하는 또다른 방법으로 throws를 사용할 수 있음

```java
void method() thorws Exception1, Exception2, ... ExceptionN {

}
```

- 발생할 수 있는 예외를 적어두면 메서드를 사용하려는 사람이 메서드의 선언부를 보았을 때, 어떤 예외들이 처리되어야하는지 쉽게 알 수 있음
- 일반적으로 RuntimeException 클래스들은 적지 않음
- throws는 자신을 호출한 메서드에게 예외를 전달하는 것 어디선가는 try-catch로 예외를 처리해야함
- 맨 마지막에 있는 main메서드에서도 예외가 처리되지 않으면 프로그램이 종료됨

### finally블럭

- finally 블럭은 예외의 발생 여부에 상관 없이 실행되어야 할 코드를 포함시킬 목적으로 사용됨(optional)

```java
try {
	// 예외가 발생할 가능성이 있는 문장들을 넣음
} catch (Exception e){
	// 예외 처리를 위한 문장을 적음
} finally {
	// 예외의 발생여부에 관계없이 항상 수행되어야하는 문장들을 넣음
}
```



### 자동 자원 반환 -try-with-resources문

- 주로 입출력에 사용되는 클래스 중에서는 사용한 후에 꼭 닫아줘야하는것들이 있는데 이때 try-with-resources를 사용하면 됨

```java
//일반 try-catch-finally

try {
  FileInputStream fis = new FileInputStream("data.dat")
  DataInputStream dis = new DataInputStream(fis)
} catch (Exception e) {
	
} finally {
  try {
    if(dis != null) {
      dis.close();
    }
  } catch (IOException ie) {
    
  }
}


//try-with-resources
try(FileInputStream fis = new FileInputStream("data.dat");
    DataInputStream dis = new DataInputStream("data.dat")) {

} catch (Exception e) {

}
```

- try-with-resources를 사용하면 자동으로 close()가 호출됨
- try-with-resources에의해 자동으로 객체의 close()가 호출될 수 있으려면 클래스가 AutoCloseable이라는 인터페이스를 구현한 것이어야만 함
- close() 내부에서 예외가 발생했다면 supressed(억제된) 이라는 의미의 머리말과 함께 출력됨



### 사용자정의 예외 만들기

- 프로그래머가 새로운 예외 클래스를 정의하여 사용할 수 있음

```java
class MyException extends Exception {
	MyException(String msg)() {
		super(msg);
	}
}
```

- unchecked예외 또는 checked예외를 상속받아 예외처리 여부를 선택하게 할 수 있음

### 예외 되던지기(exception re-throwing)

- 예외를 처리하고 인위적으로 다시 발생시킬 수 있음
- 이 방법은 하나의 예외에 대해서 예외가 발생한 메서드와 이를 호출한 메서드 양쪽 모두에서 처리해줘야 할 작업이 있을 때 사용됨

```java
class ExceptionEx {
	public static void main(String[] args) {
		try {
			method1();
		} catch (Exception e) {
		}
	}
	
	static void method1() throws Exception {
		try {
			throw new Exception();
		} else {
			throw e; //<= 예외 재발생
		}
	}
}
```

- 메서드 return 시그니처가 void가 아니라면 catch에서도 리턴을 해야하지만 예외 되던지기의 경우 return문을 대신할 수 있음.

  

### 연결된 예외(chained exception)

- 예외를 연결시켜서 한 예외가 다른 예외를 발생시킬수도 있음

```java
try {
	startInstall();
	copyFiles();
} catch (SpaceException e) {
	InstallException ie = new InstallException("설치중 예외 발생");
	ie.initCause(e);
	throw ie;
}
```

- 예외를 연결시키는 이유는 여러가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위해서이고 checked예외를 한번 감싸서 unchecked예외로 던져서 예외처리를 선택적으로 하도록 할 수 있음





# #9 java.lang 패키지와 유용한 클래스

# #10 날짜와 시간 & 형식화

# #11 컬렉션 프레임웍

# #12 제네릭, 열거형, 애너테이션

## 제네릭이란?

- 제네릭은 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능임
- 객체의 타입을 컴파일시에 체크하기 때문에 객체의 타입 안전성을 높이고 형변환의 번거로움이 줄어듦

## 제네릭 클래스의 선언

```java
class Box<T>
	T item;
	
	void setItem(T item) {
		this.item = item;
	}
	T getItem() {
		return item;
	}
```

- 타입변수는 의미있게 사용하면됨 ex Key Value경우 <K, V>
- 기호의 종류만 다를 뿐 임의의 참조형 타입을 의미한다는 개념만 이해하면됨
- Object 타입으로 받아서 형변환하지않고 원하는 타입을 지정해서 사용하기만하면 됨

```java
Box<String> b = new Box<>();
b.setItem("ABS");
```

- 제네릭클래스에 타입을 지정하지 않을 수 있지만 컴파일러가 경고를 표시함
- 타입 매개변수에 타입을 지정하는 것을 '제네릭 타입 호출'이라하고 지정된 타입을  '매개변수화된 타입' 이라함
- 모든 객체에 동일하게 동작해야하는 static 멤버 타입에는 T 변수를 사용할 수 없음
- 제네릭 배열 타입의 참조변수를 선언하는 것은 가능하지만 new T[10]와 같은 형태로 배열을 생성하는 것은 안됨 new는 컴파일 ㅅㅣ점에 타입T가 뭔지 정확히 알아야하기 때문.
- 위와 같은 맥락으로 instanceof 연산자도 T타입을 피연산자로 사용할 수 없음



## 제네릭 클래스의 객체 생성과 사용

- 참조변수와 생성자에 대입된 타입이 일치해야함

```java
Box<Apple> appleBox = new Box<Apple>();
Box<Apple> appleBox = new Box<Grape>(); // 에러
```

- 아래와 같이 





