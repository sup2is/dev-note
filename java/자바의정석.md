# 자바의 정석







# #1 자바를 시작하기 전에

# #2 변수

# #3 연산자

# #4 조건문과 반복문

- 때로는 같은 문장을 반복해서 수행하거나 조건에 따라 문장을 건너뛰어야함
- 프로그램의 흐름을 바꾸는 역할을 하는 문장들을 제어문이라고함
  - 조건문: 조건에 따라 다른 문장이 수행되도록 함
  - 반복문: 특정 문자들을 반복해서 수행함

## 조건문 - if, switch

- 조건문은 if문과 switch문이 있음
- 주로 if문이 사용되지만 많은 조건을 처리할 경우 switch문이 효율적임

### if문

- 가장 기본적인 조건문
- 만일 조건식이 true이면 괄호 안의 문장들을 수행하라 라는 의미로 해석하면 됨

```java
if (조건식) {
	// 조건식이 true일때 수행될 문장들을 적는다.
}
```

- 조건식의 결과가 false라면 괄호 안의 문장들이 실행되지 않음
- 비교연산자와 `&&` 또는  `||` 와 같은 논리 연산자로 여러 조건들을 추가할 수 있음
- 자바에서의 조건식 결과는 반드시 true 또는 false
- 조건문의 블록(괄호)에는 보통 여러 문장을 넣지만 한 문장만 있다면 괄호를 생략하고 한줄로 쓸 수 있음

```java
if(score < 60) println("합격")
```



### if-else문

- if문의 변형구조
- if문의 조건이 false라면 else 블럭의 문장을 수행함

```java
if (조건식) {
	// 조건식이 true일때 수행될 문장들을 적는다.
} else {
	// 조건식이 false일때 수행될 문장들을 적는다.
}
```

- if-else문은 true or false이기때문에 반드시 어느 한 블록은 실행되는 구조

### if-else if문

- true 또는 false이 아닌 처리해야할 경우의 수가 셋 이상인 경우엔 if - else - if 문을 사용하면 됨

```java
if (조건식1) {
	// 조건식1이 true일때 수행될 문장들을 적는다.
} else if (조건식2) {
	// 조건식2가 true일때 수행될 문장들을 적는다.
} else if (조건식n) {
  // 조건식n이 true일때 수행될 문장들을 적는다.
} else { // <- 맨 마지막 else는 생략 가능
  // 위의 어느 조건도 만족하지 않을 때 수행될 문장들을 적는다. 
}
```

### 중첩 if문

- if문의 블럭 내에 또 다른 if문을 포함시키는 것이 가능한데 이것을 중첩 if문이라 부름
- 중첩의 횟수는 거의 제한이 없음

```java
if (조건식1) {

	if (조건식2) {
		// 조건식1과 조건식2가 모두 true일때 수행될 문장들을 적는다.
  } else {
    // 조건식1이 true이고 조건식2가 false일때 수행될 문장들을 적는다.
  }

} else {
  // 조건식1이 false일 때 수행되는 문장들을 적는다.
}
```

- 중첩시에 괄호 생략 또는 들여쓰기에 주의해야함

### switch문

- if- else if  의 조건식이 많아지면 복잡해지고 여러 개의 조건식을 계산해야하므로 성능상 좋지 않음
- switch문은 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있고 표현도 간결하므로 알아보기 쉬움
- 처리해야할 조건수의 수가 많다면 switch문이 좋음
- switch문 동작 방법
  - 조건식을 계산한다.
  - 조건식의 결과와 일치하는 case문으로 이동한다.
  - 이후의 문장들을 수행한다.
  - break문이나 switch문의 끝을 만나면 switch문 전체를 빠져나간다.

```java
switch (조건식) {
	case 값1 :
		//조건식의 결과가 값1과 같을 경우 수행될 문장들
		break;
	case 값2 :
		//조건식의 결과가 값2과 같을 경우 수행될 문장들
		break;
	default :
  	//조건식의 결과와 일치하는 case문이 없을 때 수행될 문장들
}
```

- break를 만나지 않으면 순서대로 모든 문장들을 수행하기 때문에 빼먹지 말아야하지만 경우에 따라서 고의적으로 break문을 생략하는 경우도 있음

```java
switch (level) {
	case 3 :
		//삭제권한
	case 2 :
		//쓰기권한
	case 1 :
		//읽기권한
}
```

- switch문의 제약 조건
  - switch 문의 조건식 결과는 정수 또는 문자열이어야함
  - case문의 값은 정수, 상수 또는 문자열만 가능하며, 중복되지 않아야함
- switch문 역시 중첩이 가능함



## 반복문 - for, while, do-while

- 반복문은 어떤 작업이 반복적으로 수행도되록 할 때 사용
- 반복문의 종류는 for문, while문, do - while문이 있음
- do - while문은 최소한 한번은 수행될 것이 보장되는 것이 특징
- 반복문은 주어진 조건을 만족하는 동안 블록안의 문장들을 반복적으로 수행함
- for문은 주로 반복 횟수를 알고 있을 때 사용함

### for문

- 반복 횟수를 알고 있을 때 적합함

```java
for (int i = 1; i <= 5; i ++) {
	//반복 내용
}

...

for (초기화;조건식;증감식) {
	//반복 내용
}
```

- for문의 구조와 실행 순서
  1. 초기화
  2. 조건식
  3. 수행될문장
  4. 증감식 (2번으로 반복)

- 조건식을 잘못 작성하면 블럭내의 문장이 한 번도 수행되지 않거나 무한반복에 빠지기 쉬우므로 주의해야함
- 초기화 또는 증감식에도 두문장을 하나로 연결해서 쓸 수 있음

```java
for (int i = 1, j = 5; i <= 5; i ++, j --) {
	//반복 내용
}
```

- 아래와 같이 초기화, 조건식, 증감식을 전부 제거하면 무한반복문이됨

```java
for (;;) {
	//반복 내용
}
```

- for문도 중첩이 가능함
- jdk1.5부터 배열과 컬렉션에 저장된 요소에 접근할 때 기존보다 편리한 방법으로 처리할 수 있도록 향상된 for문이 추가됨

```java
for (int value : arr) {
	//반복 내용
}

for (타입 변수명 : 배열 또는 컬렉션) {
	//반복 내용
}
```



### while문

- while문은 조건식이 true이고 조건식이 false가 될 때까지 블럭 내의 문장을 반복함

```java
while (조건식) {
	//반복 내용
}
```

- 초기화나 증감식이 필요하지 않은 경우라면 while문이 적합함
- while문의 무한반복, 무한 반복문은 반드시 특정 조건을 만족하면 벗어나도록 해야 함

```
while (true) {
	//반복 내용
}
```

### do-while문

- while문의 변형으로 기본적인 구조는 while문과 같으나 조건식과 블럭의 순서를 바꿔놓은것

```
do {
	//반복 내용
} while (조건식);
```

- do 블록을 최소한 한번은 실행을 보장함

### break문

- break문은 자신이 포함된 가장 가까운 반복문을 벗어남
- 주로 if문과 함꼐 사용되어 특정 조건을 만족하면 반복문을 벗어나도록 함

```java
while (true) {
	//반복 내용
	if(조건식) {
		break;
	}
}
```



### continue문

- 반복이 진행되는 도중애 continue문을 만나면 다음 반복으로 넘어감
- continue문은 반복문 전체를 벗어나지 않고 다음 반복을 계속 수행한다는 점이 break문과 다름
- 주로 if문과 함꼐 사용되어 특정 조건을 만족하면 다음 반복으로 넘어가도록 사용함

```java
while (true) {
	//반복 내용
	if(조건식) {
		continue;
	}
}
```



### 이름 붙은 반복문

- break문은 근접한 단 하나의 반복문만 벗어날 수 있기 때문에, 여러 개의 반복문이 중첩된 경우에는 break문으로 중첩 반복문을 완전히 벗어날 수 없음
- 반복문에 이름을 붙이고 break문과 continue문에 이름을 지정해줌으로써 하나 이상의 반복문을 벗어나거나 반복을 건너 뛸 수 있음

```java
loop : for (int i = 1; i <= 5; i ++) {
  for (int j = 1; j <= 5; j ++) {
		if (조건식) {
			break loop;
			continue loop;
		}
  }
}
```





# #5 배열

# #6 객체지향 프로그래밍 1

# #7 객체지향 프로그래밍 2



# #8 예외처리(Exception Handling)

## 예외처리(Exception Handling)

### 프로그램 오류

- 프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있음
- 이를 발생 시점에 따라 컴파일에러와 런타임에러로 나눌 수 있음 + 논리적에러 (물건의 재고가 음수)
  - 컴파일 에러 : 컴파일 시에 발생하는 에러
  - 런타임 에러 : 실행 시에 발생하는 에러
  - 논리적 에러 : 실행은 되지만, 의도와 다르게 동작하는 것
- 자바에서는 런타임에서 발생할 수 있는 프로그램 오류를 Error(에러)와 Exception(예외) 두가지로 구분했음
- Error는 OOM이나 StackOverFlowError와 같이 일단 발생하면 복구할 수 없는 심각한 오류
- Exception은 발생하더라도 수습될 수 있는 비교적 덜 심각한 것
- Error가 발생하면 프로그램의 비정상적인 종료를 막을 길이 없지만 예외는 발생하더라도 프로그래머가 이에 대한 적절한 코드를 미리 작성해 놓음으로써 프로그램의 비정상적인 종료를 막을 수 있음
  - Error: 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
  - Exception: 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류

### 예외 클래스의 계층구조

![](https://user-images.githubusercontent.com/30790184/109766400-74d49100-7c39-11eb-93b8-3cd169c44c2f.png)

- 모든 예외의 최고 조상은 Exception 클래스
- RuntimeException하위 클래스들은 프로그래머의 실수에 의해서 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊음 ex: ArrayIndexOutOfBoundsException, NPE, etc...

### 예외 처리하기 try-catch문

- 예외처리란 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것임
- 예외처리의 목적은 예외의 발생으로 인한 실행 중인 갑작스런 비정상 종료를 막고, 정상적인 실행 상태를 유지할 수 있도록 하는 것
- 발생한 예외를 처리하지 못하면 프로그램은 비정상적으로 종료되고 처리되지 못한 예외는 jvm의 예외처리기가 받아서 예외의 원인을 화면에 출력함
- 예외를 처리하기 위해서는 try-catch문을 사용함

```java
try {
	// 예외가 발생할 가능성이 있는 문장들을 넣음
} catch (Exception1 e1) {
	// Exception1이 발생했을 경우 이를 처리하기 위한 문장을 넣음
} catch (Exception2 e2) {
  // Exception2이 발생했을 경우 이를 처리하기 위한 문장을 넣음
}
```

- 하나의 try 블럭과 n개의 catch 블럭이 올 수 있음
- 이 중 발생한 예외의 종류와 일치하는 단 한개의 catch 블럭만 수행됨
- 발생한 예외의 종류와 일치하는 catch블럭이 없으면 예외는 처리되지 않음
- 여러개의 catch문에 참조변수명은 겹치면 안됨

### try-catch문에서의 흐름

- try 블럭 내에서 예외가 발생한 경우.
  - 발생한 예외와 일치하는 catch블럭이 있는지 확인함
  - 일치하는 catch 블럭을 찾게 되면, 그 catch 블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서 그 다음 문장을 계속해서 수행함. 만일 일치하는 catch 블럭을 찾지 못하면 예외는 처리되지 못함
- try 블럭 내에서 예외가 발생하지 않은 경우.
  - catch블럭을 거치지 않고 try-catch문을 빠져나가서 수행을 계속함
- try 블럭에 포함시킬 코드의 범위를 잘 선택해야함

### 예외의 발생과 catch 블럭

- 예외가 발생하면 발생한 예외에 해당하는 클래스의 인스턴스가 만들어짐
- 첫번째 catch 블록부터 차례대로 내려가면서 catch에 선언된 예외와 생성된 예외 클래스의 인스턴스에 instanceof연산자를 이용해서 검사 결과가 true인 catch 블록을 만날때까지 하향식으로 검사함
- 검사 결과가 전부 false라면 예외는 처리되지 않음
- 모든 예외 클래스는 Exception 클래스의 자손이므로 catch 블럭의 괄호에 Exception 클래스 타입의 참조 변수를 선언해 놓으면 어떤 종류의 예외가 발생하더라도 catch 가능
- 

### 예외 발생시키기

### 메서드으에 예외 선언하기

### finally블럭

### 자동 자원 반환 -try -with - resources문

### 사용자정의 예외 만들기

### 예외 되던지기(exception re-throwing)

### 연결된 예외(chained exception)

