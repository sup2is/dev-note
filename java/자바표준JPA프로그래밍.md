https://github.com/holyeye/jpabook



# #1 JPA 소개

- JPA는 지루하고 반복적인 CRUD SQL을 알아서 처리해줄 뿐만 아니라 객체 모델링과 관계형 데이터베이스 사이의 차이점도 해결해준다.

## SQL을 직접 다룰 때 발생하는 문제점

- 개발자가 객체지향 어플리케이션과 데이터베이스 중간에서 SQL과 JDBC API를 사용해서 변환작업을 해줘야함 이는 RDB와 객체지향 패러다임의 차이가 있기 때문임
- 개발자가 SQL 쿼리로 인한 실수를 만들 여지가 많음
- 진정한 의미의 계층 분할이 안되고 엔티티를 신뢰할 수 없음
- SQL에 의존적인 개발을 피할 수 없음

## 패러다임의 불일치

- JPA는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해줌 개발자는 마치 자바 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면 됨
- 객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회하고 DB는 외래키를 사용해서 다른 테이블과의 조인으로 연관데이터를 가져온다.
- JPA는 연관관계와 관련된 패러다임의 불일치 문제를 해결해준다. 참조하는 객체를 외래키로 변환해서 적절한 insert sql을 만들어준다. 
- JPA를 사용하면 객체 그래프를 마음껏 사용할 수 있음 SQL의 경우 객체 그래프의 정도를 SQL 시점에서 결정해야하지만 JPA는 그렇지 않음
- JPA는 같은 트랜잭션일때 같은 객체가 조회되는것을 보장함.
- 객체지향과 데이터베이스 패러다임의 불일치로 어플리케이션이 점점 데이터 중심의 모델로 변하는 것을 JPA를 통해 해결할 수 있다. 

## JPA란 ?

- JPA는 자바진영의 ORM 기술 표준임 Java 와 JDBC api 사이에 존재함
- ORM은 Object-Relational Mapping임 객체와 데이터베이스를 매핑해주는 프레임워크
- ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 데이터베이스에 전달해주는 것뿐만 아니라 다양한 패러다임의 불일치 문제들도 해결해줌

### JPA 소개

- Java진영에서는 ORM 프레임워크중 하이버네이트를 가장 많이사용함
- EJB3.0에서 하이버네이트를 기반으로 새로운 자바 ORM이 탄생함 이게 JPA, JPA는 자바 ORM 기술에 대한 API 표준 명세

### JPA를 왜 사용해야 하는가?

- **생산성 :** SQL로 처리하던 지루한 CRUD를 JPA가 대신 처리해줌 기존에 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있음
- **유지보수:** 컬럼하나로 수많은 코드를 변경해야했던 부분이 JPA로 해결되기때문에 유지보수성 향상
- **패러다임의 불일치 해결:** JPA는 상속, 연관관계, 객체 그래프탐색, 동등성 비교 같은 패러다임의 불일치 해결
- **성능:** 기존 SQL 쿼리로 Database에 두번 나가는걸 1차캐시로 한번만으로 끝낼 수 있음
- **데이터 접근 추상화와 벤더 독립성:** 하나의 데이터베이스에 의존하지않도록 추상화된 레이어로 데이터베이스를 쉽게 변경할 수 있음
- **표준:** JPA는 표준이기 때문에 다른 기술로 손쉽게 변경 가능함



# #2 JPA 시작

- **@Entity:** 이 클래스를 테이블과 매핑한다고 JPA에게 알려줌 이런 클래스를 엔티티 클래스라함
- **@Table:** 엔티티 클래스에 매핑할 테이블 정보를 알려줌
- **@Id:** primary key에 매핑함 이 필드를 식별자 필드라고함
- **@Column :** 데이터베이스와 매핑될 컬럼명을 지정할 수 있음
- **매핑 정보가 없는 필드:** 자동적으로 컬럼명으로 매핑함

## 엔티티 매니저 설정

- **엔티티 매니저 팩토리 생성:** JPA를 시작하려면 우선 persistence.xml의 설정 정보를 사용해서 엔티티 매니저 팩토리를 생성해야함 Persistance 클래스를 사용해서 엔티티 매니저 팩토리를 생성하고 데이터 베이스 커넥션 풀 등을 생성해서  JPA를 사용할 수 있게 해줌 그러나 이 엔티티 매니저 팩토리는 초기 생성 비용이 굉장히 크기때문에 어플리케이션 전체에서 딱 한번만 생성하고 공유해서 사용해야함
- **엔티티 매니저 생성:** 엔티티 매니저 팩토리에서 엔티티 매니저를 생성함 JPA의 대부분의 기능들은 엔티티 매니저가 제공(CRUD), 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용하면 안됨
- **종료:** 사용이 끝난 엔티티매니저는 반드시 종료해야함 어플리케이션 종료시점에도 매니저 팩토리 역시 종료시켜야함

## 트랜잭션 관리

- JPA를 사용하면 반드시 트랜잭션 안에서 데이터를 변경해야함 엔티티매니저에서 트랜잭션을 얻어오고 정상동작시 커밋 아니면 롤백함

## 비지니스 로직 

## JPQL

- 애플리케이션이 필요한 데이터만 데이터베이스에서 불러오려면 JPQL을 통해서 질의하면 됨
- JPQL은 엔티티를 대상으로 질의하고 SQL은 데이터베이스를 대상으로 질의함 JPQL은 데이터베이스를 알지 못함





# #3 영속성 관리

- JPA가 제공하는 기능은 크게 엔티티와 테이블을 매핑하는 설계 부분과 매핑한 엔티티를 실제 사용하는 부분으로 나눌 수 있음

## 엔티티 매니저 팩토리와 엔티티 매니저

- 엔티티 매니저 팩토리를 생성하는 비용은 매우 크지만 앤티티 매니저 팩토리에서 엔티티 매니저를 생성하는 비용은 거의 들지 않음
- 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간에 절대 공유 금지! 
- 엔티티매니저는 바로 데이터베이스 커넥션을 얻지 않고 필요할 때 얻음

## 영속성 컨텍스트란 ?

- JPA를 이해한데 가장 중요한 용어
- 엔티티를 영구 저장하는 환경
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 만들어지고 엔티티매니저를 통해 접근 관리한다

## 엔티티의 생명주기

- **비영속:** 영속성 컨텍스트와 전혀 관계가 없는 상태
- **영속:** 영속성 컨텍스트에 저장된 상태
- **준영속:** 영속성 컨텍스트에 저장되었다가 분리된 상태
- **삭제:** 삭제된 상태

## 영속성 컨텍스트의 특징

- **영속성 컨텍스트와 식별자 값:**  @Id로 매핑된 식별자 필드가 반드시 있어야함
- **영속성 컨텍스트와 데이터베이스 저장:** 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 flush라함
- **영속성 컨텍스트가 엔티티를 고나리하면 좋은점:**
  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

### 엔티티 조회

- 영속성 컨텍스트 내부에는 캐시를 갖고 있는데 이걸 1차 캐시라함
- 영속성 컨텍스트 내부에 저장 조회하는 모든 기준은 @Id 가 붙은 식별자 필드임
- 1차캐시에서 엔티티를 찾고 만약 찾는 엔티티가 있으면 캐시에서만 조회함 없을경우 DB에 질의 후 1차캐시에 저장
- 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장함

### 엔티티 생성

- insert 문이 여러개가 있어도 하나의 트랜잭션 안에서는 마지막 트랜잭션 커밋에 데이터베이스에 flush하는데 이걸 트랜잭션을 지원하는 쓰기지연이라함
- 데이터베이스에 한번만 액세스하기때문에 성능읠 최적화 할 수 있음

### 엔티티 수정

- 변경감지를 통해서 엔티티 내부에 변경사항이 있으면 데이터베이스에 자동으로 반영해줌
- JPA는 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 스냅샷을 만들어둠
- 변경감지는 영속 상태의 엔티티만 관리함
- 쿼리는 모든 변경필드 뿐만 아니라 모든 필드에 대해 적용되므로 컬럼이 30개 이상이라면 @DynamicUpdate를 사용하는걸 추천함

### 엔티티 삭제

- 쓰기지연으로 삭제하지만 em.remove()를 적용하는 순간 이미 영속성 컨텍스트에서 제거됨

## 플러시

- flush()는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영함
  1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾음 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록함
  2. 쓰기지연 SQL 저장소의 쿼리를 DB에 등록함
- 영속성 컨텍스트 플러쉬방법 
  1. em.flush를 직접 호출
  2. 트랜잭션 커밋시 자동호출
  3. JPQL쿼리 실행시 자동호출
- 영속성 컨텍스트와 데이터베이스를 동기화시키는 것이 바로 플러시

## 준영속

- 영속성 컨텍스트가 관리하는 용속 상태의 엔티티가 영속성 컨텍스트에서 분리된것을 준영속 상태라함
- em.detach(한개의 entity), em.close(), em.clear()

### 준영속 상태의 특징

- 거의 비영속 상태임
- 식별자 값을 가지고 있음
- 지연 로딩 불가능

### 병합 merge()

- 준영속 상태의 엔티티를 영속상태로 변경하려면 병합을 사용하면 됨
- 새로운 영속상태의 엔티티를 반환함
- 식별자 값으로 엔티티를 조회할 수 있다면 비영속, 준영속도 신경쓰지 않음



# #4 엔티티 매핑



## @Entity

- 매핑할 클래스는 @Entity 필수
- 기본생성자 필수
- final 클래스에 사용 불가
- 저장할 필드가 final이면 사용 불가



## @Table

- 매핑될 테이블을 지정하고 없으면 class 네임으로 매핑됨



## 다양한 매핑 사용

- hivernate.hbm2ddl.auto 옵션을 사용해서 엔티티 클래스들만으로 테이블을 생성할 수 있음
  - create: 기존 테이블을 삭제하고 새로 생성 DROP + CREATE
  - create-drop: 애플리케이션 종료시점에 한번 더 DROP
  - update: 엔티티 매핑정보의 변경사항만 반영
  - validate: DB 테이블과 엔티티정보를 비교해서 문제가 있을경우 아렬줌
  - none
- 운영서버에서 create나 create-drop은 절대 사용 금지 validate or none
- hibernate.ejb.naming_strategy 속성으로 이름 매핑 전략 선택 가능

## 

## DDL 생성 기능

- 컬럼에 unique 속성이나 notnull 속성을 구현할 수 있음



## 기본 키 매핑 

**JPA가 제공하는 데이터베이스 기본 키 생성 전략**

- 직접할당: 기본 키를 애플리케이션에 직접 할당함
- 자동 생성: 대리키 사용 방식
  - IDENTITY: 기본 키 새엇ㅇ을 데이터베이스에 위임
  - SEQUENCE: 데이터베이스 시퀀스를 사용해서 기본키를 할당
  - TABLE: 키 생성 테이블을 사용

### 기본키 직접 할당 전략

- 기본기를 직접 할당하려면 @Id를 사용, 자동 생성 전략은 @GeneratedValue로 지정

### IDENTITY 전략

- 이 전략은 DB에 들어가는 시점에 ID가 부여되므로 INSERT 후에 기본 키 값을 조회 가능함
- 이 전략을 사용한다면 트랜잭션을 지원하는 쓰기 지연이 동작하지 않음

### SEQUENCE 전략

- 이전략은 시퀀스를 사용해서 기본키를 생성함
- 오라클 PostgreSQL, DB2, H2에서 사용 가능
- 먼저 시퀀스를 생성하고 사용해야함
- identity 전략이랑 조금 다르게 엔티티 저장전에 db에서 시퀀스를 꺼내오고 트랜잭션을 지원하는 쓰기 지연으로 flush 시점에 엔티티가 저장됨

### TABLE 전략

- 키 생성 전용 테이블을 하나 만들고 여기에 이름과 값으로 사용할 컬럼을 만들어 데이터베이스의 시퀀스를 흉내내는 것

### Auto 전략

- 위 전략중 하나를 자동으로 선택함 oracle은 시퀀스 전략, mysql은 identity전략



## 필드와 컬럼 매핑 : 레퍼런스



## @Column

- 객체 필드를 테이블 컬럼에 매핑 name, nullable이 가장 많이 사용, insertable, updateable 등
- @Column을 붙이면 기본값이 nullable false임

## @Enumerated

- 자바의 enum 타입 매핑에 사용하고 EnumType.String 만 사용할것

## @Temporal

- 날짜타입을 매핑할때 사용

## @Lob

- 데이터베이스의 Blob, Clob 타입에 매핑

## @Transient

- 이 필드는 JPA가 테이블이랑 매치하지않음 임시로 어떤 값을 보관할때 사용

## @Access

- JPA가 엔티티 데이터에 접근하는 방식을 지정
- 필드 접근, 프로퍼티 접근이 있음



# #5 연관관계 매핑

- 객체의 참조와 테이블의 외래키를 매핑하는 것
- 방향: 단방향, 양방향이 있음, 방향 개념은 객체관계에서만 존재하고 테이블 관계에는 항상 양방향임
- 다중성: 다대일, 일대다,일대일,다대다 가 있음
- 연관관계의 주인: 객체를 양방향 연관관계로 만들면 연고나관계의 주인을 정해야함



## 단방향 연관관계

- 회원과 팀이 있을때 회원은 하나의 팀에만 소속될 수 있음 이럴때 회원과 팀은 다대일 관계임
- **객체 연관관계와 테이블 연관관계의 가장 큰 차이**: 참조를 통한 연관관계는 언제나 단방향이고 양방향으로 설계한다고 하더라도 결국 서로 다른 단방향 2개를 만드는 것임 테이블은 하나의 키로 양방향 조인 가능
- 객체 연관관계: 객체는 참조로 연관관계를 맺음
- 테이블 연관관계: 테이블은 외래키로 연관관계를 맺음
- @ManyToOne: 다대일 관계 매핑 어노테이션
- @JoinColumn: 매핑할 외래 키 이름을 지정



## 연관관계 사용

- 객체 그래프 탐색 또는 JPQL을 사용해서 꺼내올 수 있음



## 양방향 연관관계

- JPA는 List등 자바의 컬렉션도 지원함
- 다대일에 대응하는 일대다로 @OneToMany를 사용함



## 연관관계의 주인

- 객체에는 양방향 연관관계라는 것이 없음
- 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야하는데 이것을 연관관계의 주인이라고함
- 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리(등록 수정 삭제)할 수 있음 반면에 주인이 아니라면 단순히 읽기만 가능함
- 주인은 mappedBy 속성을 사용하지 않음 연관관계의 주인이 아니라면 mappedBy 속성을 사용하면 됨
- 연관관계의 주인을 정하는것은 사실 외래 키 관리자를 선택하는 것
- @ManyToOne은 항상 연관관계의 주인이므로 mappedBy 속성이 없음



## 양방향 연관관계 저장

## 양방향 연관관계의 주의점

- 연관관계의 주인만이 외래키의 값을 변경할 수 있음

### 순수한 객체까지 고려한 양방향 연관관계

- 객체의 관점에서는 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전함

### 연관관계 편의 메소드

- 연관관계 편의 메소드를 통해 객체 연관관계를 반드시 해줘야 함

# #6 다양한 연관관계 매핑

- 연관관계 매핑시 3가지 고려사항
- 다중성, 단반향, 양방향, 연관관계의 주인

## 다대일

- 객체의 양방향 관계에서 연관관계의 주인은 항상 다 쪽임 일대다, 다대일
- 양항향은 외래키가 있는 쪽이 연관관계의 주인임
- 양방향 연관관계는 항상 서로를 참조해야함

## 일대다

- 일대다 단방향 매핑은 매핑한 객체가 관리하는 외래키가 다른 테이블에 있다는 점임 이때 insert 쿼리와 update 쿼리가 한번씩 나감
- 일대다 단방향 매핑보다 다대일 양방향 매핑을 사용하는게 좋음

## 일대일

- 일대일의 반대도 일대일임
- 어느곳이나 외래키를 가질 수 있음
- 단방향 양방향을 정할 수 있고 양방향시 연관관계의 주인만 정하면 됨
- 대상테이블에 키값을 두고 싶으면 무조건 양방향으로 매핑해야함

## 다대다

- RDB에서는 정규화된 테이블 2개로 다대다 매핑을 표현할 수 없음
- RDB에서는 연결해주는테이블을 한개 더 생성함
- 객체지향에서는 다대다 매핑이 가능함
- 다대다를 실무에서 적용하는건 무리가 있기때문에 어떻게 일대다 다대일로 풀어갈 지 생각해야함



직접 구성하면서 필요에 따라 자료를 찾아보는게 좋을 듯 함 ..

# #7 고급 매핑

- 상속 관계 매핑: 객체의 상속 관계를 어떻게 DB 테이블에 매핑하는지 
- MappedSuperclass: 등록일 수정일 같이 여러 엔티티에서 공통으로 사용하는 매핑 정보만 상속받고싶으면 이 기능을 사용하면 됨
- 복합 키와 식별 관계 매핑: 테이터베이스의 식별자가 하나 이상일 때 매핑하는 방법
- 조인테이블: 테이블은 외래키 하나로 연관관계를 맺을 수 있지만 연관관계를 관리하는 연결테이블을 두는 방법도 있음
- 엔티티 하나에 여러 테이블 매핑하기: 보통 엔티티 하나에 테이블 하나를 매핑하지만 엔티티 하나에 여러 테이블을 매핑하는 방법도 있음



## 상속 관계 매핑

- 관계형 데이터베이스에는 객체지향의 상속개념이 없음
- 슈퍼타입 서브타입 논리 모델을 테이블로 구현하는 세가지 방법
  1. 조인 전략
  2. 단일 테이블 전략
  3. 구현 클래스마다 테이블 전략

### 조인 전략

- 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본키 + 외래키로 사용하는 전략
- 조회할때 조인을 사용
- 객체는 타입으로 구분할 수 있지만 테이블은 타입의 개념이 없기때문에 주의해야함 타입을 구분컬럼으로 사용
- @Inheritance(strategy = InheritanceType.JOINED): 상속 매핑은 부모 클래스에 이 어노테이션을 사용해야함
- @DisciriminatorColumn(name = "DTYPE") 부모 클래스에 구분 컬럼을 지정함 이 컬럼으로 저장된 자식 테이블을 구분할 수 있음
- @DiscriminatorValue("{DTYPE 값}") 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정
- 기본값으로 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용하는데 만약 자식 테이블의 기본 키 컬럼명을 변경하고 싶으면 @PrimaryKeyJoinColumn을 사용하면 됨
- 조인 전략의 장단점
  - 장점 : 테이블이 정규화되고 외래키 참조 무결성 제약 조건 활용이 가능하고 저장 공간을 효율적으로 관리 가능함
  - 단점: 조회할때 성능 저하와 쿼리 복잡, 데이터 등록시 insert 두번

### 단일 테이블 전략

- 테이블을 하나만 사용하고 자식 엔티티가 매핑한 컬럼은 null을 허용해야함
- InheritanceType.SINGLE_TABLE로 지정하면 단일 테이블 전략을 사용할 수 있음 조인 전략이랑 사용방법은 같고 이 값면 명시해주면 됨
- 단일 테이블 전략의 장단점
  - 장점 : 조인이 필요없고 조회성능 빠르고 쿼리 간단
  - 단점 : 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야하고 테이블이 비대해질 수 있음
  - 특징 :@DiscriminatorValue을 사용하지 않으면 기본적으로 클래스명이 컬럼명이됨



### 구현 클래스마다 테이블 전략

- 자식 엔티티마다 테이블을 만들고 일반적으로 추천하지 않음



## @MappedSuperclass

- 부모클래스는 테이블과 매핑하지 않고 부모 클래스를 상속 받는 자식 클래스에게 매핑 정보만 제공하고 싶으면 @MappedSuperclass를 사용하면 됨
- @MappedSuperclass는 실제 테이블과 매핑되지 않음 주로 공통 매핑 정보를 하나로 추상화시켰을때 사용
- 부모로부터 물려받은 매핑 정보를 재정의하려면 @AuttributeOverride , @AuttributeOverrides를 사용하고 연관관계를 재정의하려면 @AssociationOverrides @AssociationOverride 를 사용할 것
- 당연히 엔티티가 아니기때문에 조회 불가
- 이 클래스를 직접 생성할 일도 없기때문에 추상클래스로 만드는 것을 추천함



## 복합 키와 식별 관계 매핑



### 식별관계 vs 비식별 관계

- 데이터베이스 테이블 사이에 관계는 외래키가 기본 키에 포함되는지 여부에 따라 식별 관계와 비식별 관계로 구분함 

**식별관계**

- 식별관계는 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용하는관계

**비식별관계**

- 부모 텡블의 기본 키를 받아서 그 키를 외래키로 사용하는 것
- 비식별 관계는 외래키의 null 허용 여부에 따라 필수적 비식별 관계, 선택적 비식별 관계로 나뉨
- 최근에는 비식별 관계를 주로 사용하고 필요한 곳에만 식별 관계를 사용하는 추세

### 복합 키: 비식별 관계 매핑

- JPA에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들고 equals와 hashcode를 구현해야함
- JPA에서는 @IdClass @EmbeddedId를 제공함 IdClass는 RDB에 가까운 방법이고 @EmbeddedId는 좀 더 객체지향에 가까운 방법

**@IdClass**

- 별도의 식별자 클래스를 생성해서 사용함
- 식별자 클래스의 속셩명과 엔티티에서 사용하는 식별자의 속성 명이 같아야함
- Serializable 인터페이스를 구현해야함
- equals, hashcode를 구현해야함
- 기본 생성자가 있어야함
- 식별자 클래스는 public 이어야함
- 서브클래스에서는 @JoinColums @JoinColum으로 부모와 매핑



**@EmbeddedId**

- @Embeddable 어노테이션을 사용함
- Serializable 인터페이스를 구현해야함
- equals, hashcode를 구현해야함
- 기본 생성자가 있어야함
- 식별자 클래스는 public 이어야함
- 서브클래스에서는 @JoinColums @JoinColum으로 부모와 매핑



**@IdClass vs @EmbeddedId**

- 각각 장단점이 있으므로 취향에 따라 일관성있게 작성하면 되고
- @EmbeddedId가 좀 더 객체지향 적이지만 특정 상황에 JPQL이 좀 더 길어질 수 있음



### 복합키: 식별 관계 매핑

생략



### 식별 비식별 관계의 장단점

- 비식별 관계를 선호함
- 식별 관계는 테이블이 늘어날수록 키도 늘어나기때문에 기본 키 인덱스가 불필요하게 커질 수 있음 쿼리도 복잡
- 식별관계는 비지니스의 의미가 있는 자연 키 컬럼을 조합하고 비식별관계는 비지니스와 관계 없는 대리키를 주로 사용함
- 식별관계는 비식별관계 테이블보다 유연하지 못함
- 식별관계는 기본 키 인덱스를 활용하기 좋고 하위 테이블만으로도 상위 테이블을 검색할 수 있는 장점이 있긴 함



## 조인 테이블





























