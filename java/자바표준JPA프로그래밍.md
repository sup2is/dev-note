https://github.com/holyeye/jpabook



# #1 JPA 소개

- JPA는 지루하고 반복적인 CRUD SQL을 알아서 처리해줄 뿐만 아니라 객체 모델링과 관계형 데이터베이스 사이의 차이점도 해결해준다.

## SQL을 직접 다룰 때 발생하는 문제점

- 개발자가 객체지향 어플리케이션과 데이터베이스 중간에서 SQL과 JDBC API를 사용해서 변환작업을 해줘야함 이는 RDB와 객체지향 패러다임의 차이가 있기 때문임
- 개발자가 SQL 쿼리로 인한 실수를 만들 여지가 많음
- 진정한 의미의 계층 분할이 안되고 엔티티를 신뢰할 수 없음
- SQL에 의존적인 개발을 피할 수 없음

## 패러다임의 불일치

- JPA는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해줌 개발자는 마치 자바 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면 됨
- 객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회하고 DB는 외래키를 사용해서 다른 테이블과의 조인으로 연관데이터를 가져온다.
- JPA는 연관관계와 관련된 패러다임의 불일치 문제를 해결해준다. 참조하는 객체를 외래키로 변환해서 적절한 insert sql을 만들어준다. 
- JPA를 사용하면 객체 그래프를 마음껏 사용할 수 있음 SQL의 경우 객체 그래프의 정도를 SQL 시점에서 결정해야하지만 JPA는 그렇지 않음
- JPA는 같은 트랜잭션일때 같은 객체가 조회되는것을 보장함.
- 객체지향과 데이터베이스 패러다임의 불일치로 어플리케이션이 점점 데이터 중심의 모델로 변하는 것을 JPA를 통해 해결할 수 있다. 

## JPA란 ?

- JPA는 자바진영의 ORM 기술 표준임 Java 와 JDBC api 사이에 존재함
- ORM은 Object-Relational Mapping임 객체와 데이터베이스를 매핑해주는 프레임워크
- ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 데이터베이스에 전달해주는 것뿐만 아니라 다양한 패러다임의 불일치 문제들도 해결해줌

### JPA 소개

- Java진영에서는 ORM 프레임워크중 하이버네이트를 가장 많이사용함
- EJB3.0에서 하이버네이트를 기반으로 새로운 자바 ORM이 탄생함 이게 JPA, JPA는 자바 ORM 기술에 대한 API 표준 명세

### JPA를 왜 사용해야 하는가?

- **생산성 :** SQL로 처리하던 지루한 CRUD를 JPA가 대신 처리해줌 기존에 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있음
- **유지보수:** 컬럼하나로 수많은 코드를 변경해야했던 부분이 JPA로 해결되기때문에 유지보수성 향상
- **패러다임의 불일치 해결:** JPA는 상속, 연관관계, 객체 그래프탐색, 동등성 비교 같은 패러다임의 불일치 해결
- **성능:** 기존 SQL 쿼리로 Database에 두번 나가는걸 1차캐시로 한번만으로 끝낼 수 있음
- **데이터 접근 추상화와 벤더 독립성:** 하나의 데이터베이스에 의존하지않도록 추상화된 레이어로 데이터베이스를 쉽게 변경할 수 있음
- **표준:** JPA는 표준이기 때문에 다른 기술로 손쉽게 변경 가능함



# #2 JPA 시작

- **@Entity:** 이 클래스를 테이블과 매핑한다고 JPA에게 알려줌 이런 클래스를 엔티티 클래스라함
- **@Table:** 엔티티 클래스에 매핑할 테이블 정보를 알려줌
- **@Id:** primary key에 매핑함 이 필드를 식별자 필드라고함
- **@Column :** 데이터베이스와 매핑될 컬럼명을 지정할 수 있음
- **매핑 정보가 없는 필드:** 자동적으로 컬럼명으로 매핑함

## 엔티티 매니저 설정

- **엔티티 매니저 팩토리 생성:** JPA를 시작하려면 우선 persistence.xml의 설정 정보를 사용해서 엔티티 매니저 팩토리를 생성해야함 Persistance 클래스를 사용해서 엔티티 매니저 팩토리를 생성하고 데이터 베이스 커넥션 풀 등을 생성해서  JPA를 사용할 수 있게 해줌 그러나 이 엔티티 매니저 팩토리는 초기 생성 비용이 굉장히 크기때문에 어플리케이션 전체에서 딱 한번만 생성하고 공유해서 사용해야함
- **엔티티 매니저 생성:** 엔티티 매니저 팩토리에서 엔티티 매니저를 생성함 JPA의 대부분의 기능들은 엔티티 매니저가 제공(CRUD), 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용하면 안됨
- **종료:** 사용이 끝난 엔티티매니저는 반드시 종료해야함 어플리케이션 종료시점에도 매니저 팩토리 역시 종료시켜야함

## 트랜잭션 관리

- JPA를 사용하면 반드시 트랜잭션 안에서 데이터를 변경해야함 엔티티매니저에서 트랜잭션을 얻어오고 정상동작시 커밋 아니면 롤백함

## 비지니스 로직 

## JPQL

- 애플리케이션이 필요한 데이터만 데이터베이스에서 불러오려면 JPQL을 통해서 질의하면 됨
- JPQL은 엔티티를 대상으로 질의하고 SQL은 데이터베이스를 대상으로 질의함 JPQL은 데이터베이스를 알지 못함





# #3 영속성 관리

- JPA가 제공하는 기능은 크게 엔티티와 테이블을 매핑하는 설계 부분과 매핑한 엔티티를 실제 사용하는 부분으로 나눌 수 있음

## 엔티티 매니저 팩토리와 엔티티 매니저

- 엔티티 매니저 팩토리를 생성하는 비용은 매우 크지만 앤티티 매니저 팩토리에서 엔티티 매니저를 생성하는 비용은 거의 들지 않음
- 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간에 절대 공유 금지! 
- 엔티티매니저는 바로 데이터베이스 커넥션을 얻지 않고 필요할 때 얻음

## 영속성 컨텍스트란 ?

- JPA를 이해한데 가장 중요한 용어
- 엔티티를 영구 저장하는 환경
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 만들어지고 엔티티매니저를 통해 접근 관리한다

## 엔티티의 생명주기

- **비영속:** 영속성 컨텍스트와 전혀 관계가 없는 상태
- **영속:** 영속성 컨텍스트에 저장된 상태
- **준영속:** 영속성 컨텍스트에 저장되었다가 분리된 상태
- **삭제:** 삭제된 상태

## 영속성 컨텍스트의 특징

- **영속성 컨텍스트와 식별자 값:**  @Id로 매핑된 식별자 필드가 반드시 있어야함
- **영속성 컨텍스트와 데이터베이스 저장:** 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 flush라함
- **영속성 컨텍스트가 엔티티를 고나리하면 좋은점:**
  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

### 엔티티 조회

- 영속성 컨텍스트 내부에는 캐시를 갖고 있는데 이걸 1차 캐시라함
- 영속성 컨텍스트 내부에 저장 조회하는 모든 기준은 @Id 가 붙은 식별자 필드임
- 1차캐시에서 엔티티를 찾고 만약 찾는 엔티티가 있으면 캐시에서만 조회함 없을경우 DB에 질의 후 1차캐시에 저장
- 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장함

### 엔티티 생성

- insert 문이 여러개가 있어도 하나의 트랜잭션 안에서는 마지막 트랜잭션 커밋에 데이터베이스에 flush하는데 이걸 트랜잭션을 지원하는 쓰기지연이라함
- 데이터베이스에 한번만 액세스하기때문에 성능읠 최적화 할 수 있음

### 엔티티 수정

- 변경감지를 통해서 엔티티 내부에 변경사항이 있으면 데이터베이스에 자동으로 반영해줌
- JPA는 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 스냅샷을 만들어둠
- 변경감지는 영속 상태의 엔티티만 관리함
- 쿼리는 모든 변경필드 뿐만 아니라 모든 필드에 대해 적용되므로 컬럼이 30개 이상이라면 @DynamicUpdate를 사용하는걸 추천함

### 엔티티 삭제

- 쓰기지연으로 삭제하지만 em.remove()를 적용하는 순간 이미 영속성 컨텍스트에서 제거됨

## 플러시

- flush()는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영함
  1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾음 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록함
  2. 쓰기지연 SQL 저장소의 쿼리를 DB에 등록함
- 영속성 컨텍스트 플러쉬방법 
  1. em.flush를 직접 호출
  2. 트랜잭션 커밋시 자동호출
  3. JPQL쿼리 실행시 자동호출
- 영속성 컨텍스트와 데이터베이스를 동기화시키는 것이 바로 플러시

## 준영속

- 영속성 컨텍스트가 관리하는 용속 상태의 엔티티가 영속성 컨텍스트에서 분리된것을 준영속 상태라함
- em.detach(한개의 entity), em.close(), em.clear()

### 준영속 상태의 특징

- 거의 비영속 상태임
- 식별자 값을 가지고 있음
- 지연 로딩 불가능

### 병합 merge()

- 준영속 상태의 엔티티를 영속상태로 변경하려면 병합을 사용하면 됨
- 새로운 영속상태의 엔티티를 반환함
- 식별자 값으로 엔티티를 조회할 수 있다면 비영속, 준영속도 신경쓰지 않음



# #4 엔티티 매핑



## @Entity

- 매핑할 클래스는 @Entity 필수
- 기본생성자 필수
- final 클래스에 사용 불가
- 저장할 필드가 final이면 사용 불가



## @Table

- 매핑될 테이블을 지정하고 없으면 class 네임으로 매핑됨



## 다양한 매핑 사용

- hivernate.hbm2ddl.auto 옵션을 사용해서 엔티티 클래스들만으로 테이블을 생성할 수 있음
  - create: 기존 테이블을 삭제하고 새로 생성 DROP + CREATE
  - create-drop: 애플리케이션 종료시점에 한번 더 DROP
  - update: 엔티티 매핑정보의 변경사항만 반영
  - validate: DB 테이블과 엔티티정보를 비교해서 문제가 있을경우 아렬줌
  - none
- 운영서버에서 create나 create-drop은 절대 사용 금지 validate or none
- hibernate.ejb.naming_strategy 속성으로 이름 매핑 전략 선택 가능

## 

## DDL 생성 기능

- 컬럼에 unique 속성이나 notnull 속성을 구현할 수 있음



## 기본 키 매핑 

**JPA가 제공하는 데이터베이스 기본 키 생성 전략**

- 직접할당: 기본 키를 애플리케이션에 직접 할당함
- 자동 생성: 대리키 사용 방식
  - IDENTITY: 기본 키 새엇ㅇ을 데이터베이스에 위임
  - SEQUENCE: 데이터베이스 시퀀스를 사용해서 기본키를 할당
  - TABLE: 키 생성 테이블을 사용

### 기본키 직접 할당 전략

- 기본기를 직접 할당하려면 @Id를 사용, 자동 생성 전략은 @GeneratedValue로 지정

### IDENTITY 전략

- 이 전략은 DB에 들어가는 시점에 ID가 부여되므로 INSERT 후에 기본 키 값을 조회 가능함
- 이 전략을 사용한다면 트랜잭션을 지원하는 쓰기 지연이 동작하지 않음

### SEQUENCE 전략

- 이전략은 시퀀스를 사용해서 기본키를 생성함
- 오라클 PostgreSQL, DB2, H2에서 사용 가능
- 먼저 시퀀스를 생성하고 사용해야함
- identity 전략이랑 조금 다르게 엔티티 저장전에 db에서 시퀀스를 꺼내오고 트랜잭션을 지원하는 쓰기 지연으로 flush 시점에 엔티티가 저장됨

### TABLE 전략

- 키 생성 전용 테이블을 하나 만들고 여기에 이름과 값으로 사용할 컬럼을 만들어 데이터베이스의 시퀀스를 흉내내는 것

### Auto 전략

- 위 전략중 하나를 자동으로 선택함 oracle은 시퀀스 전략, mysql은 identity전략



## 필드와 컬럼 매핑 : 레퍼런스



## @Column

- 객체 필드를 테이블 컬럼에 매핑 name, nullable이 가장 많이 사용, insertable, updateable 등
- @Column을 붙이면 기본값이 nullable false임

## @Enumerated

- 자바의 enum 타입 매핑에 사용하고 EnumType.String 만 사용할것

## @Temporal

- 날짜타입을 매핑할때 사용

## @Lob

- 데이터베이스의 Blob, Clob 타입에 매핑

## @Transient

- 이 필드는 JPA가 테이블이랑 매치하지않음 임시로 어떤 값을 보관할때 사용

## @Access

- JPA가 엔티티 데이터에 접근하는 방식을 지정
- 필드 접근, 프로퍼티 접근이 있음



# #5 연관관계 매핑

- 객체의 참조와 테이블의 외래키를 매핑하는 것
- 방향: 단방향, 양방향이 있음, 방향 개념은 객체관계에서만 존재하고 테이블 관계에는 항상 양방향임
- 다중성: 다대일, 일대다,일대일,다대다 가 있음
- 연관관계의 주인: 객체를 양방향 연관관계로 만들면 연고나관계의 주인을 정해야함



## 단방향 연관관계

- 회원과 팀이 있을때 회원은 하나의 팀에만 소속될 수 있음 이럴때 회원과 팀은 다대일 관계임
- **객체 연관관계와 테이블 연관관계의 가장 큰 차이**: 참조를 통한 연관관계는 언제나 단방향이고 양방향으로 설계한다고 하더라도 결국 서로 다른 단방향 2개를 만드는 것임 테이블은 하나의 키로 양방향 조인 가능
- 객체 연관관계: 객체는 참조로 연관관계를 맺음
- 테이블 연관관계: 테이블은 외래키로 연관관계를 맺음
- @ManyToOne: 다대일 관계 매핑 어노테이션
- @JoinColumn: 매핑할 외래 키 이름을 지정



## 연관관계 사용

- 객체 그래프 탐색 또는 JPQL을 사용해서 꺼내올 수 있음



## 양방향 연관관계

- JPA는 List등 자바의 컬렉션도 지원함
- 다대일에 대응하는 일대다로 @OneToMany를 사용함



## 연관관계의 주인

- 객체에는 양방향 연관관계라는 것이 없음
- 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야하는데 이것을 연관관계의 주인이라고함
- 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리(등록 수정 삭제)할 수 있음 반면에 주인이 아니라면 단순히 읽기만 가능함
- 주인은 mappedBy 속성을 사용하지 않음 연관관계의 주인이 아니라면 mappedBy 속성을 사용하면 됨
- 연관관계의 주인을 정하는것은 사실 외래 키 관리자를 선택하는 것
- @ManyToOne은 항상 연관관계의 주인이므로 mappedBy 속성이 없음



## 양방향 연관관계 저장

## 양방향 연관관계의 주의점

- 연관관계의 주인만이 외래키의 값을 변경할 수 있음

### 순수한 객체까지 고려한 양방향 연관관계

- 객체의 관점에서는 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전함

### 연관관계 편의 메소드

- 연관관계 편의 메소드를 통해 객체 연관관계를 반드시 해줘야 함

# #6 다양한 연관관계 매핑

- 연관관계 매핑시 3가지 고려사항
- 다중성, 단반향, 양방향, 연관관계의 주인

## 다대일

- 객체의 양방향 관계에서 연관관계의 주인은 항상 다 쪽임 일대다, 다대일
- 양항향은 외래키가 있는 쪽이 연관관계의 주인임
- 양방향 연관관계는 항상 서로를 참조해야함

## 일대다

- 일대다 단방향 매핑은 매핑한 객체가 관리하는 외래키가 다른 테이블에 있다는 점임 이때 insert 쿼리와 update 쿼리가 한번씩 나감
- 일대다 단방향 매핑보다 다대일 양방향 매핑을 사용하는게 좋음

## 일대일

- 일대일의 반대도 일대일임
- 어느곳이나 외래키를 가질 수 있음
- 단방향 양방향을 정할 수 있고 양방향시 연관관계의 주인만 정하면 됨
- 대상테이블에 키값을 두고 싶으면 무조건 양방향으로 매핑해야함

## 다대다

- RDB에서는 정규화된 테이블 2개로 다대다 매핑을 표현할 수 없음
- RDB에서는 연결해주는테이블을 한개 더 생성함
- 객체지향에서는 다대다 매핑이 가능함
- 다대다를 실무에서 적용하는건 무리가 있기때문에 어떻게 일대다 다대일로 풀어갈 지 생각해야함



직접 구성하면서 필요에 따라 자료를 찾아보는게 좋을 듯 함 ..

# #7 고급 매핑

- 상속 관계 매핑: 객체의 상속 관계를 어떻게 DB 테이블에 매핑하는지 
- MappedSuperclass: 등록일 수정일 같이 여러 엔티티에서 공통으로 사용하는 매핑 정보만 상속받고싶으면 이 기능을 사용하면 됨
- 복합 키와 식별 관계 매핑: 테이터베이스의 식별자가 하나 이상일 때 매핑하는 방법
- 조인테이블: 테이블은 외래키 하나로 연관관계를 맺을 수 있지만 연관관계를 관리하는 연결테이블을 두는 방법도 있음
- 엔티티 하나에 여러 테이블 매핑하기: 보통 엔티티 하나에 테이블 하나를 매핑하지만 엔티티 하나에 여러 테이블을 매핑하는 방법도 있음



## 상속 관계 매핑

- 관계형 데이터베이스에는 객체지향의 상속개념이 없음
- 슈퍼타입 서브타입 논리 모델을 테이블로 구현하는 세가지 방법
  1. 조인 전략
  2. 단일 테이블 전략
  3. 구현 클래스마다 테이블 전략

### 조인 전략

- 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본키 + 외래키로 사용하는 전략
- 조회할때 조인을 사용
- 객체는 타입으로 구분할 수 있지만 테이블은 타입의 개념이 없기때문에 주의해야함 타입을 구분컬럼으로 사용
- @Inheritance(strategy = InheritanceType.JOINED): 상속 매핑은 부모 클래스에 이 어노테이션을 사용해야함
- @DisciriminatorColumn(name = "DTYPE") 부모 클래스에 구분 컬럼을 지정함 이 컬럼으로 저장된 자식 테이블을 구분할 수 있음
- @DiscriminatorValue("{DTYPE 값}") 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정
- 기본값으로 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용하는데 만약 자식 테이블의 기본 키 컬럼명을 변경하고 싶으면 @PrimaryKeyJoinColumn을 사용하면 됨
- 조인 전략의 장단점
  - 장점 : 테이블이 정규화되고 외래키 참조 무결성 제약 조건 활용이 가능하고 저장 공간을 효율적으로 관리 가능함
  - 단점: 조회할때 성능 저하와 쿼리 복잡, 데이터 등록시 insert 두번

### 단일 테이블 전략

- 테이블을 하나만 사용하고 자식 엔티티가 매핑한 컬럼은 null을 허용해야함
- InheritanceType.SINGLE_TABLE로 지정하면 단일 테이블 전략을 사용할 수 있음 조인 전략이랑 사용방법은 같고 이 값면 명시해주면 됨
- 단일 테이블 전략의 장단점
  - 장점 : 조인이 필요없고 조회성능 빠르고 쿼리 간단
  - 단점 : 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야하고 테이블이 비대해질 수 있음
  - 특징 :@DiscriminatorValue을 사용하지 않으면 기본적으로 클래스명이 컬럼명이됨



### 구현 클래스마다 테이블 전략

- 자식 엔티티마다 테이블을 만들고 일반적으로 추천하지 않음



## @MappedSuperclass

- 부모클래스는 테이블과 매핑하지 않고 부모 클래스를 상속 받는 자식 클래스에게 매핑 정보만 제공하고 싶으면 @MappedSuperclass를 사용하면 됨
- @MappedSuperclass는 실제 테이블과 매핑되지 않음 주로 공통 매핑 정보를 하나로 추상화시켰을때 사용
- 부모로부터 물려받은 매핑 정보를 재정의하려면 @AuttributeOverride , @AuttributeOverrides를 사용하고 연관관계를 재정의하려면 @AssociationOverrides @AssociationOverride 를 사용할 것
- 당연히 엔티티가 아니기때문에 조회 불가
- 이 클래스를 직접 생성할 일도 없기때문에 추상클래스로 만드는 것을 추천함



## 복합 키와 식별 관계 매핑



### 식별관계 vs 비식별 관계

- 데이터베이스 테이블 사이에 관계는 외래키가 기본 키에 포함되는지 여부에 따라 식별 관계와 비식별 관계로 구분함 

**식별관계**

- 식별관계는 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용하는관계

**비식별관계**

- 부모 텡블의 기본 키를 받아서 그 키를 외래키로 사용하는 것
- 비식별 관계는 외래키의 null 허용 여부에 따라 필수적 비식별 관계, 선택적 비식별 관계로 나뉨
- 최근에는 비식별 관계를 주로 사용하고 필요한 곳에만 식별 관계를 사용하는 추세

### 복합 키: 비식별 관계 매핑

- JPA에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들고 equals와 hashcode를 구현해야함
- JPA에서는 @IdClass @EmbeddedId를 제공함 IdClass는 RDB에 가까운 방법이고 @EmbeddedId는 좀 더 객체지향에 가까운 방법

**@IdClass**

- 별도의 식별자 클래스를 생성해서 사용함
- 식별자 클래스의 속셩명과 엔티티에서 사용하는 식별자의 속성 명이 같아야함
- Serializable 인터페이스를 구현해야함
- equals, hashcode를 구현해야함
- 기본 생성자가 있어야함
- 식별자 클래스는 public 이어야함
- 서브클래스에서는 @JoinColums @JoinColum으로 부모와 매핑



**@EmbeddedId**

- @Embeddable 어노테이션을 사용함
- Serializable 인터페이스를 구현해야함
- equals, hashcode를 구현해야함
- 기본 생성자가 있어야함
- 식별자 클래스는 public 이어야함
- 서브클래스에서는 @JoinColums @JoinColum으로 부모와 매핑



**@IdClass vs @EmbeddedId**

- 각각 장단점이 있으므로 취향에 따라 일관성있게 작성하면 되고
- @EmbeddedId가 좀 더 객체지향 적이지만 특정 상황에 JPQL이 좀 더 길어질 수 있음



### 복합키: 식별 관계 매핑

생략



### 식별 비식별 관계의 장단점

- 비식별 관계를 선호함
- 식별 관계는 테이블이 늘어날수록 키도 늘어나기때문에 기본 키 인덱스가 불필요하게 커질 수 있음 쿼리도 복잡
- 식별관계는 비지니스의 의미가 있는 자연 키 컬럼을 조합하고 비식별관계는 비지니스와 관계 없는 대리키를 주로 사용함
- 식별관계는 비식별관계 테이블보다 유연하지 못함
- 식별관계는 기본 키 인덱스를 활용하기 좋고 하위 테이블만으로도 상위 테이블을 검색할 수 있는 장점이 있긴 함



## 조인 테이블

- 데이터베이스 테이블의 연관관계를 설계하는 2가지 방법
- 조인 컬럼 사용
- 조인 테이블 사용

**조인 컬럼 사용**

- 테이블 간에 관계는 주로 조인 컬럼이라 부르는 외래 키 컬럼을 사용해서 관리함
- 둘 사이 관계가 정해지지 않았을 경우 왜래키에 null을 허용해야하는데 이런 관계를 선택적 비식별관계라함

**조인 테이블 사용**

- 두 테이블 사이에 조인 테이블을 두어 테이블간에 서로 연관관계를 관리하기 위한 왜리 키 컬럼 이 없음
- 가장 큰 단점은 테이블을 하나 추가해야 한다는 점

***



- 객체와 테이블을 매핑할 때 조인 컬럼은 @JoinColumn으로 매핑하고 조인 테이블은 @JoinTable로 매핑함
- 조인 테이블은 주로 다대다 관계를 일대다, 다대일 관계로 풀어내기 위해 사용함 그렇지만 일대일, 일대다, 다대일 관계에서도 사용함



### 일대일 조인 테이블

### 일대다 조인 테이블

### 다대일 조인 테이블

### 다대다 조인 테이블

***

> 조인 테이블에 컬럼을 추가하면 @JoinTable 전략을 사용할 수 없음 대신에 새로운 엔티티를 만들어서 조인 테이블과 매핑해야함



## 엔티티 하나에 여러 테이블 매핑

- 잘 사용하지는 않지만 @SecondaryTable을 사용하면 한 엔티티에 여러 테이블을 매핑할 수 있음
- 테이블당 엔티티를 각각 만들어서 일대일 매핑하는 것을 권장함
- 이 방법은 항상 두 테이블을 조회하므로 최적화 하기 어려움





# #8 프록시와 연관관계 분리

**프록시와 즉시로딩, 지연로딩**

- jpa는 프록시를 사용해서 연관된 객체를 처음부터 데이터베이스에서 조회하는 것이 아니라, 실제 사용하는 시점에 데이터베이스에서 조회할 수 있음
- 하지만 자주 함께 사용하는 객체들은 조인을 사용해서 함께 조회하는 것이 효과적임
- jpa는 즉시로딩과 지연로딩이라는 방법으로 두가지 모두 지원함

**영속성 전이와 고아 객체**

- jpa는 연관된 객체를 함께 저장하거나 함께 삭제할 수 있는 영속성 전이와 고아 객체 제거라는 편리한 기능을 제공함



## 프록시

- 엔티티의 값을 실제 사용하는 시점에서 필요한 데이터를 조회함
- 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 프록시 객체라 함

> 지연로딩은 프록시, 바이트코드 구성이 있음



### 프록시 기초

- jpa에서 식별자로 엔티티 하나를 조회할때 EntityManager.find()를 사용함 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회함
- 만약 실제 사용 시점까지 데이터베이스 조회를 미루고 싶으면 EntityManager.getReference() 메서드를 사용하면 됨

**프록시의 특징**

- 프록시 클래스는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 겉 모양이 같음 따라서 사용하는 입장에서 신경쓰지 않아도 됨
- 프록시는 실제 객체에 대한 참조를 보관함 프록시 객체의 메서드를 호출하면 실제 메서드를 호출함

**프록시 객체의 초기화**

- 실제 엔티티 객체를 초기화할때 프록시 객체의 초기화라 함 

**프록시 초기화 과정**

1. 메서드를 호출해서 실제 데이터 조회
2. 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데 이것을 초기화라함
3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성함
4. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 멤버변수에 보관함
5. 프록시 객체는 실제 엔티티 객채의 메서드를 호출해서 결과를 반환함

**프록시의 특징**

- 프록시는 처음 사용할 때 한번만 초기화됨
- 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아님 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있음
- 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크시에 주의해서 사용해야 함
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없음 이후에는 실제 엔티티를 반환함
- 초기화는 영속성 컨텍스트의 도움을 받아야 가능함 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속상태의 프록시를 초기화하면 문제가 발생함 항비ㅓ네이트는 LazyInitializationException을 발생

**준영속 상태와 초기화**



### 프록시와 식별자

- 엔티티를 프록시로 조회할 때 식별자 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관하고 있음
- 엔티티 접근 방식을 프로퍼티로 설정한 경우에만 식별자 값을 조회해도 초기화 되지 않음
- 엔티티 접근 방식을 필드로 설정하면 식별자 조회라도 프록시 객체를 초기화함
- 프록시는 연관관계를 설정할때 유용하게 사용할 수 있음
- 참고로 연관관계 설정시에는 엔티티 접근 방식을 필드로 설정해도 초기화하지 않음



### 프록시 확인

- jpa가 제공하는 PersistenceUnitUtil.isLoaded() 메서드를 사용하면 프록시 인스턴스의 초기화 여부를 알 수 있음
- 하이버네이트에는 강제로 초기화시키는 메서드가 있음



## 즉시 로딩과 지연 로딩

- jpa는 개발자가 연관된 엔티티의 조회 시점을 선택할수 있도록 다음 두가지 방법을 제공함

**즉시 로딩**

- 엔티티를 조회할 때 연관된 엔티티도 함께 조회함
- @ManyToOne(fetch = FetchType.EAGER)

**지연 로딩**

- 연관된 엔티티를 실제 사용할 때 조회함
- @ManyToOne(fetch = FetchType.LAZY)

### 즉시 로딩

- 대부분의 jpa 구현체는 즉시 로딩을 최적화 하기 위해 가능하면 조인 쿼리를 사용함

> **null 제약조건과 jpa 조인 전략**
>
> - 최적화에는 내부조인이 좋은데 내부조인을 반드시 사용하려면 @JoinColumn(nullable= false) 값을 주면 내부조인을 사용함
> - 또는 @ManyToOne.optional= false로 설정해도 내부조인을 사용함
> - 정리하면 jpa는 선택적 관계면 외부조인을 사용하고 필수 관계면 내부조인을 사용함



### 지연 로딩

- 연관관계로 매핑된 객체는 프록시 객체로 대체되어서 들어옴
- 실제 조회시점에 데이터베이스에 액세스함

### 즉시 로딩, 지연 로딩 정리

- 상황에 따라서 알맞는 방법을 선택해야함



## 지연 로딩 활용



### 프록시와 컬렉션 래퍼

- 하이버네티으는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경하는데 이것을 컬렉션 래퍼라함
- 엔티티를 지연 로딩하면 프록시 객체를 사용해서 지연 로딩을 수행하지만 주문 내역 같은 컬렉션은 컬렉션 래퍼가 지연 로딩을 처리해줌



### jpa 기본 페치 전략

- @ManyToOne,  @OneToMany: 즉시 로딩
- @OneToMany, @ManyToMany: 지연 로딩
- 추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것임
- 애플리케이션 개발이 어느정도 완료 단계에 왔을 때 실제 사용하는 상황을 보고 꼭 필요한 고셍서만 즉시 로딩을 사용하도록 최적화하면 됨



### 컬렉션에 FetchType.EAGER 사용시 주의점

- 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않음
- 컬렉션 즉시 로딩은 항상 외부조인을 사용함



## 영속성 전이: CASCADE

- 특정 엔티티를 영속 상태로 만들때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이 기능을 사용하면 됨 
- JPA는 CASCADE 옵션으로 영속성 전이를 제공함



### 영속성 전이: 저장

- @OneToMany(cascade = CascadeType.PERSIST)
- 저장시 한번에 등록됨
- 영속성 전이는 연관관계를 매핑하는 것과는 아무 관련이 없음 단지 엔티티를 영속화할 때 연관된 엔티티도 같이 영속화하는 편리함을 제공함



### 영속성 전이: 삭제

- 영속성 전이는 엔티티를 삭제할 때도 사용할 수 있음 Cascade.REMOVE

> PERSIST, REMOVE는 flush를 호출할때 전이가 발생함



## 고아 객체

- JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체 제거라함
- 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 제동으로 삭제됨
- @OneToMany(orphanRemoval= true)
- 플러시 시점에 적용
- 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제함
- @OneToOne @OneToMany에서만 사용
- 부모제거시 자동 삭제



## 영속성 전이 + 고아 객체, 생명 주기



# #9 값 타입

**값 타입 종류**

- 기본 값 타입
  - 자바 기본 타입
  - 래퍼 클래스
  - String
- 임베디드 타입 (복합 값 타입)
- 컬렉션 값 타입



## 기본 값 타입

- String, int 등

## 임베디드 타입

- 새로움 값 타입을 직접 정의해서 사용할 수 있는데 jpa에서는 이걸 임베디드 타입이라 함
- @Embeddable: 값 타입을 정의하는 곳에 표시
- @Embedded: 값 타입을 사용하는 곳에 표시
- 새로 정의한 값 타입들은 재사용할 수 있고 응집도도 아주 높음
- 임베디드 타입은 기본 생성자가 필수임
- 임베디드 타입을 포함한 모든 값 타입은 엔티티 생명주기에 의존하므로 엔티티와 임베디드 타입의 관계를 uml로 표현하면 컴포지션 관계라고함

> 하이버네이트는 임베디드 타입을 컴포넌트라함



### 임베디드 타입과 테이블 매핑

- 임베디드 타입으로 객체와 테이블을 세밀하게 매핑하는것이 가능함

### 임베디드 타입과 연관 관계

### @AttributeOverrid: 속성 재정의

- 임베디드 타입에 정의한 매핑 정보를 재정의하려면 엔티티에 @AttributeOverride를 사용하면 됨
- @AttributeOverride를 사용할 일이 많지 않음
- @AttributeOverride는 엔티티에 사용해야함

### 임베디드 타입과 null

- 임베디드 타입이 null이면 매핑한 컬럼값은 모두 null



## 값 타입과 불변 객체

### 값  타입 공유 참조

- 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함
- 값 타입 공유로 야기한 버그는 매우 찾기 어려움
- 복사해서 사용해야함
- 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입임 <- 객체 공유가 가능함
- setter 같은 메서드를 없애는게 가장 좋은 방법일듯
- 자바에서 객체 공유는 막을 수 없으니 어디서 이상하게 변경되는 setter같은게 없으면 부작용 발생은 어려워짐

### 불변 객체

- 값 타입은 부작용 걱정 없이 사용할 수 있어야함
- 객체를 불변하게 만들면 값을 수정할 수 없으므로 부작용 원천 차단 가능
- 따라서 값 타입은 가능하면 불변객체로 설계해야함



## 값 타입의 비교

- 값 타입은 비록 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야함

## 값 타입 컬렉션

- 값 타입을 하나 이상 저장하려면 컬렉션에 보고나하고 @ElementCollection, @CollectionTable 애너테이션을 사용하면 됨

### 값 타입 컬렉션 사용

- 값 타입 컬렉션은 영속성 전이 + 고아 객체 제거 기능을 필수로 가져감
- 엔티티가 저장되는 시점에 자동 저장됨
- LAZY가 기본옵션

### 값 타입 컬렉션의 제약사항

- 식별자라는 개념이 없기 때문에 단순한 값들의 모음이므로 값을 변경해버리면 원본 데이터를 찾기 어려움
- 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 값 타입 컬렉션 대신에 일대다 관계를 고려해야함



## 정리



**엔티티 타입의 특징**

- 식별자가 있다
  - 엔티티 타입은 식별자가 있고 식별자로 구별할 수 있다.
- 생명 주기가 있다
  - 생성하고 영속화하고 소멸하는 생명 주기가 있다.
  - em.persist(entity)로 영속화한다.
  - em.remove(entity)로 제거한다
- 공유할 수 있다.
  - 참조 값을 공유할 수 있다. 이것을 공유 참조라 한다.
  - 예를 들어 회원 엔티티가 있다면 다른 엔티티에서 얼마든지 회원 엔티티를 참조할 수 있다.



**값 타입의 특징**

- 식별자가 없다.
- 생명주기를 엔티티에 의존한다.
  - 스스로 생명주기를 가지지 않고 엔티티에 의존한다. 의존하는 엔티티를 제거하면 같이 제거된다
- 공유하지 않는 것이 안전하다
  - 엔티티 타입과는 다르게 공유하지 않는 것이 안전하다 대신에 값을 복사해서 사용해야한다
  - 오직 하나의 주인만이 관리해야 한다
  - 불변 객체로 만드는 것이 안전하다.
- 값 타입은 정말 값 타입이라 판단될 때만 사용해야함 특히 엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안됨. 식별자가 필요하고 지속해서 값을 추적하고 구분하고 변경해야 한다면 그것은 값 타입이 아닌 엔티티임





# #10 객제지향 쿼리 언어

- JPQL
- Criteria
- QueryDSL
- 네이티브 SQL
- 객체지향 쿼리 심화



## 객체지향 쿼리 소개

- 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리다.
- SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다.



### JPQL 소개

- JPQL은 엔티티 객체를 조회하는 객체지향 쿼리다.
- JPQL은 SQL을 추상화해서 특정 데이터베이스에 의존하지 않는다.
- JPQL은 SQL보다 간결하다



### Criteria 쿼리 소개

- Criteria는 JPQL을 생성하는 빌더 클래스임
- Criteria의 장점은 문자가 아닌 query.select(m) 처럼 프로그래밍 코드로 JPQL을 작성할 수 있다는 점임
- 컴파일 시점에 오류 발견
- IDE의 자동완성기능
- 동적 쿼리 작성이 편함
- 메타모델 사용 가능
- 장점이 많지만 복잡하고 장황함 



### QueryDSL 소개

- 오픈소스인데 Criteria보다 보기 편하고 사용도 편함



### 네이티브 SQL 소개

- 특정 데이터베이스 언어에 의존해야하는 경우 네이티브로 쿼리를 날릴 수 있음
- 단점은 db 변경시 쿼리도 변경해야함



### JDBC 직접 사용, 마이바티스 같은 SQL 매퍼 프레임워크 사용

- jdbc나 마이바티스를 jpa와 함께 사용하면 영속성 컨텍스트를 적절한 시점에 강제로 플러시해야함
- aop로 메서드 호출시에 플러시하면 문제 해결이 쉬워짐



## JPQL

- JPQL은 객체지향 쿼리 언어. 엔티티를 대상으로 쿼리함
- JPQL은 SQL을 추상화해서 특정 데이터베이스 SQL에 의존하지 않음
- 결국 SQL로 변환됨

**대소문자 구분**

- 엔티티와 속성은 대소문자를 구분함 JPQL 키워드는 대소문자를 구분하지 않음

**엔티티 이름**

- 클래스 명이 아니라 엔티티 명임 따로 지정하지 않으면 클래스 명이 엔티티 명이됨

**별칭 필수**

- 별칭을 필수로 사용해야함

**TypeQuery, Query**

- 반환할 타입을 명확하게 지정할 수 있으면 TypeQuery 객체
- 반환 타입을 모르면 Query 객체를 사용하면 됨
- 여러 엔티티나 컬럼 선택시엔 Query 객체를 사용해야함 Query 객체는 2개 이상이면 Object[] 를 반환하고 하나면 Object를 반환
- 가능하면 TypeQuery



### 파라미터 바인딩

**이름 기준 파라미터**

-  이름 기준 파라미터는 앞에 :를 사용함

**위치 기준 파라미터**

- ?1 처럼 순서를줌

> - 이름 기준 파라미터 방식이 좋음
> - 파라미터 바인딩을 사용하지 않고 문자열을 붙여서 사용하면 sql 인젝션 공격을 당할 수 있음



### 프로젝션

- select 절에 조회할 대상을 지정하는 것을 프로젝션 이라 함

**엔티티 프로젝션**

- select m from member m
- 엔티티는 영속성 컨텍스트에 저장



**임베디드 타입 프로젝션**

- 임베디드 타입은 조회의 시작점이 될 수 없음
- 엔티티부터 시작해야함
- 임베디드 타입은 엔티티 타입이아닌 값 타입임
- 직접 조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않음

**스칼라 타입 프로젝션**

- 숫자 문자, 날짜와 같은 기본 데이터 타입들을 스칼라 타입이라고함

**여러 값 조회**

**NEW 명령어**

- jpql에 클래스 생성자를 넘겨주는 방법이 있음



### 페이징 api

- 페이징 sql을 최적화 하고 싶다면 네이티브 sql을 사용해야함



### 집합과 정렬

- count, max, min, avg, sum 사용 가능
- null 값은 무시하므로 통계에 잡히지 않음
- 값이 없으면 count를 제외하고 null이됨 단 count는 0
- distinct를 집합 함수 안에 사용해서 중복된 값을 제거하고 나서 집할을 구할 수 있음
- distinct를 count에서 사용할 때 임베디드 타입은 지원 안함



### jpql 조인

- jqpl도 조인을 원함 sql 조인과 기능은 같고 문법만 약간 다름

**내부조인**

- inner 생략 가능



**외부 조인**

- outer 생략 가능 left or right



**컬렉션 조인**

**세타조인**

**JOIN ON 절**

- JPA 2.1부터 지원함
- ON절은 외부 조인에서만 사용함



### 페치 조인

- 연관된 엔티티나 컬렉션을 한번에 같이 조회하는 기능 join fetch로 사용함

**엔티티 페치 조인**

- 페치조인을 사용하면 프록시 객체가 아닌 진짜 객체를 한번에 불러올 수 있음
- 준영속 상태에서도 연관관계 객체 호출 가능



**컬렉션 패치 조인**

- 일대 다 조인은 결과가 증가할 수 있지만 일대일 다대일 조인은 결과가 증가하지 않음
- 연관된 pk 다 불러온느거라고 생각하면 쉬움



**페치조인과 DISTINCT**

- sql 단에서 불러오는 distinct는 의미가 없지만
- application 단에서 불러오는 distinct는 의미가 있음 따라서 일대다 관계에서는 붙이는게 성능상에 좋은것 같음

**페치조인과 일반 조인의 차이**

- jpql은 결과를 반환할 때 연관관계까지 고려하지 않음.
- 일반 조인은 연관관계는 프록시나 아직 초기화되지 않은 컬렉션 래퍼를 반환함

**페치조인의 특징과 한계**

- 패치조인을 사용하면 sql 한번으로 연관된 엔티티들을 함께 조회할 수 있어서 성능 최적화가 가능해짐
- 글로벌 로딩 전략을 Lazy로 사용하더라도 페치조인을 사용하면 한방에 쿼리함
- 클로벌 로딩 전략은 Lazy로 사용하고 최적화가 필요하면 페치 조인을 적용하는 것이 효과적임
- 준영속 상태에서도 객체 그래프 탐색 가능
- 페치 조인 대상에는 별칭 X
- 둘 이상의 컬렉션 페치 불가능
- 컬렉션을 페치 조인하면 페이징 api를 사용할 수 없음



### 경로 표현식

**경로 표현식의 용어 정리**

- 상태 필드: 단순히 값을 저장하기 위한 필드
- 연관 필드: 연관관계를 위한 필드 임베디드 타입포함
  - 단일 값 연관 필드 X To One: 대상이 엔티티
  - 컬렉션 값 연관 필드 X To Many: 대상이 컬렉션



**경로 표현식과 특징**

- 상태필드 경로: 경로 탐색이 끝임
- 단일값 연관 경로: 묵시적으로 내부 조인이 일어남, 단일 값 연관 경로는 계속 탐색 가능
- 컬렉션 값 연관 경로: 묵시적으로 내부 조인이 일어남, 더는 탐색 불가 from에서 조인을 통해 별칭을 얻으면 별칭으로 탐색 가능



**상태필드 경로 탐색**

**단일 값 연관 경로 탐색**

- 단일 값 연관 필드로 경로 탐색을 하면 sql에서 내부 조인이 일어나는데 이것을 묵시적 조인이라고 함 참고로 묵시적 조인은 모두 내부 조인임

**명시적 조인**

- join을 직접 적어주는 것

**묵시적 조인**

- 경로 표현식에 의해 묵시적으로 조인이 일어나는 것, 내부조인만 할 수 있음



**컬렉션 값 연관 경로 탐색**

- jpql을 다루면서 많이 하느 ㄴ실수중 하나는 컬렉션 값에서 경로 탐색을 시도하는것임
- select t.members from Team t // 성공
- select t.members.username form Team t // 실패
- select m.username from Team t join t.members m // 성공
- 별칭을 지정해줘야만 탐색 가능
- 컬렉션 크기를 구할수 있는 size가 있음
- select t.members.size from Team t

**경로 탐색을 사용한 묵시적 조인 시 주의사항**

- 경로 탐색을 사용하면 묵시적 조인이 발생해서 sql 내부 조인이 일어날 수 있는데 이때 주의사항은 아래오 ㅏ같음
  - 항상 내부 조인
  - 컬렉션은 경로 탐색의 끝임 추가적으로 하려면 별칭을 얻어야함
  - 경로 탐색은 주로 SELECT, WHERE 절에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM절에 영향을 줌
- 성능이 중요한 경우 묵시적 조인보다는 명시적 조인을 사용해서 분석하기 쉽도록하는게 좋음



### 서브쿼리

- JPQL도 SQL처럼 서브쿼리를 지원함
- WHERE HAVING만 가능하고 SELECT, FROM 절에는 사용 불가

> 하이버네이트는 SELECT 절의 서브쿼리도 허용함

**서브쿼리함수**

- [NOT] EXISTS
- {ALL | ANY | SOME}
- [NOT] IN



### 조건식

- 이건 별도로 정리하지 않겠음



### 다형성 쿼리

- JPQL로 부모 엔티티를 조회하면 그 자식 엔티티도 함께 조회함
- 단일 테이블 전략을 사용할때는 전부가져옴

**TYPE**

- 엔티티 상속 구조에서 조회 대상을 특정 자식 타입으로 한정할때 사용
- select i from Item i where type(i) IN(Book Movie)

**TREAT(JPA 2.1)**

- 2.1 에서 추가되었고 자바의 타입 캐스팅과 비슷함

### 사용자 정의 함수 호출 (JPA 2.1)



### 기타 정리

- enum은 = 비교 연산만 지원
- 인베디드 타입은 비교를 지원하지 않음

**EMPTY STRING**

- jpa 표준은 ''을 길이 0인 empty string으로 정했지만 데이터베이스에 따라 null로 사용할 수 있으니 확인

**null 정의**

- 조건을 만족하는 데이터가 하나도 없으면 null
- null은 알 수 없는 값임 null 과의 모든 수학적 계산 결과는 null
- null == null은 알 수 없는 값
- null is null 은 참



### 엔티티 직접 사용

**기본 키 값**

- 객체 인스턴스는 참조 값으로 식별하고 테이블 로우는 기본 키 값으로 식별함
- 기본키 값으로 조회하거나 엔티티로 조회하거나 실제 쿼리는 기본키 값으로 나감

**외래 키값**



### Named 쿼리: 정적 쿼리

-  동적 쿼리: em.createQuery("select ..") 처럼 jpql을 문자로 완성해서 직접 넘기는 것을 동적 쿼리라 함
- 정적 쿼리: 미리 정의한 쿼리에 이름을 부여해서 필요할 때 사용할 수 있는데 이것을 Named 쿼리라함 한번 정의후 변경 불가
- Named쿼리는 애플리케이션 로딩 시점에
-  jpql문법 체크를 해주고 오류 확인 파싱후 재사용함 
- 애너테이션에 정의하는 방법이 있음 @NamedQuery @NamedQueries
- xml에 정의도 가능



## Criteria

- criteria 쿼리는 jpql을 자바 코드로 작성하도록 도와주는 빌더 클래스 api임
- 컴파일 오류 체크 jpql보다 동적쿼리를 안전하게 생성 가능하지만 장황하고 복잡함

## QueryDSL

## 네이티브 쿼리



## 객체지향 쿼리 심화

### 벌크 연산

- 대용량으로 수정 삭제연산이 있다면 벌크 연산 사용하면 됨
- executeUpdate() 메서드를 사용함

**벌크 연산 주의점**

- 벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다는 점에 주의해야함
- 예를들어 1차캐시된 데이터가있고 벌크작업하면 1차캐시에는 적용되지 않았기때문에 데이터가 다를 수 있음

**em.refresh() 사용**

- 벌크작업 했으면 적용하는게 좋을듯

**벌크 연산 먼저 실행**

- 벌크 연산을 가장 먼저 실행하는것도 좋음

**벌크 연산 수행 후 영속성 컨텍스트 초기화**



### 영속성 컨텍스트와 jpql 

**쿼리 후 영속 상태인 것과 아닌 것**

- 엔티티가 아니면 영속성 컨텍스트에서 관리되지 않음
- jpql로 데이터베이스에서 조회한 엔티티가 영속성 컨텍스트에 이미 있으면 조회한 결과를 버리고 영속성 컨텍스트에 있던 엔티티를 반환함
  1. jpql을 사용해서 조회 요청
  2. jpql은 sql로 변환되어 조회
  3. 조회한 결과와 영속성 컨텍스트를 비교
  4. 식별자 값을 기준으로 있으면 버리고 기존 영속성 컨텍스트 반환
  5. 없으면 영속성 컨텍스트에 추가
- jpql로 조회한 엔티티는 영속 상태
- jpql은 한상 데이터베이스에서 sql을 실행해서 결과를 조회함 캐시 여부랑 상관 없음



### jpql과 플러시 모드

- 플러시는 컨텍스트의 변경 내역을 데이터베이스에 동기화 하는 것 
- 직접 flush 호출도 가능하지만 보통 플러시 모드에 따라 커밋하기 직전이나 쿼리 실행 직전에 자동으로 플러시가 호출됨
- FlushModeType.AUTO: 커밋 또는 쿼리 실행시 플러시, 기본값
- FlushModeType.COMMIT: 커밋시에만 플러시, 꼭 필요할때만 사용

**쿼리와 플러시 모드**

- 예를들어 상품 a를 수정하고 JPQL로 조회하는 시점에 기본 옵션으로 상품 A를 수정한 쿼리가 DB에 적용됨
- 근데 COMMIT 모드로하면 커밋시에만 적용되기때문에 데이터가 다를 수 있음



**플러시 모드와 최적화**

- DB에 쿼리를 너무 많이 날릴때 성능 최적화 목적으로 플러시 모드를 바꿀 수 있으나 주의해서 사용해야함

## 정리

- JPQL은 SQL을 추상화해서 특정 데이터베이스 기술에 의존하지 않음
- Criteria나 QueryDSL은 JPQL을 만들어주는 빌더 역할을 할 뿐이므로 핵심은 jpql을 잘 알아야함
- Criteria나 QueryDSL을 사용하면 동적으로 변하는 쿼리를 편하게 잘성할 수 있음
- Critera는 jpa가 공식지원하지만 직관적이지 않고 사용하기에 불편함 반면에 QueryDSL은 jpa가 공식 지원하지는 않지만 직관적이고 편리함
- jpa도 네이티브 sql을 제공하므로 직접 sql을 사용할 수 있음 마지막방법임
- jpql은 벌크연산이 있음



# #11 웹 애플리케이션 개발

생략



# #12 스프링 데이터 JPA



## 스프링 데이터 JPA 소개

- 스프링에서 jpa를 편리하게 사용할 수 있도록 지원하는 프로젝트
- 데이터 접근 계층 개발시 구현 클래스 없이 인터페이스만 작성해도 개발을 완료할 수 있음
- 메서드 명으로 분석해서 알아서 쿼리 날려줌

### 스프링 데이터 프로젝트



## 스프링 데이터 jpa 설정



## 공통 인터페이스 기능

- 기본 crud 제공함

## 쿼리 메서드 기능

- 메서드 이름으로 쿼리 생성
- 메서드 이름으로 jpa namedQuery 호출
- @Query 애너테이션을 사용해서 리포지토리 인터페이스에 쿼리 직접 정의

## 명세

- 다양한 검색조건을 조립해서 새로운 검색 조건을 쉽게 만들 수 있도록 제공함
- specification은 컴포지트 패턴으로 구성되어있음



## 사용자 정의 리포지토리 구현

- 실제 구현체를 만들어야할 때 사용하면 됨
- 이름 + Impl 로 지어야 사용자 정의 구현 클래스로 인식 함
- 속성으로 변경 가능함 repsitory-impl-postfix 확인

## web 확장

- 스프링 데이터 프로젝트는 스프링 mvc에서 사용할 수 있는 편리한 기능을 제공함
- 식별자로 도메인 클래스를 바로 바인딩해주는 도메인 클래스 컨버터 기능과 페이징 정렬 이 있음
- @EnableSpringDataWebSupport
- 식별자 id만으로 http 요청으로 넘어올때 자동으로 컨버팅해줌
- 이 엔티티를 바로 수정할 경우 적용되지 않음



### 페이징과 정렬 기능

- 스프링 데이터가 제공하는 페이징과 정렬 기능을 스프링 mvc에서 편하게 사용할 수 있도록 HandlerMethodArgumentResolver를 제공함
- 페이징: PageableHandlerMethodArgumentResolver
- 정렬 : SortHandlerMethodArgumentResolver
- PageRequest 객체를 확인할 것



## 스프링 데이터 jpa가 사용하는 구현체

-  @Transactional : jpa의 모든 변경은 트랜잭션 안에서 이루어져야함 서비스계층에서 실행하지 않으면 리포지토리에서 트랜잭션을 실행함 그러나 서비스 계층에서 실행했다면 리포지토리로 자연스럽게 넘어감
- Transactional(readOnly = ture): 데이터를 조회하는 메서드에서 사용하면 플러시를 생략해서 약간의 성능 향상을 얻을 수 있음



# 웹 애플리케이션과 영속성 관리

## 트랜잭션 범위의 영속성 컨텍스트

### 스프링 컨테이너의 기본 전략

- 스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용함
- 트랜잭션의 범위와 영속성 컨텍스트의 생존 범위가 같다는 의미임
- @Transaction은 스프링의 트랜잭션 aop를 동작시킴
- 메서드 호출 직전에 트랜잭션을 시작하고 대상 메서드가 정상 종료되면 트랜잭션을 커밋하면서 종료하는데 트랜잭션을 커밋하면 jpa는 먼저 영속성 컨텍스트를 플러시해서 변경 내용을 데이터베이스에 반영한 후에 데이터베이스 트랜잭션을 커밋함
- 정상적일 경우 db에 잘 저장이되지만 예외 발생시 트랜잭션을 롤백하고 종료할때 플러시가 이루어지지 않음
- @PersistenceContext 애너테이션을 사용하면 스프링 컨테이너가 엔티티 매니저를 주입해줌

**트랜잭션이 같으면 같은 영속성 컨텍스트를 사용함**

- 같은 트랜잭션이라면 항상 같은 영속성 컨텍스트를 사용함

**트랜잭션이 다르면 다른 영속성 컨텍스트를 사용함**



## 준영속 상태와 지연 로딩

- 조회한 엔티티가 서비스와 리포지토리를 벗어나고 컨트롤러나 뷰쪽을가면 준영속상태가됨

**준영속 상태와 변경 감지**

- 변경 감지 기능은 영속상태에서만 사용 가능함

**준영속 상태와 지연 로딩**

- 준영속 상태에서는 지연로딩 역시 불가능함
- 해결 방법은 뷰가 필요한 엔티티를 미리 로딩해두는 방법, osiv를 사용해서 엔티티를 항상 영속상태로 유지하는 방법이 있음
- 미리 로딩하는 방법은 3가지가 있음

### 글로벌 페치 전략 수정

- 가장 간단하게 페치전략으로 즉시 로딩하면 됨
- EAGER 모드

**글로벌 페치 전략에 즉시 로딩 사용시 단점**

- 사용하지 않는 엔티티까지 로딩함
- n+1 문제가 발생함

**사용하지 않는 엔티티 로딩**

**n+1 문제**

- jpa에서 성능상 가장 조심해야하는게 n+1임
- 조회한 엔티티가 10개면 연관된 엔티티도 10번 실행함
- jpa가 jpql을 분석해서 sql을 생성할 때는 글로벌 페치 전략을 참고하지 않고 오직 jpql 자체만 사용함
- 따라서 즉시 로딩이든 지연 로딩이든 구분하지 않고 jpql 쿼리 자체에 충실하게 sql 쿼리를 만듬
- n+1문제는 페치 조인으로 해결 가능함



### jpql 페치 조인

- jpql을 호출하는 시점에 함께 로딩할 엔티티를 선택할 수 있음
- 페치조인은 join fetch로 사용함
- 페치조인을 사용하면 sql join을 사용해서 페치 조인 대상까지 함께 조회함

**jpql 페치 조인의 단점**

- 화면이 다르고 조회하는 엔티티의 접근 범위가 다르다면 메서드를 두개씩 만들어서 해야함
- 이럴 경우 뷰단이 데이터계층 영역을 침범하게됨 뷰가 소스에 녹아있음
- 페치조인은 join을 사용해서 쿼리한번으로 필요한 데이터를 조회하기때문에 성능에 미치는 영향이 그렇게 크지는 않음
- 알아서 잘 조율해서 뷰단이 데이터 계층 영역 침범에 대해 조율해서 사용하면 될 것



### 강제로 초기화

- 연관관계에 포함된 메서드를 호출해서 강제로 초기화시키면됨
- 하이버네이트를 사용하면 initialize 메서드를 사용해서 프록시 강제 초기화 가능함
- 비지니스 로직을 담당하는 서비스 계층에서 프리젠테이션 계층을 위한 프록시 초기화 역할을 분리해야함
- facade 계층을 하나 더 두면 해결 가능함

### facade 계층 추가

- facade 계층을 도입해서 서비스 계층과 프리젠테이션 계층 사이에 논리적인 의존성을 분리할 수 있음

**facade 계층의 역할과 특징**

- 프리젠테이션 계층과 도메인 모델 계층 간의 논리적 의존성을 분리해줌
- 프리젠테이션 계층에서 필요한 프록시 객체를 초기화함
- 서비스 계층을 호출해서 비지니스 로직을 실행함
- 리포지토리를 직접 호출해서 뷰가 요구하는 엔티티를 찾아줌
- 실용적인 관점에서 볼때 facade 의 최대 단점은 계층이 늘어나고 관리 포인트가 늘어나는 것



### 준영속 상태와 지연 로딩의 문제점

- 결국 모든 문제는 엔티티가 프리젠테이션 계층에서 준영속 상태이기 때문에 발생함
- osiv를 사용하면 해결 가능함



## Open Session In View

- 영속성 컨텍스트를 뷰까지 열어둠
- 따라서 뷰에서도 지연 로딩을 사용할 수 있음



### 과거 osiv: 요청 당 트랜잭션

- 클라이언트의 요청이 들어오자마자 서블릿 필터나 스프링 인터셉터에서 트랜잭션을 시작하고 요청이 끝날 때 트랜잭션도 끝냄



**요청 당 트랜잭션 방식의 osiv 문제점**

- 컨트롤러나 뷰 같은 프리젠테이션 계층이 엔티티를 변경할 수 있다는 점이 치명적임
- 하지만 3가지 방법으로 방어 가능함

**엔티티를 읽기 전용 인터페이스로 제공**

**엔티티 래핑**

- 엔티티의 읽기 전용 메서드만 가지고 잇는 엔티티를 감싼 객체를 만들고 이것을 프리젠테이션 계층에 반환하는 방법

**DTO만 반환**

- 이런 방법들은 모두 코드량이 상당히 증가한다는 단점이 있음
- 스프링 OSIV를 사용하면 됨 <- 서버사이드 렌더링쪽은 dto에 대해 약간은 부정적임



### 스프링 OSIV: 비지니스 계층 트랜잭션

- 요청 당 트랜잭션 방식의 OSIV는 프리젠테이션 계층에서 데이터를 변경할 수 있다는 문제가 있음 스프링 OSIV로 어느정도 해결이 가능함
- osiv를 사용하기는 하지만 트랜잭션은 비지니스 계층에서만 사용함

1. 클라이언트의 요청이 들어오면 서블릿 필터나, 스프링 인터셉터에서 영속성 컨텍스트 생성, 이때 트랜잭션은 생성하지 않음
2. 서비스 계층에서 @Transactional로 트랜잭션을 시작할 때 1번에서 미리 생성해둔 영속성 컨텍스트를 찾아와서 트랜잭션 시작
3. 서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시함 이때 트랜잭션은 끝내지만 영속성 컨텍스트는 종료하지 않음
4. 컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속 상태를 유지함
5. 서블릿 필터나, 스프링 이터셉터로 요청이 돌아오면 영속성 컨텍스트를 종료함 이때 플러시르 호출하지 않고 바로 종료

**트랜잭션 없이 읽기**

- 영속성 컨텍스트를 통한 모든 변경은 트랜잭션 안에서 이루어져야함, 트랜잭션 없이 엔티티를 변경하고 영속성 컨텍스트를 플러시하면 예외 발생
- 엔티티를 변경하지 않고 단순히 조회만 할 때는 트랜잭션이 없어도 되는데 이것을 트랜잭션 없이 읽기라고함
- 영속성 컨텍스트는 트랜잭션 범위 안에서 엔티티를 조회하고 수정할 수 있음
- 영속성 컨텍스트는 트랜잭션 범위 밖에서 엔티티를 조회만 할 수 있음 이것을 트랜잭션 없이 읽기라 함
- 스프링이 제공하는 OSIV를 사용하면 프리젠테이션 계층에서는 트랜잭션이 없으므로 엔티티를 수정할 수 없음, 트랜잭션 없이 읽기를 사용해서 프리젠테이션 계층에서 지연 로딩 기능을 사용할수 있게 함
- 정리한 스프링 비지니스 계층 트랜잭션 OSIV
  - 영속성 컨텍스트를 프리젠테이션 까지 유지함
  - 프리젠테이션에는 트랜잭션이 없으므로 수정 불가
  - 프리젠테이션에는 트랜잭션이 없지만 트랜잭션 없이 읽기를 사용해서 지연로딩을 할 수 있음

**스프링 OSIV 주의사항**

- 프리젠테이션 계층에서 엔티티를 수정한 직후에 트랜잭션을 시작하는 서비스 계층을 호출하면 문제 발생
- 비지니스 로직을 전부 수행 후 엔티티를 수정할 것 <- 변경되지 않을 엔티티 수정



### 정리

**스프링 OSIV 특징**

- OSIV는 클라이언트의 요청이들어올 때 영속성 컨텍스트를 생성해서 요청이 끝날 때까지 같은 영속성 컨텍스트를 유지함 따라서 한 번 조회한 엔티티는 요청이 끝날 때까지 영속 성태를 유지함
- 엔티티 수정은 트랜잭션이 있는 계층에서만 동작함. 트랜잭션이 없는 프리젠테이션 계층은 지연 로딩을 포함해서 조회만 가능

**스프링 OISV 단점**

- OSIV를 적용하면 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있다는 점을 주의해야 함
- 프리젠테이션 계층에서 엔티티를 수정하고 나서 비지니스 로직을 수행하면 엔티티가 수정될 수 있음
- 프리젠테이션 계층에서 지연 로딩에 의한 SQL이 실행됨. 따라서 성능 튜닝시에 확인해야할 부분이 넓음

**OSIV가 만능은아니다**

- JPQL을 사용해서 필요한 데이터들만 조회후 DTO로 반환하는것이 더 나은 해결책일 수 있음

**OSIV는 같은 JVM을 벗어난 원격 상황에서는 사용 불가**

- 



















































