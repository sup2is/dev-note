https://github.com/holyeye/jpabook



# #1 JPA 소개

- JPA는 지루하고 반복적인 CRUD SQL을 알아서 처리해줄 뿐만 아니라 객체 모델링과 관계형 데이터베이스 사이의 차이점도 해결해준다.

## SQL을 직접 다룰 때 발생하는 문제점

- 개발자가 객체지향 어플리케이션과 데이터베이스 중간에서 SQL과 JDBC API를 사용해서 변환작업을 해줘야함 이는 RDB와 객체지향 패러다임의 차이가 있기 때문임
- 개발자가 SQL 쿼리로 인한 실수를 만들 여지가 많음
- 진정한 의미의 계층 분할이 안되고 엔티티를 신뢰할 수 없음
- SQL에 의존적인 개발을 피할 수 없음

## 패러다임의 불일치

- JPA는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해줌 개발자는 마치 자바 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면 됨
- 객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회하고 DB는 외래키를 사용해서 다른 테이블과의 조인으로 연관데이터를 가져온다.
- JPA는 연관관계와 관련된 패러다임의 불일치 문제를 해결해준다. 참조하는 객체를 외래키로 변환해서 적절한 insert sql을 만들어준다. 
- JPA를 사용하면 객체 그래프를 마음껏 사용할 수 있음 SQL의 경우 객체 그래프의 정도를 SQL 시점에서 결정해야하지만 JPA는 그렇지 않음
- JPA는 같은 트랜잭션일때 같은 객체가 조회되는것을 보장함.
- 객체지향과 데이터베이스 패러다임의 불일치로 어플리케이션이 점점 데이터 중심의 모델로 변하는 것을 JPA를 통해 해결할 수 있다. 

## JPA란 ?

- JPA는 자바진영의 ORM 기술 표준임 Java 와 JDBC api 사이에 존재함
- ORM은 Object-Relational Mapping임 객체와 데이터베이스를 매핑해주는 프레임워크
- ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 데이터베이스에 전달해주는 것뿐만 아니라 다양한 패러다임의 불일치 문제들도 해결해줌

### JPA 소개

- Java진영에서는 ORM 프레임워크중 하이버네이트를 가장 많이사용함
- EJB3.0에서 하이버네이트를 기반으로 새로운 자바 ORM이 탄생함 이게 JPA, JPA는 자바 ORM 기술에 대한 API 표준 명세

### JPA를 왜 사용해야 하는가?

- **생산성 :** SQL로 처리하던 지루한 CRUD를 JPA가 대신 처리해줌 기존에 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있음
- **유지보수:** 컬럼하나로 수많은 코드를 변경해야했던 부분이 JPA로 해결되기때문에 유지보수성 향상
- **패러다임의 불일치 해결:** JPA는 상속, 연관관계, 객체 그래프탐색, 동등성 비교 같은 패러다임의 불일치 해결
- **성능:** 기존 SQL 쿼리로 Database에 두번 나가는걸 1차캐시로 한번만으로 끝낼 수 있음
- **데이터 접근 추상화와 벤더 독립성:** 하나의 데이터베이스에 의존하지않도록 추상화된 레이어로 데이터베이스를 쉽게 변경할 수 있음
- **표준:** JPA는 표준이기 때문에 다른 기술로 손쉽게 변경 가능함



# #2 JPA 시작

- **@Entity:** 이 클래스를 테이블과 매핑한다고 JPA에게 알려줌 이런 클래스를 엔티티 클래스라함
- **@Table:** 엔티티 클래스에 매핑할 테이블 정보를 알려줌
- **@Id:** primary key에 매핑함 이 필드를 식별자 필드라고함
- **@Column :** 데이터베이스와 매핑될 컬럼명을 지정할 수 있음
- **매핑 정보가 없는 필드:** 자동적으로 컬럼명으로 매핑함

## 엔티티 매니저 설정

- **엔티티 매니저 팩토리 생성:** JPA를 시작하려면 우선 persistence.xml의 설정 정보를 사용해서 엔티티 매니저 팩토리를 생성해야함 Persistance 클래스를 사용해서 엔티티 매니저 팩토리를 생성하고 데이터 베이스 커넥션 풀 등을 생성해서  JPA를 사용할 수 있게 해줌 그러나 이 엔티티 매니저 팩토리는 초기 생성 비용이 굉장히 크기때문에 어플리케이션 전체에서 딱 한번만 생성하고 공유해서 사용해야함
- **엔티티 매니저 생성:** 엔티티 매니저 팩토리에서 엔티티 매니저를 생성함 JPA의 대부분의 기능들은 엔티티 매니저가 제공(CRUD), 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용하면 안됨
- **종료:** 사용이 끝난 엔티티매니저는 반드시 종료해야함 어플리케이션 종료시점에도 매니저 팩토리 역시 종료시켜야함

## 트랜잭션 관리

- JPA를 사용하면 반드시 트랜잭션 안에서 데이터를 변경해야함 엔티티매니저에서 트랜잭션을 얻어오고 정상동작시 커밋 아니면 롤백함

## 비지니스 로직 

## JPQL

- 애플리케이션이 필요한 데이터만 데이터베이스에서 불러오려면 JPQL을 통해서 질의하면 됨
- JPQL은 엔티티를 대상으로 질의하고 SQL은 데이터베이스를 대상으로 질의함 JPQL은 데이터베이스를 알지 못함





# #3 영속성 관리

- JPA가 제공하는 기능은 크게 엔티티와 테이블을 매핑하는 설계 부분과 매핑한 엔티티를 실제 사용하는 부분으로 나눌 수 있음

## 엔티티 매니저 팩토리와 엔티티 매니저

- 엔티티 매니저 팩토리를 생성하는 비용은 매우 크지만 앤티티 매니저 팩토리에서 엔티티 매니저를 생성하는 비용은 거의 들지 않음
- 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간에 절대 공유 금지! 
- 엔티티매니저는 바로 데이터베이스 커넥션을 얻지 않고 필요할 때 얻음

## 영속성 컨텍스트란 ?

- JPA를 이해한데 가장 중요한 용어
- 엔티티를 영구 저장하는 환경
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 만들어지고 엔티티매니저를 통해 접근 관리한다

## 엔티티의 생명주기

- **비영속:** 영속성 컨텍스트와 전혀 관계가 없는 상태
- **영속:** 영속성 컨텍스트에 저장된 상태
- **준영속:** 영속성 컨텍스트에 저장되었다가 분리된 상태
- **삭제:** 삭제된 상태

## 영속성 컨텍스트의 특징

- **영속성 컨텍스트와 식별자 값:**  @Id로 매핑된 식별자 필드가 반드시 있어야함
- **영속성 컨텍스트와 데이터베이스 저장:** 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 flush라함
- **영속성 컨텍스트가 엔티티를 고나리하면 좋은점:**
  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

### 엔티티 조회

- 영속성 컨텍스트 내부에는 캐시를 갖고 있는데 이걸 1차 캐시라함
- 영속성 컨텍스트 내부에 저장 조회하는 모든 기준은 @Id 가 붙은 식별자 필드임
- 1차캐시에서 엔티티를 찾고 만약 찾는 엔티티가 있으면 캐시에서만 조회함 없을경우 DB에 질의 후 1차캐시에 저장
- 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장함

### 엔티티 생성

- insert 문이 여러개가 있어도 하나의 트랜잭션 안에서는 마지막 트랜잭션 커밋에 데이터베이스에 flush하는데 이걸 트랜잭션을 지원하는 쓰기지연이라함
- 데이터베이스에 한번만 액세스하기때문에 성능읠 최적화 할 수 있음

### 엔티티 수정

- 변경감지를 통해서 엔티티 내부에 변경사항이 있으면 데이터베이스에 자동으로 반영해줌
- JPA는 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 스냅샷을 만들어둠
- 변경감지는 영속 상태의 엔티티만 관리함
- 쿼리는 모든 변경필드 뿐만 아니라 모든 필드에 대해 적용되므로 컬럼이 30개 이상이라면 @DynamicUpdate를 사용하는걸 추천함

### 엔티티 삭제

- 쓰기지연으로 삭제하지만 em.remove()를 적용하는 순간 이미 영속성 컨텍스트에서 제거됨

## 플러시

- flush()는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영함
  1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾음 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록함
  2. 쓰기지연 SQL 저장소의 쿼리를 DB에 등록함
- 영속성 컨텍스트 플러쉬방법 
  1. em.flush를 직접 호출
  2. 트랜잭션 커밋시 자동호출
  3. JPQL쿼리 실행시 자동호출
- 영속성 컨텍스트와 데이터베이스를 동기화시키는 것이 바로 플러시

## 준영속

- 영속성 컨텍스트가 관리하는 용속 상태의 엔티티가 영속성 컨텍스트에서 분리된것을 준영속 상태라함
- em.detach(한개의 entity), em.close(), em.clear()

### 준영속 상태의 특징

- 거의 비영속 상태임
- 식별자 값을 가지고 있음
- 지연 로딩 불가능

### 병합 merge()

- 준영속 상태의 엔티티를 영속상태로 변경하려면 병합을 사용하면 됨
- 새로운 영속상태의 엔티티를 반환함
- 식별자 값으로 엔티티를 조회할 수 있다면 비영속, 준영속도 신경쓰지 않음



# #4 엔티티 매핑



## @Entity

- 매핑할 클래스는 @Entity 필수
- 기본생성자 필수
- final 클래스에 사용 불가
- 저장할 필드가 final이면 사용 불가



## @Table

- 매핑될 테이블을 지정하고 없으면 class 네임으로 매핑됨



## 다양한 매핑 사용

- hivernate.hbm2ddl.auto 옵션을 사용해서 엔티티 클래스들만으로 테이블을 생성할 수 있음
  - create: 기존 테이블을 삭제하고 새로 생성 DROP + CREATE
  - create-drop: 애플리케이션 종료시점에 한번 더 DROP
  - update: 엔티티 매핑정보의 변경사항만 반영
  - validate: DB 테이블과 엔티티정보를 비교해서 문제가 있을경우 아렬줌
  - none
- 운영서버에서 create나 create-drop은 절대 사용 금지 validate or none
- hibernate.ejb.naming_strategy 속성으로 이름 매핑 전략 선택 가능

## 

## DDL 생성 기능

- 컬럼에 unique 속성이나 notnull 속성을 구현할 수 있음



## 기본 키 매핑 

**JPA가 제공하는 데이터베이스 기본 키 생성 전략**

- 직접할당: 기본 키를 애플리케이션에 직접 할당함
- 자동 생성: 대리키 사용 방식
  - IDENTITY: 기본 키 새엇ㅇ을 데이터베이스에 위임
  - SEQUENCE: 데이터베이스 시퀀스를 사용해서 기본키를 할당
  - TABLE: 키 생성 테이블을 사용

### 기본키 직접 할당 전략

- 기본기를 직접 할당하려면 @Id를 사용, 자동 생성 전략은 @GeneratedValue로 지정

### IDENTITY 전략

- 이 전략은 DB에 들어가는 시점에 ID가 부여되므로 INSERT 후에 기본 키 값을 조회 가능함
- 이 전략을 사용한다면 트랜잭션을 지원하는 쓰기 지연이 동작하지 않음

### SEQUENCE 전략

- 이전략은 시퀀스를 사용해서 기본키를 생성함
- 오라클 PostgreSQL, DB2, H2에서 사용 가능
- 먼저 시퀀스를 생성하고 사용해야함
- identity 전략이랑 조금 다르게 엔티티 저장전에 db에서 시퀀스를 꺼내오고 트랜잭션을 지원하는 쓰기 지연으로 flush 시점에 엔티티가 저장됨

### TABLE 전략

- 키 생성 전용 테이블을 하나 만들고 여기에 이름과 값으로 사용할 컬럼을 만들어 데이터베이스의 시퀀스를 흉내내는 것

### Auto 전략

- 위 전략중 하나를 자동으로 선택함 oracle은 시퀀스 전략, mysql은 identity전략



## 필드와 컬럼 매핑 : 레퍼런스



## @Column

- 객체 필드를 테이블 컬럼에 매핑 name, nullable이 가장 많이 사용, insertable, updateable 등
- @Column을 붙이면 기본값이 nullable false임

## @Enumerated

- 자바의 enum 타입 매핑에 사용하고 EnumType.String 만 사용할것

## @Temporal

- 날짜타입을 매핑할때 사용

## @Lob

- 데이터베이스의 Blob, Clob 타입에 매핑

## @Transient

- 이 필드는 JPA가 테이블이랑 매치하지않음 임시로 어떤 값을 보관할때 사용

## @Access

- JPA가 엔티티 데이터에 접근하는 방식을 지정
- 필드 접근, 프로퍼티 접근이 있음



# #5 연관관계 매핑

- 객체의 참조와 테이블의 외래키를 매핑하는 것
- 방향: 단방향, 양방향이 있음, 방향 개념은 객체관계에서만 존재하고 테이블 관계에는 항상 양방향임
- 다중성: 다대일, 일대다,일대일,다대다 가 있음
- 연관관계의 주인: 객체를 양방향 연관관계로 만들면 연고나관계의 주인을 정해야함



## 단방향 연관관계

- 회원과 팀이 있을때 회원은 하나의 팀에만 소속될 수 있음 이럴때 회원과 팀은 다대일 관계임
- **객체 연관관계와 테이블 연관관계의 가장 큰 차이**: 참조를 통한 연관관계는 언제나 단방향이고 양방향으로 설계한다고 하더라도 결국 서로 다른 단방향 2개를 만드는 것임 테이블은 하나의 키로 양방향 조인 가능
- 객체 연관관계: 객체는 참조로 연관관계를 맺음
- 테이블 연관관계: 테이블은 외래키로 연관관계를 맺음
- @ManyToOne: 다대일 관계 매핑 어노테이션
- @JoinColumn: 매핑할 외래 키 이름을 지정



## 연관관계 사용

- 객체 그래프 탐색 또는 JPQL을 사용해서 꺼내올 수 있음



## 양방향 연관관계

- JPA는 List등 자바의 컬렉션도 지원함
- 다대일에 대응하는 일대다로 @OneToMany를 사용함



## 연관관계의 주인

- 객체에는 양방향 연관관계라는 것이 없음
- 두 객체 연관관계 중 하나를 정해서 테이블의 외래키를 관리해야하는데 이것을 연관관계의 주인이라고함
- 연관관계의 주인만이 데이터베이스 연관관계와 매핑되고 외래 키를 관리(등록 수정 삭제)할 수 있음 반면에 주인이 아니라면 단순히 읽기만 가능함
- 주인은 mappedBy 속성을 사용하지 않음 연관관계의 주인이 아니라면 mappedBy 속성을 사용하면 됨
- 연관관계의 주인을 정하는것은 사실 외래 키 관리자를 선택하는 것
- @ManyToOne은 항상 연관관계의 주인이므로 mappedBy 속성이 없음



## 양방향 연관관계 저장

## 양방향 연관관계의 주의점

- 연관관계의 주인만이 외래키의 값을 변경할 수 있음

### 순수한 객체까지 고려한 양방향 연관관계

- 객체의 관점에서는 양쪽 방향에 모두 값을 입력해주는 것이 가장 안전함

### 연관관계 편의 메소드

- 연관관계 편의 메소드를 통해 객체 연관관계를 반드시 해줘야 함

# #6 다양한 연관관계 매핑

- 연관관계 매핑시 3가지 고려사항
- 다중성, 단반향, 양방향, 연관관계의 주인

## 다대일

- 객체의 양방향 관계에서 연관관계의 주인은 항상 다 쪽임 일대다, 다대일
- 양항향은 외래키가 있는 쪽이 연관관계의 주인임
- 양방향 연관관계는 항상 서로를 참조해야함

## 일대다

- 일대다 단방향 매핑은 매핑한 객체가 관리하는 외래키가 다른 테이블에 있다는 점임 이때 insert 쿼리와 update 쿼리가 한번씩 나감
- 일대다 단방향 매핑보다 다대일 양방향 매핑을 사용하는게 좋음

## 일대일

- 일대일의 반대도 일대일임
- 어느곳이나 외래키를 가질 수 있음
- 단방향 양방향을 정할 수 있고 양방향시 연관관계의 주인만 정하면 됨
- 대상테이블에 키값을 두고 싶으면 무조건 양방향으로 매핑해야함

## 다대다

- RDB에서는 정규화된 테이블 2개로 다대다 매핑을 표현할 수 없음
- RDB에서는 연결해주는테이블을 한개 더 생성함
- 객체지향에서는 다대다 매핑이 가능함
- 다대다를 실무에서 적용하는건 무리가 있기때문에 어떻게 일대다 다대일로 풀어갈 지 생각해야함



직접 구성하면서 필요에 따라 자료를 찾아보는게 좋을 듯 함 ..

# #7 고급 매핑

- 상속 관계 매핑: 객체의 상속 관계를 어떻게 DB 테이블에 매핑하는지 
- MappedSuperclass: 등록일 수정일 같이 여러 엔티티에서 공통으로 사용하는 매핑 정보만 상속받고싶으면 이 기능을 사용하면 됨
- 복합 키와 식별 관계 매핑: 테이터베이스의 식별자가 하나 이상일 때 매핑하는 방법
- 조인테이블: 테이블은 외래키 하나로 연관관계를 맺을 수 있지만 연관관계를 관리하는 연결테이블을 두는 방법도 있음
- 엔티티 하나에 여러 테이블 매핑하기: 보통 엔티티 하나에 테이블 하나를 매핑하지만 엔티티 하나에 여러 테이블을 매핑하는 방법도 있음



## 상속 관계 매핑

- 관계형 데이터베이스에는 객체지향의 상속개념이 없음
- 슈퍼타입 서브타입 논리 모델을 테이블로 구현하는 세가지 방법
  1. 조인 전략
  2. 단일 테이블 전략
  3. 구현 클래스마다 테이블 전략

### 조인 전략

- 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본키 + 외래키로 사용하는 전략
- 조회할때 조인을 사용
- 객체는 타입으로 구분할 수 있지만 테이블은 타입의 개념이 없기때문에 주의해야함 타입을 구분컬럼으로 사용
- @Inheritance(strategy = InheritanceType.JOINED): 상속 매핑은 부모 클래스에 이 어노테이션을 사용해야함
- @DisciriminatorColumn(name = "DTYPE") 부모 클래스에 구분 컬럼을 지정함 이 컬럼으로 저장된 자식 테이블을 구분할 수 있음
- @DiscriminatorValue("{DTYPE 값}") 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정
- 기본값으로 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용하는데 만약 자식 테이블의 기본 키 컬럼명을 변경하고 싶으면 @PrimaryKeyJoinColumn을 사용하면 됨
- 조인 전략의 장단점
  - 장점 : 테이블이 정규화되고 외래키 참조 무결성 제약 조건 활용이 가능하고 저장 공간을 효율적으로 관리 가능함
  - 단점: 조회할때 성능 저하와 쿼리 복잡, 데이터 등록시 insert 두번

### 단일 테이블 전략

- 테이블을 하나만 사용하고 자식 엔티티가 매핑한 컬럼은 null을 허용해야함
- InheritanceType.SINGLE_TABLE로 지정하면 단일 테이블 전략을 사용할 수 있음 조인 전략이랑 사용방법은 같고 이 값면 명시해주면 됨
- 단일 테이블 전략의 장단점
  - 장점 : 조인이 필요없고 조회성능 빠르고 쿼리 간단
  - 단점 : 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야하고 테이블이 비대해질 수 있음
  - 특징 :@DiscriminatorValue을 사용하지 않으면 기본적으로 클래스명이 컬럼명이됨



### 구현 클래스마다 테이블 전략

- 자식 엔티티마다 테이블을 만들고 일반적으로 추천하지 않음



## @MappedSuperclass

- 부모클래스는 테이블과 매핑하지 않고 부모 클래스를 상속 받는 자식 클래스에게 매핑 정보만 제공하고 싶으면 @MappedSuperclass를 사용하면 됨
- @MappedSuperclass는 실제 테이블과 매핑되지 않음 주로 공통 매핑 정보를 하나로 추상화시켰을때 사용
- 부모로부터 물려받은 매핑 정보를 재정의하려면 @AuttributeOverride , @AuttributeOverrides를 사용하고 연관관계를 재정의하려면 @AssociationOverrides @AssociationOverride 를 사용할 것
- 당연히 엔티티가 아니기때문에 조회 불가
- 이 클래스를 직접 생성할 일도 없기때문에 추상클래스로 만드는 것을 추천함



## 복합 키와 식별 관계 매핑



### 식별관계 vs 비식별 관계

- 데이터베이스 테이블 사이에 관계는 외래키가 기본 키에 포함되는지 여부에 따라 식별 관계와 비식별 관계로 구분함 

**식별관계**

- 식별관계는 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본 키 + 외래 키로 사용하는관계

**비식별관계**

- 부모 텡블의 기본 키를 받아서 그 키를 외래키로 사용하는 것
- 비식별 관계는 외래키의 null 허용 여부에 따라 필수적 비식별 관계, 선택적 비식별 관계로 나뉨
- 최근에는 비식별 관계를 주로 사용하고 필요한 곳에만 식별 관계를 사용하는 추세

### 복합 키: 비식별 관계 매핑

- JPA에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들고 equals와 hashcode를 구현해야함
- JPA에서는 @IdClass @EmbeddedId를 제공함 IdClass는 RDB에 가까운 방법이고 @EmbeddedId는 좀 더 객체지향에 가까운 방법

**@IdClass**

- 별도의 식별자 클래스를 생성해서 사용함
- 식별자 클래스의 속셩명과 엔티티에서 사용하는 식별자의 속성 명이 같아야함
- Serializable 인터페이스를 구현해야함
- equals, hashcode를 구현해야함
- 기본 생성자가 있어야함
- 식별자 클래스는 public 이어야함
- 서브클래스에서는 @JoinColums @JoinColum으로 부모와 매핑



**@EmbeddedId**

- @Embeddable 어노테이션을 사용함
- Serializable 인터페이스를 구현해야함
- equals, hashcode를 구현해야함
- 기본 생성자가 있어야함
- 식별자 클래스는 public 이어야함
- 서브클래스에서는 @JoinColums @JoinColum으로 부모와 매핑



**@IdClass vs @EmbeddedId**

- 각각 장단점이 있으므로 취향에 따라 일관성있게 작성하면 되고
- @EmbeddedId가 좀 더 객체지향 적이지만 특정 상황에 JPQL이 좀 더 길어질 수 있음



### 복합키: 식별 관계 매핑

생략



### 식별 비식별 관계의 장단점

- 비식별 관계를 선호함
- 식별 관계는 테이블이 늘어날수록 키도 늘어나기때문에 기본 키 인덱스가 불필요하게 커질 수 있음 쿼리도 복잡
- 식별관계는 비지니스의 의미가 있는 자연 키 컬럼을 조합하고 비식별관계는 비지니스와 관계 없는 대리키를 주로 사용함
- 식별관계는 비식별관계 테이블보다 유연하지 못함
- 식별관계는 기본 키 인덱스를 활용하기 좋고 하위 테이블만으로도 상위 테이블을 검색할 수 있는 장점이 있긴 함



## 조인 테이블

- 데이터베이스 테이블의 연관관계를 설계하는 2가지 방법
- 조인 컬럼 사용
- 조인 테이블 사용

**조인 컬럼 사용**

- 테이블 간에 관계는 주로 조인 컬럼이라 부르는 외래 키 컬럼을 사용해서 관리함
- 둘 사이 관계가 정해지지 않았을 경우 왜래키에 null을 허용해야하는데 이런 관계를 선택적 비식별관계라함

**조인 테이블 사용**

- 두 테이블 사이에 조인 테이블을 두어 테이블간에 서로 연관관계를 관리하기 위한 왜리 키 컬럼 이 없음
- 가장 큰 단점은 테이블을 하나 추가해야 한다는 점

***



- 객체와 테이블을 매핑할 때 조인 컬럼은 @JoinColumn으로 매핑하고 조인 테이블은 @JoinTable로 매핑함
- 조인 테이블은 주로 다대다 관계를 일대다, 다대일 관계로 풀어내기 위해 사용함 그렇지만 일대일, 일대다, 다대일 관계에서도 사용함



### 일대일 조인 테이블

### 일대다 조인 테이블

### 다대일 조인 테이블

### 다대다 조인 테이블

***

> 조인 테이블에 컬럼을 추가하면 @JoinTable 전략을 사용할 수 없음 대신에 새로운 엔티티를 만들어서 조인 테이블과 매핑해야함



## 엔티티 하나에 여러 테이블 매핑

- 잘 사용하지는 않지만 @SecondaryTable을 사용하면 한 엔티티에 여러 테이블을 매핑할 수 있음
- 테이블당 엔티티를 각각 만들어서 일대일 매핑하는 것을 권장함
- 이 방법은 항상 두 테이블을 조회하므로 최적화 하기 어려움





# #8 프록시와 연관관계 분리

**프록시와 즉시로딩, 지연로딩**

- jpa는 프록시를 사용해서 연관된 객체를 처음부터 데이터베이스에서 조회하는 것이 아니라, 실제 사용하는 시점에 데이터베이스에서 조회할 수 있음
- 하지만 자주 함께 사용하는 객체들은 조인을 사용해서 함께 조회하는 것이 효과적임
- jpa는 즉시로딩과 지연로딩이라는 방법으로 두가지 모두 지원함

**영속성 전이와 고아 객체**

- jpa는 연관된 객체를 함께 저장하거나 함께 삭제할 수 있는 영속성 전이와 고아 객체 제거라는 편리한 기능을 제공함



## 프록시

- 엔티티의 값을 실제 사용하는 시점에서 필요한 데이터를 조회함
- 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 가짜 객체가 필요한데 이것을 프록시 객체라 함

> 지연로딩은 프록시, 바이트코드 구성이 있음



### 프록시 기초

- jpa에서 식별자로 엔티티 하나를 조회할때 EntityManager.find()를 사용함 영속성 컨텍스트에 엔티티가 없으면 데이터베이스를 조회함
- 만약 실제 사용 시점까지 데이터베이스 조회를 미루고 싶으면 EntityManager.getReference() 메서드를 사용하면 됨

**프록시의 특징**

- 프록시 클래스는 실제 클래스를 상속 받아서 만들어지므로 실제 클래스와 겉 모양이 같음 따라서 사용하는 입장에서 신경쓰지 않아도 됨
- 프록시는 실제 객체에 대한 참조를 보관함 프록시 객체의 메서드를 호출하면 실제 메서드를 호출함

**프록시 객체의 초기화**

- 실제 엔티티 객체를 초기화할때 프록시 객체의 초기화라 함 

**프록시 초기화 과정**

1. 메서드를 호출해서 실제 데이터 조회
2. 프록시 객체는 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 실제 엔티티 생성을 요청하는데 이것을 초기화라함
3. 영속성 컨텍스트는 데이터베이스를 조회해서 실제 엔티티 객체를 생성함
4. 프록시 객체는 생성된 실제 엔티티 객체의 참조를 멤버변수에 보관함
5. 프록시 객체는 실제 엔티티 객채의 메서드를 호출해서 결과를 반환함

**프록시의 특징**

- 프록시는 처음 사용할 때 한번만 초기화됨
- 프록시 객체를 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는 것은 아님 프록시 객체가 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있음
- 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크시에 주의해서 사용해야 함
- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 데이터베이스를 조회할 필요가 없음 이후에는 실제 엔티티를 반환함
- 초기화는 영속성 컨텍스트의 도움을 받아야 가능함 따라서 영속성 컨텍스트의 도움을 받을 수 없는 준영속상태의 프록시를 초기화하면 문제가 발생함 항비ㅓ네이트는 LazyInitializationException을 발생

**준영속 상태와 초기화**



### 프록시와 식별자

- 엔티티를 프록시로 조회할 때 식별자 값을 파라미터로 전달하는데 프록시 객체는 이 식별자 값을 보관하고 있음
- 엔티티 접근 방식을 프로퍼티로 설정한 경우에만 식별자 값을 조회해도 초기화 되지 않음
- 엔티티 접근 방식을 필드로 설정하면 식별자 조회라도 프록시 객체를 초기화함
- 프록시는 연관관계를 설정할때 유용하게 사용할 수 있음
- 참고로 연관관계 설정시에는 엔티티 접근 방식을 필드로 설정해도 초기화하지 않음



### 프록시 확인

- jpa가 제공하는 PersistenceUnitUtil.isLoaded() 메서드를 사용하면 프록시 인스턴스의 초기화 여부를 알 수 있음
- 하이버네이트에는 강제로 초기화시키는 메서드가 있음



## 즉시 로딩과 지연 로딩

- jpa는 개발자가 연관된 엔티티의 조회 시점을 선택할수 있도록 다음 두가지 방법을 제공함

**즉시 로딩**

- 엔티티를 조회할 때 연관된 엔티티도 함께 조회함
- @ManyToOne(fetch = FetchType.EAGER)

**지연 로딩**

- 연관된 엔티티를 실제 사용할 때 조회함
- @ManyToOne(fetch = FetchType.LAZY)

### 즉시 로딩

- 대부분의 jpa 구현체는 즉시 로딩을 최적화 하기 위해 가능하면 조인 쿼리를 사용함

> **null 제약조건과 jpa 조인 전략**
>
> - 최적화에는 내부조인이 좋은데 내부조인을 반드시 사용하려면 @JoinColumn(nullable= false) 값을 주면 내부조인을 사용함
> - 또는 @ManyToOne.optional= false로 설정해도 내부조인을 사용함
> - 정리하면 jpa는 선택적 관계면 외부조인을 사용하고 필수 관계면 내부조인을 사용함



### 지연 로딩

- 연관관계로 매핑된 객체는 프록시 객체로 대체되어서 들어옴
- 실제 조회시점에 데이터베이스에 액세스함

### 즉시 로딩, 지연 로딩 정리

- 상황에 따라서 알맞는 방법을 선택해야함



## 지연 로딩 활용



### 프록시와 컬렉션 래퍼

- 하이버네티으는 엔티티를 영속 상태로 만들 때 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경하는데 이것을 컬렉션 래퍼라함
- 엔티티를 지연 로딩하면 프록시 객체를 사용해서 지연 로딩을 수행하지만 주문 내역 같은 컬렉션은 컬렉션 래퍼가 지연 로딩을 처리해줌



### jpa 기본 페치 전략

- @ManyToOne,  @OneToMany: 즉시 로딩
- @OneToMany, @ManyToMany: 지연 로딩
- 추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것임
- 애플리케이션 개발이 어느정도 완료 단계에 왔을 때 실제 사용하는 상황을 보고 꼭 필요한 고셍서만 즉시 로딩을 사용하도록 최적화하면 됨



### 컬렉션에 FetchType.EAGER 사용시 주의점

- 컬렉션을 하나 이상 즉시 로딩하는 것은 권장하지 않음
- 컬렉션 즉시 로딩은 항상 외부조인을 사용함



## 영속성 전이: CASCADE

- 특정 엔티티를 영속 상태로 만들때 연관된 엔티티도 함께 영속 상태로 만들고 싶으면 영속성 전이 기능을 사용하면 됨 
- JPA는 CASCADE 옵션으로 영속성 전이를 제공함



### 영속성 전이: 저장

- @OneToMany(cascade = CascadeType.PERSIST)
- 저장시 한번에 등록됨
- 영속성 전이는 연관관계를 매핑하는 것과는 아무 관련이 없음 단지 엔티티를 영속화할 때 연관된 엔티티도 같이 영속화하는 편리함을 제공함



### 영속성 전이: 삭제

- 영속성 전이는 엔티티를 삭제할 때도 사용할 수 있음 Cascade.REMOVE

> PERSIST, REMOVE는 flush를 호출할때 전이가 발생함



## 고아 객체

- JPA는 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능을 제공하는데 이것을 고아 객체 제거라함
- 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 제동으로 삭제됨
- @OneToMany(orphanRemoval= true)
- 플러시 시점에 적용
- 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제함
- @OneToOne @OneToMany에서만 사용
- 부모제거시 자동 삭제



## 영속성 전이 + 고아 객체, 생명 주기



# #9 값 타입

**값 타입 종류**

- 기본 값 타입
  - 자바 기본 타입
  - 래퍼 클래스
  - String
- 임베디드 타입 (복합 값 타입)
- 컬렉션 값 타입



## 기본 값 타입

- String, int 등

## 임베디드 타입

- 새로움 값 타입을 직접 정의해서 사용할 수 있는데 jpa에서는 이걸 임베디드 타입이라 함
- @Embeddable: 값 타입을 정의하는 곳에 표시
- @Embedded: 값 타입을 사용하는 곳에 표시
- 새로 정의한 값 타입들은 재사용할 수 있고 응집도도 아주 높음
- 임베디드 타입은 기본 생성자가 필수임
- 임베디드 타입을 포함한 모든 값 타입은 엔티티 생명주기에 의존하므로 엔티티와 임베디드 타입의 관계를 uml로 표현하면 컴포지션 관계라고함

> 하이버네이트는 임베디드 타입을 컴포넌트라함



### 임베디드 타입과 테이블 매핑

- 임베디드 타입으로 객체와 테이블을 세밀하게 매핑하는것이 가능함

### 임베디드 타입과 연관 관계

### @AttributeOverrid: 속성 재정의

- 임베디드 타입에 정의한 매핑 정보를 재정의하려면 엔티티에 @AttributeOverride를 사용하면 됨
- @AttributeOverride를 사용할 일이 많지 않음
- @AttributeOverride는 엔티티에 사용해야함

### 임베디드 타입과 null

- 임베디드 타입이 null이면 매핑한 컬럼값은 모두 null



## 값 타입과 불변 객체

### 값  타입 공유 참조

- 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함
- 값 타입 공유로 야기한 버그는 매우 찾기 어려움
- 복사해서 사용해야함
- 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입임 <- 객체 공유가 가능함
- setter 같은 메서드를 없애는게 가장 좋은 방법일듯
- 자바에서 객체 공유는 막을 수 없으니 어디서 이상하게 변경되는 setter같은게 없으면 부작용 발생은 어려워짐

### 불변 객체

- 값 타입은 부작용 걱정 없이 사용할 수 있어야함
- 객체를 불변하게 만들면 값을 수정할 수 없으므로 부작용 원천 차단 가능
- 따라서 값 타입은 가능하면 불변객체로 설계해야함



## 값 타입의 비교

- 값 타입은 비록 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야함

## 값 타입 컬렉션

- 값 타입을 하나 이상 저장하려면 컬렉션에 보고나하고 @ElementCollection, @CollectionTable 애너테이션을 사용하면 됨

### 값 타입 컬렉션 사용

- 값 타입 컬렉션은 영속성 전이 + 고아 객체 제거 기능을 필수로 가져감
- 엔티티가 저장되는 시점에 자동 저장됨
- LAZY가 기본옵션

### 값 타입 컬렉션의 제약사항

- 식별자라는 개념이 없기 때문에 단순한 값들의 모음이므로 값을 변경해버리면 원본 데이터를 찾기 어려움
- 값 타입 컬렉션이 매핑된 테이블에 데이터가 많다면 값 타입 컬렉션 대신에 일대다 관계를 고려해야함



## 정리



**엔티티 타입의 특징**

- 식별자가 있다
  - 엔티티 타입은 식별자가 있고 식별자로 구별할 수 있다.
- 생명 주기가 있다
  - 생성하고 영속화하고 소멸하는 생명 주기가 있다.
  - em.persist(entity)로 영속화한다.
  - em.remove(entity)로 제거한다
- 공유할 수 있다.
  - 참조 값을 공유할 수 있다. 이것을 공유 참조라 한다.
  - 예를 들어 회원 엔티티가 있다면 다른 엔티티에서 얼마든지 회원 엔티티를 참조할 수 있다.



**값 타입의 특징**

- 식별자가 없다.
- 생명주기를 엔티티에 의존한다.
  - 스스로 생명주기를 가지지 않고 엔티티에 의존한다. 의존하는 엔티티를 제거하면 같이 제거된다
- 공유하지 않는 것이 안전하다
  - 엔티티 타입과는 다르게 공유하지 않는 것이 안전하다 대신에 값을 복사해서 사용해야한다
  - 오직 하나의 주인만이 관리해야 한다
  - 불변 객체로 만드는 것이 안전하다.
- 값 타입은 정말 값 타입이라 판단될 때만 사용해야함 특히 엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안됨. 식별자가 필요하고 지속해서 값을 추적하고 구분하고 변경해야 한다면 그것은 값 타입이 아닌 엔티티임













































