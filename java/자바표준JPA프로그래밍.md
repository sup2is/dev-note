https://github.com/holyeye/jpabook



# #1 JPA 소개

- JPA는 지루하고 반복적인 CRUD SQL을 알아서 처리해줄 뿐만 아니라 객체 모델링과 관계형 데이터베이스 사이의 차이점도 해결해준다.

## SQL을 직접 다룰 때 발생하는 문제점

- 개발자가 객체지향 어플리케이션과 데이터베이스 중간에서 SQL과 JDBC API를 사용해서 변환작업을 해줘야함 이는 RDB와 객체지향 패러다임의 차이가 있기 때문임
- 개발자가 SQL 쿼리로 인한 실수를 만들 여지가 많음
- 진정한 의미의 계층 분할이 안되고 엔티티를 신뢰할 수 없음
- SQL에 의존적인 개발을 피할 수 없음

## 패러다임의 불일치

- JPA는 상속과 관련된 패러다임의 불일치 문제를 개발자 대신 해결해줌 개발자는 마치 자바 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면 됨
- 객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회하고 DB는 외래키를 사용해서 다른 테이블과의 조인으로 연관데이터를 가져온다.
- JPA는 연관관계와 관련된 패러다임의 불일치 문제를 해결해준다. 참조하는 객체를 외래키로 변환해서 적절한 insert sql을 만들어준다. 
- JPA를 사용하면 객체 그래프를 마음껏 사용할 수 있음 SQL의 경우 객체 그래프의 정도를 SQL 시점에서 결정해야하지만 JPA는 그렇지 않음
- JPA는 같은 트랜잭션일때 같은 객체가 조회되는것을 보장함.
- 객체지향과 데이터베이스 패러다임의 불일치로 어플리케이션이 점점 데이터 중심의 모델로 변하는 것을 JPA를 통해 해결할 수 있다. 

## JPA란 ?

- JPA는 자바진영의 ORM 기술 표준임 Java 와 JDBC api 사이에 존재함
- ORM은 Object-Relational Mapping임 객체와 데이터베이스를 매핑해주는 프레임워크
- ORM 프레임워크는 단순히 SQL을 개발자 대신 생성해서 데이터베이스에 전달해주는 것뿐만 아니라 다양한 패러다임의 불일치 문제들도 해결해줌

### JPA 소개

- Java진영에서는 ORM 프레임워크중 하이버네이트를 가장 많이사용함
- EJB3.0에서 하이버네이트를 기반으로 새로운 자바 ORM이 탄생함 이게 JPA, JPA는 자바 ORM 기술에 대한 API 표준 명세

### JPA를 왜 사용해야 하는가?

- **생산성 :** SQL로 처리하던 지루한 CRUD를 JPA가 대신 처리해줌 기존에 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있음
- **유지보수:** 컬럼하나로 수많은 코드를 변경해야했던 부분이 JPA로 해결되기때문에 유지보수성 향상
- **패러다임의 불일치 해결:** JPA는 상속, 연관관계, 객체 그래프탐색, 동등성 비교 같은 패러다임의 불일치 해결
- **성능:** 기존 SQL 쿼리로 Database에 두번 나가는걸 1차캐시로 한번만으로 끝낼 수 있음
- **데이터 접근 추상화와 벤더 독립성:** 하나의 데이터베이스에 의존하지않도록 추상화된 레이어로 데이터베이스를 쉽게 변경할 수 있음
- **표준:** JPA는 표준이기 때문에 다른 기술로 손쉽게 변경 가능함



# #2 JPA 시작

- **@Entity:** 이 클래스를 테이블과 매핑한다고 JPA에게 알려줌 이런 클래스를 엔티티 클래스라함
- **@Table:** 엔티티 클래스에 매핑할 테이블 정보를 알려줌
- **@Id:** primary key에 매핑함 이 필드를 식별자 필드라고함
- **@Column :** 데이터베이스와 매핑될 컬럼명을 지정할 수 있음
- **매핑 정보가 없는 필드:** 자동적으로 컬럼명으로 매핑함

## 엔티티 매니저 설정

- **엔티티 매니저 팩토리 생성:** JPA를 시작하려면 우선 persistence.xml의 설정 정보를 사용해서 엔티티 매니저 팩토리를 생성해야함 Persistance 클래스를 사용해서 엔티티 매니저 팩토리를 생성하고 데이터 베이스 커넥션 풀 등을 생성해서  JPA를 사용할 수 있게 해줌 그러나 이 엔티티 매니저 팩토리는 초기 생성 비용이 굉장히 크기때문에 어플리케이션 전체에서 딱 한번만 생성하고 공유해서 사용해야함
- **엔티티 매니저 생성:** 엔티티 매니저 팩토리에서 엔티티 매니저를 생성함 JPA의 대부분의 기능들은 엔티티 매니저가 제공(CRUD), 엔티티 매니저는 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용하면 안됨
- **종료:** 사용이 끝난 엔티티매니저는 반드시 종료해야함 어플리케이션 종료시점에도 매니저 팩토리 역시 종료시켜야함

## 트랜잭션 관리

- JPA를 사용하면 반드시 트랜잭션 안에서 데이터를 변경해야함 엔티티매니저에서 트랜잭션을 얻어오고 정상동작시 커밋 아니면 롤백함

## 비지니스 로직 

## JPQL

- 애플리케이션이 필요한 데이터만 데이터베이스에서 불러오려면 JPQL을 통해서 질의하면 됨
- JPQL은 엔티티를 대상으로 질의하고 SQL은 데이터베이스를 대상으로 질의함 JPQL은 데이터베이스를 알지 못함





# #3 영속성 관리

- JPA가 제공하는 기능은 크게 엔티티와 테이블을 매핑하는 설계 부분과 매핑한 엔티티를 실제 사용하는 부분으로 나눌 수 있음

## 엔티티 매니저 팩토리와 엔티티 매니저

- 엔티티 매니저 팩토리를 생성하는 비용은 매우 크지만 앤티티 매니저 팩토리에서 엔티티 매니저를 생성하는 비용은 거의 들지 않음
- 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드간에 절대 공유 금지! 
- 엔티티매니저는 바로 데이터베이스 커넥션을 얻지 않고 필요할 때 얻음

## 영속성 컨텍스트란 ?

- JPA를 이해한데 가장 중요한 용어
- 엔티티를 영구 저장하는 환경
- 영속성 컨텍스트는 엔티티 매니저를 생성할 때 만들어지고 엔티티매니저를 통해 접근 관리한다

## 엔티티의 생명주기

- **비영속:** 영속성 컨텍스트와 전혀 관계가 없는 상태
- **영속:** 영속성 컨텍스트에 저장된 상태
- **준영속:** 영속성 컨텍스트에 저장되었다가 분리된 상태
- **삭제:** 삭제된 상태

## 영속성 컨텍스트의 특징

- **영속성 컨텍스트와 식별자 값:**  @Id로 매핑된 식별자 필드가 반드시 있어야함
- **영속성 컨텍스트와 데이터베이스 저장:** 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 flush라함
- **영속성 컨텍스트가 엔티티를 고나리하면 좋은점:**
  - 1차 캐시
  - 동일성 보장
  - 트랜잭션을 지원하는 쓰기 지연
  - 변경 감지
  - 지연 로딩

### 엔티티 조회

- 영속성 컨텍스트 내부에는 캐시를 갖고 있는데 이걸 1차 캐시라함
- 영속성 컨텍스트 내부에 저장 조회하는 모든 기준은 @Id 가 붙은 식별자 필드임
- 1차캐시에서 엔티티를 찾고 만약 찾는 엔티티가 있으면 캐시에서만 조회함 없을경우 DB에 질의 후 1차캐시에 저장
- 영속성 컨텍스트는 성능상 이점과 엔티티의 동일성을 보장함

### 엔티티 생성

- insert 문이 여러개가 있어도 하나의 트랜잭션 안에서는 마지막 트랜잭션 커밋에 데이터베이스에 flush하는데 이걸 트랜잭션을 지원하는 쓰기지연이라함
- 데이터베이스에 한번만 액세스하기때문에 성능읠 최적화 할 수 있음

### 엔티티 수정

- 변경감지를 통해서 엔티티 내부에 변경사항이 있으면 데이터베이스에 자동으로 반영해줌
- JPA는 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 스냅샷을 만들어둠
- 변경감지는 영속 상태의 엔티티만 관리함
- 쿼리는 모든 변경필드 뿐만 아니라 모든 필드에 대해 적용되므로 컬럼이 30개 이상이라면 @DynamicUpdate를 사용하는걸 추천함

### 엔티티 삭제

- 쓰기지연으로 삭제하지만 em.remove()를 적용하는 순간 이미 영속성 컨텍스트에서 제거됨

## 플러시

- flush()는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영함
  1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾음 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록함
  2. 쓰기지연 SQL 저장소의 쿼리를 DB에 등록함
- 영속성 컨텍스트 플러쉬방법 
  1. em.flush를 직접 호출
  2. 트랜잭션 커밋시 자동호출
  3. JPQL쿼리 실행시 자동호출
- 영속성 컨텍스트와 데이터베이스를 동기화시키는 것이 바로 플러시

## 준영속

- 영속성 컨텍스트가 관리하는 용속 상태의 엔티티가 영속성 컨텍스트에서 분리된것을 준영속 상태라함
- em.detach(한개의 entity), em.close(), em.clear()

### 준영속 상태의 특징

- 거의 비영속 상태임
- 식별자 값을 가지고 있음
- 지연 로딩 불가능

### 병합 merge()

- 준영속 상태의 엔티티를 영속상태로 변경하려면 병합을 사용하면 됨
- 새로운 영속상태의 엔티티를 반환함
- 식별자 값으로 엔티티를 조회할 수 있다면 비영속, 준영속도 신경쓰지 않음































