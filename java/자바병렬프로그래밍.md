



# 자바 병렬 프로그래밍

**소스코드**

[https://jcip.net/listings](https://jcip.net/listings)



# #1 개요

## 작업을 동시에 실행하는 일에 대한 간략한 역사

- 자원 활용, 공정성, 편의성 등 프로세스 개념을 만들어내게 된 것과 같은 동기를 갖고 스레드가 고안됨
- 스레드로 인해 한 프로세스 안에 여러개의 프로그램 제어 흐름이 공존할 수 있음
- 스레드는 메모리, 파일 핸들과 같이 프로세스에 할당된 자원을 공유함 하지만 각 스레드는 각기 별도의 프로그램 카운터, 스택, 지역변수를 가짐
- 프로그램을 스레드로 분리하면 멀티프로세서 시스템에서 자연스럽게 하드웨어 병렬성을 이용할 수 있음 즉 한 프로그램 내 여러 스레드를 동시에 여러 개의 cpu에 할당해 실행시킬 수 있음
- 스레드는 lightweight process라고 부르기도 함
- 운영체제의 대부분은 프로세스가 아니라 스레드를 기분 단위로 cpu 자원의 스케줄을 정함
- 스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드들은 같은 변수에 접근하고 같은 힙에 객체를 할당함 이때 공유된 과정을 적절하게 동기화하지 않으면 다른 스레드가 사용중인 변수를 순간적으로 수정해서 예상치 못한 결과를 얻을 수도 있음

## 스레드의 이점

- 스레드를 제대로만 사용하면 개발 및 유지보수 비용을 줄이고 복잡한 애플리케이션의 성능을 향상시킬 수 있음

### 멀티 프로세서 활용

- 여러개의 스레드를 사용하면 프로세서가 하나라 해도 처리속도를 높일 수 있음
- 프로세스가 여러개라도 스레드가 하나라면 자원 낭비임

### 단순한 모델링

### 단순한 비동기 이벤트 처리

### 더 빨리 반응하는 사용자 인터페이스

## 스레드 사용의 위험성

### 안전성 위해 요소

- 동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산의 순서를 예측하기 매우 어려움

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * UnsafeSequence
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
public class UnsafeSequence {
    private int value;

    /**
     * Returns a unique value.
     */
    public int getNext() {
        return value++;
    }
}
```

- 위 코드는 여러 스레드에서 실행될때 getNext()를 동시에 호출했을때 같은 값을 얻을 가능성이 있음
- 스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용 중일지도 모르는 변수를 읽거나 수정할 수도 있음 편리하지만 위험 요소이기도 함. 데이터가 예측 못한 시점에 변경될 수 있기 때문
- 스레드가 서로 간섭하지 않도록 공유된 변수에 접근하는 시점에 적절하게 조율해야함
- 위 클래스는 아래처럼 수정 가능함

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * Sequence
 *
 * @author Brian Goetz and Tim Peierls
 */

@ThreadSafe
public class Sequence {
    @GuardedBy("this") private int nextValue;

    public synchronized int getNext() {
        return nextValue++;
    }
}
```

### 

### 활동성 위험

- 동시 수행 코드를 개발할 때는 반드시 스레드 안전성 문제를 신경써야 함 반드시!
- 멀티 스레드 프로그램에서는 단일 스레드 프로그램에서 발생하지 않는 추가적인 위험에 노출됨
- deadlock, starvation, livelock 등등 활동성 장애



### 성능 위험

- 성능 문제는 형편없는 서비스 시간, 만응성, 처리율, 자원 소모, 규모에 따른 확장성 등 넓은 범위의 문제들을 포괄함
- 잘 설계된 병렬 프로그램은 스레드를 사용해서 궁극적으로 성능을 향상시킬 수 있으나 많은 스레드를 사용함으로써 메모리의 지역성이 손실되고 동기화 수단을 사용 하는 등의 성능 손실을 유발할 수 있음



## 스레드는 어디에나

- 모든 자바 프로그램은 기본적으로 스레드를 사용함 main 메서드를 실행하는 스레드, JVM에서 사용하는 스레드 등
- 개발자는 병렬성과 스레드 안전성에 대해 잘 알아야함



# #2 스레드 안전성

- 스레드에 안전한 코드를 작성하는 것은 근본적으로는 상태, 특히 공유되고 변경할 수 있는 상태에 대한 접근을 관리하는 것 ex static,  인스턴스 변수
- 스레드 안전성이란 데이터에 제어 없이 동시 접근을 막으려는 의미
- 객체가 스레드에 안전해야 하느냐는 해당 객체에 여러 스레드가 접근할지의 여부에 달렸음
- 객체를 스레드에 안전하게 만드려면 동기화를 통해 변경할 수 있는 상태에 접근하는 과정을 조율해야 함
- 스레드가 하나 이상 상태 변수에 접근하고 그 중 하나라도 변수에 값을 쓰면, 해당 변수에 접근할 때 관련된 모든 스레드가 동기화를 통해 조율되어야함
- 자바에서는 synchronized 키워드로 배타적인 락을 통해 보호 기능을 제공함
- volatile변수, 명시적 락, 단일 연산 변수 atomic variable을 사용하는 경우에도 동기화라는 용어를 사용함
- 동시성 관련된 문제를 해결하는 세가지 방법
  - 해당 상태 변수를 스레드 간에 공유하지 않도록 함
  - 해당 상태 변수를 변경할 수 없도록 만듬
  - 해당 상태 변수에 접근할 땐 언제나 동기화를 사용함
- 클래스 설계시점에 스레드 안전하게 설계하는것이 훨씬 쉬움
- 프로그램 상태를 잘 캡슐화할수록 스레드 안전하게 만들기 쉽고 유지보수도 쉬움
- 스레드 안전한 클래스를 설계할 땐, 바람직한 객체 지향 기법이 왕도. 캡슐화와 불변객체를 잘활용하고 불변 조건을 명확하게 기술해야함

## 스레드 안전성이란?

- 여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케줄하든 어띠에 끼워넣든, 호출하는 쪽에서추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고함
- 스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화함



### 예제: 상태없는 서블릿

```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * StatelessFactorizer
 *
 * A stateless servlet
 * 
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class StatelessFactorizer extends GenericServlet implements Servlet {

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[] { i };
    }
}
```

- 위와 같이 상태가 없는 객체는 항상 스레드에 안전함
- 서블릿 요청 간에 뭔가를 기억할 필요가 있을 때에야 스레드 안전성이 문제가 됨



## 단일 연산



```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * UnsafeCountingFactorizer
 *
 * Servlet that counts requests without the necessary synchronization
 *
 * @author Brian Goetz and Tim Peierls
 */
@NotThreadSafe
public class UnsafeCountingFactorizer extends GenericServlet implements Servlet {
    private long count = 0;

    public long getCount() {
        return count;
    }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        ++count;
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse res, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[] { i };
    }
}
```

- ++count 은 3개의 별도의 3개의 동작을 한줄로 표현한 것
- 위 클래스는 스레드에 안전하지 않음
- 병렬 프로그램의 입장에서 타이밍이 안좋을 때 결과가 잘못될 가능성은 race condition(경쟁 조건)이라는 용어를 사용함



### 경쟁 조건

- race condition이 발생하는 클래스는 결과를 신뢰할 수 없음
- 어떤 사실을 확인하고 그 관찰에 기반해 행동을 하는 류의 경쟁 조건을 점검 후 행동이라고함 해당 관찰은 관찰한 시각과 행동한 시각 사이에 더 이상 유효하지 않게 됐을 수 있음



### 예제: 늦은 초기화 시 경쟁 조건

- 점검 후 행동하는 흔한 프로그래밍 패턴으로 lazy initialization이 있음

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * LazyInitRace
 *
 * Race condition in lazy initialization
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
public class LazyInitRace {
    private ExpensiveObject instance = null;

    public ExpensiveObject getInstance() {
        if (instance == null)
            instance = new ExpensiveObject();
        return instance;
    }
}

class ExpensiveObject { }


```

- 위 클래스는 두개의 스레드가 동시에 `if (instance == null)` 에서 null을 받았을때 서로 다른 인스턴스를 생성할 수 있음

### 

### 복합 동작

- 경쟁 조건을 피하려면 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 막을 방법이 있어야하고 이런 방법으로 보호해두면 특정 스레드에서 변수를 수정할 때 다른 스레드는 수정 도중이 아닌 수정 이전이나 이후에만 상태를 읽거나 변경을 가할 수 있음

```java
package net.jcip.examples;

import java.math.BigInteger;
import java.util.concurrent.atomic.*;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * CountingFactorizer
 *
 * Servlet that counts requests using AtomicLong
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class CountingFactorizer extends GenericServlet implements Servlet {
    private final AtomicLong count = new AtomicLong(0);

    public long getCount() { return count.get(); }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        count.incrementAndGet();
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse res, BigInteger[] factors) {}
    BigInteger extractFromRequest(ServletRequest req) {return null; }
    BigInteger[] factor(BigInteger i) { return null; }
}
```

- `UnsafeCountingFactorizer`을 `AtomicLong`을 사용하서 스레드 세이프하게 작성한 클래스
- java.util.concurrent.atomic 패키지에는 숫자나 객체 참조 값에 대해 상태를 단일 연산으로 변경할 수 있도록 단일 연산 변수 클래스가 준비돼 있음
- 상태 없는 클래스에 상태 요소를 하나 추가할 때 스레드 안전한 객체 하나로 모든 상태를 관리한다면 해당 클래스는 스레드에 안전함
- 가능하면 클래스 상태를 관리하기 위해 AtomicLong처럼 스레드에 안전하게 이미 만들어져 있는 객체를 사용하는 편이 좋음. 스레드 안전하지 않은 상태 변수를 선언해두고 사용하는 것보다 이미 스레드 안전하게 만들어진 클래스가 가질 수 있는 가능한 상태의 변화를 파악하는 편이 훨씬 쉽고, 스레드 안전성을 더 쉽게 유지하고 검증할 수 있음



## 락



```java
package net.jcip.examples;

import java.math.BigInteger;
import java.util.concurrent.atomic.*;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * UnsafeCachingFactorizer
 *
 * Servlet that attempts to cache its last result without adequate atomicity
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
public class UnsafeCachingFactorizer extends GenericServlet implements Servlet {
    private final AtomicReference<BigInteger> lastNumber
            = new AtomicReference<BigInteger>();
    private final AtomicReference<BigInteger[]> lastFactors
            = new AtomicReference<BigInteger[]>();

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        if (i.equals(lastNumber.get()))
            encodeIntoResponse(resp, lastFactors.get());
        else {
            BigInteger[] factors = factor(i);
            lastNumber.set(i);
            lastFactors.set(factors);
            encodeIntoResponse(resp, factors);
        }
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[]{i};
    }
}

```

- 위 클래스는 서로 다른 클라이언트가 연이어 같은 숫자를 인수분해하길 원할 경우 가장 최근 계산결과를 캐시해둬서 리턴하는 향상된 서블릿 클래스임 but 잘 동작하는 클래스가 아님
- 스레드 안전성의 정의에 따르면 여려 스레드에서 수행되는 작업의 타이밍이나 스케줄링에 따른 교차 실행과 관계 없이 불변조건이 유지되어야 스레드에 안전함
- 여러 개의 변수가 하나의 불변 조건을 구성하고 있고 이 작업들이 단일 연산 작업 내에서 변경되지 않는다면 문제가 생길 수 있음
- 상태를 일관성 있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야함

### 암묵적인 락

- 자바에는 단일 연산 특성을 보장하기 위해 synchronized라는 구문으로 사용할 수 있는 락을 제공함
- synchronized구문은 락으로 사용될 객체의 참조 값과 해당 락으로 보호하려는 코드 블록으로 구성됨
- synchronized는 메서드가 포함된 클래스의 인스턴스 락으로 사용하는 synchronized블록을 간략하게 표현한 것
- static으로 선언된 synchronized메서드는 해당 Class 객체를 락으로 사용
- 모든 자바 객체는 락으로 사용할 수 있음
- 자바에 내장된 락을 암묵적인 락 혹은 모니터 락이라고 함 락은 스레드가 synchronized블록에 들어가기 전에 자동으로 확보되고 정상적으로든 예외가 발생해서든 해당 블록을 벗어날 때 자동으로 해제됨
- 해당 락으로 보호된 synchronized 블록이나 메서드에 들어가야만 암묵적인 락을 확보할 수 있음
- 자바에서 암묵적인 락은 뮤텍스로 동작함 즉 한번에 한 스레드만 특정 락을 소유할 수 있음
- 같은 락으로 보호되는 synchronized 서로 다른 블력 역시 서로 단일 연산으로 실행됨
- 동시성 맥락에서 단일 연산의 특성은 트랜잭션 프로그램에서 말하는 단일 연산 특성과 같은 의미임
- 한 스레드가 synchronized 블록을 실행중이라면 같은 락으로 보호되는 synchronized블록에 다른 스레드가 들어와 있을 수 없음



```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * SynchronizedFactorizer
 *
 * Servlet that caches last result, but with unnacceptably poor concurrency
 *
 * @author Brian Goetz and Tim Peierls
 */

@ThreadSafe
public class SynchronizedFactorizer extends GenericServlet implements Servlet {
    @GuardedBy("this") private BigInteger lastNumber;
    @GuardedBy("this") private BigInteger[] lastFactors;

    public synchronized void service(ServletRequest req,
                                     ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        if (i.equals(lastNumber))
            encodeIntoResponse(resp, lastFactors);
        else {
            BigInteger[] factors = factor(i);
            lastNumber = i;
            lastFactors = factors;
            encodeIntoResponse(resp, factors);
        }
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[] { i };
    }
}

```

- 위는 UnsafeCachingFactorizer를 극단적으로 변경한 케이스, 성능이 엄청나게 떨어짐



### 재진입성

- 스레드가 다른 스레드가 가진 락을 요청하면 해당 스레드는 대기 상태에 들어감 하지만 암묵적인 락은 재진입 가능하기 때문에 특정 스레드가 자기가 이미 획득한 락을 다시 확보할 수 있음
- 재진입성은 확보 요청 단위가 아닌 스레드 단위로 락을 얻는다는 것을 의미함
- JVM이 락에 대한 소유 스레드를 기록하고 확소 횟수를 1로 지정, 계속 증가하다가 0이되면 해당 락이 해제
- 재진입 가능한 락이 없다면 중첩된 락은 데드락에 빠짐



## 락으로 상태 보호하기

- 락은 자신이 보호하는 코드 경로에 여러 스레드가 순차적으로 접근하도록 하기 때문에 공유된 상태에 배타적으로 접근할 수 있도록 보장하는 규칙을 만들 때 유용함
- 여러 스레드에서 접근할 수 있고 변경 가능한 모든 변수를 대상으로 해당 변수에 접근할 때는 항상 동일한 락을 먼저 확보한 상태여야 함. 이 경우 해당 변수는 확보된 락에 의해 보호된다고 말함
- 모든 변경할 수 있는 공유 변수는 정확하게 단 하나의 락으로 보호해야 함. 유지보수 하는 사람이 알 수 있게 어느락으로 보호하고 있는지를 명확하게 표시할 것
- 락을 활용함에 있어 일반적인 사용 예는 먼저 모든 변경 가능한 변수를 객체 안에 캡슐화하고 해당 객체의 암묵적인 락을 사용해 캡슐화한 변수에 접근하는 모든 코드 경로를 동기화함으로써 보호하는 방법 <= 이패턴은 Vector를 비롯해 여러 클래스에서 사용하는 방법
- 여러 변수에 대한 불변조건이 있으면 해당 변수들은 모두 같은 락으로 보호해야 함
- 무차별적인 synchronized 사용은 동기화가 너무 과도할 수 있음



## 활동성과 성능

- 단순하고 큰 단위로 동기화에 접근하면 안전성을 확보할 수 있지만 치러야 할 대가가 너무 큼
- synchronized블록의 범위를 줄이면 스레드 안정성을 유지하면서 쉽게 동시성을 향상시킬 수 있음 이 때 synchronized 블록의 범위를 너무 작게 줄이지 않도록 조심해야함 => 필요한 부분은 반드시 단일 연산으로 처리해야함 => 하나의 락으로

```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * CachedFactorizer
 * <p/>
 * Servlet that caches its last request and result
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class CachedFactorizer extends GenericServlet implements Servlet {
    @GuardedBy("this") private BigInteger lastNumber;
    @GuardedBy("this") private BigInteger[] lastFactors;
    @GuardedBy("this") private long hits;
    @GuardedBy("this") private long cacheHits;

    public synchronized long getHits() {
        return hits;
    }

    public synchronized double getCacheHitRatio() {
        return (double) cacheHits / (double) hits;
    }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = null;
        synchronized (this) {
            ++hits;
            if (i.equals(lastNumber)) {
                ++cacheHits;
                factors = lastFactors.clone();
            }
        }
        if (factors == null) {
            factors = factor(i);
            synchronized (this) {
                lastNumber = i;
                lastFactors = factors.clone();
            }
        }
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[]{i};
    }
}
```

- 두 변수 모두 공유상태에 속하기 떄문에 접근할때도 항상 동기화 구문을 사용해야함
- synchronized밖이라면 스택 상의 변수만 사용하기 떄문에 동기화가 필요 없음
- 이미 동기화처리 되어있다면 AtomicX를 사용하지 않는것이 좋음 서로 다른 두가지 동기화 수단은 혼동만 주고 성능상에 이점이 없음
- 락을 얻는 작업은 어느정도 비용이 있으므로 synchronized블록을 너무 잘게 쪼개지 않는것이 중요함
- 동기화 정책을 구현할 때는 성능을 위해 조급하게 단순성을 희생하고픈 유혹을 버려야함 안전성이 가장 중요
- 락을 사용할 땐 블록 안의 코드가 무엇을 하는지, 수행하는데 얼마나 걸릴지를 파악해야함 활동성이나 성능 문제를 야기할 수 있음
- 복잡하고 오래 걸리는 계싼 작업, 네트웍 작업, 사용자 입출력 작업과 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 한 락을 잡지 말 것!





# #3 객체 공유

- 병렬 프로그램 작성은 상태가 바뀔 수 있는 내용을 프로그램 내부의 여러 부분에서 어떻게 잘 공유해 사용하도록 관리할 것인지에 대한 문제

## 가시성

- 일반적으로 특정 변수의 값을 가져갈 때 다른 스레드가 작성한 값을 가져갈 수 있다는 보장이 없음 메모리상의 공유된 변수를 여러 스레드에서 서로 사용할 수 있게 하려면 반드시 동기화 기능을 구현해야함

```java
package net.jcip.examples;

/**
 * NoVisibility
 * <p/>
 * Sharing variables without synchronization
 *
 * @author Brian Goetz and Tim Peierls
 */

public class NoVisibility {
    private static boolean ready;
    private static int number;

    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready)
                Thread.yield();
            System.out.println(number);
        }
    }

    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```

- 메인 스레드와 ReaderThread는 변수를 공유하지만 동기화되지 않았음. 절대 사용하지 말 것!
- 위 코드는 어떤 스레드가 먼저 공유 변수에 접근할지 모르는 현상이 있는데 재배치 현상이라고함
- 재배치 현상은 특정 메서드의 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에 기인하는 문제. 단일 스레드로 동작할 때는 차이점을 전혀 알아챌 수 없지만 여러 스레드가 동시에 동작하는 경우에는 확연하게 나타날 수 있음
- 동기화되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 ''반드시 이런 순서로 동작할 것이다'' 라고 단정할 수 없음
- 병렬프로그램에서 동기화가 완벽하게 맞춰지지 않았다면 정상적으로 작동할 것인지를 추측하기가 매우 어려움
- 여러 스레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용해야함



### 스테일 데이터

- 변수를 사용하는 모든 경우에 동기화를 시켜주지 않으면 해당 변수에 대한 최신 값이 아닌 다른 값을 사용하게 되는 경우가 발생할 수 있음

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * MutableInteger
 * <p/>
 * Non-thread-safe mutable integer holder
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
public class MutableInteger {
    private int value;

    public int get() {
        return value;
    }

    public void set(int value) {
        this.value = value;
    }
}
```

- 동기화처리되지 않아서 스레드에 안전하지 않음

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * SynchronizedInteger
 * <p/>
 * Thread-safe mutable integer holder
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class SynchronizedInteger {
    @GuardedBy("this") private int value;

    public synchronized int get() {
        return value;
    }

    public synchronized void set(int value) {
        this.value = value;
    }
}
```

- 동기화처리되어서 스레드에 안전함



### 단일하지 않은 64비트 연산 

- 동기화되지 않은 상태에서 특정 스레드가 변수의 값을 읽어려 할때는 stale한 값을 읽어갈 가능성이 있긴 하지만 전혀 엉뚱한 값을 가져가는 것은 아니고 바로 이전 스레드에서 설정한 값을 가져가게됨
- 하지만 64비트를 사용하는 숫자형 double, long 에 volatile 키워드를 사용하지 않은 경우엔 이상한 값마저 생길 가능성이 있음



### 락과 가시성

- 값을 변경할 수 있는 변수를 여러 개의 스레드에서 동시에 사용한다면, 바로 이전 스레드에서 사용했던 변수의 값을 오류 없이 정상적으로 다음 스레드가 사용할 수 있도록 synchronized를 사용해야함
- 여러 스레드에서 사용하는 변수를 적당한 락으로 막아주지 않으면 stale 상태에 쉽게 빠질 수 있음
- 락은 상호 배제 뿐만 아니라 정상적인 메모리 가시성을 확보하기 위해서도 사용함. 변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상적인 값으로 활용하려면 동일한 락을 사용해 모두 동기화시켜야함



### volatile 변수

- 자바에서는 volatile변수로 좀더 약한 동기화 기능을 제공함
- volatile변수를 사용하면 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해줌
- volatile변수를 사용하면 컴파일러와 런타임 모두 '이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치해서는 안된다' 라고 이해함 따라서 캐시되지 않고 항상 다른 스레드가 보관해둔 최신의 값을 읽어갈 수 있음
- 동기화하고자하는 부분을 명확하게 볼 수 있고, 구현하기가 훨씬 간단한 경우에만 volatile 변수를 활용할 것. 반대로 작은 부분이라도 가시성을 추론해봐야 하는 경우에는 volatile 변수를 사용하지 않는 것이 좋음. volatile 변수를 사용하는 적절한 경우는, 일반적으로 변수에 보관된 클래스의 상태에 대한 가시성을 확보하거나 중요한 이벤트가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우 등이 해당됨
- 락을 사용하면 가시성과 연산의 단일성을 모두 보장받을 수 있지만 volatile변수는 연산의 단일성을 보장하지 못하고 가시성만 보장함
- volatile변수를 쓰면 좋을때
  - 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재할 경우
  - 해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어있지 않은 경우
  - 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없는 경우



## 공개와 유출

- 특정 객체를 현재 코드의 스코프 범위 밖에서 사용할 수 있도록 만들면 공개되었다고 함
- 만약 클래스 내부 상태 변수를 외부에 공개해야한다면 객체 캡슐화 작업이 물거품이되거나 내부 데이터의 안전성을 해칠 수 있음 따라서 객체가 안정적이지 않은 상태에서 공개하면 스레드 안전성에 문제가 생길 수 있음
- 의도적으로 공개시키지 안았지만 외부에서 사용할 수 있게 공개된 경우를 유출 상태라고함

```java
package net.jcip.examples;

import java.util.*;

/**
 * Secrets
 *
 * Publishing an object
 *
 * @author Brian Goetz and Tim Peierls
 */
class Secrets {
    public static Set<Secret> knownSecrets;

    public void initialize() {
        knownSecrets = new HashSet<Secret>();
    }
}


class Secret {
}
```

- 위에 knownSecrets은 스코프에 관계 없이 완전히 공개됨

```java
package net.jcip.examples;

/**
 * UnsafeStates
 * <p/>
 * Allowing internal mutable state to escape
 *
 * @author Brian Goetz and Tim Peierls
 */
class UnsafeStates {
    private String[] states = new String[]{
        "AK", "AL" /*...*/
    };

    public String[] getStates() {
        return states;
    }
}
```

- 위 클래스는 getStates() 메서드를 사용해서 private 멤버변수를 직접변경할 수 있음. states 변수는 유출상태임
- 정리하자면 객체를 공개했을 때 그 객체 내부의 private이 아닌 변수나 메서드를 통해 불러올 수 있는 모든 객체는 함께 공개된다는 점을 알아둘 것
- 항상 누군가는 의도했건 의도하지 않았건 공개된 객체를 잘못 사용할 가능성에 노출이되기때문에 어떤 객체건 객체 내부에서 사용하는 값이 적절하게 캡슐화되도록 해야함

```java
package net.jcip.examples;

/**
 * ThisEscape
 * <p/>
 * Implicitly allowing the this reference to escape
 *
 * @author Brian Goetz and Tim Peierls
 */
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
        });
    }

    void doSomething(Event e) {
    }


    interface EventSource {
        void registerListener(EventListener e);
    }

    interface EventListener {
        void onEvent(Event e);
    }

    interface Event {
    }
}

```

-  위와 같은 코드는 EventListener 클래스를 포함하고 있는 ThisEscape 클래스도 함께 외부에 공개됨 안좋은 방법!



### 생성 메소드 안전성

- 일반적으로 생성 메서드가 완전히 종료하고 난 이후가 되어야 객체의 상태가 개발자가 예상한 상태로 초기화되기 때문에 생성 메서드가 실행되는 도중에 해당 객체를 외부에 공개해야 한다면 정상적이지 않은 상태의 객체를 외부에서 불러 사용할 가능성이 있음
- 생성 메서드를 실행하는 도중에는 this 변수가 외부에 유출되지 않도록 해야함 <= 먼말인지 이해가 잘 안됨
- 생성 메서드에서 this 변수를 유출시키는 가장 흔한 오류는 생성 메서드에서 스레드를 새로 만들어 시작시키는 일.

```java
package net.jcip.examples;

/**
 * SafeListener
 * <p/>
 * Using a factory method to prevent the this reference from escaping during construction
 *
 * @author Brian Goetz and Tim Peierls
 */
public class SafeListener {
    private final EventListener listener;

    private SafeListener() {
        listener = new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
        };
    }

    public static SafeListener newInstance(EventSource source) {
        SafeListener safe = new SafeListener();
        source.registerListener(safe.listener);
        return safe;
    }

    void doSomething(Event e) {
    }


    interface EventSource {
        void registerListener(EventListener e);
    }

    interface EventListener {
        void onEvent(Event e);
    }

    interface Event {
    }
}


```

- 위와 같이 사용하면 생성 메서드에서 this 변수가 외부로 유촐되지 않도록 팩토리 메서드를 사용할 수 있음



## 스레드 한정

- 변경 가능한 객체를 공유해 사용하는 경우에는 항상 동기화시켜야함
- 만약 싱글 스레드에서만 사용한다고 확신할 수 있다면 해당 객체는 따로 동기화할 필요가 없음
- 이처럼 객체를 사용하는 스레드를 한정하는 방법으로 스레드 안전성을 확보할 수 있음. 객체 인스턴스를 특정 스레드에 한정시켜두면 해당하는 객체가 아니라 해도 자동으로 스레드 안전성을 확보하게 됨
- 언어적인 차원에서 특정 변수를 대상으로 락을 걸 수 있는 기능을 제공하지 않은 것처럼, 임의의 객체를 특정 스레드에 한정시키는 기능도 제공하지 않음. 스레드 한정 기법은 프로그램을 처음 설계하는 과정부터 함께 다뤄야 하며, 프로그램을 구현하는 과정 내내 한정 기법을 계속해서 적용해야 함

### 스레드 한정 - 주먹구구식

- 특정 모듈을 단일 스레드로 동작하도록 구현하면 데드락을 미연에 방지할 수 있는 장점이 있음 대부분의 gui 프로그램은 단일 스레드로 동작하도록 구현된 큰 이유.

### 스택 한정

- 스택 한정 기법은 특정 객체를 로컬 변수를 통해서만 사용할 수 있는 특별한 경우의 스레드 한정 기법이라고 할 수 있음 
- 변수를 클래스 내부에 숨겨두면 변경 상태를 관리하기가 쉬움, 또한 클래스 내부에 숨겨둔 변수는 특정 스레드에 쉽게 한정시킬 수 있음
- 로컬 변수는 모두 암묵적으로 현재 실행중인 스레드에 한정되어 있다고 볼 수 있음. 즉 로컬 변수는 현재 실행중인 스레드 내부의 스택에만 존재하기 때문.



```java
package net.jcip.examples;

import java.util.*;

/**
 * Animals
 * <p/>
 * Thread confinement of local primitive and reference variables
 *
 * @author Brian Goetz and Tim Peierls
 */
public class Animals {
    Ark ark;
    Species species;
    Gender gender;

    public int loadTheArk(Collection<Animal> candidates) {
        SortedSet<Animal> animals;
        int numPairs = 0;
        Animal candidate = null;

        // animals confined to method, don't let them escape!
        animals = new TreeSet<Animal>(new SpeciesGenderComparator());
        animals.addAll(candidates);
        for (Animal a : animals) {
            if (candidate == null || !candidate.isPotentialMate(a))
                candidate = a;
            else {
                ark.load(new AnimalPair(candidate, a));
                ++numPairs;
                candidate = null;
            }
        }
        return numPairs;
    }


    class Animal {
        Species species;
        Gender gender;

        public boolean isPotentialMate(Animal other) {
            return species == other.species && gender != other.gender;
        }
    }

    enum Species {
        AARDVARK, BENGAL_TIGER, CARIBOU, DINGO, ELEPHANT, FROG, GNU, HYENA,
        IGUANA, JAGUAR, KIWI, LEOPARD, MASTADON, NEWT, OCTOPUS,
        PIRANHA, QUETZAL, RHINOCEROS, SALAMANDER, THREE_TOED_SLOTH,
        UNICORN, VIPER, WEREWOLF, XANTHUS_HUMMINBIRD, YAK, ZEBRA
    }

    enum Gender {
        MALE, FEMALE
    }

    class AnimalPair {
        private final Animal one, two;

        public AnimalPair(Animal one, Animal two) {
            this.one = one;
            this.two = two;
        }
    }

    class SpeciesGenderComparator implements Comparator<Animal> {
        public int compare(Animal one, Animal two) {
            int speciesCompare = one.species.compareTo(two.species);
            return (speciesCompare != 0)
                    ? speciesCompare
                    : one.gender.compareTo(two.gender);
        }
    }

    class Ark {
        private final Set<AnimalPair> loadedAnimals = new HashSet<AnimalPair>();

        public void load(AnimalPair pair) {
            loadedAnimals.add(pair);
        }
    }
}


```

- loadTheArk() 메서드는 스택 변수에 복사해서 사용하기때문에 스레드의 스택에 안전하게 한정되어 있음
- 여기에서 TreeSet을 외부에 노출한다면 스택 한정 상태가 깨짐
- 스레드에 안전하지 않은 객체라 해도 특정 스레드 내부에서만 사용한다면 동기화 문제가 없기 때문에 안전함
- 이런 부분을 코드를 처음 작성한 개발자만 인식할 뿐 후임 개발자는 전달받지 못하는 경우가 많은데 정리해서 누구든지 알아볼 수 있도록 표시해두는것이 좋음 누군가 TreeSet을 외부에 노출하지 않도록.

###  ThreadLocal

- 스래드 내부의 값과 값을 갖고 있는 객체를 연결해 스레드 한정 기법을 적용할 수 있도록 도와주는 좀 더 형식적인 방법으로 ThreadLocal이 있음
- ThreadLocal클래스의 get 메서드를 호출하면 현재 실행중인 스레드에서 최근에 set 메서드를 호출해 저장했던 값을 가져올 수 있음

```java
package net.jcip.examples;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

/**
 * ConnectionDispenser
 * <p/>
 * Using ThreadLocal to ensure thread confinement
 *
 * @author Brian Goetz and Tim Peierls
 */
public class ConnectionDispenser {
    static String DB_URL = "jdbc:mysql://localhost/mydatabase";

    private ThreadLocal<Connection> connectionHolder
            = new ThreadLocal<Connection>() {
                public Connection initialValue() {
                    try {
                        return DriverManager.getConnection(DB_URL);
                    } catch (SQLException e) {
                        throw new RuntimeException("Unable to acquire Connection, e");
                    }
                };
            };

    public Connection getConnection() {
        return connectionHolder.get();
    }
}
```

- 위 클래스는 ThreadLocal하게 동작해서 스레드마다 새로운 Connection을 생성함
- 스레드 단위로 트랜잭션 컨텍스트를 관리하고자할때는 static으로 선언된 ThreadLocal변수에 트랜잭션 컨텍스트를 넣어두면 편리함 하지만 일반적인 전역 변수가 갖는 단점처럼 ThreadLocal을 사용할 때에도 재사용성을 크게 떨어뜨릴 수 있고 객체 간에 눈에 보이지 않는 연결 관계를 만들어 내기 쉽기 때문에 애플리케이션에 어떤 영향을 미치는지 정확하게 알고 써야함



## 불변성

- 직접적으로 객체를 동기화하지 않고도 안전하게 사용할 수 있는 방법은 불변객체를 사용하는것임
- 동시성에 대한 모든 문제는 변경 가능한 값을 동시에 사용하려 하기 때문에 발ㅇ생함
- 불변객체는 언제라도 스레드에 안전함
- 다음 조건을 만족하면 불변임
  - 생성되고 난 이후에는 객체의 상태를 변경할 수 없음
  - 내부의 모든 변수는 final로 설정 되어야함
  - 적절한 방법으로 생성돼야 함 (this 변수에 대한 참조가 외부로 유촐되지 않아야함)



```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * ThreeStooges
 * <p/>
 * Immutable class built out of mutable underlying objects,
 * demonstration of candidate for lock elision
 *
 * @author Brian Goetz and Tim Peierls
 */
@Immutable
 public final class ThreeStooges {
    private final Set<String> stooges = new HashSet<String>();

    public ThreeStooges() {
        stooges.add("Moe");
        stooges.add("Larry");
        stooges.add("Curly");
    }

    public boolean isStooge(String name) {
        return stooges.contains(name);
    }

    public String getStoogeNames() {
        List<String> stooges = new Vector<String>();
        stooges.add("Moe");
        stooges.add("Larry");
        stooges.add("Curly");
        return stooges.toString();
    }
}
```

- ThreeStooges 클래스의 구조를 보면 생성 메서드를 실행한 이후에는 stooges의 값을 변경하지 못하게함
- 객체가 불변이라는 것과 참조가 불변이라는 것은 반드시 구분해서 생각해야함 예를 들어 프로그램이 사용하는 데이터가 불변 객체에 들어있다 해도, 해당 객체를 가리키고 있는 참조 변수에 또 다른 불변 객체를 바꿔치기 하면 프로그램의 데이터가 언제든 바뀌는 셈



### final 변수

- final 키워드는 불변 객체를 생성할 떄도 도움을 줌
- final 키워드를 적절하게 사용하면 초기화 안전성을 보장하기 때문에 별다른 동기화 작업 없이도 불변 객체를 자유롭게 사용하고 공유할 수 있음
- 외부에서 반드시 사용할 일이 없는 변수는 private으로 선언하는 것처럼 나중에 변경할 일이 없다고 판단되는 변수는 final로 선언해두는 것도 좋은 방법임



### 예제: 불변 객체를 공개할 때 volatile 키워드를 사용

- 만약 여러개의 값이 단일하게 한꺼번에 행동해야 한다면 아래 클래스와 같이 여러개의 값을 한데 묶는 불변 클래스를 만들어 사용하는 방법이 좋음

```java
package net.jcip.examples;

import java.math.BigInteger;
import java.util.*;

import net.jcip.annotations.*;

/**
 * OneValueCache
 * <p/>
 * Immutable holder for caching a number and its factors
 *
 * @author Brian Goetz and Tim Peierls
 */
@Immutable
public class OneValueCache {
    private final BigInteger lastNumber;
    private final BigInteger[] lastFactors;

    public OneValueCache(BigInteger i,
                         BigInteger[] factors) {
        lastNumber = i;
        lastFactors = Arrays.copyOf(factors, factors.length);
    }

    public BigInteger[] getFactors(BigInteger i) {
        if (lastNumber == null || !lastNumber.equals(i))
            return null;
        else
            return Arrays.copyOf(lastFactors, lastFactors.length);
    }
}
```

- 서로 관련되어 있는 여러 개의 변수 값을 서로 읽거나 쓰는 과정에 경쟁 조건이 발생할 수 있는데 불변 객체에 해당하는 변수를 모두 모아두면 경쟁 조건을 방지할 수 있음

```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * VolatileCachedFactorizer
 * <p/>
 * Caching the last result using a volatile reference to an immutable holder object
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class VolatileCachedFactorizer extends GenericServlet implements Servlet {
    private volatile OneValueCache cache = new OneValueCache(null, null);

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = cache.getFactors(i);
        if (factors == null) {
            factors = factor(i);
            cache = new OneValueCache(i, factors);
        }
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[]{i};
    }
}

```

- VolatileCachedFactorizer 클래스는 OneValueCache 클래스를 사용해 입력 값과 결과를 캐시함.
- 스레드 하나가 volatile로 선언된 cache변수에 새로 생성한 OneValueCache 인스턴스를 설정하면 다른 스레드에서도 cache변수에 설정된 새로운 값을 즉시 사용할 수 있음
- 불변 + volatile변수를 사용하면 시간적으로 가시성을 확보하기 때문에 락을 사용하지 않아도 스레드에 안전함





## 안전 공개



# #4 객체 구성

## 스레드 안전한 클래스 설계

## 인스턴스 한정

## 스레드 안전성 위임d

## 스레드 안전하게 구현된 클래스에 기능 추가

## 동기화 정책 문서화 하기



# #5 구성 단위

## 동기화된 컬렉션 클래스

## 병렬 컬렉션

## 블로킹 큐와 프로듀서-컨슈머 패턴

## 블로킹 메소드, 인터럽터블 메소드

## 동기화 클래스

## 효율적이고 확장성 있는 결과 캐시 구현





# #6 작업 실행

## 스레드에서 작업 실행

## Executor 프레임웍

## 병렬로 처리할 만한 작업



# #7 중단 및 종료

## 작업 중단

## 스레드 기반 서비스 중단

## 비정상적인 스레드 종료 상황 처리

## JVM종료



# #8 스레드 풀 활용

## 작업과 실행 정책 간의 보이지 않는 연결 관계

## 스레드 풀 크기 조절

## ThreadPoolExecutor 설정

## ThreadPoolExecutor 상속

## 재귀 함수 병렬화



# #9 GUI 애플리케이션

## GUI는 왜 단일 스레드로 동작하는가?

## 짧게 실행되는 GUI 작업

## 장시간 실행되는 GUI 작업

## 데이터 공유 모델

## 다른 형태의 단일 스레드 서브 시스템



# #10 활동성을 최대로 높이기

## 데드락

## 데드락 방지 및 원인 추적

## 그 밖의 활동성 문제점



# #11 성능, 확장성

## 성능에 대해

## 암달의 법칙

## 스레드와 비용

## 락 경쟁 줄이기



## 예제: Map 객체의 성능 분석



# #12 병렬 프로그램 테스트

## 정확성 테스트

## 성능 테스트

## 성능 측정의 함정 피하기

## 보조적인 테스트 방법



# #13 명시적인 락

## Lock과 ReentrantLock

## 성능에 대한 고려 사항

## 공정성

## synchronized 또는 ReentrantLock 선택

## 읽기-쓰기 락



# #14 동기화 클래스 구현

## 상태 종속성 관리

## 조건 큐 활용

## 명시적인 조건 객체

## 동기화 클래스의 내부 구조

## AbstractQueuedSynchronizer

## java.util.concurrent 패키지의 동기화 클래스에서 AQS 활용 모습

## 

# #15 단일 연산 변수와 넌블로킹 동기화

## 락의 단점

## 병렬 연산을 위한 하드웨어적인 지원

## 단일 연산 변수 클래스

## 넌블로킹 알고리즘



# #16 자바 메모리 모델

## 자바 메모리 모델은 무엇이며, 왜 사용해야 하는가?

## 안전한 공개

## 초기화 안전성



