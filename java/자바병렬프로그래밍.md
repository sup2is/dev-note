



# 자바 병렬 프로그래밍

**소스코드**

https://jcip.net/listings/UnsafeSequence.java



# #1 개요

## 작업을 동시에 실행하는 일에 대한 간략한 역사

- 자원 활용, 공정성, 편의성 등 프로세스 개념을 만들어내게 된 것과 같은 동기를 갖고 스레드가 고안됨
- 스레드로 인해 한 프로세스 안에 여러개의 프로그램 제어 흐름이 공존할 수 있음
- 스레드는 메모리, 파일 핸들과 같이 프로세스에 할당된 자원을 공유함 하지만 각 스레드는 각기 별도의 프로그램 카운터, 스택, 지역변수를 가짐
- 프로그램을 스레드로 분리하면 멀티프로세서 시스템에서 자연스럽게 하드웨어 병렬성을 이용할 수 있음 즉 한 프로그램 내 여러 스레드를 동시에 여러 개의 cpu에 할당해 실행시킬 수 있음
- 스레드는 lightweight process라고 부르기도 함
- 운영체제의 대부분은 프로세스가 아니라 스레드를 기분 단위로 cpu 자원의 스케줄을 정함
- 스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드들은 같은 변수에 접근하고 같은 힙에 객체를 할당함 이때 공유된 과정을 적절하게 동기화하지 않으면 다른 스레드가 사용중인 변수를 순간적으로 수정해서 예상치 못한 결과를 얻을 수도 있음

## 스레드의 이점

- 스레드를 제대로만 사용하면 개발 및 유지보수 비용을 줄이고 복잡한 애플리케이션의 성능을 향상시킬 수 있음

### 멀티 프로세서 활용

- 여러개의 스레드를 사용하면 프로세서가 하나라 해도 처리속도를 높일 수 있음
- 프로세스가 여러개라도 스레드가 하나라면 자원 낭비임

### 단순한 모델링

### 단순한 비동기 이벤트 처리

### 더 빨리 반응하는 사용자 인터페이스

## 스레드 사용의 위험성

### 안전성 위해 요소

- 동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산의 순서를 예측하기 매우 어려움

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * UnsafeSequence
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
public class UnsafeSequence {
    private int value;

    /**
     * Returns a unique value.
     */
    public int getNext() {
        return value++;
    }
}
```

- 위 코드는 여러 스레드에서 실행될때 getNext()를 동시에 호출했을때 같은 값을 얻을 가능성이 있음
- 스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용 중일지도 모르는 변수를 읽거나 수정할 수도 있음 편리하지만 위험 요소이기도 함. 데이터가 예측 못한 시점에 변경될 수 있기 때문
- 스레드가 서로 간섭하지 않도록 공유된 변수에 접근하는 시점에 적절하게 조율해야함
- 위 클래스는 아래처럼 수정 가능함

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * Sequence
 *
 * @author Brian Goetz and Tim Peierls
 */

@ThreadSafe
public class Sequence {
    @GuardedBy("this") private int nextValue;

    public synchronized int getNext() {
        return nextValue++;
    }
}
```

### 

### 활동성 위험

- 동시 수행 코드를 개발할 때는 반드시 스레드 안전성 문제를 신경써야 함 반드시!
- 멀티 스레드 프로그램에서는 단일 스레드 프로그램에서 발생하지 않는 추가적인 위험에 노출됨
- deadlock, starvation, livelock 등등 활동성 장애



### 성능 위험

- 성능 문제는 형편없는 서비스 시간, 만응성, 처리율, 자원 소모, 규모에 따른 확장성 등 넓은 범위의 문제들을 포괄함
- 잘 설계된 병렬 프로그램은 스레드를 사용해서 궁극적으로 성능을 향상시킬 수 있으나 많은 스레드를 사용함으로써 메모리의 지역성이 손실되고 동기화 수단을 사용 하는 등의 성능 손실을 유발할 수 있음



## 스레드는 어디에나

- 모든 자바 프로그램은 기본적으로 스레드를 사용함 main 메서드를 실행하는 스레드, JVM에서 사용하는 스레드 등
- 개발자는 병렬성과 스레드 안전성에 대해 잘 알아야함



# #2 스레드 안전성

## 스레드 안전성이란?

## 단일 연산

## 락

## 락으로 상태 보호하기

## 활동성과 성능



# #3 객체 공유

## 가시성

## 공개와 유출

## 스레드 한정

## 불변성

## 안전 공개



# #4 객체 구성

## 스레드 안전한 클래스 설계

## 인스턴스 한정

## 스레드 안전성 위임

## 스레드 안전하게 구현된 클래스에 기능 추가

## 동기화 정책 문서화 하기



# #5 구성 단위

## 동기화된 컬렉션 클래스

## 병렬 컬렉션

## 블로킹 큐와 프로듀서-컨슈머 패턴

## 블로킹 메소드, 인터럽터블 메소드

## 동기화 클래스

## 효율적이고 확장성 있는 결과 캐시 구현





# #6 작업 실행

## 스레드에서 작업 실행

## Executor 프레임웍

## 병렬로 처리할 만한 작업



# #7 중단 및 종료

## 작업 중단

## 스레드 기반 서비스 중단

## 비정상적인 스레드 종료 상황 처리

## JVM종료



# #8 스레드 풀 활용

## 작업과 실행 정책 간의 보이지 않는 연결 관계

## 스레드 풀 크기 조절

## ThreadPoolExecutor 설정

## ThreadPoolExecutor 상속

## 재귀 함수 병렬화



# #9 GUI 애플리케이션

## GUI는 왜 단일 스레드로 동작하는가?

## 짧게 실행되는 GUI 작업

## 장시간 실행되는 GUI 작업

## 데이터 공유 모델

## 다른 형태의 단일 스레드 서브 시스템



# #10 활동성을 최대로 높이기

## 데드락

## 데드락 방지 및 원인 추적

## 그 밖의 활동성 문제점



# #11 성능, 확장성

## 성능에 대해

## 암달의 법칙

## 스레드와 비용

## 락 경쟁 줄이기

## 예제: Map 객체의 성능 분석



# #12 병렬 프로그램 테스트

## 정확성 테스트

## 성능 테스트

## 성능 측정의 함정 피하기

## 보조적인 테스트 방법



# #13 명시적인 락

## Lock과 ReentrantLock

## 성능에 대한 고려 사항

## 공정성

## synchronized 또는 ReentrantLock 선택

## 읽기-쓰기 락



# #14 동기화 클래스 구현

## 상태 종속성 관리

## 조건 큐 활용

## 명시적인 조건 객체

## 동기화 클래스의 내부 구조

## AbstractQueuedSynchronizer

## java.util.concurrent 패키지의 동기화 클래스에서 AQS 활용 모습

## 

# #15 단일 연산 변수와 넌블로킹 동기화

## 락의 단점

## 병렬 연산을 위한 하드웨어적인 지원

## 단일 연산 변수 클래스

## 넌블로킹 알고리즘



# #16 자바 메모리 모델

## 자바 메모리 모델은 무엇이며, 왜 사용해야 하는가?

## 안전한 공개

## 초기화 안전성



