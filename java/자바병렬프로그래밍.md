



# 자바 병렬 프로그래밍

**소스코드**

[https://jcip.net/listings](https://jcip.net/listings)



# #1 개요

## 작업을 동시에 실행하는 일에 대한 간략한 역사

- 자원 활용, 공정성, 편의성 등 프로세스 개념을 만들어내게 된 것과 같은 동기를 갖고 스레드가 고안됨
- 스레드로 인해 한 프로세스 안에 여러개의 프로그램 제어 흐름이 공존할 수 있음
- 스레드는 메모리, 파일 핸들과 같이 프로세스에 할당된 자원을 공유함 하지만 각 스레드는 각기 별도의 프로그램 카운터, 스택, 지역변수를 가짐
- 프로그램을 스레드로 분리하면 멀티프로세서 시스템에서 자연스럽게 하드웨어 병렬성을 이용할 수 있음 즉 한 프로그램 내 여러 스레드를 동시에 여러 개의 cpu에 할당해 실행시킬 수 있음
- 스레드는 lightweight process라고 부르기도 함
- 운영체제의 대부분은 프로세스가 아니라 스레드를 기분 단위로 cpu 자원의 스케줄을 정함
- 스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드들은 같은 변수에 접근하고 같은 힙에 객체를 할당함 이때 공유된 과정을 적절하게 동기화하지 않으면 다른 스레드가 사용중인 변수를 순간적으로 수정해서 예상치 못한 결과를 얻을 수도 있음

## 스레드의 이점

- 스레드를 제대로만 사용하면 개발 및 유지보수 비용을 줄이고 복잡한 애플리케이션의 성능을 향상시킬 수 있음

### 멀티 프로세서 활용

- 여러개의 스레드를 사용하면 프로세서가 하나라 해도 처리속도를 높일 수 있음
- 프로세스가 여러개라도 스레드가 하나라면 자원 낭비임

### 단순한 모델링

### 단순한 비동기 이벤트 처리

### 더 빨리 반응하는 사용자 인터페이스

## 스레드 사용의 위험성

### 안전성 위해 요소

- 동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산의 순서를 예측하기 매우 어려움

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * UnsafeSequence
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
public class UnsafeSequence {
    private int value;

    /**
     * Returns a unique value.
     */
    public int getNext() {
        return value++;
    }
}
```

- 위 코드는 여러 스레드에서 실행될때 getNext()를 동시에 호출했을때 같은 값을 얻을 가능성이 있음
- 스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용 중일지도 모르는 변수를 읽거나 수정할 수도 있음 편리하지만 위험 요소이기도 함. 데이터가 예측 못한 시점에 변경될 수 있기 때문
- 스레드가 서로 간섭하지 않도록 공유된 변수에 접근하는 시점에 적절하게 조율해야함
- 위 클래스는 아래처럼 수정 가능함

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * Sequence
 *
 * @author Brian Goetz and Tim Peierls
 */

@ThreadSafe
public class Sequence {
    @GuardedBy("this") private int nextValue;

    public synchronized int getNext() {
        return nextValue++;
    }
}
```

### 

### 활동성 위험

- 동시 수행 코드를 개발할 때는 반드시 스레드 안전성 문제를 신경써야 함 반드시!
- 멀티 스레드 프로그램에서는 단일 스레드 프로그램에서 발생하지 않는 추가적인 위험에 노출됨
- deadlock, starvation, livelock 등등 활동성 장애



### 성능 위험

- 성능 문제는 형편없는 서비스 시간, 만응성, 처리율, 자원 소모, 규모에 따른 확장성 등 넓은 범위의 문제들을 포괄함
- 잘 설계된 병렬 프로그램은 스레드를 사용해서 궁극적으로 성능을 향상시킬 수 있으나 많은 스레드를 사용함으로써 메모리의 지역성이 손실되고 동기화 수단을 사용 하는 등의 성능 손실을 유발할 수 있음



## 스레드는 어디에나

- 모든 자바 프로그램은 기본적으로 스레드를 사용함 main 메서드를 실행하는 스레드, JVM에서 사용하는 스레드 등
- 개발자는 병렬성과 스레드 안전성에 대해 잘 알아야함



# #2 스레드 안전성public class PrivateLock

- 스레드에 안전한 코드를 작성하는 것은 근본적으로는 상태, 특히 공유되고 변경할 수 있는 상태에 대한 접근을 관리하는 것 ex static,  인스턴스 변수
- 스레드 안전성이란 데이터에 제어 없이 동시 접근을 막으려는 의미
- 객체가 스레드에 안전해야 하느냐는 해당 객체에 여러 스레드가 접근할지의 여부에 달렸음
- 객체를 스레드에 안전하게 만드려면 동기화를 통해 변경할 수 있는 상태에 접근하는 과정을 조율해야 함
- 스레드가 하나 이상 상태 변수에 접근하고 그 중 하나라도 변수에 값을 쓰면, 해당 변수에 접근할 때 관련된 모든 스레드가 동기화를 통해 조율되어야함
- 자바에서는 synchronized 키워드로 배타적인 락을 통해 보호 기능을 제공함
- volatile변수, 명시적 락, 단일 연산 변수 atomic variable을 사용하는 경우에도 동기화라는 용어를 사용함
- 동시성 관련된 문제를 해결하는 세가지 방법
  - 해당 상태 변수를 스레드 간에 공유하지 않도록 함
  - 해당 상태 변수를 변경할 수 없도록 만듬
  - 해당 상태 변수에 접근할 땐 언제나 동기화를 사용함
- 클래스 설계시점에 스레드 안전하게 설계하는것이 훨씬 쉬움
- 프로그램 상태를 잘 캡슐화할수록 스레드 안전하게 만들기 쉽고 유지보수도 쉬움
- 스레드 안전한 클래스를 설계할 땐, 바람직한 객체 지향 기법이 왕도. 캡슐화와 불변객체를 잘활용하고 불변 조건을 명확하게 기술해야함

## 스레드 안전성이란?

- 여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케줄하든 어띠에 끼워넣든, 호출하는 쪽에서추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고함
- 스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화함



### 예제: 상태없는 서블릿

```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * StatelessFactorizer
 *
 * A stateless servlet
 * 
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class StatelessFactorizer extends GenericServlet implements Servlet {

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[] { i };
    }
}
```

- 위와 같이 상태가 없는 객체는 항상 스레드에 안전함
- 서블릿 요청 간에 뭔가를 기억할 필요가 있을 때에야 스레드 안전성이 문제가 됨



## 단일 연산



```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * UnsafeCountingFactorizer
 *
 * Servlet that counts requests without the necessary synchronization
 *
 * @author Brian Goetz and Tim Peierls
 */
@NotThreadSafe
public class UnsafeCountingFactorizer extends GenericServlet implements Servlet {
    private long count = 0;

    public long getCount() {
        return count;
    }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        ++count;
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse res, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[] { i };
    }
}
```

- ++count 은 3개의 별도의 3개의 동작을 한줄로 표현한 것
- 위 클래스는 스레드에 안전하지 않음
- 병렬 프로그램의 입장에서 타이밍이 안좋을 때 결과가 잘못될 가능성은 race condition(경쟁 조건)이라는 용어를 사용함



### 경쟁 조건

- race condition이 발생하는 클래스는 결과를 신뢰할 수 없음
- 어떤 사실을 확인하고 그 관찰에 기반해 행동을 하는 류의 경쟁 조건을 점검 후 행동이라고함 해당 관찰은 관찰한 시각과 행동한 시각 사이에 더 이상 유효하지 않게 됐을 수 있음



### 예제: 늦은 초기화 시 경쟁 조건

- 점검 후 행동하는 흔한 프로그래밍 패턴으로 lazy initialization이 있음

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * LazyInitRace
 *
 * Race condition in lazy initialization
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
public class LazyInitRace {
    private ExpensiveObject instance = null;

    public ExpensiveObject getInstance() {
        if (instance == null)
            instance = new ExpensiveObject();
        return instance;
    }
}

class ExpensiveObject { }


```

- 위 클래스는 두개의 스레드가 동시에 `if (instance == null)` 에서 null을 받았을때 서로 다른 인스턴스를 생성할 수 있음

### 

### 복합 동작

- 경쟁 조건을 피하려면 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 막을 방법이 있어야하고 이런 방법으로 보호해두면 특정 스레드에서 변수를 수정할 때 다른 스레드는 수정 도중이 아닌 수정 이전이나 이후에만 상태를 읽거나 변경을 가할 수 있음

```java
package net.jcip.examples;

import java.math.BigInteger;
import java.util.concurrent.atomic.*;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * CountingFactorizer
 *
 * Servlet that counts requests using AtomicLong
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class CountingFactorizer extends GenericServlet implements Servlet {
    private final AtomicLong count = new AtomicLong(0);

    public long getCount() { return count.get(); }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        count.incrementAndGet();
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse res, BigInteger[] factors) {}
    BigInteger extractFromRequest(ServletRequest req) {return null; }
    BigInteger[] factor(BigInteger i) { return null; }
}
```

- `UnsafeCountingFactorizer`을 `AtomicLong`을 사용하서 스레드 세이프하게 작성한 클래스
- java.util.concurrent.atomic 패키지에는 숫자나 객체 참조 값에 대해 상태를 단일 연산으로 변경할 수 있도록 단일 연산 변수 클래스가 준비돼 있음
- 상태 없는 클래스에 상태 요소를 하나 추가할 때 스레드 안전한 객체 하나로 모든 상태를 관리한다면 해당 클래스는 스레드에 안전함
- 가능하면 클래스 상태를 관리하기 위해 AtomicLong처럼 스레드에 안전하게 이미 만들어져 있는 객체를 사용하는 편이 좋음. 스레드 안전하지 않은 상태 변수를 선언해두고 사용하는 것보다 이미 스레드 안전하게 만들어진 클래스가 가질 수 있는 가능한 상태의 변화를 파악하는 편이 훨씬 쉽고, 스레드 안전성을 더 쉽게 유지하고 검증할 수 있음



## 락



```java
package net.jcip.examples;

import java.math.BigInteger;
import java.util.concurrent.atomic.*;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * UnsafeCachingFactorizer
 *
 * Servlet that attempts to cache its last result without adequate atomicity
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
public class UnsafeCachingFactorizer extends GenericServlet implements Servlet {
    private final AtomicReference<BigInteger> lastNumber
            = new AtomicReference<BigInteger>();
    private final AtomicReference<BigInteger[]> lastFactors
            = new AtomicReference<BigInteger[]>();

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        if (i.equals(lastNumber.get()))
            encodeIntoResponse(resp, lastFactors.get());
        else {
            BigInteger[] factors = factor(i);
            lastNumber.set(i);
            lastFactors.set(factors);
            encodeIntoResponse(resp, factors);
        }
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[]{i};
    }
}

```

- 위 클래스는 서로 다른 클라이언트가 연이어 같은 숫자를 인수분해하길 원할 경우 가장 최근 계산결과를 캐시해둬서 리턴하는 향상된 서블릿 클래스임 but 잘 동작하는 클래스가 아님
- 스레드 안전성의 정의에 따르면 여려 스레드에서 수행되는 작업의 타이밍이나 스케줄링에 따른 교차 실행과 관계 없이 불변조건이 유지되어야 스레드에 안전함
- 여러 개의 변수가 하나의 불변 조건을 구성하고 있고 이 작업들이 단일 연산 작업 내에서 변경되지 않는다면 문제가 생길 수 있음
- 상태를 일관성 있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야함

### 암묵적인 락

- 자바에는 단일 연산 특성을 보장하기 위해 synchronized라는 구문으로 사용할 수 있는 락을 제공함
- synchronized구문은 락으로 사용될 객체의 참조 값과 해당 락으로 보호하려는 코드 블록으로 구성됨
- synchronized는 메서드가 포함된 클래스의 인스턴스 락으로 사용하는 synchronized블록을 간략하게 표현한 것
- static으로 선언된 synchronized메서드는 해당 Class 객체를 락으로 사용
- 모든 자바 객체는 락으로 사용할 수 있음
- 자바에 내장된 락을 암묵적인 락 혹은 모니터 락이라고 함 락은 스레드가 synchronized블록에 들어가기 전에 자동으로 확보되고 정상적으로든 예외가 발생해서든 해당 블록을 벗어날 때 자동으로 해제됨
- 해당 락으로 보호된 synchronized 블록이나 메서드에 들어가야만 암묵적인 락을 확보할 수 있음
- 자바에서 암묵적인 락은 뮤텍스로 동작함 즉 한번에 한 스레드만 특정 락을 소유할 수 있음
- 같은 락으로 보호되는 synchronized 서로 다른 블력 역시 서로 단일 연산으로 실행됨
- 동시성 맥락에서 단일 연산의 특성은 트랜잭션 프로그램에서 말하는 단일 연산 특성과 같은 의미임
- 한 스레드가 synchronized 블록을 실행중이라면 같은 락으로 보호되는 synchronized블록에 다른 스레드가 들어와 있을 수 없음



```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * SynchronizedFactorizer
 *
 * Servlet that caches last result, but with unnacceptably poor concurrency
 *
 * @author Brian Goetz and Tim Peierls
 */

@ThreadSafe
public class SynchronizedFactorizer extends GenericServlet implements Servlet {
    @GuardedBy("this") private BigInteger lastNumber;
    @GuardedBy("this") private BigInteger[] lastFactors;

    public synchronized void service(ServletRequest req,
                                     ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        if (i.equals(lastNumber))
            encodeIntoResponse(resp, lastFactors);
        else {
            BigInteger[] factors = factor(i);
            lastNumber = i;
            lastFactors = factors;
            encodeIntoResponse(resp, factors);
        }
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[] { i };
    }
}

```

- 위는 UnsafeCachingFactorizer를 극단적으로 변경한 케이스, 성능이 엄청나게 떨어짐



### 재진입성

- 스레드가 다른 스레드가 가진 락을 요청하면 해당 스레드는 대기 상태에 들어감 하지만 암묵적인 락은 재진입 가능하기 때문에 특정 스레드가 자기가 이미 획득한 락을 다시 확보할 수 있음
- 재진입성은 확보 요청 단위가 아닌 스레드 단위로 락을 얻는다는 것을 의미함
- JVM이 락에 대한 소유 스레드를 기록하고 확소 횟수를 1로 지정, 계속 증가하다가 0이되면 해당 락이 해제
- 재진입 가능한 락이 없다면 중첩된 락은 데드락에 빠짐



## 락으로 상태 보호하기

- 락은 자신이 보호하는 코드 경로에 여러 스레드가 순차적으로 접근하도록 하기 때문에 공유된 상태에 배타적으로 접근할 수 있도록 보장하는 규칙을 만들 때 유용함
- 여러 스레드에서 접근할 수 있고 변경 가능한 모든 변수를 대상으로 해당 변수에 접근할 때는 항상 동일한 락을 먼저 확보한 상태여야 함. 이 경우 해당 변수는 확보된 락에 의해 보호된다고 말함
- 모든 변경할 수 있는 공유 변수는 정확하게 단 하나의 락으로 보호해야 함. 유지보수 하는 사람이 알 수 있게 어느락으로 보호하고 있는지를 명확하게 표시할 것
- 락을 활용함에 있어 일반적인 사용 예는 먼저 모든 변경 가능한 변수를 객체 안에 캡슐화하고 해당 객체의 암묵적인 락을 사용해 캡슐화한 변수에 접근하는 모든 코드 경로를 동기화함으로써 보호하는 방법 <= 이패턴은 Vector를 비롯해 여러 클래스에서 사용하는 방법
- 여러 변수에 대한 불변조건이 있으면 해당 변수들은 모두 같은 락으로 보호해야 함
- 무차별적인 synchronized 사용은 동기화가 너무 과도할 수 있음



## 활동성과 성능

- 단순하고 큰 단위로 동기화에 접근하면 안전성을 확보할 수 있지만 치러야 할 대가가 너무 큼
- synchronized블록의 범위를 줄이면 스레드 안정성을 유지하면서 쉽게 동시성을 향상시킬 수 있음 이 때 synchronized 블록의 범위를 너무 작게 줄이지 않도록 조심해야함 => 필요한 부분은 반드시 단일 연산으로 처리해야함 => 하나의 락으로

```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * CachedFactorizer
 * <p/>
 * Servlet that caches its last request and result
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class CachedFactorizer extends GenericServlet implements Servlet {
    @GuardedBy("this") private BigInteger lastNumber;
    @GuardedBy("this") private BigInteger[] lastFactors;
    @GuardedBy("this") private long hits;
    @GuardedBy("this") private long cacheHits;

    public synchronized long getHits() {
        return hits;
    }

    public synchronized double getCacheHitRatio() {
        return (double) cacheHits / (double) hits;
    }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = null;
        synchronized (this) {
            ++hits;
            if (i.equals(lastNumber)) {
                ++cacheHits;
                factors = lastFactors.clone();
            }
        }
        if (factors == null) {
            factors = factor(i);
            synchronized (this) {
                lastNumber = i;
                lastFactors = factors.clone();
            }
        }
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[]{i};
    }
}
```

- 두 변수 모두 공유상태에 속하기 떄문에 접근할때도 항상 동기화 구문을 사용해야함
- synchronized밖이라면 스택 상의 변수만 사용하기 떄문에 동기화가 필요 없음
- 이미 동기화처리 되어있다면 AtomicX를 사용하지 않는것이 좋음 서로 다른 두가지 동기화 수단은 혼동만 주고 성능상에 이점이 없음
- 락을 얻는 작업은 어느정도 비용이 있으므로 synchronized블록을 너무 잘게 쪼개지 않는것이 중요함
- 동기화 정책을 구현할 때는 성능을 위해 조급하게 단순성을 희생하고픈 유혹을 버려야함 안전성이 가장 중요
- 락을 사용할 땐 블록 안의 코드가 무엇을 하는지, 수행하는데 얼마나 걸릴지를 파악해야함 활동성이나 성능 문제를 야기할 수 있음
- 복잡하고 오래 걸리는 계싼 작업, 네트웍 작업, 사용자 입출력 작업과 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 한 락을 잡지 말 것!





# #3 객체 공유

- 병렬 프로그램 작성은 상태가 바뀔 수 있는 내용을 프로그램 내부의 여러 부분에서 어떻게 잘 공유해 사용하도록 관리할 것인지에 대한 문제

## 가시성

- 일반적으로 특정 변수의 값을 가져갈 때 다른 스레드가 작성한 값을 가져갈 수 있다는 보장이 없음 메모리상의 공유된 변수를 여러 스레드에서 서로 사용할 수 있게 하려면 반드시 동기화 기능을 구현해야함

```java
package net.jcip.examples;

/**
 * NoVisibility
 * <p/>
 * Sharing variables without synchronization
 *
 * @author Brian Goetz and Tim Peierls
 */

public class NoVisibility {
    private static boolean ready;
    private static int number;

    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready)
                Thread.yield();
            System.out.println(number);
        }
    }

    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```

- 메인 스레드와 ReaderThread는 변수를 공유하지만 동기화되지 않았음. 절대 사용하지 말 것!
- 위 코드는 어떤 스레드가 먼저 공유 변수에 접근할지 모르는 현상이 있는데 재배치 현상이라고함
- 재배치 현상은 특정 메서드의 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에 기인하는 문제. 단일 스레드로 동작할 때는 차이점을 전혀 알아챌 수 없지만 여러 스레드가 동시에 동작하는 경우에는 확연하게 나타날 수 있음
- 동기화되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 ''반드시 이런 순서로 동작할 것이다'' 라고 단정할 수 없음
- 병렬프로그램에서 동기화가 완벽하게 맞춰지지 않았다면 정상적으로 작동할 것인지를 추측하기가 매우 어려움
- 여러 스레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용해야함



### 스테일 데이터

- 변수를 사용하는 모든 경우에 동기화를 시켜주지 않으면 해당 변수에 대한 최신 값이 아닌 다른 값을 사용하게 되는 경우가 발생할 수 있음

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * MutableInteger
 * <p/>
 * Non-thread-safe mutable integer holder
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
public class MutableInteger {
    private int value;

    public int get() {
        return value;
    }

    public void set(int value) {
        this.value = value;
    }
}
```

- 동기화처리되지 않아서 스레드에 안전하지 않음

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * SynchronizedInteger
 * <p/>
 * Thread-safe mutable integer holder
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class SynchronizedInteger {
    @GuardedBy("this") private int value;

    public synchronized int get() {
        return value;
    }

    public synchronized void set(int value) {
        this.value = value;
    }
}
```

- 동기화처리되어서 스레드에 안전함



### 단일하지 않은 64비트 연산 

- 동기화되지 않은 상태에서 특정 스레드가 변수의 값을 읽어려 할때는 stale한 값을 읽어갈 가능성이 있긴 하지만 전혀 엉뚱한 값을 가져가는 것은 아니고 바로 이전 스레드에서 설정한 값을 가져가게됨
- 하지만 64비트를 사용하는 숫자형 double, long 에 volatile 키워드를 사용하지 않은 경우엔 이상한 값마저 생길 가능성이 있음



### 락과 가시성

- 값을 변경할 수 있는 변수를 여러 개의 스레드에서 동시에 사용한다면, 바로 이전 스레드에서 사용했던 변수의 값을 오류 없이 정상적으로 다음 스레드가 사용할 수 있도록 synchronized를 사용해야함
- 여러 스레드에서 사용하는 변수를 적당한 락으로 막아주지 않으면 stale 상태에 쉽게 빠질 수 있음
- 락은 상호 배제 뿐만 아니라 정상적인 메모리 가시성을 확보하기 위해서도 사용함. 변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상적인 값으로 활용하려면 동일한 락을 사용해 모두 동기화시켜야함



### volatile 변수

- 자바에서는 volatile변수로 좀더 약한 동기화 기능을 제공함
- volatile변수를 사용하면 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해줌
- volatile변수를 사용하면 컴파일러와 런타임 모두 '이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치해서는 안된다' 라고 이해함 따라서 캐시되지 않고 항상 다른 스레드가 보관해둔 최신의 값을 읽어갈 수 있음
- 동기화하고자하는 부분을 명확하게 볼 수 있고, 구현하기가 훨씬 간단한 경우에만 volatile 변수를 활용할 것. 반대로 작은 부분이라도 가시성을 추론해봐야 하는 경우에는 volatile 변수를 사용하지 않는 것이 좋음. volatile 변수를 사용하는 적절한 경우는, 일반적으로 변수에 보관된 클래스의 상태에 대한 가시성을 확보하거나 중요한 이벤트가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우 등이 해당됨
- 락을 사용하면 가시성과 연산의 단일성을 모두 보장받을 수 있지만 volatile변수는 연산의 단일성을 보장하지 못하고 가시성만 보장함
- volatile변수를 쓰면 좋을때
  - 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재할 경우
  - 해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어있지 않은 경우
  - 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없는 경우



## 공개와 유출

- 특정 객체를 현재 코드의 스코프 범위 밖에서 사용할 수 있도록 만들면 공개되었다고 함
- 만약 클래스 내부 상태 변수를 외부에 공개해야한다면 객체 캡슐화 작업이 물거품이되거나 내부 데이터의 안전성을 해칠 수 있음 따라서 객체가 안정적이지 않은 상태에서 공개하면 스레드 안전성에 문제가 생길 수 있음
- 의도적으로 공개시키지 안았지만 외부에서 사용할 수 있게 공개된 경우를 유출 상태라고함

```java
package net.jcip.examples;

import java.util.*;

/**
 * Secrets
 *
 * Publishing an object
 *
 * @author Brian Goetz and Tim Peierls
 */
class Secrets {
    public static Set<Secret> knownSecrets;

    public void initialize() {
        knownSecrets = new HashSet<Secret>();
    }
}


class Secret {
}
```

- 위에 knownSecrets은 스코프에 관계 없이 완전히 공개됨

```java
package net.jcip.examples;

/**
 * UnsafeStates
 * <p/>
 * Allowing internal mutable state to escape
 *
 * @author Brian Goetz and Tim Peierls
 */
class UnsafeStates {
    private String[] states = new String[]{
        "AK", "AL" /*...*/
    };

    public String[] getStates() {
        return states;
    }
}
```

- 위 클래스는 getStates() 메서드를 사용해서 private 멤버변수를 직접변경할 수 있음. states 변수는 유출상태임
- 정리하자면 객체를 공개했을 때 그 객체 내부의 private이 아닌 변수나 메서드를 통해 불러올 수 있는 모든 객체는 함께 공개된다는 점을 알아둘 것
- 항상 누군가는 의도했건 의도하지 않았건 공개된 객체를 잘못 사용할 가능성에 노출이되기때문에 어떤 객체건 객체 내부에서 사용하는 값이 적절하게 캡슐화되도록 해야함

```java
package net.jcip.examples;

/**
 * ThisEscape
 * <p/>
 * Implicitly allowing the this reference to escape
 *
 * @author Brian Goetz and Tim Peierls
 */
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
        });
    }

    void doSomething(Event e) {
    }


    interface EventSource {
        void registerListener(EventListener e);
    }

    interface EventListener {
        void onEvent(Event e);
    }

    interface Event {
    }
}

```

-  위와 같은 코드는 EventListener 클래스를 포함하고 있는 ThisEscape 클래스도 함께 외부에 공개됨 안좋은 방법!



### 생성 메소드 안전성

- 일반적으로 생성 메서드가 완전히 종료하고 난 이후가 되어야 객체의 상태가 개발자가 예상한 상태로 초기화되기 때문에 생성 메서드가 실행되는 도중에 해당 객체를 외부에 공개해야 한다면 정상적이지 않은 상태의 객체를 외부에서 불러 사용할 가능성이 있음
- 생성 메서드를 실행하는 도중에는 this 변수가 외부에 유출되지 않도록 해야함 <= 먼말인지 이해가 잘 안됨
- 생성 메서드에서 this 변수를 유출시키는 가장 흔한 오류는 생성 메서드에서 스레드를 새로 만들어 시작시키는 일.

```java
package net.jcip.examples;

/**
 * SafeListener
 * <p/>
 * Using a factory method to prevent the this reference from escaping during construction
 *
 * @author Brian Goetz and Tim Peierls
 */
public class SafeListener {
    private final EventListener listener;

    private SafeListener() {
        listener = new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
        };
    }

    public static SafeListener newInstance(EventSource source) {
        SafeListener safe = new SafeListener();
        source.registerListener(safe.listener);
        return safe;
    }

    void doSomething(Event e) {
    }


    interface EventSource {
        void registerListener(EventListener e);
    }

    interface EventListener {
        void onEvent(Event e);
    }

    interface Event {
    }
}


```

- 위와 같이 사용하면 생성 메서드에서 this 변수가 외부로 유촐되지 않도록 팩토리 메서드를 사용할 수 있음



## 스레드 한정

- 변경 가능한 객체를 공유해 사용하는 경우에는 항상 동기화시켜야함
- 만약 싱글 스레드에서만 사용한다고 확신할 수 있다면 해당 객체는 따로 동기화할 필요가 없음
- 이처럼 객체를 사용하는 스레드를 한정하는 방법으로 스레드 안전성을 확보할 수 있음. 객체 인스턴스를 특정 스레드에 한정시켜두면 해당하는 객체가 아니라 해도 자동으로 스레드 안전성을 확보하게 됨
- 언어적인 차원에서 특정 변수를 대상으로 락을 걸 수 있는 기능을 제공하지 않은 것처럼, 임의의 객체를 특정 스레드에 한정시키는 기능도 제공하지 않음. 스레드 한정 기법은 프로그램을 처음 설계하는 과정부터 함께 다뤄야 하며, 프로그램을 구현하는 과정 내내 한정 기법을 계속해서 적용해야 함

### 스레드 한정 - 주먹구구식

- 특정 모듈을 단일 스레드로 동작하도록 구현하면 데드락을 미연에 방지할 수 있는 장점이 있음 대부분의 gui 프로그램은 단일 스레드로 동작하도록 구현된 큰 이유.

### 스택 한정

- 스택 한정 기법은 특정 객체를 로컬 변수를 통해서만 사용할 수 있는 특별한 경우의 스레드 한정 기법이라고 할 수 있음 
- 변수를 클래스 내부에 숨겨두면 변경 상태를 관리하기가 쉬움, 또한 클래스 내부에 숨겨둔 변수는 특정 스레드에 쉽게 한정시킬 수 있음
- 로컬 변수는 모두 암묵적으로 현재 실행중인 스레드에 한정되어 있다고 볼 수 있음. 즉 로컬 변수는 현재 실행중인 스레드 내부의 스택에만 존재하기 때문.



```java
package net.jcip.examples;

import java.util.*;

/**
 * Animals
 * <p/>
 * Thread confinement of local primitive and reference variables
 *
 * @author Brian Goetz and Tim Peierls
 */
public class Animals {
    Ark ark;
    Species species;
    Gender gender;

    public int loadTheArk(Collection<Animal> candidates) {
        SortedSet<Animal> animals;
        int numPairs = 0;
        Animal candidate = null;

        // animals confined to method, don't let them escape!
        animals = new TreeSet<Animal>(new SpeciesGenderComparator());
        animals.addAll(candidates);
        for (Animal a : animals) {
            if (candidate == null || !candidate.isPotentialMate(a))
                candidate = a;
            else {
                ark.load(new AnimalPair(candidate, a));
                ++numPairs;
                candidate = null;
            }
        }
        return numPairs;
    }


    class Animal {
        Species species;
        Gender gender;

        public boolean isPotentialMate(Animal other) {
            return species == other.species && gender != other.gender;
        }
    }

    enum Species {
        AARDVARK, BENGAL_TIGER, CARIBOU, DINGO, ELEPHANT, FROG, GNU, HYENA,
        IGUANA, JAGUAR, KIWI, LEOPARD, MASTADON, NEWT, OCTOPUS,
        PIRANHA, QUETZAL, RHINOCEROS, SALAMANDER, THREE_TOED_SLOTH,
        UNICORN, VIPER, WEREWOLF, XANTHUS_HUMMINBIRD, YAK, ZEBRA
    }

    enum Gender {
        MALE, FEMALE
    }

    class AnimalPair {
        private final Animal one, two;

        public AnimalPair(Animal one, Animal two) {
            this.one = one;
            this.two = two;
        }
    }

    class SpeciesGenderComparator implements Comparator<Animal> {
        public int compare(Animal one, Animal two) {
            int speciesCompare = one.species.compareTo(two.species);
            return (speciesCompare != 0)
                    ? speciesCompare
                    : one.gender.compareTo(two.gender);
        }
    }

    class Ark {
        private final Set<AnimalPair> loadedAnimals = new HashSet<AnimalPair>();

        public void load(AnimalPair pair) {
            loadedAnimals.add(pair);
        }
    }
}


```

- loadTheArk() 메서드는 스택 변수에 복사해서 사용하기때문에 스레드의 스택에 안전하게 한정되어 있음
- 여기에서 TreeSet을 외부에 노출한다면 스택 한정 상태가 깨짐
- 스레드에 안전하지 않은 객체라 해도 특정 스레드 내부에서만 사용한다면 동기화 문제가 없기 때문에 안전함
- 이런 부분을 코드를 처음 작성한 개발자만 인식할 뿐 후임 개발자는 전달받지 못하는 경우가 많은데 정리해서 누구든지 알아볼 수 있도록 표시해두는것이 좋음 누군가 TreeSet을 외부에 노출하지 않도록.

###  ThreadLocal

- 스래드 내부의 값과 값을 갖고 있는 객체를 연결해 스레드 한정 기법을 적용할 수 있도록 도와주는 좀 더 형식적인 방법으로 ThreadLocal이 있음
- ThreadLocal클래스의 get 메서드를 호출하면 현재 실행중인 스레드에서 최근에 set 메서드를 호출해 저장했던 값을 가져올 수 있음

```java
package net.jcip.examples;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

/**
 * ConnectionDispenser
 * <p/>
 * Using ThreadLocal to ensure thread confinement
 *
 * @author Brian Goetz and Tim Peierls
 */
public class ConnectionDispenser {
    static String DB_URL = "jdbc:mysql://localhost/mydatabase";

    private ThreadLocal<Connection> connectionHolder
            = new ThreadLocal<Connection>() {
                public Connection initialValue() {
                    try {
                        return DriverManager.getConnection(DB_URL);
                    } catch (SQLException e) {
                        throw new RuntimeException("Unable to acquire Connection, e");
                    }
                };
            };

    public Connection getConnection() {
        return connectionHolder.get();
    }
}
```

- 위 클래스는 ThreadLocal하게 동작해서 스레드마다 새로운 Connection을 생성함
- 스레드 단위로 트랜잭션 컨텍스트를 관리하고자할때는 static으로 선언된 ThreadLocal변수에 트랜잭션 컨텍스트를 넣어두면 편리함 하지만 일반적인 전역 변수가 갖는 단점처럼 ThreadLocal을 사용할 때에도 재사용성을 크게 떨어뜨릴 수 있고 객체 간에 눈에 보이지 않는 연결 관계를 만들어 내기 쉽기 때문에 애플리케이션에 어떤 영향을 미치는지 정확하게 알고 써야함



## 불변성

- 직접적으로 객체를 동기화하지 않고도 안전하게 사용할 수 있는 방법은 불변객체를 사용하는것임
- 동시성에 대한 모든 문제는 변경 가능한 값을 동시에 사용하려 하기 때문에 발ㅇ생함
- 불변객체는 언제라도 스레드에 안전함
- 다음 조건을 만족하면 불변임
  - 생성되고 난 이후에는 객체의 상태를 변경할 수 없음
  - 내부의 모든 변수는 final로 설정 되어야함
  - 적절한 방법으로 생성돼야 함 (this 변수에 대한 참조가 외부로 유촐되지 않아야함)



```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * ThreeStooges
 * <p/>
 * Immutable class built out of mutable underlying objects,
 * demonstration of candidate for lock elision
 *
 * @author Brian Goetz and Tim Peierls
 */
@Immutable
 public final class ThreeStooges {
    private final Set<String> stooges = new HashSet<String>();

    public ThreeStooges() {
        stooges.add("Moe");
        stooges.add("Larry");
        stooges.add("Curly");
    }

    public boolean isStooge(String name) {
        return stooges.contains(name);
    }

    public String getStoogeNames() {
        List<String> stooges = new Vector<String>();
        stooges.add("Moe");
        stooges.add("Larry");
        stooges.add("Curly");
        return stooges.toString();
    }
}
```

- ThreeStooges 클래스의 구조를 보면 생성 메서드를 실행한 이후에는 stooges의 값을 변경하지 못하게함
- 객체가 불변이라는 것과 참조가 불변이라는 것은 반드시 구분해서 생각해야함 예를 들어 프로그램이 사용하는 데이터가 불변 객체에 들어있다 해도, 해당 객체를 가리키고 있는 참조 변수에 또 다른 불변 객체를 바꿔치기 하면 프로그램의 데이터가 언제든 바뀌는 셈



### final 변수

- final 키워드는 불변 객체를 생성할 떄도 도움을 줌
- final 키워드를 적절하게 사용하면 초기화 안전성을 보장하기 때문에 별다른 동기화 작업 없이도 불변 객체를 자유롭게 사용하고 공유할 수 있음
- 외부에서 반드시 사용할 일이 없는 변수는 private으로 선언하는 것처럼 나중에 변경할 일이 없다고 판단되는 변수는 final로 선언해두는 것도 좋은 방법임



### 예제: 불변 객체를 공개할 때 volatile 키워드를 사용

- 만약 여러개의 값이 단일하게 한꺼번에 행동해야 한다면 아래 클래스와 같이 여러개의 값을 한데 묶는 불변 클래스를 만들어 사용하는 방법이 좋음

```java
package net.jcip.examples;

import java.math.BigInteger;
import java.util.*;

import net.jcip.annotations.*;

/**
 * OneValueCache
 * <p/>
 * Immutable holder for caching a number and its factors
 *
 * @author Brian Goetz and Tim Peierls
 */
@Immutable
public class OneValueCache {
    private final BigInteger lastNumber;
    private final BigInteger[] lastFactors;

    public OneValueCache(BigInteger i,
                         BigInteger[] factors) {
        lastNumber = i;
        lastFactors = Arrays.copyOf(factors, factors.length);
    }

    public BigInteger[] getFactors(BigInteger i) {
        if (lastNumber == null || !lastNumber.equals(i))
            return null;
        else
            return Arrays.copyOf(lastFactors, lastFactors.length);
    }
}
```

- 서로 관련되어 있는 여러 개의 변수 값을 서로 읽거나 쓰는 과정에 경쟁 조건이 발생할 수 있는데 불변 객체에 해당하는 변수를 모두 모아두면 경쟁 조건을 방지할 수 있음

```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * VolatileCachedFactorizer
 * <p/>
 * Caching the last result using a volatile reference to an immutable holder object
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class VolatileCachedFactorizer extends GenericServlet implements Servlet {
    private volatile OneValueCache cache = new OneValueCache(null, null);

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = cache.getFactors(i);
        if (factors == null) {
            factors = factor(i);
            cache = new OneValueCache(i, factors);
        }
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[]{i};
    }
}

```

- VolatileCachedFactorizer 클래스는 OneValueCache 클래스를 사용해 입력 값과 결과를 캐시함.
- 스레드 하나가 volatile로 선언된 cache변수에 새로 생성한 OneValueCache 인스턴스를 설정하면 다른 스레드에서도 cache변수에 설정된 새로운 값을 즉시 사용할 수 있음
- 불변 + volatile변수를 사용하면 시간적으로 가시성을 확보하기 때문에 락을 사용하지 않아도 스레드에 안전함





## 안전 공개

- 객체에 대한 참조를 public 변수에 넣어 공개하는 것은 객체를 공개하는 그다지 안전한 방법이 아님

```java
package net.jcip.examples;

/**
 * StuffIntoPublic
 * <p/>
 * Unsafe publication
 *
 * @author Brian Goetz and Tim Peierls
 */
public class StuffIntoPublic {
    public Holder holder;

    public void initialize() {
        holder = new Holde(42);
    }
}
```

- 위와 같은 단순한 방법으로 객체를 외부에 공개하면 생성 메서드가 채 끝나기도 전에 공개된 객체를 다른 스레드가 사용할 수 있음

### 적절하지 않은 공개 방법: 정상적인 객체도 문제를 일으킨다.

```java
package net.jcip.examples;

/**
 * Holder
 * <p/>
 * Class at risk of failure if not properly published
 *
 * @author Brian Goetz and Tim Peierls
 */
public class Holder {
    private int n;

    public Holder(int n) {
        this.n = n;
    }

    public void assertSanity() {
        if (n != n)
            throw new AssertionError("This statement is false.");
    }
}
```

- 위와 같이 올바르게 공개하지 않으면 문제가 생길 수 있음
- Holder 객체를 다른 스레드가 사용할 수 있도록 코드를 작성하면서 적절한 동기화 방법을 적용하지 않았으므로 올바르게 공개되지 않았다고 할 수 있음
-  객체가 올바르게 공개되지 않을때 두가지 문제
  - holder 변수에 stale 상태가 발생할 수 있음
  - 다른 스레드는 모두 holder 변수에서 정상적인 참조 값을 가져갈 수 있지만 Holder 클래스의 입장에서는 stale 상태에 빠질 수 있음 (Object 클래스와 관련있음)
- 특정 데이터를 여러 개의 스레드에서 사용하도록 공유할 때 적절한 동기화 방법을 적용하지 않는다면 굉장히 이상한 일이 발생할 가능성이 높음



### 불변 객체와 초기화 안전성

- 불변 객체를 사용하면 객체의 참조를 외부에 공개할 때 추가적인 동기화 방법을 사용하지 않았다 해도 항상 안전하게 올바른 참조 값을 사용할 수 있음
- 불변 객체가 안전하다고 보장되는 내용은 올바른 방법으로 생성한 객체의 내부에 final로 선언된 모든 변수에 적용할 수 있음
- final로 선언된 모든 변수는 별다른 동기화 작업 없이도 안전하게 사용할 수 있음 하지만 final로 선언된 변수에 변경 가능한 객체가 지정되어 있다면 해당 변수에 들어있는 객체의 값을 사용하려고 하는 부분을 모두 동기화시켜야함

### 안전한 공개 방법의 특성

- 객체를 안전하게 공개하려면 해당 객체에 대한 참조와 객체 내부의 상태를 외부 스레드에게 동시에 볼 수 있어야함. 올바르게 생성 메서드가 실행되고 난 객체는 다음과 같은 방법으로 안전하게 공개 가능

  - 객체에 대한 참조를 static 메서드에서 초기화 시킨다.
  - 객체에 대한 참조를 volatile 변수 또는 AtomicReference 클래스에 보관한다.
  - 객체에 대한 참조를 올바르게 생성된 클래스 내부의 final 변수에 보관한다.
  - 락을 사용해 올바르게 막혀 있는 변수에 객체에 대한 참조를 보관한다.

- 스레드 안전한 컬렉션

  - Hashtable, ConcurrentMap, synchronizedMap을 사용해 만든 Map 객체를 사용하면 키와 값 모두를 어느 스레드에서라도 항상 안전하게 사용 가능
  - Vector, CopyOnWriteArrayList, CopyOnWriteArraySet, synchronizedList, synchronizedSet 메서드로 만든 컬렉션은 그 안에 보관하고 있는 객체를 어느 스레드에라도 항상 안전하게 사용할 수 있음
  - BlockingQueue, ConcurrentLinkedQueue 컬렉션 안에 있는 객체는 안전

- static 변수를 선언할 때 직접 new 연산자로 생성 메서드를 실행해 객체를 생성할 수 있다면 가장 쉬우면서도 안전한 객체 공개 방법임

- ```java
  public static Holder holder = new Holder(42);
  ```

- static 초기화 방법은 jvm 에서 클래스를 초기화하는 시점에 작업이 모두 진행됨 jvm 내부에서는 동기화가 맞춰져 있어서 이런 방법은 안정함

### 결과적으로 불변인 객체

- 특정 객체를 안전한 방법으로 공개했을 경우, 해당 객체에 대한 참조를 갖고 객체를 불러와 사용하는 시점에는 공개하는 시점의 객체 상태를 정확하게 사용 가능하고 해당 객체 내부의 값이 바뀌지 않는 한 여러 스레드에서 동시에 값을 가져다 사용해도 동기화문제가 발생하지 않음
- 예를 들어 Date 클래스는 가변으로 설계되었는데 Date를 synchronizedMap에 넣고 사용하면 Date에 대한 추가적인 락 없이 스레드 안전하게 사용이 가능함

### 가변 객체

- 가변객체를 안전하게 사용하려면 안전하게 공개해야하고 또 동기화와 락을 사용해 스레드 안전성을 확보해야함
- 가변성에 따라 객체를 공개할 때 필요한점
  - 불변 객체는 어떤 방법으로 공개해도 아무 문제가 없음
  - 결과적으로 불변인 객체는 안전하게 공개해야함
  - 가변 객체는 안전하게 공개해야하고 스레드에 안전하게 만들거나 락으로 동기화시켜야함



### 객체를 안전하게 공유하기

- 언제든 객체에 대한 참조를 가져다 사용하는 부분이 있다면, 그 객체로 어느 정도의 일을 할 수 있는지를 정확하게 알고 있어야함
- 반대로 객체를 외부에서 사용할 수 있도록 공개할 때에는 해당 객체를 어떤 방법으로 사용할 수 있고 사용해야 하는지에 대해서 정확하게 설명할 수 있어야함
- 객체를 공유할때 가장 많이 사용되는 원칙 정리
  - 스레드 한정: 스레드에 한정된 객체는 오나전하게 해당 스레드 내부에 존재하면서 그 스레드에서만 호출해 사용할 수 있음
  - 읽기 전용 객체를 공유: 읽기 전용 객체를 공유해 사용한다면 동기화 작업을 하지 않더라도 여러 스레드에서 언제든지 마음껏 값을 읽어 사용할 수 있음 ex 불변객체
- 스레드에 안전한 객체를 공유
  - 스레드에 안전한 객체는 객체 내부적으로 필수적인 동기화 기능이 만들어져 있기 때문에 외부에서 동기화를 신경쓸 필요가 없고 여러 스레드에서 마음껏 호출 가능
- 동기화 방법 적용
  - 특정 객체에 동기화 방법을 적용해두면 지정한 락을 획득하기 전에는 해당 객체를 사용할 수 없음. 스레드에 안전한 객체 내부에서 사용하는 객체나 공개된 객체 가운데 특정 락을 확보해야 사용할 수 있도록 막혀 있는 객체 등에 동기화 방법이 적용되어 있다고 볼 수 있음



# #4 객체 구성

## 스레드 안전한 클래스 설계

- 객체가 갖고 있는 여러가지 정보를 해당 객체 내부에 숨겨두면 전체 프로그램을 다 뒤져볼 필요 없이 객체 단위로 스레드 안전성이 확보되어 있는지 확인할 수 있음
- 클래스가 스레드 안전성을 확보하도록 설계하고자 할 때는 다음과 같은 세가지를 고려해야함
  - 객체의 상태를 보관하는 변수가 어떤 것인가?
  - 객체의 상태를 보관하는 변수가 가질 수 있는 값이 어떤 종류, 어떤 범위에 해당하는가?
  - 객체 내부의 값을 동시에 사용하고자 할 때, 그 과정을 관리할 수 있는 정책
- 객체의 상태는 항상 객체 내부의 변수를 기반으로 함
- 객체 내부의 변수가 모두 기본 변수형으로 만들어져 있다면 해당 변수만으로 객체의 상태를 완전하게 표현할 수 있음
- 객체 내부의 여러 변수가 갖고 있는 현재 상태를 사용하고자 할 때 값이 계속해서 변하는 상황에서도 값을 안전하게 사용할 수 있도록 조절하는 방법을 동기화 정책이라고 함
- 동기화 정책에서는 객체의 불변성, 스레드 한정, 락 등을 어떻게 적절하게 활용해 스레드 안전성을 확보할 수 있으며 어떤 변수를 어떤 락으로 막아야 하는지 등의 내용을 명시해야함

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * Counter
 * <p/>
 * Simple thread-safe counter using the Java monitor pattern
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public final class Counter {
    @GuardedBy("this") private long value = 0;

    public synchronized long getValue() {
        return value;
    }

    public synchronized long increment() {
        if (value == Long.MAX_VALUE)
            throw new IllegalStateException("counter overflow");
        return ++value;
    }
}
```

- 위 Counter 클래스는 value변수만 보면 상태를 완벽하게 알 수 있음

### 동기화 요구사항 정리

- 여러 스레드가 동시에 클래스를 사용하려 하는 상황에서 클래스 내부의 값을 안정적인 상태로 유지할 수 있다면 바로 스레드 안전성을 확보했다고 말할 수 있음
- 객체와 변수가 가질 수 있는 가능한 값의 범위를 상태 범위라고 하는데 이 상태 범위가 좁으면 좁을수록 객체의 논리적인 상태를 파악하기 쉬움 (불변 객체는 상태 범위가 반드시 1임 생성 이후에는 변경되지 않음)
- 클래스가 특정 상태를 가질 수 없도록 구현해야 한다면 해당 변수는 클래스 내부에 숨겨야함. 숨기지 않으면 외부에서 올바르지 않은 값을 지정할 수 있음. 그리고 변경시 올바르지 않은 값을 지정할 가능성이 있다면 해당 연산은 단일 연산으로 구현해야함
- 서로 연관된 값은 단일 연산으로 한번에 읽거나 변경해야함
- 상태 범위에 두 개 이상의 변수가 연결되어 동시에 관여하고 있다면 이런 변수를 사용하는 모든 부분에서 락을 사용해 동기화를 맞춰야함
- 객체가 가질 수 있는 값의 범위와 변동 폭을 정확하게 인식하지 못한다면 스레드 안전성을 완벽하게 확보할 수 없음 클래스의 상태가 정상적이라는 여러가지 제약 조건이 있을 때 클래스의 상태를 정상적으로 유지하려면 여러 가지 추가적인 동기화 기법을 적용하거나 상태 변수를 클래스 내부에 적절히 숨겨야함



### 상태 의존 연산

- 현재 조건에 따라 동작 여부가 결정되는 연산을 상태 의존 연산이라고함
- 여러 스레드가 동시에 움직이는 경우라면 실행하기 시작한 이후에 선행 조건이 올바른 상태로 바뀔 수 있음
- java에서는 wait과 notice를 제공하지만 올바르게 사용하기가 쉽지 않아 주의해야함
- wait과 notify를 사용하는 대신 세마포어나 블로킹 큐와 같이 현재 알려져 있는 여러 가지 라이브러리를 사용하는 편이 훨씬 간단하고 안전함

### 상태 소유권

- 자바에서는 상태 소유권이라는 개념이 모호함 gc가 관리하기 때문
- 상태 소유권은 말그대로 이상태에 대한 소유권을 말하는 듯. 특정 변수를 외부에 공개하면 해당 변수에 대한 소유권을 외부와 공유하게되는 원리



## 인스턴스 한정

- 객체가 스레드 안전성을 확보하지 못하고 있다 하더라도, 몇 가지 기법을 활용하면 멀티 스레드 프로그램에서 안전하게 사용이 가능함
- 스레드 한정 기법을 사용하거나 해당 객체를 사용하고자 하는 부분에서 락을 사용해 동시 사용되는 경우를 막을 수 있음.
- 객체를 적절하게 캡슐화하는 것으로도 스레드 안전성을 확보할 수 있음 <= 인스턴스 한정
- 데이터를 객체 내부에 캡슐화해 숨겨두면 숨겨진 내용은 해당 객체의 메서드에서만 사용 할 수 있기 때문에 숨겨진 데이터를 사용하고자 할 때에는 항상 지정된 형태의 락이 적용되는지 쉽고 정확하게 파악할 수 있음
- 한정된 객체는 제한된 범위를 벗어나서는 안됨

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * PersonSet
 * <p/>
 * Using confinement to ensure thread safety
 *
 * @author Brian Goetz and Tim Peierls
 */

@ThreadSafe
public class PersonSet {
    @GuardedBy("this") private final Set<Person> mySet = new HashSet<Person>();

    public synchronized void addPerson(Person p) {
        mySet.add(p);
    }

    public synchronized boolean containsPerson(Person p) {
        return mySet.contains(p);
    }

    interface Person {
    }
}
```

- 위 PersonSet 클래스의 mySet 변수는 스레드 안전한 객체가 아니지만 private로 외부에 노출되어 있지 않고 myset에 접근하는 모든 메서드는 synchronized 키워드가 걸려있어서 스레드 안전성을 확보했다고 말할 수 있음
- 인스턴스 한정 기법은 클래스를 구현할 때 스레드 안전성을 확보할 수 있는 가장 쉬운 방법이라고 해도 무리가 없음
- 인스턴스 한정 기법을 사용하면 동기화를 위한 락의 방식도 마음대로 선택 가능
- 자바에서도 비슷하게 ArrayList를 감싸는 래퍼 클래스를 생성하는 Collections.synchronizedList가 있음
- 한정됐어야 할 객체를 공개하면 한정 조건이 깨질 수 있음
- 인스턴스 한정 기법을 사용하면 전체 프로그램을 다 뒤져보지 않고도 스레드 안전성을 확보하고 있는지 쉽게 분석해볼 수 있기 때문에 스레드에 안전한 객체를 좀 더쉽게 구현할 수 있음

### 자바 모니터 패턴

- 자바 모니터 패턴을 따르는 객체는 변경가능한 데이터를 모두 객체 내부에 숨긴 다음 객체의 암묵적인 락으로 데이터에 대한 동시 접근을 막음
- 아래 클래스처럼 사용하는게 자바 모니터 패턴의 전형적인 예

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * Counter
 * <p/>
 * Simple thread-safe counter using the Java monitor pattern
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public final class Counter {
    @GuardedBy("this") private long value = 0;

    public synchronized long getValue() {
        return value;
    }

    public synchronized long increment() {
        if (value == Long.MAX_VALUE)
            throw new IllegalStateException("counter overflow");
        return ++value;
    }
}
```

- 자바 모니터 패턴은 Vector, Hashtable 등 여러가지 클래스에 널리 사용하고 있음
- 자바 모니터 패턴의 가장 큰 장점은 간결함

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * PrivateLock
 * <p/>
 * Guarding state with a private lock
 *
 * @author Brian Goetz and Tim Peierls
 */
public class PrivateLock {
    private final Object myLock = new Object();
    @GuardedBy("myLock") Widget widget;

    void someMethod() {
        synchronized (myLock) {
            // Access or modify the state of widget
        }
    }
}
```

- 위 방식으로 락을 구현할 수도 있음
- 위처럼 사용할때는 락을 외부에 공개하면 절대 안됨 만약 공개한다면 락을 사용하는 코드가 올바르게 의도한 대로 동작하는지 확인해야함



### 예제: 차량 위치 추적

- 모든 차량은 String 형태의 ID로 구분하고 차량의 위치는 x y 좌표로 표시함

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * MutablePoint
 * <p/>
 * Mutable Point class similar to java.awt.Point
 *
 * @author Brian Goetz and Tim Peierls
 */
@NotThreadSafe
public class MutablePoint {
    public int x, y;

    public MutablePoint() {
        x = 0;
        y = 0;
    }

    public MutablePoint(MutablePoint p) {
        this.x = p.x;
        this.y = p.y;
    }
}
```

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * MonitorVehicleTracker
 * <p/>
 * Monitor-based vehicle tracker implementation
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
 public class MonitorVehicleTracker {
    @GuardedBy("this") private final Map<String, MutablePoint> locations;

    public MonitorVehicleTracker(Map<String, MutablePoint> locations) {
        this.locations = deepCopy(locations);
    }

    public synchronized Map<String, MutablePoint> getLocations() {
        return deepCopy(locations);
    }

    public synchronized MutablePoint getLocation(String id) {
        MutablePoint loc = locations.get(id);
        return loc == null ? null : new MutablePoint(loc);
    }

    public synchronized void setLocation(String id, int x, int y) {
        MutablePoint loc = locations.get(id);
        if (loc == null)
            throw new IllegalArgumentException("No such ID: " + id);
        loc.x = x;
        loc.y = y;
    }

    private static Map<String, MutablePoint> deepCopy(Map<String, MutablePoint> m) {
        Map<String, MutablePoint> result = new HashMap<String, MutablePoint>();

        for (String id : m.keySet())
            result.put(id, new MutablePoint(m.get(id)));

        return Collections.unmodifiableMap(result);
    }
}

```

- 위에서 사용한 MutablePoint 클래스는 스레드에 안전하지 않지만 실제 사용하는 MonitorVehicleTracker 클래스에서는 MutablePoint 에 대해서 스레드에 안전하도록 설계했음
- 외부에서 변경 가능한 데이터를 요청한 경우 그에 대한 복사본을 넘겨주는 방법을 사용하면 스레드 안전성을 부분적이나마 확보할 수 있음
- 경우에 따라 만약 호출된 시점에 해당하는 좌표값을 얻는것이 요구사항이라면 적합하나 만약 지속적으로 좌표를 추적해야하는 경우라면 위와 같은 경우 계속해서 MutablePoint를 생성하기때문에 적합하지 않음

## 스레드 안전성 위임

- 아주 간단한 몇가지 객체를 제외하고는 대부분의 객체가 둘 이상의 객체를 조합해 사용하는 합성 객체임
- 스레드 안전성이 없는 객체를 조합하더라도 내부에 있는 객체들이 스레드에 안전하다면 그 래퍼 클래스도 스레드에 안전할 수 있음

### 예제: 위임 기법을 활용한 차량 추적

- 스레드 안전성 위임방법을 통해 차량 추적 프로그램을 재설계함

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * Point
 * <p/>
 * Immutable Point class used by DelegatingVehicleTracker
 *
 * @author Brian Goetz and Tim Peierls
 */
@Immutable
public class Point {
    public final int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```



```java
package net.jcip.examples;

import java.util.*;
import java.util.concurrent.*;
import java.awt.*;
import java.awt.Point;

import net.jcip.annotations.*;

/**
 * DelegatingVehicleTracker
 * <p/>
 * Delegating thread safety to a ConcurrentHashMap
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class DelegatingVehicleTracker {
    private final ConcurrentMap<String, Point> locations;
    private final Map<String, Point> unmodifiableMap;

    public DelegatingVehicleTracker(Map<String, Point> points) {
        locations = new ConcurrentHashMap<String, Point>(points);
        unmodifiableMap = Collections.unmodifiableMap(locations);
    }

    public Map<String, Point> getLocations() {
        return unmodifiableMap;
    }

    public Point getLocation(String id) {
        return locations.get(id);
    }

    public void setLocation(String id, int x, int y) {
        if (locations.replace(id, new Point(x, y)) == null)
            throw new IllegalArgumentException("invalid vehicle name: " + id);
    }

    // Alternate version of getLocations (Listing 4.8)
    public Map<String, Point> getLocationsAsStatic() {
        return Collections.unmodifiableMap(
                new HashMap<String, Point>(locations));
    }
}

```

- 위 코드에서는 어떠한 락도 없지만 ConcurrentHashMap을 사용하기때문에 스레드에 안전함
- 그리고 개인적으로 재미있는부분이 생성 시점에 locations의 인스턴스를 포함한 unmodifiableMap을 만드는데 이후에 locations에 추가가 되더라도 unmodifiableMap이 갖고 잇는 참조는 locations이기 때문에 변경 또는 추가된 좌표를 어느 스레드에서나 확인할 수 있음 unmodifiableMap얘만 갖고 있다면! 만약 특정 시점만 조회하고싶다면 getLocationsAsStatic()를 사용하면됨



### 독립 상태 변수

- 위임하고자하는 내부 변수가 두 개 이상이라 해도 두 개 이상의 변수가 서로 독립적이라면 클래스의 스레드 안전성을 위임할 수 있는데, 독립적이라는 의미는 변수가 서로의 상태 값에 대한 연관성이 없다는 말임
- 아래 두개의 eventListeners 변수들은 서로 연관이 없어서 스레드 안전성을 위임할 수 있음

```java
package net.jcip.examples;

import java.awt.event.KeyListener;
import java.awt.event.MouseListener;
import java.util.*;
import java.util.concurrent.*;

/**
 * VisualComponent
 * <p/>
 * Delegating thread safety to multiple underlying state variables
 *
 * @author Brian Goetz and Tim Peierls
 */
public class VisualComponent {
    private final List<KeyListener> keyListeners
            = new CopyOnWriteArrayList<KeyListener>();
    private final List<MouseListener> mouseListeners
            = new CopyOnWriteArrayList<MouseListener>();

    public void addKeyListener(KeyListener listener) {
        keyListeners.add(listener);
    }

    public void addMouseListener(MouseListener listener) {
        mouseListeners.add(listener);
    }

    public void removeKeyListener(KeyListener listener) {
        keyListeners.remove(listener);
    }

    public void removeMouseListener(MouseListener listener) {
        mouseListeners.remove(listener);
    }
}
```



### 위임할 때의 문제점

- 거의 모든 객체가 내부의 상태 변수 간에 의존성을 갖고 있음
- 따라서 의존성이 있는 경우에 단일 연산으로 묶어야하고 스레드 안전성 위임 방식을 사용할 수 없음

```java
package net.jcip.examples;

import java.util.concurrent.atomic.*;

/**
 * NumberRange
 * <p/>
 * Number range class that does not sufficiently protect its invariants
 *
 * @author Brian Goetz and Tim Peierls
 */

public class NumberRange {
    // INVARIANT: lower <= upper
    private final AtomicInteger lower = new AtomicInteger(0);
    private final AtomicInteger upper = new AtomicInteger(0);

    public void setLower(int i) {
        // Warning -- unsafe check-then-act
        if (i > upper.get())
            throw new IllegalArgumentException("can't set lower to " + i + " > upper");
        lower.set(i);
    }

    public void setUpper(int i) {
        // Warning -- unsafe check-then-act
        if (i < lower.get())
            throw new IllegalArgumentException("can't set upper to " + i + " < lower");
        upper.set(i);
    }

    public boolean isInRange(int i) {
        return (i >= lower.get() && i <= upper.get());
    }
}

```

- 두 변수가 독립적으로 동작하지 않은데 락이 없어서 매우 위험함
- 이런 경우에는 내부적으로 락을 사용해서 복합 연산이 단일 연산으로 처리되도록 해야함
- 클래스가 서로 의존성 없이 독립적이고 스레드 안전한 두 개 이상의 클래스를 조합해 만들어져 있고 두 개 이상의 클래스를 한번에 처리하는 복합 연산 메서드가 없는 상태라면 스레드 안전성을 내부 변수에게 모두 위임할 수 있음

### 내부 상태 변수를 외부에 공개

- 상태 변수가 스레드에 안전하고, 클래스 내부에서 상태 변수의 값에 대한 의존성을 갖고 있지 않고, 상태 변수에 대한 어떤 연산을 수행하더라도 잘못된 상태에 이를 가능성이 없다면 해당 변수는 외부에 공개해도 안전함



### 예제: 차량 추적 프로그램의 상태를 외부에 공개

- 차량 추적 프로그램의 내부 상태를 외부에 공개하는 구조로 변경해보기

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * SafePoint
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class SafePoint {
    @GuardedBy("this") private int x, y;

    private SafePoint(int[] a) {
        this(a[0], a[1]);
    }

    public SafePoint(SafePoint p) {
        this(p.get());
    }

    public SafePoint(int x, int y) {
        this.set(x, y);
    }

    public synchronized int[] get() {
        return new int[]{x, y};
    }

    public synchronized void set(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

```java
package net.jcip.examples;

import java.util.*;
import java.util.concurrent.*;

import net.jcip.annotations.*;

/**
 * PublishingVehicleTracker
 * <p/>
 * Vehicle tracker that safely publishes underlying state
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class PublishingVehicleTracker {
    private final Map<String, SafePoint> locations;
    private final Map<String, SafePoint> unmodifiableMap;

    public PublishingVehicleTracker(Map<String, SafePoint> locations) {
        this.locations = new ConcurrentHashMap<String, SafePoint>(locations);
        this.unmodifiableMap = Collections.unmodifiableMap(this.locations);
    }

    public Map<String, SafePoint> getLocations() {
        return unmodifiableMap;
    }

    public SafePoint getLocation(String id) {
        return locations.get(id);
    }

    public void setLocation(String id, int x, int y) {
        if (!locations.containsKey(id))
            throw new IllegalArgumentException("invalid vehicle name: " + id);
        locations.get(id).set(x, y);
    }
}
```

- 위처럼 내부에 상태를 안전하게 공개하면서 차량 추적 프로그램을 만들 수 있음



## 스레드 안전하게 구현된 클래스에 기능 추가

- 만들어져 있는 클래스를 쓰는게 대부분 적절한 방법임
- 이미 스레드에 안전한 클래스라고 하더라도 두개의 연산을 섞어서 사용한다고 하면 동시성에 위반될 수 있음
- 스레드 안전성은 반드시 단일 연산에만 적용된다는것을 명심!

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * BetterVector
 * <p/>
 * Extending Vector to have a put-if-absent method
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class BetterVector <E> extends Vector<E> {
    // When extending a serializable class, you should redefine serialVersionUID
    static final long serialVersionUID = -3963416950630760754L;

    public synchronized boolean putIfAbsent(E x) {
        boolean absent = !contains(x);
        if (absent)
            add(x);
        return absent;
    }
}
```

- 위처럼 Vector 클래스를 상속해서 putIfAbsent() 메서드를 추가했음
- 기존 클래스를 상속받아 기능을 추가하는 방법은 문제가 생길 위험이 많음. 상위 클래스가 내부적으로 상태 변수의 스레드 안전성을 보장하는 동기화 기법을 약간만 수정해도 하위 클래스에서 전부 깨질 수 있음 참고

### 호출하는 측의 동기화

- 클래스를 상속받지 않고도 클래스에 원하는 기능을 추가할 수 있는 방법으로 도우미 클래스를 따로 구현해서 추가 기능을 구현하는 방법임

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * ListHelder
 * <p/>
 * Examples of thread-safe and non-thread-safe implementations of
 * put-if-absent helper methods for List
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
class BadListHelper <E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());

    public synchronized boolean putIfAbsent(E x) {
        boolean absent = !list.contains(x);
        if (absent)
            list.add(x);
        return absent;
    }
}

@ThreadSafe
class GoodListHelper <E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());

    public boolean putIfAbsent(E x) {
        synchronized (list) {
            boolean absent = !list.contains(x);
            if (absent)
                list.add(x);
            return absent;
        }
    }
}
```

- BadListHelper 클래스는 동기화된것처럼 보이지만 사실 BadListHelper의 putIfAbsent()을 동기화했을뿐 내부 멤버변수인 list와는 연관이 없음.
- GoodListHelper클래스가 실제로 동시성을 보장함
- 제3의 도우미 클래스를 만들어 사용하려는 방법을 올바르게 구현하려면 클라이언트 측 락이나 외부 락을 사용해 List가 사용하는 것과 동일한 락을 사용해야함
- 이런 제 3의 도우미 클래스를 만드는 방법은 특정 클래스 내부에서 제 3의 클래스를 락을 거는거라 매우매우 위험함 반드시 동기화 전략에 대한 내용을 정확하게 구현하고 공지해야함

### 클래스 재구성

- 기존 클래스에 새로운 단일 연산을 추가하고자 할 때 안전하게 사용할 수 있는 방법은 바로 재구성임

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * ImprovedList
 *
 * Implementing put-if-absent using composition
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class ImprovedList<T> implements List<T> {
    private final List<T> list;

    /**
     * PRE: list argument is thread-safe.
     */
    public ImprovedList(List<T> list) { this.list = list; }

    public synchronized boolean putIfAbsent(T x) {
        boolean contains = list.contains(x);
        if (!contains)
            list.add(x);
        return !contains;
    }

    // Plain vanilla delegation for List methods.
    // Mutative methods must be synchronized to ensure atomicity of putIfAbsent.
    
    public int size() {
        return list.size();
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    public boolean contains(Object o) {
        return list.contains(o);
    }

    public Iterator<T> iterator() {
        return list.iterator();
    }

    public Object[] toArray() {
        return list.toArray();
    }

    public <T> T[] toArray(T[] a) {
        return list.toArray(a);
    }

    public synchronized boolean add(T e) {
        return list.add(e);
    }

    public synchronized boolean remove(Object o) {
        return list.remove(o);
    }

    public boolean containsAll(Collection<?> c) {
        return list.containsAll(c);
    }

    public synchronized boolean addAll(Collection<? extends T> c) {
        return list.addAll(c);
    }

    public synchronized boolean addAll(int index, Collection<? extends T> c) {
        return list.addAll(index, c);
    }

    public synchronized boolean removeAll(Collection<?> c) {
        return list.removeAll(c);
    }

    public synchronized boolean retainAll(Collection<?> c) {
        return list.retainAll(c);
    }

    public boolean equals(Object o) {
        return list.equals(o);
    }

    public int hashCode() {
        return list.hashCode();
    }

    public T get(int index) {
        return list.get(index);
    }

    public T set(int index, T element) {
        return list.set(index, element);
    }

    public void add(int index, T element) {
        list.add(index, element);
    }

    public T remove(int index) {
        return list.remove(index);
    }

    public int indexOf(Object o) {
        return list.indexOf(o);
    }

    public int lastIndexOf(Object o) {
        return list.lastIndexOf(o);
    }

    public ListIterator<T> listIterator() {
        return list.listIterator();
    }

    public ListIterator<T> listIterator(int index) {
        return list.listIterator(index);
    }

    public List<T> subList(int fromIndex, int toIndex) {
        return list.subList(fromIndex, toIndex);
    }

    public synchronized void clear() { list.clear(); }
}
```

- 이런식으로 구현하는 방법이 이전에 설명했던 방법들보다 조금 더 안전하게 단일 연산을 추가하는 방법임





## 동기화 정책 문서화 하기

- 구현한 클래스가 어느정도 수준까지 스레드 안전성을 보장하는지에 대해 충분히 문서를 작성해둬야함 동기화 기법이나 정책을 잘 정리해두면 유지보수 팀이 원활하게 관리할 수 있음
- 클라이언트가 추측하는 위험한 상황보다는 정리된 글로 안내해주는게 좋음



### 애매한 문서 읽어내기

# #5 구성 단위

## 동기화된 컬렉션 클래스

- 동기화되어 있는 컬렉션 클래스의 대표주자는 바로 Vector와 Hashtable 등이 있는데 이와 같은 클래스는 모두 public으로 선언된 모든 메서드를 클래스 내부에 캡슐화해 내부의 값을 한 번에 한 스레드만 사용할 수 있도록 제어하면서 스레드 안전성을 확보하고 있음

### 동기화된 컬렉션 클래스의 문제점

- 안전성을 확보하고 있지만 여러 개의 연산을 묶어서 하나의 단일 연산처럼 활용해야 할 필요성이 있을때는 주의해야함

```java
package net.jcip.examples;

import java.util.*;

/**
 * UnsafeVectorHelpers
 * <p/>
 * Compound actions on a Vector that may produce confusing results
 *
 * @author Brian Goetz and Tim Peierls
 */
public class UnsafeVectorHelpers {
    public static Object getLast(Vector list) {
        int lastIndex = list.size() - 1;
        return list.get(lastIndex);
    }

    public static void deleteLast(Vector list) {
        int lastIndex = list.size() - 1;
        list.remove(lastIndex);
    }
}

```

- 위와 같이 동일한 Vector 클래스를 놓고 따로 연산하는 경우는 올바르게 동작하지 않을 수 있음
- 절묘하게 두 메서드가 동시에 실행된다고 가정했을때는 list.size()를 얻어오는 시점이 다르기때문에 문제가 생길 수 있음
- 동기화된 컬렉션 클래스는 대부분 클라이언트 측 락을 사용할 수 있도록 만들어져 있기 때문에 컬렉션 클래스가 사용하는 락을 함께 사용한다면 새로 추가하는 기능을 컬렉션 클래스에 들어있는 다른 메서드와 같은 수준으로 동기화시킬 수 있음

```java
package net.jcip.examples;

import java.util.*;

/**
 * SafeVectorHelpers
 * <p/>
 * Compound actions on Vector using client-side locking
 *
 * @author Brian Goetz and Tim Peierls
 */
public class SafeVectorHelpers {
    public static Object getLast(Vector list) {
        synchronized (list) {
            int lastIndex = list.size() - 1;
            return list.get(lastIndex);
        }
    }

    public static void deleteLast(Vector list) {
        synchronized (list) {
            int lastIndex = list.size() - 1;
            list.remove(lastIndex);
        }
    }
}
```

- 위와 같이 synchronized 블록으로 감쌓으면 list 자체에 대한 락을 걸기 때문에 문제가 생기지 않음



### Iterator와 ConcurrentModificationException

> 책에는 예제가 있는데 사이트에 없네 왜지 ? 

- 동기화된 컬렉션 클래스에서 만들어낸 Interator를 사용한다 해도 다른 스레드가 같은 시점에 컬렉션 클래스 내부의 값을 변경하는 작업을 하려 할때 즉시 멈춤의 형태로 반응하게 되어 있음
- 즉시 멈춤이란 반복문을 실행하는 도중에 컬렉션 클래스 내부의 값을 변경하는 상황이 포착되면 그 즉시 ConcurrentModificationException 예외를 발생시키고 멈추는 처리 방법
- 컬렉션 클래스는 내부에 값 변경 횟수를 카운트하는 변수를 마련해두고 반복문 실행 동안 횟수 값이 바뀌면 ConcurrentModificationException을 발생시킴
- 반복문을 실행하는 코드 전체를 동기화하면 ConcurrentModificationException을 방지할 수 있지만 좋은 방법이 아님
- 컬렉션 내부에 요소가 많다면 락을 잡는 비용이 너무 큼
- 멀티 스레드 환경에서 컬렉션에 ConcurrentModificationException을 피하고싶다면 기존 객체를 clone해서 스레드 한정기법으로 동시성을 보장받게 할 수 있음

### 숨겨진 Iterator

- Iterator가 숨겨진 경우도 있기 때문에 컬렉션을 공유해 사용하는 모든 부분에서 동기화를 맞춰줘야함

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * HiddenIterator
 * <p/>
 * Iteration hidden within string concatenation
 *
 * @author Brian Goetz and Tim Peierls
 */
public class HiddenIterator {
    @GuardedBy("this") private final Set<Integer> set = new HashSet<Integer>();

    public synchronized void add(Integer i) {
        set.add(i);
    }

    public synchronized void remove(Integer i) {
        set.remove(i);
    }

    public void addTenThings() {
        Random r = new Random();
        for (int i = 0; i < 10; i++)
            add(r.nextInt());
        System.out.println("DEBUG: added ten elements to " + set);
    }
}
```

- 믿기힘들겠지만 `System.out.println("DEBUG: added ten elements to " + set);` 이부분이 문제임 set의 toString()이 동작할때 내부적으로는 Iterator가 동작함 ..
- 개발자는 상태 변수와 상태 변수의 동기화를 맞춰주는 락이 멀리 떨어져 있을수록 동기화를 맞춰야 한다는 필요성을 잊기 쉽다는 점임. 만약 HiddenIterator 클래스에서 사용했던 것처럼 HashSet을 직접 사용하지말고 synchronizedSet메서드로 동기화된 컬렉션을 사용하면 동기화가 이미 맞춰져 있기 때문에 Iterator와 관련한 이런 문제가 발생하지 않음



## 병렬 컬렉션

- 자바5부터 병렬 컬렉션 클래스가 추가되면서 성능을 상당히 끌어올릴 수 있게됐음 

### ConcurrentHashMap

- 동기화된 컬렉션 클래스는 각 연산을 수행하는 시간 동안 항상 락을 확보하고 있어야함
- ConcurrentHashMap은 HashMap과 같이 해시를 기반으로 하는 Map임 하지만 내부적으로는 이전에 사용하던 것과 전혀 다른 동기화 기법을 채택해 병렬성과 확장성이 훨씬 나아졌음
- 이전에는 모든 연산에서 하나의 락을 사용했기 때문에 특정 시점에 하나의 스레드만이 해당 컬렉션을 사용 가능했으나 ConcurrentHashMap은 락 스트라이핑 이라 부르는 굉장히 세밀한 동기화 방법을 사용해 여러 스레드에서 공유하는 상태에 훨씬 잘 대응할 수 있게됨
- 값을 읽어가는 연산은 많은 수의 스레드라도 얼마든지 동시에 처리할 수 있고, 읽기 연산과 쓰기 연산도 동시에 처리할 수 있고 쓰기 연산은 제한된 개수만큼 동시에 수행할 수 있음
- ConcurrentHashMap이 만들어낸 Iterator는 ConcurrentModificationException을 발생시키지 않도록 설계됨
- 신경써야할 부분도 생겼는데 예를 들어 size()와 isEmpty()의 경우 정확한 값이 아니라 추정된 값인데 그렇게 크게 문제되는 부분은 아님
- ConcurrentHashMap은 독점적으로 락을 사용할 수 없음
- 만약 작업중인 애플리케이션에서 특정 Map을 완전히 독점해서 사용하는 경우가 있다면 그 부분에 ConcurrentHashMap을 사용할때는 충분히 주의할것



### Map기반의 또 다른 단일 연산

- ConcurrentHashMap에는 put-if-absent, remove-if-eqaul, replace-if-eqaul 같은 자주 필요한 몇가지 연산이 이미 구현되어 있음



### CopyOnWriteArrayList

- CopyOnWriteArrayList 클래스는 동기화된 List클래스보다 병렬성을 훨씬 높이고자 만들어짐
- 변경할 때마다 복사한다면 별다른 동기화 작업 없이 스레드 안전함. CopyOnWriteArrayList는 컬렉션 내용이 변경될 때마다 복사본을 새로 만들어 내는 전략을 취함.
- CopyOnWriteArrayList의 Iterator는 ConcurrentModificationException을 발생시키지 않음. 복사하기 때문에
- 컬렉션을 복사하는게 비용이 있어서 변경할때마다 복사하는 컬렉션은 변경 작업보다 반복문으로 읽어내는 일이 훨씬 빈번한 경우에 효과적임 ex 이벤트 리스너



## 블로킹 큐와 프로듀서-컨슈머 패턴

- 블로킹 큐는 put과 take라는 핵심 메서드가 있고 offer와 poll이라는 메서드가 있음
- 만약 큐가 가득 차 있다면 put 메서드는 값을 추가할 공간이 생길 때까지 대기함 반대로 큐가 비어있는 상태라면 take 메서드는 뽑아낼 값이 들어올 때까지 대기함
- 큐의 크기에 제한을 두지 않을 수 있기 때문에 그럴 경우엔 put 연산이 대기 상태에 들어가는 경우가 없음
- 블로킹큐는 프로듀서-컨슈머 패턴을 구현할 때 사용하기에 좋음
-  프로듀서 컨슈머 패턴을 사용하면 작업을 만들어 내는 부분과 작업을 처리하는 부분을 완전히 분리할 수 있기 때문에 개발 과정을 좀 더 명확하게 단순화시킬 수 있고, 작업을 생성하는 부분과 처리하는 부분이 각각 감당할 수 있는 부하를 조절할 수 있다는 장점이 있음
- 프로듀서는 작업을 새로 만들어 큐에 쌓아두고 컨슈머는 큐에 쌓여 있는 작업을 가져다 처리하는 구조
- 큐와 함께 스레드 풀을 사용하는 경우가 바로 프로듀서 컨슈머 패턴을 활용하는 가장 흔한 경우
- 블로킹큐는 애플리케이션이 안정적으로 동작하도록 만들고자 할 때 요긴하게 사용할 수 있는 도구임 블로킹 큐를 사용하면 처리할 수 있는 양보다 훨씬 많은 작업이 생겨 부하가 걸리는 상황에서 작업량을 조절해 애플리케이션이 안정적으로 동작하도록 유도할 수 있음



### 예제: 데스크탑 검색

- 프로듀서 컨슈머 패턴을 사용하면 데스크탑 검색 프로그램을 구현하는 것과같이 멀티스레드를 사용하는 경우에 프로그램의 세부 기능을 쉽게 컴포넌트화 할 수 있음
- 디렉토리 구조를 따라가며 파일을 읽어들이고 파일의 내용을 색인하는 기능을 두개의 클래스로 구분



### 직렬 스레드 한정

- 프로듀서 컨슈머 패턴과 블로킹 큐는 가변객체를 사용할 때 객체의 소유권을 프로듀서에서 컨슈머로 넘기는 과정에서 직렬 스레드 한정 기법을 사용함 스레드에 한정된 객체는 특정 스레드 하나만이 소유권을 가질 수 있는데 객체를 안전한 방법으로 공개하면 객체에 대한 소유권을 이전할 수 있음
- 객체 풀은 직렬 스레드 한정 기법을 잘 활용하는 예



```java
package net.jcip.examples;

import java.io.File;
import java.io.FileFilter;
import java.util.concurrent.*;

/**
 * ProducerConsumer
 * <p/>
 * Producer and consumer tasks in a desktop search application
 *
 * @author Brian Goetz and Tim Peierls
 */
public class ProducerConsumer {
    static class FileCrawler implements Runnable {
        private final BlockingQueue<File> fileQueue;
        private final FileFilter fileFilter;
        private final File root;

        public FileCrawler(BlockingQueue<File> fileQueue,
                           final FileFilter fileFilter,
                           File root) {
            this.fileQueue = fileQueue;
            this.root = root;
            this.fileFilter = new FileFilter() {
                public boolean accept(File f) {
                    return f.isDirectory() || fileFilter.accept(f);
                }
            };
        }

        private boolean alreadyIndexed(File f) {
            return false;
        }

        public void run() {
            try {
                crawl(root);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        private void crawl(File root) throws InterruptedException {
            File[] entries = root.listFiles(fileFilter);
            if (entries != null) {
                for (File entry : entries)
                    if (entry.isDirectory())
                        crawl(entry);
                    else if (!alreadyIndexed(entry))
                        fileQueue.put(entry);
            }
        }
    }

    static class Indexer implements Runnable {
        private final BlockingQueue<File> queue;

        public Indexer(BlockingQueue<File> queue) {
            this.queue = queue;
        }

        public void run() {
            try {
                while (true)
                    indexFile(queue.take());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        public void indexFile(File file) {
            // Index the file...
        };
    }

    private static final int BOUND = 10;
    private static final int N_CONSUMERS = Runtime.getRuntime().availableProcessors();

    public static void startIndexing(File[] roots) {
        BlockingQueue<File> queue = new LinkedBlockingQueue<File>(BOUND);
        FileFilter filter = new FileFilter() {
            public boolean accept(File file) {
                return true;
            }
        };

        for (File root : roots)
            new Thread(new FileCrawler(queue, filter, root)).start();

        for (int i = 0; i < N_CONSUMERS; i++)
            new Thread(new Indexer(queue)).start();
    }
}
```



### 덱 작업 가로채기

- 자바6에는 Deque가 추가되었음 덱은 앞 뒤 어느 쪽에도 객체를 쉽게 삽입하거나 제거할 수 있도록 준비된 큐임
- 프로듀서 컨슈머 패턴에서 블로킹 큐의 기능을 그대로 가져다 사용하는 것처럼 작업 개로채기라는 패턴을 적용할 때에는 덱을 그대로 가져다 사용할 수 있음
- 작업 가로채기 패턴에서는 모든 컨슈머가 각자의 덱을 가짐
- 만약 특정 컨슈머가 자신의 덱에 있는 작업을 모두 처리하면 다른 컨슈머의 덱의 가장 마지막 작업을 가로채 올 수 있음
- 작업 가로채기 패턴은 특성상 컨슈머가 하나의 큐를 바라보면서 서로 작업을 가져가려고 경쟁하지 않기 때문에 일반적인 프로듀서 컨슈머 패턴보다 규모가 큰 시스템을 구현하기에 적당함 더군다나 누군가 가로채더라도 맨 뒤에서 작업을 가져오기 때문에 경쟁이 없음
- 작업 가로채기 패턴은 컨슈머가 프로듀서의 역할도 갖고 있는 경우에 적용하기에 좋음



## 블로킹 메소드, 인터럽터블 메소드

- 스레드는 여러가지 원인에 의해 블록당하거나 멈춰질 수 있음 ex: I/O작업이 끝나기를 기다리거나 락을 확보하기 위해 등등
- 인터럽트는 스레드가 서로 협력해서 실행하기 위한 방법임 어떤 스레드라도 다른 스레드가 하고 있는 일을 중간에 강제로 멈추라고는 할 수 없음 단지 요청하는 것일 뿐
- 인터럽트를 원활하게 처리하도록 만들어진 메서드는 실행 시간이 너무 길어질 때 일정 시간이 지난 이후 실행을 중단할 수 있도록 구성하기 좋음
- InterruptedException이 발생할 수 있는 메서드가 있다면 그 메서드를 호출하는 메서드 역시 블로킹 메서드임 따라서 InterruptedException이 발생했을때 그에 대한 대처방법을 마련해둬야함
- 두가지 방법이 있음
  - InterruptedException을 전달: 받아낸 InterruptedException을 그대로 호출한 메서드에게 넘겨버리는 방법.
  - 인터럽트를 무시하고 복구: 특정 상황에서 InterruptedException를 throw할 수 없는 경우. InterruptedException을 catch한 다음 현재 스레드의 interrupt 메서드를 호출해 인터럽트 상태를 설정해 상위 호출 메서드가 인터럽트 상황이 발생했음을 알 수 있도록 해야 함
- InterruptedException을 catch하고 아무런 일도 하지 않는 것은 절대 하지 말아야 함!

```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * TaskRunnable
 * <p/>
 * Restoring the interrupted status so as not to swallow the interrupt
 *
 * @author Brian Goetz and Tim Peierls
 */
public class TaskRunnable implements Runnable {
    BlockingQueue<Task> queue;

    public void run() {
        try {
            processTask(queue.take());
        } catch (InterruptedException e) {
            // restore interrupted status
            Thread.currentThread().interrupt();
        }
    }

    void processTask(Task task) {
        // Handle the task
    }

    interface Task {
    }
}
```

- 위 클래스처럼 인터럽트가 발생한 사실을 저장해야함



## 동기화 클래스

- 상태 정보를 사용해 스레드 간의 작업 흐름을 조절할 수 있도록 만들어진 모든 클래스를 동기화 클래스라고함
- 블로킹큐, 세마포어, 배리어, 래치 등이 있음
- 모든 동기화 클래스는 구조적인 특징을 갖고 있음 모두 동기화 클래스에 접근하려는 스레드가 어느 경우에 통과하고 어느 경우에는 대기하도록 멈추게 해야 하는지를 결정하는 상태 정보를 갖고 있고 그 상태를 변경할 수 있는 메서드를 제공하고, 동기화 클래스가 특정 상태에 진입할 때까지 효과적으로 대기할 수 있는 메서드도 제공함

### 래치

- 래치는 스스로가 터미널 상태에 이를때까지의 스레드가 동작하는 과정을 늦출 수 있도록 해주는 동기화 클래스임
- 래치는 일종의 관문과 같은 형태로 동작함 래치가 터미널 상태에 다다르면 관문이 열리고 모든 스레드가 통과함
- 래치가 한 번 터미널 상태에 다다르면 그 상태를 다시 이전으로 되돌릴 수 없음 
- 래치는 특정한 단일 동작이 완료되기 잊전에는 어떤 기능도 동작하지 않도록 막아내야 하는 경우에 요긴하게 사용할 수 있음 예를 들어 다음 과 같은 경우에
  - 특정 자원을 확보하기 전에는 작업을 시작하지 말아야 하는 경우에 사용 가능. 아주 간단한 이진 래치를 사용해 "자원R을 확보했다" 는 상태를 표현하고, 자원 R을 사용해야 하는 모든 작업은 이 래치의 관문이 열리기를 기다리도록 함
  - 의존성을 갖고 있는 다른 서비스가 시작하기 전에는 특정 서비스가 실행되지 않도록 막아야 하는 경우에 사용 가능. 각 서비스마다 이진 래치를 갖고 있으며, S라는 서비스를 시작하면 먼저 S가 의존성을 갖고 있는 모든 서비스의 래치가 열리기를 기다림 기다리던 모든 래치가 열리고 나면 서비스 S는 자신의 래치를 열어, 자신이 시작되기를 기다리는 서비스가 실행될 수 있도록 함
  - 특정 작업에 필요한 모든 객체가 실행할 준비를 갖출때까지 기다리는 경우에도 사용 가능 예를 들어 여러 사용자가 동시에 참여하는 게임을 쵲초에 시작하기 전에 모든 사용자가 게임을 시작할 준비가 끝났는지 확인하는데 요긴함. 이런 경우에는 모든 사용자가 준비됐다는 상태에 이르면 래치가 터미널 상태에 다다르게 구성할 수 있음
- CountDownLatch는 위에서 소개한 모든 경우에 쉽게 적용할 수 있는 유연한 구조를 갖고 있음 하나 또는 둘 이상의 스레드가 여러 개의 이벤트가 일어날 때까지 대기할 수 있도록 되어 있음
- 래치의 상태는 양의 정수값으로 카운터를 초기화하며, 이 값은 대기하는 동안 발생해야 하는 이벤트의 건수를 의미함
- CountDownLatch 클래스의 countDown 메서드는 대기하던 이벤트가 발생했을 때 내부에 갖고 있는 이벤트 카운터를 하나 낮춰주고 await 메서드는 래치의 내부의 카운터가 0이 될 때까지, 즉 대기하던 이벤트가 모두 발생했을 때까지 대기하도록 하는 메서드임. 외부 스레드가 wait메서드를 호출할 때 래치 내부의 카운터가 0 보다 큰 값이었다면, await메서드는 카운터가 0이 되거나. 대기하던 스레드에 인터럽트가 걸리거나, 대기 시간이 길어 타임아웃이 걸릴 때까지 대기함.

```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * TestHarness
 * <p/>
 * Using CountDownLatch for starting and stopping threads in timing tests
 *
 * @author Brian Goetz and Tim Peierls
 */
public class TestHarness {
    public long timeTasks(int nThreads, final Runnable task)
            throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);

        for (int i = 0; i < nThreads; i++) {
            Thread t = new Thread() {
                public void run() {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) {
                    }
                }
            };
            t.start();
        }

        long start = System.nanoTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end - start;
    }
}
```

- 스레드 run 내부에서 startGate.await();을 써서 스레드가 start 되어도 시작을 안하는건가?




### FutureTask

- FutureTask 역시 래치와 비슷한 형태로 동작함FutureTask 나타내는 연산 작업은 Callable인터페이스를 구현하도록 되어 있는데 시작전 대기, 시작됨, 종료됨과 같은 세가지 상태를 가질 수 있음
- 종료된 상태는 정상적인 종료, 취소, 예외 상황 발생과 같이 연산이 끝나는 모든 종류의 상태를 의미함
- FutureTask는 한번 종료 상태가 되면 더 이상 상태가 바뀌는 일이 없음
- FutureTask.get 메서드의 동작모습도 실행 상태에 따라 다름. FutureTask의 작업이 종료된 상태라면 그 즉시 결과를 알려주고 종료상태에 이르지 못했다면 종료 상태에 이를 때까지 대기하고, 종료된 이후에 연산 결과나 예외 상황을 알려줌.
- FutureTask는 Executor 프레임웍에서 비동기적인 작업을 싱해하고자 할 때 사용하고 기타 시간이 많이 필요한 모든 작업이 있을 때 실제 결과가 필요한 시점 이전에 미리 작업을 실행시켜두는 용도로 사용함



```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * Preloader
 *
 * Using FutureTask to preload data that is needed later
 *
 * @author Brian Goetz and Tim Peierls
 */

public class Preloader {
    ProductInfo loadProductInfo() throws DataLoadException {
        return null;
    }

    private final FutureTask<ProductInfo> future =
        new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
            public ProductInfo call() throws DataLoadException {
                return loadProductInfo();
            }
        });
    private final Thread thread = new Thread(future);

    public void start() { thread.start(); }

    public ProductInfo get()
            throws DataLoadException, InterruptedException {
        try {
            return future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof DataLoadException)
                throw (DataLoadException) cause;
            else
                throw LaunderThrowable.launderThrowable(cause);
        }
    }

    interface ProductInfo {
    }
}

class DataLoadException extends Exception { }
```

- Preloader 클래스는 FutureTask를 사용해 결과 값이 필요한 시점 이전에 시간이 많이 걸리는 작업을 미리 실행시켜둠
- 이런식으로 시간이 많이 걸리는 작업을 미리 시작시켜두면 실제로 결과를 필요로 하는 시점이 됐을 때 기다리는 시간을 줄일 수 있음
- start 메서드로 상품 정보를 미리 가져오는 작업을 하고 실제로 필요할때 get을 호출해서 전부 가져온상태라면 바로 리턴, 아닌경우엔 전부 가져오는 시점까지 기다리고 리턴하게됨

```java
package net.jcip.examples;

/**
 * StaticUtilities
 *
 * @author Brian Goetz and Tim Peierls
 */
public class LaunderThrowable {

    /**
     * Coerce an unchecked Throwable to a RuntimeException
     * <p/>
     * If the Throwable is an Error, throw it; if it is a
     * RuntimeException return it, otherwise throw IllegalStateException
     */
    public static RuntimeException launderThrowable(Throwable t) {
        if (t instanceof RuntimeException)
            return (RuntimeException) t;
        else if (t instanceof Error)
            throw (Error) t;
        else
            throw new IllegalStateException("Not unchecked", t);
    }
}
```



### 세마포어

- 카운팅 세머포어는 특정 자원이나 특정 연산을 동시에 사용하거나 호출할 수 있는 스레드의 수를 제한하고자 할 때 사용
- 세마포어는 데이터베이스 연결 풀과 같은 자원 풀에서 요긴하게 사용할 수 있음
- 자원 풀을 만들 때, 모든 자원을 빌려주고 남아 있는 자원이 없을 때 요청이 들어오는 경우에 대기시키게 할 수 있음 이럴 때 카운팅 세마포어를 만들면서 최초 퍼밋의 개수로 원하는 풀의 크기를 지정하고 acquire를 호출해 퍼밋을 확보하고 다 사용한 자원을 반납하고 난 다음에는 항상 release를 호출해 퍼밋도 반납하도록 함
- 만약 풀에 자원이 없을 경우에 acquire메서드가 대기 상태에 들어가기 때문에 객체가 반납될 때까지 자연스럽게 대기하게됨
- 이와 유사하게 세마포어를 사용하면 어떤 클래스라도 크기가 제한된 컬렉션 클래스로 활용할 수 있음
- 세마포어는 해당하는 컬렉션 클래스가 가질 수 있는 최대 크기에 해당하는 숫자로 초기화함
- add 메서드는 객체를 내부 데이터 구조에 추가하기 전에 acquire를 호출해 추가할 여유가 있는지 확인하고 만약 add 메서드가 내부 데이터구조에 실제로 값을 추가하지 못했다면 그 즉시 release를 호출해 세마포어에 퍼밋을 반납해야함 

```java
package net.jcip.examples;

import java.util.*;
import java.util.concurrent.*;

/**
 * BoundedHashSet
 * <p/>
 * Using Semaphore to bound a collection
 *
 * @author Brian Goetz and Tim Peierls
 */
public class BoundedHashSet <T> {
    private final Set<T> set;
    private final Semaphore sem;

    public BoundedHashSet(int bound) {
        this.set = Collections.synchronizedSet(new HashSet<T>());
        sem = new Semaphore(bound);
    }

    public boolean add(T o) throws InterruptedException {
        sem.acquire();
        boolean wasAdded = false;
        try {
            wasAdded = set.add(o);
            return wasAdded;
        } finally {
            if (!wasAdded)
                sem.release();
        }
    }

    public boolean remove(Object o) {
        boolean wasRemoved = set.remove(o);
        if (wasRemoved)
            sem.release();
        return wasRemoved;
    }
}
```



### 배리어

- 래치를 사용하면 여러 작업을 하나로 묶어 다음 작업으로 진행할 수 있는 관문과 같이 사용할 수 있다는 점을 앞에서 살펴봤음
- 래치는 일회성 객체, 래치가 한번 터미널 상태에 다다르면 다시는 이전 상태로 회복 불가
- 배리어는 특정 이벤트가 발생할 떄까지 여러 개의 스레드를 대기 상태로 잡아둘 수 있다는 측면에서 래치와 비슷하다고 볼 수 있지만 모든 스레드가 배리어 위치에 동시에 이르러야 관문이 열리고 계속해서 실행할 수 있다는 점이 래치와 다른점
- 래치는 이벤트를 기다리기 위한 동기화 클래스이고 배리어는 다른 스레드를 기다리기 위한 동기화 클래스임
- 배리어는 사람들이 어딘가에서 만날 약속을 하고 모두 도착할때 까지 대기 후 모두 도착하면 행동하는것과 같음
- CyclicBarrier클래스를 사용하면 여러 스레드가 특정한 배리어 포인트에서 반복적으로 만나는 기능을 모델링할 수 있고, 커다란 문제 하나를 여러 개의 작은 부분 문제로 분리해 반복적으로 병렬 처리하는 알고리즘을 구현하고자 할 때 적용하기 좋음
- 스레드는 각자 배리어 포인트에 다다르면 await메서드를 호출하고 await메서드는 모든 스레드가 배리어 포인트에 도달할 때까지 대기함 모든 스레드가 배리어 포인트에 도달하면 배리어는 모든 스레드를 통과시키고 await메서드에서 대기하고 있던 스레드는 대기 상태가 모두 풀려 실행되고 배리어는 다시 초기 상태로 돌아가 다음 배리어 포인트를 준비함 만약 타임아웃이나 인터럽트가 걸리면 배리어가 깨진것으로 간주하고 BrokenBarrierException이 발생함
- 배리어가 성공적으로 통과하면 await메서드는 각 스레드별로 배리어 포인트에 도착한 순서를 알려주고 다음 배리어 포인트로 반복 작업을 하는 동안 뭔가 특별한 작업을 진행할 일종의 리더를 선출하는데 이 값을 사용할 수 있음
- CyclicBarrier는 생성 메서드를 통해 배리어 작업을 넘겨받을 수 있도록 되어 있음. 배리어 작업은 Runnable인터페이스를 구현한 클래스인데 배리어 작업은 배리어가 성공적으로 통과된 이후 대기하던 스레드를 놓아주기 직전에 실행됨
- 배리어는 대부분 실제 작업은 모두 여러 스레드에서 병렬로 처리하고 다음 단계로 넘어가기 전에 이번 단계에서 계산해야 할 내용을 모두 취합해야 하는 등의 작업이  많이 일어나는 시뮬레이션 알고리즘에서 유용하게 사용 가능
- 배리어와 약간 다른 형태로 Exchanger클래스가 있음 Exchanger는 두 개의 스레드가 연결되는 배리어이고 배리어 포인트에 도달하면 양쪽의 스레드가 서로 갖고 있던 값을 교환함
- Exchanger클래스는 양쪽 스레드가 서로 대칭되는 작업을 수행할 때 유용함
- 예를 들어 한쪽 스레드는 데이터 버퍼에 값을 채워 넣는 일을 하고 다른 스레드는 데이터 버퍼에 있는 값을 빼내어 사용하는 일을 한다고 했을때 이 두개의 스레드를 Exchanger로 묶고 배리어 포인트에 도달할 때마다 데이터 버퍼를 교환하게 할 수 있음 교환은 안전한 공개 방법으로 되기 때문에 동시성 걱정  x
- 교환이 일어나는 타이밍은 전적으로 애플리케이션에 대한 요구사항. 데이터가 모두 채워질때 교환 또는 시간으로도 할 수 있음



```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * CellularAutomata
 *
 * Coordinating computation in a cellular automaton with CyclicBarrier
 *
 * @author Brian Goetz and Tim Peierls
 */
public class CellularAutomata {
    private final Board mainBoard;
    private final CyclicBarrier barrier;
    private final Worker[] workers;

    public CellularAutomata(Board board) {
        this.mainBoard = board;
        int count = Runtime.getRuntime().availableProcessors();
        this.barrier = new CyclicBarrier(count,
                new Runnable() {
                    public void run() {
                        mainBoard.commitNewValues();
                    }});
        this.workers = new Worker[count];
        for (int i = 0; i < count; i++)
            workers[i] = new Worker(mainBoard.getSubBoard(count, i));
    }

    private class Worker implements Runnable {
        private final Board board;

        public Worker(Board board) { this.board = board; }
        public void run() {
            while (!board.hasConverged()) {
                for (int x = 0; x < board.getMaxX(); x++)
                    for (int y = 0; y < board.getMaxY(); y++)
                        board.setNewValue(x, y, computeValue(x, y));
                try {
                    barrier.await();
                } catch (InterruptedException ex) {
                    return;
                } catch (BrokenBarrierException ex) {
                    return;
                }
            }
        }

        private int computeValue(int x, int y) {
            // Compute the new value that goes in (x,y)
            return 0;
        }
    }

    public void start() {
        for (int i = 0; i < workers.length; i++)
            new Thread(workers[i]).start();
        mainBoard.waitForConvergence();
    }

    interface Board {
        int getMaxX();
        int getMaxY();
        int getValue(int x, int y);
        int setNewValue(int x, int y, int value);
        void commitNewValues();
        boolean hasConverged();
        void waitForConvergence();
        Board getSubBoard(int numPartitions, int index);
    }
}
```



## 효율적이고 확장성 있는 결과 캐시 구현

- 거의 대부분의 서버 애플리케이션은 모두 어떤 형태이건 캐시를 사용함
- 이전에 처리했던 작업의 결과를 재사용할 수 있다면, 메모리를 조금 더 사용하기는 하지만 대기 시간으 크게 줄이고 처리 용량을 높일 수 있음

```java
package net.jcip.examples;

import java.math.BigInteger;
import java.util.*;

import net.jcip.annotations.*;

/**
 * Memoizer1
 *
 * Initial cache attempt using HashMap and synchronization
 *
 * @author Brian Goetz and Tim Peierls
 */
public class Memoizer1 <A, V> implements Computable<A, V> {
    @GuardedBy("this") private final Map<A, V> cache = new HashMap<A, V>();
    private final Computable<A, V> c;

    public Memoizer1(Computable<A, V> c) {
        this.c = c;
    }

    public synchronized V compute(A arg) throws InterruptedException {
        V result = cache.get(arg);
        if (result == null) {
            result = c.compute(arg);
            cache.put(arg, result);
        }
        return result;
    }
}


interface Computable <A, V> {
    V compute(A arg) throws InterruptedException;
}

class ExpensiveFunction
        implements Computable<String, BigInteger> {
    public BigInteger compute(String arg) {
        // after deep thought...
        return new BigInteger(arg);
    }
}
```

- 일반 HashMap으로 구현한  캐시 클래스
- 이런 방법은 쉽게 동시성을 얻어낼 수 있지만 확장성 측면에서 문제가 생김 특정 시점에 여러 스레드중 한 스레드만 compute를 실행할 수 있기 때문임
- ConcurrentHashMap 을 사용하면 해결할 수 있음

```java
package net.jcip.examples;

import java.util.*;
import java.util.concurrent.*;

/**
 * Memoizer2
 * <p/>
 * Replacing HashMap with ConcurrentHashMap
 *
 * @author Brian Goetz and Tim Peierls
 */
public class Memoizer2 <A, V> implements Computable<A, V> {
    private final Map<A, V> cache = new ConcurrentHashMap<A, V>();
    private final Computable<A, V> c;

    public Memoizer2(Computable<A, V> c) {
        this.c = c;
    }

    public V compute(A arg) throws InterruptedException {
        V result = cache.get(arg);
        if (result == null) {
            result = c.compute(arg);
            cache.put(arg, result);
        }
        return result;
    }
}
```

- 이런식으로 사용하면 훨씬 개선된 형태로 병렬프로그래밍을 할 수 있음
- 하지만 위 클래스도 문제점이 있음. 동시에 여러 스레드가 compute에 접근하고 동시에 cache.get() 을 호출한다면 동시에 result를 null 로 받는 상황이 있을 수 있고 그 결과 두번의 compute작업이 수행될 수 있음
- 이런 경우에 어떤 연산 x를 다른 스레드가 작업하고 있을때 스레드 A는 다른 스레드의 작업을 모두 끝낼때까지 대기하고 있다가 작업이 끝나면 x의 결과값으로 무엇을 얻었는가 라고 물어보면됨
- 이럴때 FutureTask를 쓰면 됨 



```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * Memoizer
 * <p/>
 * Final implementation of Memoizer
 *
 * @author Brian Goetz and Tim Peierls
 */
public class Memoizer <A, V> implements Computable<A, V> {
    private final ConcurrentMap<A, Future<V>> cache
            = new ConcurrentHashMap<A, Future<V>>();
    private final Computable<A, V> c;

    public Memoizer(Computable<A, V> c) {
        this.c = c;
    }

    public V compute(final A arg) throws InterruptedException {
        while (true) {
            Future<V> f = cache.get(arg);
            if (f == null) {
                Callable<V> eval = new Callable<V>() {
                    public V call() throws InterruptedException {
                        return c.compute(arg);
                    }
                };
                FutureTask<V> ft = new FutureTask<V>(eval);
                f = cache.putIfAbsent(arg, ft);
                if (f == null) {
                    f = ft;
                    ft.run();
                }
            }
            try {
                return f.get();
            } catch (CancellationException e) {
                cache.remove(arg, f);
            } catch (ExecutionException e) {
                throw LaunderThrowable.launderThrowable(e.getCause());
            }
        }
    }
}
```

- 위 클래스는 먼저 원하는 값에 대한 연산 작업이 시작됐는지를 확인해봄
- cache.putIfAbsent(arg, ft)가 병렬성을 보장하기 때문에 넘어오는 같은 원소에 대한 if(f == null) 에 대한 연산은 유니크하다고 생각함
- 실제 결과 값 대신 Future 객체를 캐시하는 방법은 이른바 캐시 공해를 유발할 수 있음 예를 들어 특정 시점에 시도했던 연산이 취소되거나 오류가 발생했었다면 Future 객체 역시 취소되거나 오류가 발생했던 상황을 알려줄 것임 이런 문제를 해소하기 위해 Memoizer 클래스는 연산이 취소된 경우엔 캐시에서 해당하는 Future객체를 제거함
- 만료기능은 FutureTask 클래스를 상속받아 만료된 결과인지 여부를 알 수 있는 새로운 클래스를 만들어 사용하고 결과 캐시를 주기적으로 돌아다니면서 만료된 결과 항목이 있느지 조사해 제거하는 기능을 구하는 것으로 간단하게 해결 가능함
- 아래는 실제 사용 예제

```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * Factorizer
 * <p/>
 * Factorizing servlet that caches results using Memoizer
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class Factorizer extends GenericServlet implements Servlet {
    private final Computable<BigInteger, BigInteger[]> c =
            new Computable<BigInteger, BigInteger[]>() {
                public BigInteger[] compute(BigInteger arg) {
                    return factor(arg);
                }
            };
    private final Computable<BigInteger, BigInteger[]> cache
            = new Memoizer<BigInteger, BigInteger[]>(c);

    public void service(ServletRequest req,
                        ServletResponse resp) {
        try {
            BigInteger i = extractFromRequest(req);
            encodeIntoResponse(resp, cache.compute(i));
        } catch (InterruptedException e) {
            encodeError(resp, "factorization interrupted");
        }
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    void encodeError(ServletResponse resp, String errorString) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[]{i};
    }
}
```



# 1부 요약

- 상태가 바뀔 수 있다
  - 병렬성과 관련된 모든 문제점은 변경 가능한 변수에 접근하려는 시도를 적절하게 조율하는 것으로 해결할 수 있다. 변경 가능성이 낮으면 낮을수록 스레드 안전성을 확보하기가 쉽다.
- 변경 가능한 값이 아닌 변수는 모두 final로 선언하라.
- 불변 객체는 항상 그 자체로 스레드 안전하다.
  - 불변 객체는 병렬 프로그램을 엄청나게 간편하게 작성할 수 있도록 해준다. 불변 객체는 간결하면서 안전하고, 락이나 방어적 복사 과정을 거치지 않고도 얼마든지 공유해 사용할 수 있다.
- 캡슐화하면 복잡도를 손쉽게 제어할 수 있다.
  - 모든 값을 전역 변수에 넣어 두더라도 프로그램을 스레드 안전하게 작성할 수는 있다. 하지만 도데체 무엇 때문에 그런 짓을 하는가? 데이터를 객체 내부에 캡슐화하면 값이 변경되는 자유도를 쉽게 제어할 수 있다. 객체 내부에서 동기화하는 기법을 캡슐화 하면 동기화 정책을 손쉽게 적용할 수 있다.
- 변경 가능한 객체는 항상 락으로 막아줘야 한다.
- 불변 조건 내부에 들어가는 모든 변수는 같은 락으로 막아줘야 한다.
- 복합 연산을 처리하는 동안에는 항상 락을 확보하고 있어야 한다.
- 여러 스레드에서 변경 가능한 변수의 값을 사용하도록 되어 있으면서 적절한 동기화 기법이 적용되지 않은 프로그램은 올바른 결과를 내놓지 못한다.
- 동기화할 필요가 없는 부분에 대해서는 일부러 머리를 써서 고민할 필요가 없다. 하지만 추측은 금물
- 설계 단계부터 스레드 안전성을 염두에 두고 있어야 한다. 아니면 최소한 결과물로 작성된 클래스가 스레드에 안전하지 않다고 반드시 문서로 남겨야 한다.
- 프로그램 내부의 동기화 정책에 대한 문서를 남겨야한다.





# #6 작업 실행

- 애플리케이션이 해야 할 일을 작업이라는 단위로 분할하면 프로그램의 구조를 간결하게 잡을 수 있고 트랜잭션의 범위ㅏ를 지정함으로써 오류에 효과적으로 대응할 수 있고 작업 실행 부분의 병렬성을 자연스럽게 극대화할 수 있음

## 스레드에서 작업 실행

- 프로그램에서 일어나는 일을 작업이라는 단위로 재구성하고자 한다면 가장 먼저 해야 할 일은 작업의 범위를 어디까지로 할 것인지 정하는 일임
- 원론적으로 작업은 완전히 독립적인 동작을 말함
- 작업을 스케줄링하거나 부하 분산을 하고자 할때 폭넓은 유연성을 위해서는 작업이 충분히 작은 부분을 담당하도록 구성되어야함
- 작업은 독립적이어야 적절한 자원이 확보된 상태에서 병렬로 실행될 수 있음
- 애플리케이션에 부하가 가해지면 점진적으로 성능이 떨어지도록 설계되어야하는데 이런 특성도 작업 단위의 범위를 적절하게 구성하고 실행하는 정책이 구성되어있어야함
- 서버 애플리케이션이 가장 쉽게 생각할 수 있는 작업의 단위는 바로 클라이언트의 요청 하나를 작업 하나로 볼 수 있음

### 작업을 순차적으로 실행

- 작업을 실행하는 가장 간단한 방법은 단일 스레드에서 작업 목록을 순차적으로 실행하는 방법

```java
package net.jcip.examples;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * SingleThreadWebServer
 * <p/>
 * Sequential web server
 *
 * @author Brian Goetz and Tim Peierls
 */

public class SingleThreadWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            Socket connection = socket.accept();
            handleRequest(connection);
        }
    }

    private static void handleRequest(Socket connection) {
        // request-handling logic here
    }
}
```

- 단순하지만 실제 상황에서는 성능이 엄청나게 떨어짐
- 만약 웹서버가 이전 클라이언트의 요청을 처리하는 도중이라면 다음에 요청을 전송한 클라이언트는 웹서버가 이전 작업을 끝내기만을 기다려야함
- 서버급에서는 이렇게 쓰면 안됨!



### 작업마다 스레드를 직접 생성

- 반응 속도를 훨씬 높일 수 있는 방법 가운데 하나는 요청이 들어올 때마다 새로운 스레드를 하나씩 만들어 실행시키는 방법

```java
package net.jcip.examples;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;

/**
 * ThreadPerTaskWebServer
 * <p/>
 * Web server that starts a new thread for each request
 *
 * @author Brian Goetz and Tim Peierls
 */
public class ThreadPerTaskWebServer {
    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                public void run() {
                    handleRequest(connection);
                }
            };
            new Thread(task).start();
        }
    }

    private static void handleRequest(Socket connection) {
        // request-handling logic here
    }
}
```

- 클라가 접속할때마다 반복문에서 해당 클라이언트의 요청 처리를 담당하는 새로운 스레드를 매번 생성한다는 차이점이 있음 이렇게 변경하면 크게 세가지 결과를 얻을 수 있음
  - 작업을 처리하는 기능이 메인 스레드에서 떨어져 나옴. 따라서 소켓을 받아주는 메인스레드가 대기할 필요가 없어서 서버의 응답 속도를 높여줌
  - 동시에 병렬로 작업을 처리할 수 있음
  - 실제 작업을 처리하는 스레드의 프로그램은 여러 클라가 접속하는 경우 동시에 동작할 가능성이 매우 높아서 스레드 안전성을 확보해야함
- 다만 클라가 접속해 요청을 전송하는 속도에 비해 요청을 처리해 응답을 넘겨주는 속도가 빨라야한다는 제약이 있고 이런 제약사항이 잘 지켜지면 괜찮은 응답 속도와 성능을 보여줌



### 스레드를 많이 생성할 때의 문제점

- 작업마다 스레드를 무한정 생성하는 것은 무리가 있음 이 경우 아래와 같은 단점이 발생

**스레드 라이프 사이클 문제**

- 스레드를 생성하고 제거하는 작업에도 자원이 소모됨
- 만약 클라의 요청 내용이 간단하고 자주 발생하는 유형이라면 요청과 스레드의 생성/삭제 비용이 비례하기 때문에 전체 작업엣서 많은 부분을 차지할 수 있음

**자원 낭비**

- 실행 중인 스레드는 시스템의 자원, 특히 메모리를 소모함
- 하드웨어에 장착되어 있는 프로세서보다 많은 수의 스레드가 만들어져 동작중이라면 실제로는 대부분의 스레드가 대기 상태에 머무름
- 대기 상태가 많을수록 스레드가 소모하는 메모리가 많아짐
- 대기하는 스레드들은 cpu를 사용하기 위해 경쟁하는 모양이되기 때문에 메모리 이외에도 많은 자원을 소모함
- cpu의 개수에 해당하는 스레드가 동작중이라면, 스레드를 더 만들어 낸다 해도 성능이 직접적으로 개선되지 않을 수 있고 악영향을 미칠 가능성이 있음

**안전성 문제**

- 모든 시스템에는 생성할 수 있는 스레드의 개수가 제한되어 있음
- 플랫폼, os, jvm 등등 여러가지 요인에 따라 달라짐
- 제한된 양을 초과한다면 OOM이 발생하는데 이미 OOM이 발생한 상황에서는 오류를 바로잡을 수 있는 방법이 별로 없고 미연에 방지하는게 훨씬 쉬움

- 특정 수준을 넘어간다면 성능이 떨어지는게 핵심
- 따라서 애플리케이션이 만들어 낼 수 있는 스레드의 수에 제한을 두는 것이 현명한 방법이고 만약 높은 양의 작업 요청이 왔을때 자원이 고갈되어 멈추는 경우가 발생하지 않는지를 세심하게 테스트해봐야함



## Executor 프레임웍

- 작업은 논리적인 업무의 단위이고 스레드는 특정 작업을 비동기적으로 동작시킬 수 있는 방법을 제공함
- Executor 프레임웍의 일부분으로 유연하게 사용할 수 있는 스레드 풀이 만들어져 있음 스레드풀은 스레드를 관리하는 측면에서 통제력을 갖출 수 있도록 해줌
- Executor는 아주 다양한 여러가지 종류의 작업 실행 정책을 지원하는 유연하면서도 강력한 비동기적 작업 실행 프레임웍의 근간을 이루는 인터페이스임
- Executor는 작업 등록과 작업 실행을 분리하는 표준적인 방법이고 각 작업은 Runnable의 형태로 정의
- Executor 인터페이스를 구현한 클래스는 작업의 라이프사이클을 관리하는 기능도 갖고 있고 몇가지 통계 값을 뽑아내거나 또는 애플리케이션에서 작업 실행 과정을 관리하고 모니터링하기 위한 기능도 갖고 있음
- Executor의 구조는 프로듀서-컨슈머 패턴에 기반하고 있고 프로듀서-컨슈머 패턴을 적용해 구현할 수 있는 가장 쉬운 방법이 Executor 프레임웍을 사용하는 것



### 예제: Executor를 사용한 웹서버

```java
package net.jcip.examples;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.*;

/**
 * TaskExecutionWebServer
 * <p/>
 * Web server using a thread pool
 *
 * @author Brian Goetz and Tim Peierls
 */
public class TaskExecutionWebServer {
    private static final int NTHREADS = 100;
    private static final Executor exec
            = Executors.newFixedThreadPool(NTHREADS);

    public static void main(String[] args) throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (true) {
            final Socket connection = socket.accept();
            Runnable task = new Runnable() {
                public void run() {
                    handleRequest(connection);
                }
            };
            exec.execute(task);
        }
    }

    private static void handleRequest(Socket connection) {
        // request-handling logic here
    }
}
```

- 웹서버를 구현할 때 Executor를 적용하면 작업이 굉장히 간단해짐
- Executor에 필요한 설정은 대부분 초기에 한 번 지정하는 것이 보통이며 처음 실행하는 시점에 설정 값을 지정하는 편이 좋음
- 이런식으로 처리할 작업을 execute 메서드로 등록해두면 Executor 내부의 큐에 쌓이고, Executor 내부의 풀에 있는 스레드가 큐에 쌓여 있는 작업을 하나씩 뽑아내 처리하게 되어 있음



```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * ThreadPerTaskExecutor
 * <p/>
 * Executor that starts a new thread for each task
 *
 * @author Brian Goetz and Tim Peierls
 */
public class ThreadPerTaskExecutor implements Executor {
    public void execute(Runnable r) {
        new Thread(r).start();
    };
}
```

- 작업마다 스레드를 새로 생성시키는 Executor

```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * WithinThreadExecutor
 * <p/>
 * Executor that executes tasks synchronously in the calling thread
 *
 * @author Brian Goetz and Tim Peierls
 */
public class WithinThreadExecutor implements Executor {
    public void execute(Runnable r) {
        r.run();
    };
}
```

- 작업을 등록한 스레드에서 직접 동자시키는 Executor



### 실행 정책

- 작업을 등록하는 부분과 실행하는 부분을 서로 분리시켜두면 특정 작업을 실행하고자 할 때 코드를 많이 변경하거나 기타 여러 가지 어려운 상황에 맞닥뜨리지 않으면서도 실행 정책을 언제든지 쉽게 변경할 수 있다는 장점이 있음
- 실행 정책은 다음과 같이 무엇을, 어디에서, 언제, 어떻게 실행하는지를 지정할 수 있음
  - 작업을 어느 스레드에서 실행할 것인가?
  - 작업을 어떤 순서로 실행할 것인가?
  - 동시에 몇개의 작업을 병렬로 실행할 것인가?
  - 최대 몇 개까지의 작업이 큐에서 실행을 대기할 수 있게 할 것인가?
  - 시스템에 부하가 많이 걸려서 작업을 거절해야 하는 경우, 어떤 작업을 희생양으로 삼아야 할 것이며, 작업을 요청한 프로그램에 어떻게 알려야 할 것인가?
  - 작업을 실행하기 직전이나 실행한 직후에 어떤 동작이 있어야 하는가?
- 실행 정책은 일종의 자원 관리 도구라고 할 수 있음
- 가장 최적화된 실행 정책을 찾으려면 하드웨어나 소프트웨어 적인 자원을 얼마나 확보할 수 있는지 확인해야 함
- 병렬로 실행되는 스레드의 수를 제한한다면 제한된 자원을 서로 사용하기 위해 경쟁하느라 앱의 성능이 떨어지는 일은 별로 보기 힘들것
- 프로그램 어디선간에 스레드를 직접 생성하는 부분이 있다면 Executor를 사용해 구현하는 방안을 심각하게 고민해봐야함



### 스레드 풀

- 스레드 풀은 이름 그대로 작업을 처리할 수 있는 동일한 형태의 스레드를 풀 형태로 관리함
- 일반적으로 스레드 풀은 풀 내부의 스레드로 처리할 작업을 쌓아둬야 하기 때문에 작업 큐와 굉장히 밀접한 관련이 있음
- 작업스레드는 작업 큐에서 실행할 다음 작업을 가져오고 실행, 가져와 실행할 다음 작업이 나타날 때까지 대기하는 일으 반복
- 풀 내부의 스레드를 사용해 작업을 실행하는 방법을 사용하면 매번 스레드를 생성하는 대신 스레드를 재사용하기 때문에 시스템 자원이 줄어드는 효과가 있음
- 스레드 풀의 크기를 적절히 조절해두면 하드웨어 프로세서가 쉬지 않고 동작하도록 할 수 있고 여러 스레드가 한정된 자원을 두고 서로 경쟁하느라 성능을 까먹는 현상도 없앨 수 있음
- 자바는 여러가지 설정 상태에 맞춰 몇가지 종류의 스레드 풀을 제공함 미리 제공되어 있는 Executors 클래스에 제공되는 메서드 목록
  - newFixedThreadPool: 처리할 작업이 등록되면 그에 따라 실제 작업할 스레드를 하나씩 생성. 생성할 수 있는 스레드의 최대 개수는 제한되어 있고 제한된 개수까지 스레드를 생성하고 나면 더 이상 생성하지 않고 스레드 수를 유지함
  - newCachedThreadPool: 캐시 스레드 풀은 현재 풀에 갖고 있는 스레드의 수가 처리할 작업의 수보다 많아서 쉬는 스레드가 많이 발생할 때 쉬는 스레드를 종료시켜 훨씬 융녀하게 대응할 수 있고 처리할 작업의 수가 많아지면 필요한 만큼 스레드를 새로 생성함. 반면에 수레드의 수에는 제한을 두지 않음
  - newSingleThreadExcutor: 단일 스레드로 동작하는 Executor로서 작업을 처리하는 스레드가 단 하나뿐 만약 작업 중에 비정상적으로 종료되면 다시 하나를 생성해 나머지 작업을 실행함 등록된 작업은 설정된 큐의 우선순위 FIFO, LIFO 에 따라 반드시 순차적으로 처리됨
  - newScheduledThreadPool: 일정 시간 이후에 실행하거나 주기적으로 작업을 실행할 수 있고 스레드의 수가 고정되어 있는 형태의 Executor.Timer 클래스의 기능과 유사함
- newFixedThreadPoolr과 newCachedThreadPool 팩토리 메서드는 일반화된 형태로 구현되어 있는 ThreadPoolExecutor클래스의 인스턴스를 생성함
- 작업별로 스레드를 생성하는 전략에서 풀을 기반으로 하는 전략으로 변경하면 안정성 측면에서 엄청난 장점을 얻을 수 있음

### Executor 동작 주기

- Executor를 구현하는 클래스는 대부분 작업을 처리하기 위한 스레드를 생성하도록 되어 있음
- jvm은 모든 스레드가 종료되기 전에는 종료하지 않고 대기하기 때문에 Executor를 제대로 종료하지 않으면 jvm자체가 종료되지 않고 대기하기도함
- Executor는 작업을 비동기적으로 실행하기 때문에 앞서 실행시켰던 작업의 상태를 특정 시점에 정확하게 파악하기 어려움 특정 작업이 종료되었는지에 대한 여부에 따라 강제종료 또는 graceful 하게 종료해야함
- 서비스를 실행하는 동작 주기와 관련해 Executor를 상속받은 ExecutorService 인터페이스에는 동작 주기를 관리할 수 있는 여러가지 메서드가 추가되어 있음

| **Method Summary**    |                                                              |
| --------------------- | ------------------------------------------------------------ |
| ` boolean`            | `**[awaitTermination](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#awaitTermination(long, java.util.concurrent.TimeUnit))**(long timeout, TimeUnit unit)`      Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first. |
| `<T> List<Future<T>>` | `**[invokeAll](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#invokeAll(java.util.Collection))**(Collection<Callable<T>> tasks)`      Executes the given tasks, returning a list of Futures holding their status and results when all complete. |
| `<T> List<Future<T>>` | `**[invokeAll](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#invokeAll(java.util.Collection, long, java.util.concurrent.TimeUnit))**(Collection<Callable<T>> tasks, long timeout, TimeUnit unit)`      Executes the given tasks, returning a list of Futures holding their status and results when all complete or the timeout expires, whichever happens first. |
| `<T> T`               | `**[invokeAny](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#invokeAny(java.util.Collection))**(Collection<Callable<T>> tasks)`      Executes the given tasks, returning the result of one that has completed successfully (i.e., without throwing an exception), if any do. |
| `<T> T`               | `**[invokeAny](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#invokeAny(java.util.Collection, long, java.util.concurrent.TimeUnit))**(Collection<Callable<T>> tasks, long timeout, TimeUnit unit)`      Executes the given tasks, returning the result of one that has completed successfully (i.e., without throwing an exception), if any do before the given timeout elapses. |
| ` boolean`            | `**[isShutdown](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#isShutdown())**()`      Returns `true` if this executor has been shut down. |
| ` boolean`            | `**[isTerminated](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#isTerminated())**()`      Returns `true` if all tasks have completed following shut down. |
| ` void`               | `**[shutdown](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#shutdown())**()`      Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. |
| ` List<Runnable>`     | `**[shutdownNow](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#shutdownNow())**()`      Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution. |
| `<T> Future<T>`       | `**[submit](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#submit(java.util.concurrent.Callable))**(Callable<T> task)`      Submits a value-returning task for execution and returns a Future representing the pending results of the task. |
| ` Future<?>`          | `**[submit](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable))**(Runnable task)`      Submits a Runnable task for execution and returns a Future representing that task. |
| `<T> Future<T>`       | `**[submit](https://docs.oracle.com/javase/1.5.0/docs/api/java/util/concurrent/ExecutorService.html#submit(java.lang.Runnable, T))**(Runnable task, T result)`      Submits a Runnable task for execution and returns a Future representing that task that will upon completion return the given result |

-  내부적으로 ExcutorService가 갖고 있는 동작 주기에는 실행중, 종료중, 종료의 세가지 상태가 있음
- ExecutorService를 통해 graceful, 또는 강제종료 등등의 처리를 할 수 있음

```java
package net.jcip.examples;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.*;
import java.util.logging.*;

/**
 * LifecycleWebServer
 * <p/>
 * Web server with shutdown support
 *
 * @author Brian Goetz and Tim Peierls
 */
public class LifecycleWebServer {
    private final ExecutorService exec = Executors.newCachedThreadPool();

    public void start() throws IOException {
        ServerSocket socket = new ServerSocket(80);
        while (!exec.isShutdown()) {
            try {
                final Socket conn = socket.accept();
                exec.execute(new Runnable() {
                    public void run() {
                        handleRequest(conn);
                    }
                });
            } catch (RejectedExecutionException e) {
                if (!exec.isShutdown())
                    log("task submission rejected", e);
            }
        }
    }

    public void stop() {
        exec.shutdown();
    }

    private void log(String msg, Exception e) {
        Logger.getAnonymousLogger().log(Level.WARNING, msg, e);
    }

    void handleRequest(Socket connection) {
        Request req = readRequest(connection);
        if (isShutdownRequest(req))
            stop();
        else
            dispatchRequest(req);
    }

    interface Request {
    }

    private Request readRequest(Socket s) {
        return null;
    }

    private void dispatchRequest(Request r) {
    }

    private boolean isShutdownRequest(Request r) {
        return false;
    }
}
```



### 지연 작업, 주기적 작업

- Timer 클래스를 사용하면 특정 시간 이후에 원하는 작업을 실행하는 지연 작업이나 주기적인 작업을 실행할 수 있으나 Timer 자체로 약간의 단점이 있개 때문에 가능하면 ScheduledThreadPoolExecutor를 사용하는 방법을 생각해 보는 것이 좋음 (ScheduledThreadPoolExecutor는 상대 시각만 지원)
- Timer클래스는 스레드 하나만 생성해서 사용하는데 만약 등록된 특정 작업이 너무 오래 실행된다면 등록된 다른 TimerTask작업이 예정된 시각에 실행되지 못할 가능성이 높음
- ScheduledThreadPoolExecutor은 지연 작업과 주기적 작업마다 여러 개의 스레드를 할당해 작업을 실행해서 실행 예정 시각을 벗어나는 일이 없도록 조절해줌
- Timer 클래스의 또 다른 단점은 TimerTask가 동작하던 도중에 예상치 못한 예외를 발생하면 스레드 자체가 멈출 가능성도 있음 그리고 종료된 스레드는 새롭게 생성되지 않음 <= 모든 작업이 취소

```java
package net.jcip.examples;

import java.util.*;
import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * OutOfTime
 * <p/>
 * Class illustrating confusing Timer behavior
 *
 * @author Brian Goetz and Tim Peierls
 */

public class OutOfTime {
    public static void main(String[] args) throws Exception {
        Timer timer = new Timer();
        timer.schedule(new ThrowTask(), 1);
        SECONDS.sleep(1);
        timer.schedule(new ThrowTask(), 1);
        SECONDS.sleep(5);
    }

    static class ThrowTask extends TimerTask {
        public void run() {
            throw new RuntimeException();
        }
    }
}
```



## 병렬로 처리할 만한 작업

### 예제: 순차적 페이지 렌더링



# #7 중단 및 종료

- 작업이나 스레드를 시작시키기는 쉽지만 시작된 작업이 언제 끝날지는 끝까지 가봐야 알 수 있음
- 작업이나 스레드를 안전하고 빠르게 멈추게 하는 것을 어려운 일임
- 자바에는 스레드가 작업을 실행하고 있을 때 강제로 멈추도록 하는 방법이 없음. 인터럽트라는 방법이 있는데 인터럽트는 특정 스레드에게 작업을 멈춰 달라고 요청하는 형태임
- 실제 상황에서 특정 스레드나 서비스를 즉시 멈춰야할 경우는 거의 없고 강제로 종료하게 되면 공유되어 있는 여러가지 상태가 비정상적인 상태에 빠질 수 있기 때문에 스레드 간의 협력을 통한 접근 방법이 올바르다고 할 수 있음
- 작업이나 스레드가 작업을 멈출 수 있도록 구성해두면 시스템의 유연성이 크게 늘어남

## 작업 중단

- 외부 프로그램이 특정 작업의 정상적인 실행 상태 진행 순서를 뛰어 넘어 종료 상태에 이르도록 할 수 있다면 이 작업은 취소 가능하다고 함
- 실행중인 작업을 취소하고자 하는 요구사항은 여러가지 경우에 나타남
  - 사용자가 취소하기를 요청한 경우
  - 시간이 제한된 작업
  - 애플리케이션 이벤트
  - 오류
  - 종료
- 자바에서는 특정 스레드를 임의로 종료할 수 없음
- 작업을 실행하는 스레드와 작업을 취소했으면 한다고 요청하는 스레드가 함께 작업을 멈추는 협력적인 방법을 사용해야함
- 협력적인 방법중 가장 간단한 방법은 취소 요청과 관련된 플래그를 설정하는 것 <= 취소 요청과 관련된 플래그는 안정적으로 동작하기 위해 반드시 volatile 형식으로 선언해야함

```java
package net.jcip.examples;

import static java.util.concurrent.TimeUnit.SECONDS;
import java.math.BigInteger;
import java.util.*;
import java.util.concurrent.*;

import net.jcip.annotations.*;

/**
 * PrimeGenerator
 * <p/>
 * Using a volatile field to hold cancellation state
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class PrimeGenerator implements Runnable {
    private static ExecutorService exec = Executors.newCachedThreadPool();

    @GuardedBy("this") private final List<BigInteger> primes
            = new ArrayList<BigInteger>();
    private volatile boolean cancelled;

    public void run() {
        BigInteger p = BigInteger.ONE;
        while (!cancelled) {
            p = p.nextProbablePrime();
            synchronized (this) {
                primes.add(p);
            }
        }
    }

    public void cancel() {
        cancelled = true;
    }

    public synchronized List<BigInteger> get() {
        return new ArrayList<BigInteger>(primes);
    }

    static List<BigInteger> aSecondOfPrimes() throws InterruptedException {
        PrimeGenerator generator = new PrimeGenerator();
        exec.execute(generator);
        try {
            SECONDS.sleep(1);
        } finally {
            generator.cancel();
        }
        return generator.get();
    }
}
```

- 위 예제는 소수 계산 작업 스레드를 실행시킨 다음 1초 후에 소수 계산 작업을 멈추도록 하는 예제
- 작업의 취소를 쉽게 만드려면 취소 정책을 명확히 정의해야함 외부에서 어떤 방법으로 취소 요청을 보낼 수 있는지, 작업 내부에서 취소 요청이 들어왔을때를 언제 확인하는지 등등
- 위와같이 취소 요청 플래그를 사용하는 경우엔 BlockingQueue같은 자료구조에 대한 사용을 굉장히 조심해야함

```java
package net.jcip.examples;

import java.math.BigInteger;
import java.util.concurrent.*;

/**
 * BrokenPrimeProducer
 * <p/>
 * Unreliable cancellation that can leave producers stuck in a blocking operation
 *
 * @author Brian Goetz and Tim Peierls
 */
class BrokenPrimeProducer extends Thread {
    private final BlockingQueue<BigInteger> queue;
    private volatile boolean cancelled = false;

    BrokenPrimeProducer(BlockingQueue<BigInteger> queue) {
        this.queue = queue;
    }

    public void run() {
        try {
            BigInteger p = BigInteger.ONE;
            while (!cancelled)
                queue.put(p = p.nextProbablePrime());
        } catch (InterruptedException consumed) {
        }
    }

    public void cancel() {
        cancelled = true;
    }
}

```

- BQ가 꽉찬상태에서 프로듀서는 put() 실행 대기상태
- 컨슈머가 프로듀서의 cancel() 호출 후 더이상의 poll()을 실행하지 않을경우 BQ는 소비되지 않으므로 프로듀서의 put()은 영원히 락이 걸린 상태가됨





### 인터럽트

- 블로킹 될 수 있는 라이브러리 가운데 일부는 인터럽트를 걸 수 있음
- 스레드에게 거는 인터럽트는 특정 스레드에게 정당한 상황이고 작업을 멈추려는 의지가 있는 상황이라면 현재 실행 중이던 작업을 멈추고 다른 일을 할 수 있도록 해야 한다고 신호를 보내는 것과 같음
- 모든 스레드는 불린 값으로 인터럽트 상태를 갖고 있음
- 스레드에는 인터럽트 관련한 메서드가 있음
- interrupt 메서드는 해당하는 스레드에 인터럽트를 거는 역할을 하고 isInterrupted 메서드는 해당 스레드에 인터럽트가 걸려 있는지를 알려줌. 스태틱으로 선언된 interrupted 메서드를 호출하면 현재 스레드의 인터럽트 상태를 해제하고, 해제하기 이전의 값이 무엇이었는지를 알려줌. interrupted 메서드는 인터럽트 상태를 해제할 수 있는 유일한 방법
- Thread.sleep 이나 Object.wait 메서드와 같은 블로킹 메서드는 인터럽트 상태를 확인하고 있다가 인터럽트가 걸리면 즉시 리턴됨
- Thread.sleep 이나 Object.wait 메서드에서 대기하던 중에 인터럽트가 걸리면 인터럽트 상태를 해제하면서 InterruptedExecption을 던짐
- 스레드가 블록되어 있지 않은 실행 상태에서 인터럽트가 걸리면 상태변수가 설정되기는 하지만 그에 대응하는 일은 스레드가 알아서 해야함
- 특정 스레드의 interrupt 메서드를 호출한다 해도 해당 스레드가 처리하던 작업을 멈추지는 않음
- 인터럽트를 이해하고자 할 때 중요한 사항은 바로 실행중인 스레드에 실제적인 제한을 가해 멈추도록 하지 않는다는 것. 단지 해당 스레드가 상황을 봐서 스스로 멈춰주기를 요청하는 것일 뿐
- 인터럽트에 의해 반응하는 블로킹 메서드를 상대적으로 적게 사용하고 있다면 반복문의 조건 확인 부분에서 인터럽트 여뷰를 확인하는 방법으로 응답 속도를 개선할 수 있음

```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * NoncancelableTask
 * <p/>
 * Noncancelable task that restores interruption before exit
 *
 * @author Brian Goetz and Tim Peierls
 */
public class NoncancelableTask {
    public Task getNextTask(BlockingQueue<Task> queue) {
        boolean interrupted = false;
        try {
            while (true) {
                try {
                    return queue.take();
                } catch (InterruptedException e) {
                    interrupted = true;
                    // fall through and retry
                }
            }
        } finally {
            if (interrupted)
                Thread.currentThread().interrupt();
        }
    }

    interface Task {
    }
}
```



### 인터럽트 정책

- 단일 작업마다 해당 작업을 멈출 수 있는 취소 정책이 있는 것처럼 스레드 역시 인터럽트 처리 정책이 있어야함
- 일반적으로 가장 범용적인 인터럽트 정책은 스레드 수준이나 서비스 수준에서 작업 중단 기능을 제공하는 것
- 작업은 그 작업을 소유하는 스레드에서 실행하지 않고 스레드 풀과 같이 실행만 전담하는 스레드를 빌려 사용하게 되는데 작업을 시키는 스레드는 작업을 하는 스레드의 인터럽트 상태를 그대로 유지해 스레드를 실행시킨(소유한)  프로그램이 인터럽트 상태에 직접 대응할 수 있도록 해야함  <= 뭔말?
- 블로킹 메서드를 스스로의 스레드에서 실행하는 일은 전혀없기 때문에 실행중에 최대한 빨리 작업을 중단하고 자신을 호출한 스레드에게 전달받은 인터럽트 요청을 넘겨 인터럽트에 대응해 추가적인 작업을 할 수 있도록 배려하는 정책을 구현하고 있음
- 자신을 실행하는 스레드에서 적용하고 있는 인터럽트 정책에 대해 어떠한 가정도 해서는 안됨
- 작업 실행 도중에 인터럽트가 걸렸을 때 인터럽트 상황을 작업 중단이라는 의미로 해석할 수도 있고 인터럽트에 대응해 뭔가 작업을 처리할 수 있지만 어쨌든 작업을 실행중인 스레드의 인터럽트 상태는 그대로 유지시켜야 함
- 가장 일반적인 방법은 InterruptedException을 던지는것인데 그렇게 하지 못한다 하면 Thread.currentThread().interrupt(); 이런 코드로 스레드의 인터럽트 상태를 유지해야함
- 작업 취소 기능을 담당하는 코드 역시 각종 스레드에 대한 인터럽트 정책이 어떻다고 섣불리 가정하면 안됨
- 스레드에는 해당 스레드를 소유하는 클래스에서만 인터럽트를 걸어야함
- 각 스레드는 각자의 인터럽트 정책을 갖고 있음. 따라서 해당 스레드에서 인터럽트 요청을 받았을 때 어떻게 동작할지를 정확하게 알고 있지 않은 경우에는 함수로 인터럽트를 걸어서는 안됨



### 인터럽트에 대한 대응

- Thread.sleep이나 BlockingQueue.put 메서드와 같이 인터럽트를 걸 수 있는 블로킹 메서드를 호출하는 경우에 InterruptedException이 발생했을 때 처리할 수 있는 실질적인 방법은 대략 두가지가 있음
  - 발생한 예외를 호출 스택의 상위 메서드로 전달. 이 방법을 사용하는 메서드 역시 인터럽트를 걸 수 있는 블로킹 메서드가됨
  - 호출 스택의 상단에 위치한 메서드가 직접 처리할 수 있도록 인터럽트 상태를 유지함
- 스레드의 인터럽트 처리 정책을 정확하게 구현하는 작업만이 인터럽트 요청을 삼켜버릴 수 있음. 일반적인 용도로 작성된 작업이나 라이브러리 메서드는 인터럽트 요청을 그냥 삼키면 안됨
- 작업 중단 기능을 지원하지 않으면서 인터럽트를 걸 수 있는 블로킹 메서드를 호출하는 작업은 인터럽트가 걸렸을 때 블로킹 메서드의 기능을 자동으로 재시도하도록 반복문 내부에서 블로킹 메서드를 호출하도록 구성하는 것이 좋음

```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * NoncancelableTask
 * <p/>
 * Noncancelable task that restores interruption before exit
 *
 * @author Brian Goetz and Tim Peierls
 */
public class NoncancelableTask {
    public Task getNextTask(BlockingQueue<Task> queue) {
        boolean interrupted = false;
        try {
            while (true) {
                try {
                    return queue.take();
                } catch (InterruptedException e) {
                    interrupted = true;
                    // fall through and retry
                }
            }
        } finally {
            if (interrupted)
                Thread.currentThread().interrupt();
        }
    }

    interface Task {
    }
}
```

- 인터럽트 상태를 종료 직전에 복구시키는 중단 불가능한 작업

### 예제: 시간 지정 실행

```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * InterruptBorrowedThread
 * <p/>
 * Scheduling an interrupt on a borrowed thread
 *
 * @author Brian Goetz and Tim Peierls
 */
public class TimedRun1 {
    private static final ScheduledExecutorService cancelExec = Executors.newScheduledThreadPool(1);

    public static void timedRun(Runnable r,
                                long timeout, TimeUnit unit) {
        final Thread taskThread = Thread.currentThread();
        cancelExec.schedule(new Runnable() {
            public void run() {
                taskThread.interrupt();
            }
        }, timeout, unit);
        r.run();
    }
}
```

- Runnable을 구현한 임의의 작업을 일정 시간동안만 실행하도록 작성된 코드인데 스레드에 인터럽트를 걸 때 대상 스레드의 인터럽트 정책을 알고 있어야 한다는 규칙을 어기고 있음 이렇게 쓰면 안됨 !
- timedRun은 외부의 어떤 스레드에서도 호출될 수 있지만 호출하는 스레드의 인터럽트 정책은 알 수 없음
- 스레드가 작업이 다끝난 뒤에 인터럽트가 걸릴 수 있음

```java
package net.jcip.examples;

import java.util.concurrent.*;
import static java.util.concurrent.Executors.newScheduledThreadPool;
import static net.jcip.examples.LaunderThrowable.launderThrowable;

/**
 * TimedRun2
 * <p/>
 * Interrupting a task in a dedicated thread
 *
 * @author Brian Goetz and Tim Peierls
 */
public class TimedRun2 {
    private static final ScheduledExecutorService cancelExec = newScheduledThreadPool(1);

    public static void timedRun(final Runnable r,
                                long timeout, TimeUnit unit)
            throws InterruptedException {
        class RethrowableTask implements Runnable {
            private volatile Throwable t;

            public void run() {
                try {
                    r.run();
                } catch (Throwable t) {
                    this.t = t;
                }
            }

            void rethrow() {
                if (t != null)
                    throw launderThrowable(t);
            }
        }

        RethrowableTask task = new RethrowableTask();
        final Thread taskThread = new Thread(task);
        taskThread.start();
        cancelExec.schedule(new Runnable() {
            public void run() {
                taskThread.interrupt();
            }
        }, timeout, unit);
        taskThread.join(unit.toMillis(timeout));
        task.rethrow();
    }
}
```

- 작업을 실행하도록 생성한 스레드에는 적절한 실행 정책을 따로 정의할 수도 있고 작업이 인터럽트에 응답하지 않는다 해도 시간이 제한된 메서드 자체는 호출한 메서드에게 리턴됨 <= 어려움
- 여전히 있는 문제점으로 timedRun 메서드가 리턴됐을 때 정상적으로 스레드가 종료된 것인지, join 메서드 타임아웃이 걸린것인지를 알 수 없다는 단점이 있음

### Future를 사용해 작업 중단

- 라이브러리에 필요한 기능을 제공하는 클래스가 있다면 직접 구현보다 라이브러리 클래스를 사용하는게 좋음
- ExecutorService.submit은 등록한 작업을 나타내는 Future인스턴스를 리턴하고 Future의 cancel 메서드는 mayInterruptIfRunningd이라는 불린 값을 넘겨 받으며 취소 요청에 따른 작업 중단 시도가 성공적이었는지 알려주는 결과 값을 리턴받을 수 있음 여기에서의 성공여부는 인터럽트가 제대로 걸렸는지에 대한 여부이고 해당 작업이 실제 인터럽트에 의해 종료되었는지에 대한 여부는 아님
- mayInterruptIfRunning 값이 false이면 아직 실행하지 않았다면 실행시키지 말아라 라는 의미로 해석. 인터럽트에 대응하도록 만들어지지 않은 작업에는 항상 false를 넘겨줘야함
- 작업을 중단하려 할 때는 항상 스레드에 직접 인터럽트를 거는 대신 Future의 cancel 메서드를 사용해야함

```java
package net.jcip.examples;

import java.util.concurrent.*;
import static net.jcip.examples.LaunderThrowable.launderThrowable;

/**
 * TimedRun
 * <p/>
 * Cancelling a task using Future
 *
 * @author Brian Goetz and Tim Peierls
 */
public class TimedRun {
    private static final ExecutorService taskExec = Executors.newCachedThreadPool();

    public static void timedRun(Runnable r,
                                long timeout, TimeUnit unit)
            throws InterruptedException {
        Future<?> task = taskExec.submit(r);
        try {
            task.get(timeout, unit);
        } catch (TimeoutException e) {
            // task will be cancelled below
        } catch (ExecutionException e) {
            // exception thrown in task; rethrow
            throw launderThrowable(e.getCause());
        } finally {
            // Harmless if task already completed
            task.cancel(true); // interrupt if running
        }
    }
}
```

-  필요한 작업을 ExecutorService를 통해 실행하고 실행한 결과를 Future.get 메서드로 찾아오도록 구현된 또 다른 버전의 timedRun 메서드
- Future.get 메서드에서 IterruptedException이 발생하거나 TimeoutException이 발생 했을 때, 만약 예외 상황이 발생한 작업의 결과는 필요없다고 한다면 해당 작업에 대해 Future.cancel 메서드를 호출해 작업을 중단시킬것



### 인터럽트에 응답하지 않는 블로킹 작업 다루기

- 자바의 거의 모든 블로킹 메서드는 인터럽트가 잘생하는 즉시 멈추면서 InterruptedException을 띄우도록 되어있으나 아닌 경우도 있음.

```java
package net.jcip.examples;

import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;

/**
 * ReaderThread
 * <p/>
 * Encapsulating nonstandard cancellation in a Thread by overriding interrupt
 *
 * @author Brian Goetz and Tim Peierls
 */
public class ReaderThread extends Thread {
    private static final int BUFSZ = 512;
    private final Socket socket;
    private final InputStream in;

    public ReaderThread(Socket socket) throws IOException {
        this.socket = socket;
        this.in = socket.getInputStream();
    }

    public void interrupt() {
        try {
            socket.close();
        } catch (IOException ignored) {
        } finally {
            super.interrupt();
        }
    }

    public void run() {
        try {
            byte[] buf = new byte[BUFSZ];
            while (true) {
                int count = in.read(buf);
                if (count < 0)
                    break;
                else if (count > 0)
                    processBuffer(buf, count);
            }
        } catch (IOException e) { /* Allow thread to exit */
        }
    }

    public void processBuffer(byte[] buf, int count) {
    }
}

```

- 표준적이지 않은 방법으로 작업을 중단하는 기능을 속으로 감춰버리는 방법
- 이런식으로 하면 ReaderThread 클래스에 인터럽트를 걸었을 때 read 메서드에서 대기중인 상태이거나 기타 인터럽트에 응답할 수 있는 블로킹 메서드에 멈춰있을 때에도 작업을 중단시킬 수 있음



### newTaskFor 메서드로 비표준적인 중단 방법 처리

- 표준을 따르지 않는 중단 방법을 표준의 범주 내에서 사용할 수 있도록 ReaderThread 에서 사용했던 기법을 ThreadPoolExecutor클래스에 newTaskFor라는 메서드로 정리해 추가되었음
- newTaskFor는 RunnableFuture를 리턴해줌
- Future.cancel 메서드를 오버라이드하면 작업 중단 과정을 원하는대로 변경할 수 있음

```java
package net.jcip.examples;

import java.io.IOException;
import java.net.Socket;
import java.util.concurrent.*;

import net.jcip.annotations.*;

/**
 * SocketUsingTask
 * <p/>
 * Encapsulating nonstandard cancellation in a task with newTaskFor
 *
 * @author Brian Goetz and Tim Peierls
 */

public abstract class SocketUsingTask <T> implements CancellableTask<T> {
    @GuardedBy("this") private Socket socket;

    protected synchronized void setSocket(Socket s) {
        socket = s;
    }

    public synchronized void cancel() {
        try {
            if (socket != null)
                socket.close();
        } catch (IOException ignored) {
        }
    }

    public RunnableFuture<T> newTask() {
        return new FutureTask<T>(this) {
            public boolean cancel(boolean mayInterruptIfRunning) {
                try {
                    SocketUsingTask.this.cancel();
                } finally {
                    return super.cancel(mayInterruptIfRunning);
                }
            }
        };
    }
}


interface CancellableTask <T> extends Callable<T> {
    void cancel();

    RunnableFuture<T> newTask();
}


@ThreadSafe
class CancellingExecutor extends ThreadPoolExecutor {
    public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
    }

    public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    }

    public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    }

    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
        if (callable instanceof CancellableTask)
            return ((CancellableTask<T>) callable).newTask();
        else
            return super.newTaskFor(callable);
    }
}

```



## 스레드 기반 서비스 중단

- 애플리케이션을 깔끔하게 종료시키려면 스레득 기반의 서비스 내부에 생성되어 있는 스레드를 안전하게 종료시킬 필요가 있음
- 스레드는 선점해서 종료가 불가하고 스레드에게 종료를 요청만 가능
- 스레드를 직접 소유하고 있지 않는 한 해당 스레드에 인터럽트를 걸거나 우선 순위를 조정하는 등의 작업을 해서는 안됨
- 스레드 풀이라면 인터럽트는 스레드 풀에서 책임져야함
- 애플리케이션은 개별 스레드를 직저 소유하고 있지 않기 때문에 개별 스레드를 직접 조작하는 일이 없어야함
- 스레드 기반 서비스를 생성한 메서드보다 생성된 스레드 기반 서비스가 오래 실행될 수 있는 상황이라면 스레드 기반 서비스에서는 항상 죵료시키는 방법을 제공해야함 
- ExecutorService 인터페이스는 shutdown 메서드왜 shutdownNow 메서드를 제공하고 있고 다른 스레드 기반의 서비스 역시 이와 같은 종료 기능을 제공해야함



### 예제: 로그 서비스

```java
package net.jcip.examples;

import java.io.PrintWriter;
import java.io.Writer;
import java.util.concurrent.*;

/**
 * LogWriter
 * <p/>
 * Producer-consumer logging service with no shutdown support
 *
 * @author Brian Goetz and Tim Peierls
 */
public class LogWriter {
    private final BlockingQueue<String> queue;
    private final LoggerThread logger;
    private static final int CAPACITY = 1000;

    public LogWriter(Writer writer) {
        this.queue = new LinkedBlockingQueue<String>(CAPACITY);
        this.logger = new LoggerThread(writer);
    }

    public void start() {
        logger.start();
    }

    public void log(String msg) throws InterruptedException {
        queue.put(msg);
    }

    private class LoggerThread extends Thread {
        private final PrintWriter writer;

        public LoggerThread(Writer writer) {
            this.writer = new PrintWriter(writer, true); // autoflush
        }

        public void run() {
            try {
                while (true)
                    writer.println(queue.take());
            } catch (InterruptedException ignored) {
            } finally {
                writer.close();
            }
        }
    }
}
```

- 로그 메시지를 실제로 생성하는 스레드가 식접 스트림으로 메시지를 출력하는 대신 LogWriter에서는 BlockingQueue를 사용해 메시지를 출력 전담 스레드에게 념거주며, 출력 전담 스레드는 큐에 쌓인 메시지를 가져다 화면에 출력함
- 이런 구조는 전형적인 다수의 프로듀서와 단일 컨슈머가 동작하는 패턴이라고 볼 수 있음
- 로그를 남기기 위해 log 메서드를 호출하는 모든 스레드가 프로듀서가 되고 로그 출력전담 스레드가 바로 컨슈머 역할을 함
- LogWriter와 같은 서비스를 실제 상용에 활용하려면 애플리케이션을 종료하려고 할 때 로그 출력 전담 스레드가 계속 실행되느라 jvm이 정상적으로 멈추지 않는 현상을 방지해야함
- 위 방법에서는 단순히 멈추는것은 가능하지만 멈추는 순간 큐에 쌓인 모든 로그들을 상실함. 그리고 로그 메시지를 출력하기 위해 log 메서드를 호출했는데 큐가 가득 차서 메시지를 큐에 넣을 때까지 대기 상태에 들어가있던 스레드는 영원히 대기 상태에 머물게됨 이런 경우를 방지하기 위해 프로듀서, 컨슈머 모드 종료시켜야하나 프로듀서는 전용 스레드에서 동작하는 것이 아니기 때문에 프로듀서를 중단시키는 일이 간단하지 않음
- 로그 메시지를 추가하는 부분을 단일 연산으로 구현해야함

```java
package net.jcip.examples;

import java.io.PrintWriter;
import java.io.Writer;
import java.util.concurrent.*;

import net.jcip.annotations.*;

/**
 * LogService
 * <p/>
 * Adding reliable cancellation to LogWriter
 *
 * @author Brian Goetz and Tim Peierls
 */
public class LogService {
    private final BlockingQueue<String> queue;
    private final LoggerThread loggerThread;
    private final PrintWriter writer;
    @GuardedBy("this") private boolean isShutdown;
    @GuardedBy("this") private int reservations;

    public LogService(Writer writer) {
        this.queue = new LinkedBlockingQueue<String>();
        this.loggerThread = new LoggerThread();
        this.writer = new PrintWriter(writer);
    }

    public void start() {
        loggerThread.start();
    }

    public void stop() {
        synchronized (this) {
            isShutdown = true;
        }
        loggerThread.interrupt();
    }

    public void log(String msg) throws InterruptedException {
        synchronized (this) {
            if (isShutdown)
                throw new IllegalStateException(/*...*/);
            ++reservations;
        }
        queue.put(msg);
    }

    private class LoggerThread extends Thread {
        public void run() {
            try {
                while (true) {
                    try {
                        synchronized (LogService.this) {
                            if (isShutdown && reservations == 0)
                                break;
                        }
                        String msg = queue.take();
                        synchronized (LogService.this) {
                            --reservations;
                        }
                        writer.println(msg);
                    } catch (InterruptedException e) { /* retry */
                    }
                }
            } finally {
                writer.close();
            }
        }
    }
}

```

- 위 방법으로 안전하게 종료 가능한 LogService를 구현할 수 있음





### ExecutorService 종료

- shutdownNow를 사용해 강제로 종료시키고 나면 먼저 실행중인 모든 작업을 중단하도록 한 다음 아직 시작하지 않은 작업의 목록을 그 결과 로 리턴해줌
- 강제로 종료하는 방법은 응답이 훨씬 빠르지만 작업이 중단되는 과정에서 문제가 생길 수 있고, 안전하게 종료하는 방법은 속도가 느리지만 큐에 등록된 모든 작업을 처리할 때까지 스레드를 종료시키지 않고 놔두기 때문에 작업을 잃을 일이 없음
- 내부적으로 스레드를 소유하고 동작하는 서비스를 구현할 때에는 이와 비슷하게 종료 방법을 성태갛ㄹ 수 있도록 준비하는 것이 좋음
- 스레드를 직접 생성하는것보단 ExcutorService같은 인터페이스를 사용할 것



### 독약

- 프로듀서 컨슈머 패턴으로 구성된 서비스를 종료시키도록 종용하는 또다른 방법으로 poison pill 이라고 불리는 방법이 있음
- 이 방법은 특정 객체를 큐에 쌓고 이 객체를 받았다면 종료해야 한다 라는 의미를 갖고 있음
- FIFO 자료구조에서 사용함
- 프로듀서 측에서는 독약 객체를 넣고나면 다른 작업을 추가해서는 안됨



```java
package net.jcip.examples;

import java.io.File;
import java.io.FileFilter;
import java.util.concurrent.*;

/**
 * IndexingService
 * <p/>
 * Shutdown with poison pill
 *
 * @author Brian Goetz and Tim Peierls
 */
public class IndexingService {
    private static final int CAPACITY = 1000;
    private static final File POISON = new File("");
    private final IndexerThread consumer = new IndexerThread();
    private final CrawlerThread producer = new CrawlerThread();
    private final BlockingQueue<File> queue;
    private final FileFilter fileFilter;
    private final File root;

    public IndexingService(File root, final FileFilter fileFilter) {
        this.root = root;
        this.queue = new LinkedBlockingQueue<File>(CAPACITY);
        this.fileFilter = new FileFilter() {
            public boolean accept(File f) {
                return f.isDirectory() || fileFilter.accept(f);
            }
        };
    }

    private boolean alreadyIndexed(File f) {
        return false;
    }

    class CrawlerThread extends Thread {
        public void run() {
            try {
                crawl(root);
            } catch (InterruptedException e) { /* fall through */
            } finally {
                while (true) {
                    try {
                        queue.put(POISON);
                        break;
                    } catch (InterruptedException e1) { /* retry */
                    }
                }
            }
        }

        private void crawl(File root) throws InterruptedException {
            File[] entries = root.listFiles(fileFilter);
            if (entries != null) {
                for (File entry : entries) {
                    if (entry.isDirectory())
                        crawl(entry);
                    else if (!alreadyIndexed(entry))
                        queue.put(entry);
                }
            }
        }
    }

    class IndexerThread extends Thread {
        public void run() {
            try {
                while (true) {
                    File file = queue.take();
                    if (file == POISON)
                        break;
                    else
                        indexFile(file);
                }
            } catch (InterruptedException consumed) {
            }
        }

        public void indexFile(File file) {
            /*...*/
        };
    }

    public void start() {
        producer.start();
        consumer.start();
    }

    public void stop() {
        producer.interrupt();
    }

    public void awaitTermination() throws InterruptedException {
        consumer.join();
    }
}
```

- 독약 객체는 프로듀서의 개수와 컨슈머의 개수를 정확히 알고 있을때에만 사용할 수 있음
- 크기에 제한이 없는 큐를 사용할 때 효과적으로 동작



### 예제: 단번에 실행하는 서비스

- 일련의 작업을 순서대로 처리하고 작업이 모두 끝나기 전에는 리턴되지 않는 메서드, 이런 메서드는 내부에서만 사용할 Executor인스턴스를 하나 확보할 수 있다면 서비스의 시작과 종료를 쉽게 관리할 수 있음

```java
package net.jcip.examples;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

/**
 * CheckForMail
 * <p/>
 * Using a private \Executor whose lifetime is bounded by a method call
 *
 * @author Brian Goetz and Tim Peierls
 */
public class CheckForMail {
    public boolean checkMail(Set<String> hosts, long timeout, TimeUnit unit)
            throws InterruptedException {
        ExecutorService exec = Executors.newCachedThreadPool();
        final AtomicBoolean hasNewMail = new AtomicBoolean(false);
        try {
            for (final String host : hosts)
                exec.execute(new Runnable() {
                    public void run() {
                        if (checkMail(host))
                            hasNewMail.set(true);
                    }
                });
        } finally {
            exec.shutdown();
            exec.awaitTermination(timeout, unit);
        }
        return hasNewMail.get();
    }

    private boolean checkMail(String host) {
        // Check for mail
        return false;
    }
}
```



### shutdownNow 메서드의 약점

- shutdownNow 메서드를 사용해 ExecutorService를 강제로 종료시키는 경우에는 현재 실행중인 모든 스레드의 작업을 중단시키도록 시도하고, 등록됐지만 실행은 되지 않았던 모든 작업의 목록을 리턴해줌.
- 근데 실행되기  시작은 했지만 아직 완료되지 않은 작업이 어떤 것인지 알 수없어서 개별 작업 스스로가 작업 진행 정도와 같은것들을 알려줘야 판단이 가능함

```java
package net.jcip.examples;

import java.util.*;
import java.util.concurrent.*;

/**
 * TrackingExecutor
 * <p/>
 * ExecutorService that keeps track of cancelled tasks after shutdown
 *
 * @author Brian Goetz and Tim Peierls
 */
public class TrackingExecutor extends AbstractExecutorService {
    private final ExecutorService exec;
    private final Set<Runnable> tasksCancelledAtShutdown =
            Collections.synchronizedSet(new HashSet<Runnable>());

    public TrackingExecutor(ExecutorService exec) {
        this.exec = exec;
    }

    public void shutdown() {
        exec.shutdown();
    }

    public List<Runnable> shutdownNow() {
        return exec.shutdownNow();
    }

    public boolean isShutdown() {
        return exec.isShutdown();
    }

    public boolean isTerminated() {
        return exec.isTerminated();
    }

    public boolean awaitTermination(long timeout, TimeUnit unit)
            throws InterruptedException {
        return exec.awaitTermination(timeout, unit);
    }

    public List<Runnable> getCancelledTasks() {
        if (!exec.isTerminated())
            throw new IllegalStateException(/*...*/);
        return new ArrayList<Runnable>(tasksCancelledAtShutdown);
    }

    public void execute(final Runnable runnable) {
        exec.execute(new Runnable() {
            public void run() {
                try {
                    runnable.run();
                } finally {
                    if (isShutdown()
                            && Thread.currentThread().isInterrupted())
                        tasksCancelledAtShutdown.add(runnable);
                }
            }
        });
    }
}
```

- ExecutorService를 내부에 숨기고 중단된 작업을 등록하는 방법
- 처럼 구현하면 시작은 됐지만 정상적으로 종료되지 않은 작업이 어떤 것인지를 정확하게 알 수 있음
- 이런 기법이 제대로 동작하도록 하려면 개별 작업이 리턴될 때 자신을 실행했던 스레드의 인터럽트 상태를 유지시켜야함

```java
package net.jcip.examples;

import java.net.URL;
import java.util.*;
import java.util.concurrent.*;

import net.jcip.annotations.*;

import static java.util.concurrent.TimeUnit.MILLISECONDS;

/**
 * WebCrawler
 * <p/>
 * Using TrackingExecutorService to save unfinished tasks for later execution
 *
 * @author Brian Goetz and Tim Peierls
 */
public abstract class WebCrawler {
    private volatile TrackingExecutor exec;
    @GuardedBy("this") private final Set<URL> urlsToCrawl = new HashSet<URL>();

    private final ConcurrentMap<URL, Boolean> seen = new ConcurrentHashMap<URL, Boolean>();
    private static final long TIMEOUT = 500;
    private static final TimeUnit UNIT = MILLISECONDS;

    public WebCrawler(URL startUrl) {
        urlsToCrawl.add(startUrl);
    }

    public synchronized void start() {
        exec = new TrackingExecutor(Executors.newCachedThreadPool());
        for (URL url : urlsToCrawl) submitCrawlTask(url);
        urlsToCrawl.clear();
    }

    public synchronized void stop() throws InterruptedException {
        try {
            saveUncrawled(exec.shutdownNow());
            if (exec.awaitTermination(TIMEOUT, UNIT))
                saveUncrawled(exec.getCancelledTasks());
        } finally {
            exec = null;
        }
    }

    protected abstract List<URL> processPage(URL url);

    private void saveUncrawled(List<Runnable> uncrawled) {
        for (Runnable task : uncrawled)
            urlsToCrawl.add(((CrawlTask) task).getPage());
    }

    private void submitCrawlTask(URL u) {
        exec.execute(new CrawlTask(u));
    }

    private class CrawlTask implements Runnable {
        private final URL url;

        CrawlTask(URL url) {
            this.url = url;
        }

        private int count = 1;

        boolean alreadyCrawled() {
            return seen.putIfAbsent(url, true) != null;
        }

        void markUncrawled() {
            seen.remove(url);
            System.out.printf("marking %s uncrawled%n", url);
        }

        public void run() {
            for (URL link : processPage(url)) {
                if (Thread.currentThread().isInterrupted())
                    return;
                submitCrawlTask(link);
            }
        }

        public URL getPage() {
            return url;
        }
    }
}
```

- 웹 크롤러는 끝없이 작업하기때문에 특정 시점에 종료할때 다음에 시작해야할 중단지점을 알아내는게 중요함 이때 이런식으로 사용할 수 있음





## 비정상적인 스레드 종료 상황 처리

- 단일 스레드의 경우 제대로 처리하지못한 예외는 예측이 쉽게 가능하나 병렬 스레드에서 예외가 발생했을때는 예측하기 쉽지 않음 만약 에러가 발생해도 지나치는 경우가 있음
- 스레드를 예상치 못하게 종료시키는 가장 큰 원인은 바로 RuntimeException임 RuntimeException은 프로그램이 잘못짜여지거나 기타 회복 불능의 문제점을 나타내는 경우가 많기 때문에 try-catch로 못잡는경우가 많음
- 스레드가 비정상적으로 종료됐을때 나타나는 현상은 스레드마다 달라서 어떤 경우에는 모르고 지나칠 수 있으나 애플리케이션 입장에서는 매우 큰 문제가 생길 수도 있음
- 만약 호출해야할메서드를 잘 사용하는데 잘 이해하지 못한다면 항상 메서드가 예상대로 동작되지 않을 것을 생각하고 프로그램을 작성해야함
- RuntileException을 try-catch로 잡을 경우가 많지 않은데 몇 안되는 상황 가운데 남이 Runnable등으로 정의해둔 작업을 실행하는 프로그램을 작성하는 경우엔 잡아야됨

### 정의되지 않은 예외 처리

- 스레드에는 UncaughtExceptionHandler라는 기능을 제공하는데 이 기능을 사용하면 처리하지 못한 예외 상황으로 인해 특정 스레드가 종료되는 시점을 정확히 알 수 있음
- 처리하지 못한 예외 상황 때문에 스레드가 종료되는 경우에 jvm이 애플리케이션에서 정의한 UncaughtExceptionHandler을 호출하도록 할 수 있음
- 만약 핸들러가 하나도 정의되어 있지 않다면 기본 동작으로 스택 트레이스 콘솔에 System.err 스트림 출력

```java
package net.jcip.examples;

import java.util.logging.*;

/**
 * UEHLogger
 * <p/>
 * UncaughtExceptionHandler that logs the exception
 *
 * @author Brian Goetz and Tim Peierls
 */
public class UEHLogger implements Thread.UncaughtExceptionHandler {
    public void uncaughtException(Thread t, Throwable e) {
        Logger logger = Logger.getAnonymousLogger();
        logger.log(Level.SEVERE, "Thread terminated with exception: " + t.getName(), e);
    }
}
```

- 잠깐 실행하고 마는 애플리케이션이 아닌 이상 예외가 발생했을 때 로그 파일에 오류를 출력하는 간단한 기능만이라도 확보할 수 있도록 모든 스레드를 대상으로 UncaughtExceptionHandler를 활용해야함
- Runnable이나 Callable인터페이스를 구현하면서 run 메서드에서 try-catch 구문으로 오류를 처리하도록 되어 있는 클래스를 거쳐 실제 작업을 실행하도록 하거나 ThreadPoolExecutor클래스에 마련되어있는 afterExecute 메서드를 오버라이드 하는 방법으로 오류 상황을 알릴 것
- 혼동되는 부분은 예외 상횡이 발생했을 때 UncaughtExceptionHandler가 호출되도록 하려면 execute를 통해서 작업을 실행해야함 submit메서드는 ExecutionException에 감싸진 형태로 넘어옴



## JVM종료

- 일반적으로 절차에 맞춰 System.exit 같은 메서드 호출, 스레드가 모두 종료되는 시점이 가장 적절한 방법이고 그 외에 운영체제 수준에서 jvm 프로세스를 강제로 종료하는 방법 등으로 종료시킬 수 있음

### 종료 훅

- 예쩡된 절차대로 종료되는 경우에 jvm은 가장 먼저 등록되어 있는 모든 종료 훅을 실행시킴. 종료 훅은 Runtime.addShutdownHook 메서드를 사용해 등록된 아직 시작되지 않은 스레드를 의미함
- 종료 훅은 스레드 안전하게 만들어야함
- 종료 훅은 어떤 서비스나 애플리케이션 자체의 여러 부분을 정리하는 목적으로 사용하기 좋음. 예를 들어 임시로 만들어 사용했던 파일을 삭제하거나 운영체제에서 알아서 정리해주지 않는 모든 자원을 종료 훅에서 정리해야함



### 데몬 스레드

- 스레드는 두가지 종류인데 하나는 일반 스레드, 하나는 데몬 스레드
- jvm이 처음에 시작할때 main 스레드를 제외한 모든 스레드는 데몬스레드임 ex gc thread 외 여러가지 부수적인 스레드
- main 스레드 내부에서 생성한 스레드는 전부 일반스레드임
- 데몬스레드는 일반스레드의 보조적인 역할을 함
- 데몬스레드는 예를 들어 메모리 내부에 관리하고 있는 캐시에서 기한이 만려된 항목을 주기적으로 제거하는 등의 부수적인 단순 작업을 맡기기에 적절한 스레드임



### finalize 메서드

- 애플리케이션 내부에서 더이상 사용하지 않는 객체가 있다면 대부분 gc가 알아서 수집해 제거하고 메모리 확보하는 일을 잘 수행해줌 
- finalize 메서드는 실행 여부를 예측할 수가 없음 차라리 try-finally를 쓸 것
- finalize 메서드는 사용하지 말 것!!



## 요약

- 작업, 스레드, 서비스, 애플리케이션 등이 할 일을 모두 마치고 종료되는 시점을 적절하게 관리하려면 프로그램이 훨씬 복잡해질 수 있음
- 자바에서는 선점적으로 작업을 중단하거나 스레드를 종료시킬 수 있는 방법을 제공하지 않음 그 대신 인터럽트라는 방법을 사용해 스레드 간의 협력 과정을 거쳐 작업 중단 기능을 구현하도록 하고 있으며, 작업 중단 기능을 구현하고 전체 프로그램에 일관적으로 적용하는 일은 모두 개발자의 몫
- FutureTask나 Executor등의 프레임웍을 잘 사용하면 서비스나 서비스를 실행 도중에 중단할 수 있는 기능을 쉽게 구현할 수 있다는 점을 알아둘 것



# #8 스레드 풀 활용

## 작업과 실행 정책 간의 보이지 않는 연결 관계

- Executor 프레임웍은 작업의 정의 부분과 실행 부분을 서로 분리시켜줌
- 일정한 조건을 갖춘 실행 정책이 필요한 작업의 예
  - 의존성이 있는 작업: 독립적인 작업은 대부분 문제 없이 잘 동작하지만 다른 작업에 의존성을 갖는 작업을 스레드 풀에 올려 실행하려는 경우에는 실행 정책에 보이지 않는 조건을 거는 셈.
  - 스레드 한정 기법을 사용하는 작업: 단일 스레드는 병렬 프로그램보다 안전함. 나머지말은 뭔말인지 이해가 안감;
  - 응답 시간이 민감한 작업: gui 애플리케이션은 응답 시간이 중요함 서너개의 스레드로 동작하는 풀에 실행 시간이 긴 작업을 몇개만 등록해도 응답 성능이 크게 떨어짐
  - ThreadLocal을 사용하는 작업: ThreadLocal을 사용하면 각 스레드에서 같은 이름의 값을 각자의 버전으로 유지할 수 있음 하지만 Executor는 상황이 되는대로 기존 스레드를 최대한 재사용함. 기본으로 포함된 Executor는 처리해야할 작업의 수가 적을 때는 쉬고 있는 스레드를 제거하기도 하고, 작업량이 많을 때는 새로운 스레드를 만들어 사용하기도 함. 더군다난 작업을 실행하는 도중에 예외가 발생한다면 새로운 스레드로 대치시키도함. 스레드 풀에 속한 스레드에서 ThreadLocal을 사용할 때에는 현재 실행 중인 작업이 끝나면 더 이상 사용하지 않을 값만 보관해야함. ThreadLocal을 편법으로 활용해 작업 간에 값을 전달하는 용도로 사용해서는 안됨



- 스레드 풀은 동일하고 서로 독립적인 다수의 작업을 실행할 때 가장 효과적임
- 실행시간이 오래걸리는 작업과 금방 끝나는 작업을 섞어서 실행하도록 하면 비효율적임
- 크게가 제한되어 있는 스레드 풀에 다른 작업의 내용에 의존성을 갖고 있는 작업을 등록하면 데드락 발생 가능성이 높음
- 특정 작업을 실행하고자 할 때 그에 맞는 실행 정책을 요구하는 경우도 있고, 특정 실행 정책 아래에서는 실행되지 않는 경우도 있다. 다른 작업에 의존성이 있는 작업을 실행해야 할 때는 스레드 풀의 크기를 충분히 크게 잡아서 작업이 큐에서 대기하거나 등록되지 못하는 상황이 없도록 해야 함. 스레드 한정 기법을 사용하는 작업은 반드시 순차적으로 실행되어야함. 작업을 구현할 때는 나중에 유지보수를 진행할 때 해당 작업과 호환되지 않는 실행 정책 아래에서 실행하도록 변경해 애플리케이션의 안전성을 해치거나 실행되지 않는 경우를 막을 수 있도록 실행 정책과 관련된 내용을 문서로 남겨야함



### 스레드 부족 데드락

- 스레드 풀에서 다른 작업에 의존성을 갖고 있는 작업을 실행시킨다면 데드락에 걸릴 가능성이 높음
- 스레드 풀의 크기가 작던 크던 실행되는 모든 스레드가 큐에 쌓여 아직 실행되지 않은 작업의 결과를 받으려고 대기중이라면 데드락이 발생할 수 있는데 이련 현상을 스레드 부족 데드락 현상이라고함
- 특정 자원을 확보하고자 계속해서 대기하거나 풀 내부의 다른 작업이 실행돼야 알 수 있는 조건이 만족하기를 기다리는 것처럼 끝없이 계속 대기할 가능성이 있는 기능을 사용하는 작업이 풀에 등록된 경우에는 언제든지 발생할 수 있음

```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * ThreadDeadlock
 * <p/>
 * Task that deadlocks in a single-threaded Executor
 *
 * @author Brian Goetz and Tim Peierls
 */
public class ThreadDeadlock {
    ExecutorService exec = Executors.newSingleThreadExecutor();

    public class LoadFileTask implements Callable<String> {
        private final String fileName;

        public LoadFileTask(String fileName) {
            this.fileName = fileName;
        }

        public String call() throws Exception {
            // Here's where we would actually read the file
            return "";
        }
    }

    public class RenderPageTask implements Callable<String> {
        public String call() throws Exception {
            Future<String> header, footer;
            header = exec.submit(new LoadFileTask("header.html"));
            footer = exec.submit(new LoadFileTask("footer.html"));
            String page = renderBody();
            // Will deadlock -- task waiting for result of subtask
            return header.get() + page + footer.get();
        }

        private String renderBody() {
            // Here's where we would actually render the page
            return "";
        }
    }
}
```

- 위코드는 데드락을 발생시키는 코드임
- 머리글과 꼬리글을 가져오는 작업을 Executor에 등록하고 머리글과 꼬리글을 가져오면 전부 합쳐서 최종 페이지를 만들어내는데 Executor가 싱글스레드로 동작하기 때문에 이 클래스는 항상 데드락에 걸림 <= ~~의문이 드는게 싱글스레드에서 작업을 동시에 처리한다는것 자체가 이해가 안되는데 이걸 어디에 물어볼까 ... 직접해봤는데도 `return header.get() + page + footer.get();` 이부분에서 문제되는게 없었음~~ <= 저 RenderPageTask랑 LoadFileTask을 위에 선언한 ExecutorService에서 사용하면 스레드 부족 현상이 나옴
- 배리어를 사용해 서로의 동작을 조율하는 작업 역시 풀의 크기가 충분히 크지 않다면 스레드 부족 데드락이 발생할 수 있음
- 완전히 독립적이지 않은 작업을 Executor에 등록할 때는 항상 스레드 부족 데드락이 발생할 수 있다는 사실을 염두에 둬야 하며, 작업을 구현한 코드나 Executor를 설정하는 설정 파일 등에 항상 스레드 풀의 크기나 설정에 대한 내용을 설명해야함



### 오래 실행되는 작업

- 데드락이 발생하지 않는다 하더라도 특정 작업이 예상보다 긴 시간동안 종료되지 않고 실행된다면 스레드 풀의 응답 속도에 문제점이 생김
- 제한없이 계속 대기하지 않고 일정시간만 대기하도록 한다면 위 문제를 해결할 수 있음 ex blockingqueue의 put 메서드 등등
- 성공 또는 실패여도 반드시 끝나는 작업이 됨
- 스레드 풀을 사용하는 도중에 스레드에서 실행중인 작업이 대기 상태에 빠지는 경우가 자주 발생한다면 스레드 풀의 크기가 작다는 것으로 이해할 수도 있음



## 스레드 풀 크기 조절

- 스레드 풀의 가장 이상적인 크기는 스레드 풀에서 실행할 작업의 종류와 스레드 풀을 활용할 애플리케이션의 특성에 따라 결정됨

- 스레드 풀의 크기를 하드코딩해 고정시키는 것은 그다지 좋은 방법이 아님

- 스레드 풀의 크기는 설정 파일이나 Runtime.availableProcessors 등의 메서드 결과 값에 따라 동적으로 지정되도록 해야 함

- 스레드 풀의 공식은 없고 너무 크거나 너무 작지만 않으면 됨

- 적절한 스레드 풀의 크기는 실행중인 컴퓨터의 환경과 자원, 그리고 하고자하는 작업에 대해 잘 알아야함

- cpu를 많이 사용하는 작업의 경우 n 개의 cpu를 탑재하고 있는 하드웨어 에서 스레드 풀을 사용할 때는 스레드의 개수를 n+1개로 맞추면 최적의 성능을 발휘한다고 알려져 있음

- 스레드 개수 공식

  > **NT = NC \* U \* (1 + W/C)**
  >
  > NT: Number of Threads
  >
  > NC: Number of CPUs
  >
  > U: Target CPU Utilization (0 ~ 1)
  >
  > W/C: Ratio of Wait Time to Compute Time (0 ~ 100)

- 스레드 풀을 적용하면 메모리, 파일 핸들, 소켓 핸들, 데이터베이스 연결과 같은 자원의 사용량도 적절하게 조절할 수 있음 스레드의 개수는 각 작업에서 실제로 필요한 자원의 양을 모두 더한 값을 자원의 전체 개수로 나눠주면 스레드 풀의 최대 크기에 해당함

## ThreadPoolExecutor 설정

- ThreadPoolExecutor는 newFixedThreadPool 등등과 같은 팩토리 메서드에서 생성해주는 Executor에 대한 기본적인 내용이 구현되어 있는 클래스임
- ThreadPoolExecutor는 유연하면서도 안정적이고 여러 가지 설정을 통해 입맛에 맞게 바꿔 사용 가능
- 기존에 제공하는 Executor가 요구사항에 잘 맞지 않는다면 ThreadPoolExecutor 클래스의 생성 메서드를 직접 호출해 스레드 풀을 생성할 수 있음



### 스레드 생성과 제거

- 풀의 코어 크기, 최대 크기, 스레드 유지 시간등의 값을 통해 스레드가 생성되고 제거되는 과정을 조절할 수 있음
- ThreadPoolExecutor는 최대 코어 크기만큼 초기화시키지도 않고 큐에 작업이 가득 차지 않는 이상 스레드의 수가 코어 크기를 넘지 않음 그리고 스레드 유지 시간등도 조절해서 작업 후 사용되지 않는 자원을 반납할 수 있음
- newFixedThreadPool 팩토리 메서드의 경우 스레드 풀의 코어 크기와 최대 크기를 이미 초기화 시점에서 확정짓고 유지시간을 무제한으로 지정, newCachedThreadPool 팩토리 메서드는 스레드 풀의 최대 크기를 Integer.MAX_VALUE로 지정하고 코어 크기를 0으로 스레드 유지시간을 1분으로 지정함



### 큐에 쌓인 작업 관리

- 크기가 제한된 스레드 풀에서는 동시에 실행될 수 있는 스레드의 개수가 제한되어 있음
- 작업을 처리할 수 있는 능력보다 많은 양의 요청이 들어오면 처리하지 못한 요청이 큐에 계속해서 쌓임
- 계속해서 처리하는 속도보다 빠른 속도로 작업이 추가되면 속도 조절기능을 사용해 메모리가 가득 차는 현상을 막아야함 <= 이 방법은 흐름 제어가 아니라 클라이언트 측에서 요청을 더이상 보내지 못하게 하거나, 일부 무시하는 행위임
- ThreadPoolExecutor를 생성할 때 작업을 쌓아둘 큐로 BlockingQueue를 지정할 수 있음
- 스레드 풀에서 작업을 쌓아둘 큐에 적용할 수 있는 전략은 세가지가 있음
  1. 큐에 크기 제한을 두지 않는 방법
  2. 큐의 크기를 제한하는 방법
  3. 작업을 스레드에게 직접 넘겨주는 방법
- newFixedThreadPool 과 newSingleThreadExecutor에서 생성하는 풀은 기본적으로 크기 제한이 없는 LinkedBlockingQueue, 큐에 계속해서 작업이 쌓일 수 있음
- 자원관리측면에서 큐의 크기를 제한시켜 사용하는 방법이 훨씬 안정적임 하지만 이런 경우에 큐가 가득찼을때 어떻게 처리해야하는지에 대한 문제가 생김
- 스레드의 개수는 줄이면서 큐의 크기를 늘려주면 메모리와 cpu사용량을 줄이면서 컨텍스트 스위칭 횟수를 줄일 수 있지만 전체적인 성능에는 제한이 생길 수 있음
- SynchronousQueue는 스레드의 개수가 제한이 없는 상태이거나 넘치는 작업을 마음대로 거부할 수 있는 상황이어야 적용할만한 방법
- newCachedThreadPool 팩토리 메서드에서는 스레드 풀에 SynchronousQueue를 적용함
- 작업이 실행되는 순서를 조절하고 싶다면 PrioirotyBlockingQueue를 고려하는것도 좋음
- 크기가 고정된 풀보다는 newChachedThreadPool 팩토리 메서드가 생성해주는 Executor가 더 나은 선택일 수 있음 크기가 고정된 스레드 풀은 자원 관리 측면에서 동시에 실행되는 스레드의 수를 제한해야 하는 경우에 현명한 선택이 될 수 있음 예를 들어 네트웍으로 클라이언트의 요청을 받아 처리하는 애플리케이션과 같은 경우, 크기가 고정되어 있지 않다면 요청이 많아져 부하가 걸릴 때 문제가 커짐
- 스레드 풀에서 실행할 작업이 서로 독립적인 경우에만 스레드의 개수나 작업 큐의 크기를 제한할 수 있음 다른 작업에 의존성을 갖는데 스레드나 큐의 크기가 제한되어 있다면 스레드 부족 데드락에 걸릴 가능성이 높음 이럴땐 newCachedThreadPool 처럼 크기가 제한되지 않는 풀을 사용해야함



### 집중 대응 정책

- 크기가 제한된 큐에 작업이 가득 차면 집중 대응 정책이 동작함
- ThreadPoolExecutor의 집중 대응 정책은 setRejectedExecutionHandler 메서드를 사용해 원하는 정책으로 변경할 수 있음
- 여러가지 종류의 RejectedExecutionHandler가 있음. AbortPolicy, CallerRunsPolicy, DiscardPolicy, DiscardOldestPolicy 등등
- 정책에 따라 큐에 가장 오래된 작업을 제거하거나, 큐가 가득찬 이후 들어온 작업은 무시하는 등의 정책이 있음
- CallerRunsPolicy의 경우 작업을 제거해버리거나 예외를 던지지 않으면서 큐의 크기를 초과하는 작업을 프로듀서에게 거꾸로 넘겨 작업 추가 속도를 늦출 수 있도록 일종의 속도 조절 방법으로 사용됨
- 작업 큐가 가득 찼을 때 execute 메서드가 그저 대기하도록 하는 집중 대응 정책은 따로 만들어진 것이 없지만 Semaphore를 사용하면 작업 추가 속도를 적절한 범위 내에서 제한할 수 있음

```java
package net.jcip.examples;

import java.util.concurrent.*;

import net.jcip.annotations.*;

/**
 * BoundedExecutor
 * <p/>
 * Using a Semaphore to throttle task submission
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class BoundedExecutor {
    private final Executor exec;
    private final Semaphore semaphore;

    public BoundedExecutor(Executor exec, int bound) {
        this.exec = exec;
        this.semaphore = new Semaphore(bound);
    }

    public void submitTask(final Runnable command)
            throws InterruptedException {
        semaphore.acquire();
        try {
            exec.execute(new Runnable() {
                public void run() {
                    try {
                        command.run();
                    } finally {
                        semaphore.release();
                    }
                }
            });
        } catch (RejectedExecutionException e) {
            semaphore.release();
        }
    }
}
```





### 스레드 팩토리

- 스레드 풀에서 새로운 스레드를 생성해야 할 시점이 되면, 새로운 스레드는 항상 스레드 팩토리를 통해 생성함
- 스레드 팩토리를 직접 작성해 적용하면 스레드 풀에서 사용할 스레드의 설정을 원하는대로 지정  가능
- 스레드 풀에서 새로운 스레드를 생성할 때는 항상 ThreadFactory의 newThread 호출

```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * MyThreadFactory
 * <p/>
 * Custom thread factory
 *
 * @author Brian Goetz and Tim Peierls
 */
public class MyThreadFactory implements ThreadFactory {
    private final String poolName;

    public MyThreadFactory(String poolName) {
        this.poolName = poolName;
    }

    public Thread newThread(Runnable runnable) {
        return new MyAppThread(runnable, poolName);
    }
}
```

- MyAppThread를 생성할 때 스레드 풀이름을 넣어줘서 스레드 덤프 파일이나 로그 파일에서 특정 스레드가 어떤 스레드 풀에 속해 동작하는지 알 수 있음 이것은 디버깅에 매우 유용함
- 향상된 MyThreadFactory

```java
package net.jcip.examples;

import java.util.concurrent.atomic.*;
import java.util.logging.*;

/**
 * MyAppThread
 * <p/>
 * Custom thread base class
 *
 * @author Brian Goetz and Tim Peierls
 */
public class MyAppThread extends Thread {
    public static final String DEFAULT_NAME = "MyAppThread";
    private static volatile boolean debugLifecycle = false;
    private static final AtomicInteger created = new AtomicInteger();
    private static final AtomicInteger alive = new AtomicInteger();
    private static final Logger log = Logger.getAnonymousLogger();

    public MyAppThread(Runnable r) {
        this(r, DEFAULT_NAME);
    }

    public MyAppThread(Runnable runnable, String name) {
        super(runnable, name + "-" + created.incrementAndGet());
        setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
            public void uncaughtException(Thread t,
                                          Throwable e) {
                log.log(Level.SEVERE,
                        "UNCAUGHT in thread " + t.getName(), e);
            }
        });
    }

    public void run() {
        // Copy debug flag to ensure consistent value throughout.
        boolean debug = debugLifecycle;
        if (debug) log.log(Level.FINE, "Created " + getName());
        try {
            alive.incrementAndGet();
            super.run();
        } finally {
            alive.decrementAndGet();
            if (debug) log.log(Level.FINE, "Exiting " + getName());
        }
    }

    public static int getThreadsCreated() {
        return created.get();
    }

    public static int getThreadsAlive() {
        return alive.get();
    }

    public static boolean getDebug() {
        return debugLifecycle;
    }

    public static void setDebug(boolean b) {
        debugLifecycle = b;
    }
}
```

### 

### ThreadPoolExecutor 생성 이후 설정 변경

- ThreadPoolExecutor생성할 때 초기 인자값들은 set 메서드를 통해서 언제든지 변경 가능
- Executors의 unconfigurableExecutorService메서드를 사용해서 현재 만들어져있는 ExecutorService를 넘겨받고 더이상 수정이 불가능하도록 할 수 있음





## ThreadPoolExecutor 상속

- ThreadPoolExecutor는 애초에 상속받아 기능을 추가할 수 있도록 만들어졌음
- afterExecute, terminated 등과 같은 여러가지 훅도제공하고 있고 이런 훅을 사용하면 훨씬 다양한 기능을 구사할 수 있음



### 예제: 스레드 풀에 통계 확인 기능 추가

- 여러가지 훅들을 사용해서 작업의 시간을 체크하는 등의 작업을 수행할 수 있음

```java
package net.jcip.examples;

import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import java.util.logging.*;

/**
 * TimingThreadPool
 * <p/>
 * Thread pool extended with logging and timing
 *
 * @author Brian Goetz and Tim Peierls
 */
public class TimingThreadPool extends ThreadPoolExecutor {

    public TimingThreadPool() {
        super(1, 1, 0L, TimeUnit.SECONDS, null);
    }

    private final ThreadLocal<Long> startTime = new ThreadLocal<Long>();
    private final Logger log = Logger.getLogger("TimingThreadPool");
    private final AtomicLong numTasks = new AtomicLong();
    private final AtomicLong totalTime = new AtomicLong();

    protected void beforeExecute(Thread t, Runnable r) {
        super.beforeExecute(t, r);
        log.fine(String.format("Thread %s: start %s", t, r));
        startTime.set(System.nanoTime());
    }

    protected void afterExecute(Runnable r, Throwable t) {
        try {
            long endTime = System.nanoTime();
            long taskTime = endTime - startTime.get();
            numTasks.incrementAndGet();
            totalTime.addAndGet(taskTime);
            log.fine(String.format("Thread %s: end %s, time=%dns",
                    t, r, taskTime));
        } finally {
            super.afterExecute(r, t);
        }
    }

    protected void terminated() {
        try {
            log.info(String.format("Terminated: avg time=%dns",
                    totalTime.get() / numTasks.get()));
        } finally {
            super.terminated();
        }
    }
}
```



## 재귀 함수 병렬화

- 반복문의 각 차수에 해당하는 작업이 서로 독립적이라고 한다면 반복문 내부의 작업이 순차적으로 실행되어 끝나기를 기다릴 필요가 없음

```java
package net.jcip.examples;

import java.util.*;
import java.util.concurrent.*;

/**
 * TransformingSequential
 * <p/>
 * Transforming sequential execution into parallel execution
 *
 * @author Brian Goetz and Tim Peierls
 */
public abstract class TransformingSequential {

    void processSequentially(List<Element> elements) {
        for (Element e : elements)
            process(e);
    }

    void processInParallel(Executor exec, List<Element> elements) {
        for (final Element e : elements)
            exec.execute(new Runnable() {
                public void run() {
                    process(e);
                }
            });
    }

    public abstract void process(Element e);


    public <T> void sequentialRecursive(List<Node<T>> nodes,
                                        Collection<T> results) {
        for (Node<T> n : nodes) {
            results.add(n.compute());
            sequentialRecursive(n.getChildren(), results);
        }
    }

    public <T> void parallelRecursive(final Executor exec,
                                      List<Node<T>> nodes,
                                      final Collection<T> results) {
        for (final Node<T> n : nodes) {
            exec.execute(new Runnable() {
                public void run() {
                    results.add(n.compute());
                }
            });
            parallelRecursive(exec, n.getChildren(), results);
        }
    }

    public <T> Collection<T> getParallelResults(List<Node<T>> nodes)
            throws InterruptedException {
        ExecutorService exec = Executors.newCachedThreadPool();
        Queue<T> resultQueue = new ConcurrentLinkedQueue<T>();
        parallelRecursive(exec, nodes, resultQueue);
        exec.shutdown();
        exec.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
        return resultQueue;
    }

    interface Element {
    }

    interface Node <T> {
        T compute();

        List<Node<T>> getChildren();
    }
}

```

- 한 묶음의 작업을 한꺼번에 등록하고 그작업들이 모두 종료될 때까지 대기하고자 한다면 ExecutorService.invokeAll 메서드를 사용해볼 것
- 특정 작업을 여러번 실행하는 반복문이 있을 때, 반복되는 각 작업이 서로 독립적이라면 병렬화해서 성능의 이점을 얻을 수 있음. 특히 반복문 내부의 작업을 개별적인 작업으로 구분해 실행하느라 추가되는 약간의 부하가 부담되지 않을 만큼 적지 앟은 시간이 걸리는 작업이라야 더 효과를 볼 수 있음
- 반복문을 병렬화하는 작업은 일부 재귀 함수 처리 부분에도 적용할 수 있음



### 예제: 퍼즐 프레임웍

- 최초 상태에서 시작해 몇가지 변환과정을 거쳐 최종 목표 단계까지 이동하는 일련의 과정으로 표현할 수 있는 퍼즐
- 예제는 https://jcip.net/listings 에서 8.13~18까지



## 요약

- Executor프레임웍은 작업을 병렬로 동작시킬 수 잇는 강력함과 유연성을 고루 갖추고 있음.
- 스레드를 생성하거나 제거하는 정책이나 큐에 쌓인 작업을 처리하는 방법, 작업이 밀려 있을 때 밀린 작업을 처리하는 방법 등의 조건을 설정해 입맛에 맞게 튜닝할 수 있는 옵션도 제공하고 있으며, 여러 가지의 훅 메서드를 사용해 필요한 기능을 확장해 사용할 수 있음
- 강력하면서 유연성이 높은 프레임웍에서 자주 발생하는 일이지만 여러 가지 설정 가운데 서로 잘맞지 않느 설정이 있을 수 있음. 예를 들어 특정 종류의 작업은 일정한 실행 정책 아래에서만 제대로 동작하기도 하고, 특이한 조합을 사용하면 예측할 수 없는 이상한 형태로 작업이 실행되기도 한다는 점을 주의할 것



# #9 GUI 애플리케이션

- 프로그램이 안정적으로 동작하도록 하려면 특정 작업은 반드시 스윙의 이벤트 스레드에서 실행되어야함
- 스윙에서 사용하는 자료구조가 스레드 안전성을 확보하지 못하고 있기 때문에 주의 깊게 만들어야함
- 스윙이나 swt등을 포함한 거의 모든 gui 툴킷은 gui 관련 작업이 모두 단일 스레드에서 일어나는 단일 스레드 서브시스템으로 구현돼 있음

## GUI는 왜 단일 스레드로 동작하는가?

- 단일 스레드에서 벗어나려했지만 데드락이나 경쟁조건 문제가 계속 발생했음 따라서 대부분의 프레임웍이 이벤트 처리용 전담 스레드를 만들고 전담 스레드는 큐에 쌓여 있는 이벤트를 가져와 애플리케이션에 준비돼 있는 이벤트 처리 메서드를 호출해 기능을 동작시키는 단일 스레드 이벤트 큐 모델에 정착한 셈
- 하나의 gui 컴포넌트를 놓고 양방향으로 운영체제와 애플리케이션간의 양방향으로 움직이는 과정을 거치게 돼 있는데 이 과정에 속한 객체가 스레드 안전하도록 동기화시키다보니 락이 배치되는 순서가 적절하지 않은 경우가 많아짐
- 단일 스레드 gui 프레임웍은 스레드 제한 기법으로 스레드 안전성을 보장함



### 순차적 이벤트 처리

- gui 이벤트를 처리하는 스레드는 단 하나밖에 없기 때문에 이벤트는 항상 순차적으로 실행됨
- 작업을 순차적으로 처리하는 방법의 단점은 특정 작업이 오래 걸릴 경우 다음 작업까지의 대기시간이 길다는것
- 오래걸리는 작업은 이벤트르세드가 아닌 독립 스레드에서 동작시키고 이벤트 스레드에 제어권을 바로 넘기는 방식으로 해야함



### 스윙의 스레드 한정

- 스윙의 단일 스레드 규칙 스윙 컴포넌트와 모델 객체는 이벤트 스레드 내부에서만 생성하고 변경하고 사용할 수 있음

## 짧게 실행되는 GUI 작업

- 처리할 작업이 금방 처리되는 작업이면서 gui 객체에서만 실행하는 작업이라고 한다면 스레드에 아무런 신경쓸 필요 없이 모든 작업을 이벤트 내부에서 처리하도록 해도 별 문제가 없음

## 장시간 실행되는 GUI 작업

- gui 애플리케이션에서 시간이 오래 걸리는 작업을 처리하는 데는 newCachedThreadPool 메서드로 생성한 Executor가 제격임 <= gui 애플리케이션에서 기계적으로 스레드를 대량 생산할만한 일이 없기 때문

### 작업 중단

- 중단 가능한 작업은 Future를 활용하면 훨씬 간편하게 구현할 수 있음



### 진행 상태 및 완료 알림

- Future 인터페이스를 활용하면 장시간 실행되는 작업을 중단하는 일도 굉장히 간단하게 구현할 수 있음
- FutureTask 클래스에 포함돼있는 done 이라는 훅 메서드를 사용하면 작업이 끝났음을 알려주는 기능도 중단 기능처럼 간단하게 구현 가능



## 데이터 공유 모델

### 스레드 안전한 데이터 모델

- 일부 상황에서는 CopyOnWriteArrayList와 같은 버전 데이터 모델을 사용해 스레드 안전성과 데이터 안전성, 높은 응답 속도를 한꺼번에 얻을수도 있음
- 예를 들어 CopyOnWriteXXX 컬렉션에서는 Interator반복문도 해당 Iterator가 생성되던 시점의 내용을 그대로 보존하고 반복함 하지만 CopyOnWriteXXX 컬렉션은 데이터를 추가하거나 제거하는 기능보다 반복문을 훨씬 많이 사용하는 경우에만 정상적인 성능을 얻을 수 있음



### 분할 데이터 모델

## 다른 형태의 단일 스레드 서브 시스템

## 요약

- gui 프레임웍은 거의 대부분 단일 스레드 서브시스템으로 구현돼 있으며, 화면 표시 부분과 관련된 기능이 모두 이벤트 스레드에서 작업의 형태로 실행되도록 만들어져 있음
- 장시간 실행돼야 할 작업이 있는 경우 이벤트 스레드가 하나밖에 없기 때문에 전체적인 사용자 인터페이스의 응답 속도가 떨어질 수밖에 없음. 따라서 장시간 실행될 작업은 이벤트 스레드가 아닌 백그라운드 스레드에서 실행시켜야함. 스윙에 포함돼 있는 SwingWorker나 직접 구현해본 BackgroundTask와 같이 작업 중단. 작업 진행 상태 안내, 작업 완료 안내 등의 기능을 갖춘 도우미 클래스를 사용하면 gui 프레임웍 내부에서 오래 실행되는 작업을 쉽게 처리할 수 있음



# #10 활동성을 최대로 높이기

- 자바 애플리케이션은 데드락 상태에서 회복할 수 없기 때문에 항상 프로그램의 실행 구조상 데드락이 발생할 가능성이 없는지 먼저 확인해야함

## 데드락

- 스레드 하나가 특정 락을 놓지 않고 계속해서 잡고 있으면 그 락을 확보해야 하는 다른 스레드는 락이 풀리기를 영원히 기다리는 수밖에 없음
- 여러개의 스레드가 사이클이 생기면 데드락이 자주 발생함
- 데이터베이스의 경우 데드락 상황에서 복구하는 기능을 갖고 있음 but 자바는 아님 자바는 데드락이 걸린 상태에서 애플리케이션을 종료하고 다시 실행하는 방법밖에는 없음 

### 락 순서에 의한 데드락

```java
package net.jcip.examples;

/**
 * LeftRightDeadlock
 *
 * Simple lock-ordering deadlock
 *
 * @author Brian Goetz and Tim Peierls
 */
public class LeftRightDeadlock {
    private final Object left = new Object();
    private final Object right = new Object();

    public void leftRight() {
        synchronized (left) {
            synchronized (right) {
                doSomething();
            }
        }
    }

    public void rightLeft() {
        synchronized (right) {
            synchronized (left) {
                doSomethingElse();
            }
        }
    }

    void doSomething() {
    }

    void doSomethingElse() {
    }
}
```

- 위 코드는 데드락이 발생할 위험이 있음
- 프로그램 내부의 모든 스레드에서 필요한 락을 모두 같은 순서로만 사용한다면 락 순서에 의한 데드락은 발생하지 않음
- 락을 사용하는 순서가 일정한지를 확인하려면 프로그램 내부에서 락을 사용하는 패턴과 방법을 전반적으로 검증해야함



### 동적인 락 순서에 의한 데드락

- 모든 스레드가 동일한 순서로 확보하려 할 때 데드락이 발생할 수 있음

```java
package net.jcip.examples;

import java.util.concurrent.atomic.*;

/**
 * DynamicOrderDeadlock
 * <p/>
 * Dynamic lock-ordering deadlock
 *
 * @author Brian Goetz and Tim Peierls
 */
public class DynamicOrderDeadlock {
    // Warning: deadlock-prone!
    public static void transferMoney(Account fromAccount,
                                     Account toAccount,
                                     DollarAmount amount)
            throws InsufficientFundsException {
        synchronized (fromAccount) {
            synchronized (toAccount) {
                if (fromAccount.getBalance().compareTo(amount) < 0)
                    throw new InsufficientFundsException();
                else {
                    fromAccount.debit(amount);
                    toAccount.credit(amount);
                }
            }
        }
    }

    static class DollarAmount implements Comparable<DollarAmount> {
        // Needs implementation

        public DollarAmount(int amount) {
        }

        public DollarAmount add(DollarAmount d) {
            return null;
        }

        public DollarAmount subtract(DollarAmount d) {
            return null;
        }

        public int compareTo(DollarAmount dollarAmount) {
            return 0;
        }
    }

    static class Account {
        private DollarAmount balance;
        private final int acctNo;
        private static final AtomicInteger sequence = new AtomicInteger();

        public Account() {
            acctNo = sequence.incrementAndGet();
        }

        void debit(DollarAmount d) {
            balance = balance.subtract(d);
        }

        void credit(DollarAmount d) {
            balance = balance.add(d);
        }

        DollarAmount getBalance() {
            return balance;
        }

        int getAcctNo() {
            return acctNo;
        }
    }

    static class InsufficientFundsException extends Exception {
    }
}
```

- transferMoney가 데드락이 걸릴만한 상황은 계좌A , B 가 동시에 A -> B로 인출하고 B -> A로 인출할때 데드락이 걸릴 수 있음
- 락을 확보하려는 순서를 내부적으로 제어할 수 없기 때문에 여기에서 데드락을 방지하려면 락을 특정 순서에 맞춰 확보하도록 해야 하고, 락을 확보하는 순서를 프로그램 전반적으로 동일하게 정용해야함
- 객체의 순서를 부여하는 방법중 하나로 System.identityHashCode를 사용하는 방법



```java
package net.jcip.examples;

/**
 * InduceLockOrder
 *
 * Inducing a lock order to avoid deadlock
 *
 * @author Brian Goetz and Tim Peierls
 */
public class InduceLockOrder {
    private static final Object tieLock = new Object();

    public void transferMoney(final Account fromAcct,
                              final Account toAcct,
                              final DollarAmount amount)
            throws InsufficientFundsException {
        class Helper {
            public void transfer() throws InsufficientFundsException {
                if (fromAcct.getBalance().compareTo(amount) < 0)
                    throw new InsufficientFundsException();
                else {
                    fromAcct.debit(amount);
                    toAcct.credit(amount);
                }
            }
        }
        int fromHash = System.identityHashCode(fromAcct);1:1
        int toHash = System.identityHashCode(toAcct);2:2

        if (fromHash < toHash) {
            synchronized (fromAcct) {
                synchronized (toAcct) {
                    new Helper().transfer();
                }
            }
        } else if (fromHash > toHash) {
            synchronized (toAcct) {
                synchronized (fromAcct) {
                    new Helper().transfer();
                }
            }
        } else {
            synchronized (tieLock) {
                synchronized (fromAcct) {
                    synchronized (toAcct) {
                        new Helper().transfer();
                    }
                }
            }
        }
    }

    interface DollarAmount extends Comparable<DollarAmount> {
    }

    interface Account {
        void debit(DollarAmount d);

        void credit(DollarAmount d);

        DollarAmount getBalance();

        int getAcctNo();
    }

    class InsufficientFundsException extends Exception {
    }
}
```

- 위 방법을 사용하면 데드드락 위험이 없어짐. 그러나 객체간 hashcode가 같은 값을 가질 경우를 대비해 또 다른 방법을 사용해 락 확보 순서를 조절해야하고 이런 경우에는 타이 브레이킹 락을 사용하는 방법이 있음
- 타이브레이킹 락은 두 개의 락을 임의의 순서로 확보하는 위험한 작업을 특정 순간에 하나의 스레드에서만 할 수 있도록 막는다는 의미. 따라서 데드락이 발생하는 경우가 생기지 않도록 예방할 수 있음
- hashcode가 같은경우가 많이 발생한다면 타이 브레이킹 락은 일종의 병목구간으로 될 수 있음
- 만약 비지니스에 계좌번호, 주민등록번호 같은 pk가 있을 경우 유용하게 사용할 수 있음

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.examples.DynamicOrderDeadlock.Account;
import net.jcip.examples.DynamicOrderDeadlock.DollarAmount;

/**
 * DemonstrateDeadlock
 * <p/>
 * Driver loop that induces deadlock under typical conditions
 *
 * @author Brian Goetz and Tim Peierls
 */
public class DemonstrateDeadlock {
    private static final int NUM_THREADS = 20;
    private static final int NUM_ACCOUNTS = 5;
    private static final int NUM_ITERATIONS = 1000000;

    public static void main(String[] args) {
        final Random rnd = new Random();
        final Account[] accounts = new Account[NUM_ACCOUNTS];

        for (int i = 0; i < accounts.length; i++)
            accounts[i] = new Account();

        class TransferThread extends Thread {
            public void run() {
                for (int i = 0; i < NUM_ITERATIONS; i++) {
                    int fromAcct = rnd.nextInt(NUM_ACCOUNTS);
                    int toAcct = rnd.nextInt(NUM_ACCOUNTS);
                    DollarAmount amount = new DollarAmount(rnd.nextInt(1000));
                    try {
                        DynamicOrderDeadlock.transferMoney(accounts[fromAcct], accounts[toAcct], amount);
                    } catch (DynamicOrderDeadlock.InsufficientFundsException ignored) {
                    }
                }
            }
        }
        for (int i = 0; i < NUM_THREADS; i++)
            new TransferThread().start();
    }
}

```

- 일반적으로 락은 아주 짧은 시간동안만 사용하고 풀어놓는 경우가 많아서 위험성에 대해 인지하지 못할 수 있지만 수천 수억개의 트랜잭션중에서 단 한개만이라도 데드락이 걸린다면 애플리케이션 자체가 먹통이되기 떄문에 굉장히 중요함
- 위 예제는 아주 금방 데드락에 빠지는 예의 코드임



### 객체 간의 데드락

- 프로그램에서 여러개의 락을 확보할 때 두 개의 락을 여러 메서드에서 확보하는 경우도 많기 때문에 한눈에 보이지 않는 경우도 있음

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * CooperatingDeadlock
 * <p/>
 * Lock-ordering deadlock between cooperating objects
 *
 * @author Brian Goetz and Tim Peierls
 */
public class CooperatingDeadlock {
    // Warning: deadlock-prone!
    class Taxi {
        @GuardedBy("this") private Point location, destination;
        private final Dispatcher dispatcher;

        public Taxi(Dispatcher dispatcher) {
            this.dispatcher = dispatcher;
        }

        public synchronized Point getLocation() {
            return location;
        }

        public synchronized void setLocation(Point location) {
            this.location = location;
            if (location.equals(destination))
                dispatcher.notifyAvailable(this);
        }

        public synchronized Point getDestination() {
            return destination;
        }

        public synchronized void setDestination(Point destination) {
            this.destination = destination;
        }
    }

    class Dispatcher {
        @GuardedBy("this") private final Set<Taxi> taxis;
        @GuardedBy("this") private final Set<Taxi> availableTaxis;

        public Dispatcher() {
            taxis = new HashSet<Taxi>();
            availableTaxis = new HashSet<Taxi>();
        }

        public synchronized void notifyAvailable(Taxi taxi) {
            availableTaxis.add(taxi);
        }

        public synchronized Image getImage() {
            Image image = new Image();
            for (Taxi t : taxis)
                image.drawMarker(t.getLocation());
            return image;
        }
    }

    class Image {
        public void drawMarker(Point p) {
        }
    }
}
```

- 두개의 락을 모두 사용해야 하는 메서드는 하나도 없음에도 불구하고 setLocation 메서드와 getImage 메서드를 호출하는 클래스는 두 개의 락을 사용하는 셈이 됨
- 이런경우 데드락을 찾기가 매우 어려운데 이럴땐 락을 확보한 상태에서 에일리언 메서드를 호출하는지 확인하면 도움이됨
- 락을 확보한 상태에서 에일리언 메서드를 호출한다면 가용성에 문제가 생길 수 있음. 에일리언 메서드는 내부에서 다른 락을 확보하려고 하거나 아니면 예상하지 못한만큼 오랜 시간동안 계속해서 실행된다면 호출하기 전에 확보했던 락이 필요한 다른 스레드가 계쏙해서 대기해야 하는 경우도 생길 수 있음



### 오픈 호출

- 위 예제에서 Taxi와 Dispatcher는 데드락의 원인이 자기인지도 모르고 알지도 못해야함. 메서드 호출이라는 것이 그 너머에서 어떤 일이 일어나는지 모르게 막아주는 추상화 방법이기 때문임. 하지만 이런 경우에 특정 락을 확보한 상태에서 에일리언 메서드를 호출한다는 건 파급 효과를 분석하기 굉장히 어렵고 따라서 위험도가 높은 일임
- 락을 전혀 확보하지 않은 상태에서 메서드를 호출하는 것을 오픈 호출이라고 하고 메서드를 호출하는 부분이 모두 오픈 호출로만 이뤄진 클래스는 락을 확보한 채로 메서드를 호출하는 클래스보다 훨씬 안정적이며 달느 곳에서 불러다 쓰기도 좋음
- 데드락을 미연에 방지하고자 오픈 호출을 사용하는 것은 스레드 안전성을 확보하기 위해 캡슐화 기법을 사용하는 것과 비슷함



```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * CooperatingNoDeadlock
 * <p/>
 * Using open calls to avoiding deadlock between cooperating objects
 *
 * @author Brian Goetz and Tim Peierls
 */
class CooperatingNoDeadlock {
    @ThreadSafe
    class Taxi {
        @GuardedBy("this") private Point location, destination;
        private final Dispatcher dispatcher;

        public Taxi(Dispatcher dispatcher) {
            this.dispatcher = dispatcher;
        }

        public synchronized Point getLocation() {
            return location;
        }

        public synchronized void setLocation(Point location) {
            boolean reachedDestination;
            synchronized (this) {
                this.location = location;
                reachedDestination = location.equals(destination);
            }
            if (reachedDestination)
                dispatcher.notifyAvailable(this);
        }

        public synchronized Point getDestination() {
            return destination;
        }

        public synchronized void setDestination(Point destination) {
            this.destination = destination;
        }
    }

    @ThreadSafe
    class Dispatcher {
        @GuardedBy("this") private final Set<Taxi> taxis;
        @GuardedBy("this") private final Set<Taxi> availableTaxis;

        public Dispatcher() {
            taxis = new HashSet<Taxi>();
            availableTaxis = new HashSet<Taxi>();
        }

        public synchronized void notifyAvailable(Taxi taxi) {
            availableTaxis.add(taxi);
        }

        public Image getImage() {
            Set<Taxi> copy;
            synchronized (this) {
                copy = new HashSet<Taxi>(taxis);
            }
            Image image = new Image();
            for (Taxi t : copy)
                image.drawMarker(t.getLocation());
            return image;
        }
    }

    class Image {
        public void drawMarker(Point p) {
        }
    }

}
```

- 프로그램을 작성할 때 최대한 오픈 호출 방법을 사용하도록 함. 내부의 모든 부분에서 오픈 호출을 사용하는 프로그램은 락을 확보한 상태로 메서드를 호출하곤 하는 프로그램보다 데드락 문제를 찾아내기 위한 분석 작업을 훨씬 간편하게 해줌.



### 리소스 데드락

- 필요한 자원을 사용하기 위해 대기하는 과정에도 데드락이 발생할 수 있음 ex 데이터베이스 풀에 2개의 커넥션이 있고 (D1, D2) 어떤작업 A는 두개의 커넥션을 순서와 상관없이 가져온다고 가졍했을때 T1은 D1을 먼저 갖고있고 T2는 D2를 먼저 갖고 있다면 데드락
- 다른 작업의 실행 결과를 사용해야만 하는 작업이 있다면 스레드 소모성 데드락의 원인이 되기 쉬움
- 크기가 제한된 풀과 다른 작업과 연동됒동작하는 작업은 잘못 사용하면 문제가 될 수 있음



## 데드락 방지 및 원인 추적

- 한번에 하나 이상의 락을 사용하지 않는 프로그램은 락의 순서에 의한 데드락이 발생하지 않음 실용적이지 않지만 가능하다면 한 번에 하나 이상의 락을 사용하지 않도록 프로그램을 만들어보는 것도 좋음
- 여러 개의 락을 사용해야한다면 락을 사용하는 순서 역시 설계 단계부터 충분히 고려해야함. 설계 과정에서 여러 개의 락이 서로 함께 동작 하는 부분을 최대한 줄이고, 락의 순서를 지정하는 규칙을 정해 문서로 남기고 그 규칙을 정확하게 따라서 프로그램을 작성해야함.
- 세세한 락을 사용하는 프로그램을 분석할때는 여러 개의 락을 확보하는지 먼저 확인하고 전반적인 분석 작업을 진행해 프로그램 에더이서건 락을 지정된 순서에 맞춰 사용하도록 해야함



### 락의 시간제한

- 데드락 상태를 검출하고 데드락에서 복구하는 또 다른 방법으로는 synchronized 등의 구문으로 암묵적인 락을 사용하는 대신 Lock클래스의 메서드 가운데 시간을 제한할 수 있는 tryLock 메서드를 사용하는 방법이 있음
- tryLock은 일정 시간동안 락을 확보하지 못했다면 오류를 발생시키도록 할 수 있음



### 스레드 덤프를 활용한 데드락 분석

- jvm이 만들어내는 스레드 덤프를 활용해 데드락이 발생한 위치를 확인하는데 도움을 얻을 수 있음
- 스레드 덤프에는 실행중인 모든 스레드의 스택 트레이스가 담겨져 있음 각 스레드마다 어떤 락을 확보하고 있는지, 스택의 어느 부분에서 락을 확보했는지, 대기중인 스레드가 어느 락을 확보하려고 대기중이었는지 등등
- 명시적락은 암묵적락보다 스레드덤프에 대한 내용이 정확하지 않음 암묵적인 락은 스택 프레임에 연결되어있지만 명시적인 락은 락을 확보한 스레드와 연결되어 있기 때문



## 그 밖의 활동성 문제점

### 소모

- 소모 상태는 스레드가 작업을 진행하는데 꼭 필요한 자원을 영영 할당받지 못하는 경우에 발생함
- 소모 상태를 일으키는 가장 흔한 원인은 바로 cpu임 자바에서는 스레드의 우선 순위를 적절치 못하게 올리거나 내리기, 락을 확보한 채로 종료되지 않는 코드 등등
- 스레드 우선순위를 변경하지 않고 사용하는게 가장 현명함



### 형편 없는 응답성

- 소모 상황보다 나은 경우는 바로 응답성이 떨어지는 상황
- gui 애플리케이션에서 많이 나옴. 백그라운드 작업이 cpu를 많이 사용해서 사용자 화면의 응답성이 떨어질 수 있음
- 해당 백그라운드의 우선순위를 낮춰 응답성을 높여줄 수 있음
- 애플리케이션의 응답성이 떨어진다면 락을 제대로 관리하지 못하는 것이 원인일 수 있음



### 라이브락

- 대기중인 상태가 아니었다 해도 특정 작업의 결과를 받아와야 다음 단계로 넘어갈 수 있는 작업이 실패할 수 밖에 없는 기능을 계속해서 재시도 하는 경우에 쉽게 찾아볼 수 있음 ex 메시지 시스템에서 특정 메시지 전송을 실패하고 다시 실패한 메시지를 큐의 맨 뒤에 쌓아두는 애플리케이션에서 자주 발생
- 이런 형태의 라이브락은 에러를 너무 완벽하게 처리하고자 회복 불가능한 오류를 회복 가능하다고 판단해 계속해서 재시도하는 과정에 나타남
- 이런 형태의 라이브락은 재시도부분에 약간의 규칙적이지 않은 구조를 넣어주면 해결 가능



## 요약

- 활동성과 관련된 문제는 심각한 경우가 많은데 활동성 문제를 해결하려면 일반적으로 애플리케이션을 종료하는 것 외에는 별다른 방법이 없다는 데심각성의 원인이 있음
- 가장 흔한 형태의 활동성 문제는 락 순서에 의한 데드락. 락 순서에 의한 데드락을 방지하려면 애플리케이션을 설계하는 단계부터 여러 개의 락을 사용하는 부분에 대해 충분히 고려해야함. 애플리케이션 내부의 스레드에서 두 개 이상의 락을 한꺼번에 사용해야 하는 부분이 있다면 항상 일정한 순서를 두고 여러개의 락을 확보해야함
- 이런 문제에 대한 가장 효과적인 해결 방법은 항상 오픈 호출 방법을 사용해 메서드를 호출하는 것. 오픈 호출을 사용하면 한 번에 여러 개의 락을 사용하는 경우를 엄청나게 줄일 수 있고. 따라서 여러 개의 락을 사용하는 부분이 어디인지 쉽게 찾아낼 수 있음



# #11 성능, 확장성

- 스레드를 사용하는 가장 큰 목적은 바로 성능을 높이고자 하는 것

## 성능에 대해

- 성능을 높인다는 것은 더 적은 자원을 사용하면서 더 많은 일을 하도록 한다는 말임
- 여기서 자원이란 cpu, 메모리, 네트웍 속도, 디스크 속도, 데이터베이스 처리 속도, 디스크 용량 등 어느것이 될 지 모르지만 항상 모자라는 부분이 발생함
- 여러 개의 스레드를 사용하려 한다면 항상 단일 스레드를 사용할 때보다 성능상의 비용을 지불해야만 함. 스레드 간의 작업 내용을 조율하는데 필요한 오버헤드, 컨텍스트 스위칭, 스레드 생성 제거 비용 등등
- 이와 같은 비용을 지불한다 해도 스레드를 효율적으로 잘 적응하면 성능이나 응답성이 높아지고 처리 용량도 커지는 등의 여러 장점을 얻을 수 있음
- 더나은 성능을 위해 먼저 프로그램이 확보할 수 있는 모든 자원을 최대한 활용해야 하고 남은 자원이 생길때마다 그 자원 역시 최대한 활용할 수 있도록 해야 함

### 성능 대 확장성

- 애플리케이션의 성능은 서비스 시간, 대기 시간, 처리량, 효율성, 확장성, 용량 등의 수치를 뽑아낼 수 있음 이 성능들은 얼마나 빠르냐, 또는 동일한 자원을 갖고 얼마나 많은 양의 일을 할 수 있는지 알려줌
- 성능이라는 단어에는 얼마나 빠르게 또는 얼마나 많이 라는 두가지의 의미가 있음 어떤 경우에는 서로 화합할 수 없는 상황도 발생함. 
- 단일 스레드 애플리케이션에서 사용하던 성능 개선 방안은 대부분 확장성의 측면에서 효과적이지 않음
- 단일 구조일경우 급격히 증가하는 처리요청을 감당할 방법이 없음. 하드웨어 자원의 양이 크게 증가해야함.
- 서버 애플리케이션을 만들 때는 성능의 여러가지 측면 가운데 얼마나 빠르게 라는 측면보다 얼마나 많이 라는 측면, 즉 확장성과 처리량과 용량이라는 세 개의 측면을 훨씬 더 중요하게 생각하는 경우가 많음

### 성능 트레이드 오프 측정

- 공학적인 모든 선택의 순간에는 항상 트레이드 오프가 존재함 ...
- 최적화 기법을 너무 이른 시점에 적용하지 말아야함. 일단 제대로 동작하게 만들고 난 다음에 빠르게 동작하도록 최적화해야 하며, 예상한 것보다 심각하게 성능이 떨어지는 경우에만 최적화 기법을 적용하는 것으로 충분함
- 일부 최적화 기법을 사용하다보면 훌륭한 객체지향적인 설계 원칙에서 벗어나야 하는 경우도 있고 코드도 어렵고 유지보수하기도 어려움
- 빠르다라고 말하기 전에 다음과 같은 질문을 해볼 것 
  - '빠르다' 단어가 무엇을 의미하는가?
  - 어떤 조건을 갖춰야 이 방법이 실제로 빠르게 동작할 것인가? 부하가 적을 때 아니면 부하가 걸릴 때? 데이터가 많을 때? 아니면 적을 때? 이런 질문에 대한 대답에 명확한 수치를 보여줄 수 있는가?
  - 위의 조건에 해당하는 경우가 얼마나 많이 발생하는가? 이런 질문에 대한 대답에 명확한 수치를 보여줄 수 있는가?
  - 조건이 달라지는 다른 상황에서도 같은 코드를 사용할 수 있는가?
  - 이 방법으로 성능을 개선하고자 할 때, 숨겨진 비용, 즉 개발 비용이나 유지 보수 비용이 증가하는 부분이 어느 정도인지? 과연 그런 비용을 감수하면서까지 성능 개선 작업을 해야 하는가?
- 성능을 높이기 위해 안전성을 떨어뜨리는 것은 최악의 상황.
- 성능을 튜닝하는 모든 과정에서 항상 넝능 목표에 대한 명확한 요구 사항이 있어야 하고 그래야 어느 부분을 튜닝하고 어느 시점에서 튜닝을 그만둬야 하는지를 판단할 수 있음
- 특별히 성능을 높이기를 원하지 않는다면 여러 비용을 지불해가면서 성능을 높일 필요가 없음
- 반드시 추측하지 말고 실제로 측정해볼것



## 암달의 법칙

- 일부 작업은 자원을 더 많이 투입하면 더 빨리 처리할 수 있음
- 프로그램을 작성할 때 스레드를 사용하려는 주된 이유가 멀티프로세서의 성능을 최대한 활용하려는 것이라면 그 작업이 병렬화가 가능한지, 병렬화 했을 때 그 가능성을 최대한 활용할 수 있어야함
- 암달의 법칙을 사용하면 병렬 작업과 순차 작업의 비율에 따라 하드웨어 자원을 추가로 투입했을 때 이론적으로 속도가 얼마나 빨라질지에 대한 예측 값을 얻을 수 있음
- 암달의 법칙에 따르면 프로세서의 개수가 증가하면 증가할수록 순차적으로 실행해야하는 부분이 아주 조금이라도 늘어나면 프로세서 개수에 비해 얻을 수 있는 속도 증가량이 크게 떨어짐

```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * WorkerThread
 * <p/>
 * Serialized access to a task queue
 *
 * @author Brian Goetz and Tim Peierls
 */

public class WorkerThread extends Thread {
    private final BlockingQueue<Runnable> queue;

    public WorkerThread(BlockingQueue<Runnable> queue) {
        this.queue = queue;
    }

    public void run() {
        while (true) {
            try {
                Runnable task = queue.take();
                task.run();
            } catch (InterruptedException e) {
                break; /* Allow thread to exit */
            }
        }
    }
}
```

- BlockingQueue는 모든 작업 스레드에서 사용하도록 공유되어있기 때문에 이런 부분은 순차적으로 처리될 수 밖에 없음
- 작업을 처리한 뒤에도 순서가 필요하다면 이 역시 순차적으로 처리해야 하는 일이 됨
- 모든 병렬 프로그램에는 항상 순차적으로 실행돼야만 하는 부분이 존재함. 만약 그런 부분이 없다고 생각하면 프로그램 코드를 다시 한번 들여볼 것

### 예제: 프레임웍 내부에 감춰져 있는 순차적 실행 구조

- 애플리케이션 내부 구조에 순차적으로 처리해야 하는 구조가 어떻게 숨겨져있는지를 알아보려면 스레드 개수를 증가시킬 때마다 성능이 얼마나 빨라지는지를 기록해두고, 성능상의 차이점을 기반으로 순차적으로 처리하는 부분이 얼마만큼인지 추측해볼 수 있음



### 정성적인 암달의 법칙 적용 방법

- 암달의 법칙을 사용하면 프로그램 내부에서 순차적으로 처리돼야만 하는 부분의 비율을 알고 있을 때 하드웨어를 추가함에 따라 얼마만큼 처리 속도가 증가할 것인지를 수치화해서 예측할 수 있음



## 스레드와 비용

- 스레드를 사용하는 경우 병렬로 실행함으로써 얻을 수 있는 이득이 병렬로 실행하느라 드는 비용을 넘어서야 성능을 향상시킬 수 있음



### 컨텍스트 스위칭

- 하나의 스레드가 실행되다가 다른 스레드가 실행되는 순간 컨텍스트 스위칭이 일어남
- 먼저 현재 실행중인 스레드의 실행 상태를 보관해두고 다음 번에 실행되기로 스케줄된 다른 스레드의 실행 상태를 다시 읽어들임
- 컨텍스트 스위칭은 비용이 공짜가 아님
- 스레드가 실행하다가 락을 확보하기 위해 대기하기 시작하면 일반적으로 jvm은 해당 스레드를 일시정지 시키고 다른 스레드가 실행되도록 함. 특정 스레드가 빈번하게 대기 상태에 들어간다고 하면 스레드별로 할당된 최소 실행 시간조차 사용하지 못하는 경우가 있음. 이런 대기상태에 들어가는 연산을 많이 사용하는 프로그램은 cpu를 주로 활용하는 프로그램보다 컨텍스트 스위칭 횟수가 훨씬 많아지고, 따라서 스케줄링 부하가 늘어나면서 전체적인 처리량이 줄어듦



### 메모리 동기화

- 동기화가 성능에 미치는 영향을 파악하려면 동기화 작업이 경쟁적인지, 비경쟁적인지 확인해야함
- jvm은 대부분 다른 스레드와 경쟁할 가능성이 없다고 판단되는 부분에 락이 걸려 있으면 최적화 과정에서 해당 락을 사용하지 않도록 방지하는 기능을 제공하기도 함

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * ThreeStooges
 * <p/>
 * Immutable class built out of mutable underlying objects,
 * demonstration of candidate for lock elision
 *
 * @author Brian Goetz and Tim Peierls
 */
@Immutable
 public final class ThreeStooges {
    private final Set<String> stooges = new HashSet<String>();

    public ThreeStooges() {
        stooges.add("Moe");
        stooges.add("Larry");
        stooges.add("Curly");
    }

    public boolean isStooge(String name) {
        return stooges.contains(name);
    }

    public String getStoogeNames() {
        List<String> stooges = new Vector<String>();
        stooges.add("Moe");
        stooges.add("Larry");
        stooges.add("Curly");
        return stooges.toString();
    }
}
```

- Vector의 add() 는 락을 쓰지만 이변수가 외부에 유출된적이 없다는 것을 판단하고  getStoogeNames()를 실행하는 동안 add() 와 toString()을 실행하느라 4번의 락을 걸지 않는다는 뜻. 락 생략.
- 유출분석이 아니라면 연달아 붙어있는 add()를 하나의 락으로 묶어서 한번만 확보하고 해제시킴. 락 확장. 
- 경쟁조건에 들어가지 않는 동기화 블록에 대해서는 그다지 걱정하지 않아도 좋음. 동기화 블록의 기본적인 구조가 상당히 빠르게 동작할 뿐만 아니라 jvm 수준에서 동기화와 고나련한 추가적인 최적화 작업을 진행하기 때문에 동기화 관련 부하를 줄이거나 아예 없애주기도 함. 대신 경쟁 조건이 발생하는 동기화 블록을 어떻게 최적화할지에 대해 고민할 것.
- 특정 스레드에서 진행되는 동기화 작업으로 인해 다른 스레드의 성능이 영향을 받을 수 있음. 공유 메모리로 통하는 버스는 제한적인 대역폭을 갖고 있고 여러개의 프로세서가 공유하기 때문



### 블로킹

- 경쟁하지 않는 동기화작업은 jvm 내부에서 처리하지만 경쟁 조건이 발생하는 동기화작업은 운영체제가 관여해야함. 이런 부분은 일정량의 자원을 소모하게됨
- 락을 확보하지 못한 스레드는 항상 대기상태에 있어야하는데 jvm은 두가지 방법으로 스레드를 대기상태로둠
  - 스핀대기, 락을 확보할 때까지 계속해서 재시도 하는 방법
  - 운영체제가 제공하는 기능을 사용해 스레드를 실제 대기 상태로 두는 방법
- 두개의 방법 가운데 정답은 컨텍스트 스위칭에 필요한 자원의 양과, 락을 확보할 떄까지 걸리는 시간에 크게 좌우됨 대기시간이 짧은 경우에는 스핀 대기 방법이 효과적이고, 대기 시간이 긴 경우에는 운영체제의 기능을 호출하는 편이 효율적이라고함 대부분 후자



## 락 경쟁 줄이기

- 작업을 순차적으로 처리하면 확장성을 놓치고 작업을 병렬로 처리하면 컨텍스트 스위칭에서 성능에 악영향을 줌
- 락을 놓고 경쟁하면 순차적으로 처리함과 동시에 컨텍스트 스위칭도 많이 일어나므로 확장성과 성능을 동시에 떨어뜨리는 원인이 됨
- 락 경쟁을 줄이면 줄일수록 확장성과 성능을 함께 높일 수 있음
- 락으로 사용 제한이 걸려있는 독점적인 자원을 사용하려는 모든 스레드는 순차적. 락을 확보하고자 지속적으로 경쟁하는 상황에서는 확장성에 문제가생김
- 병렬 애플리케이션에서 확장성에 가장 큰 위협이 되는 존재는 바로 특정 자원을 독점적으로 사용하도록 제한하는 락임
- 락을 두고 발생하는 경쟁 상황에서 락을 얼마나 빈번하게 확보하려고 하는지, 그리고 한번 확보하면 해제까지 얼마나 오래 사용하는지가 주용한 요인임 이 두가지 요인을 곱한 값이 충분히 작은 값이라면 락을 두고 경쟁하는 상황 떄문에 확장성에 심각한 문제가 생기지는 않음
- 락 경쟁 조건을 줄일 수 있는 방법
  - 락을 확보한 채로 유지되는 시간을 최대한 줄일것
  - 락을 확보하고자 요청하는 횟수를 최대한 줄일것
  - 독점적인 락 대신 병렬성을 크게 높여주는 여러가지 조율 방법을 사용

### 락 구역 좁히기

- 락 경쟁이 발생할 가능성을 줄이는 효과정인 방법은 락을 유지하는 시간을 줄이는 방법
- 특히 I/O작업과 같이 대기 시간이 발생할 수 있는 코드는 최대한 synchronized블록 밖으로

```java
package net.jcip.examples;

import java.util.*;
import java.util.regex.*;

import net.jcip.annotations.*;

/**
 * AttributeStore
 * <p/>
 * Holding a lock longer than necessary
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class AttributeStore {
    @GuardedBy("this") private final Map<String, String>
            attributes = new HashMap<String, String>();

    public synchronized boolean userLocationMatches(String name,
                                                    String regexp) {
        String key = "users." + name + ".location";
        String location = attributes.get(key);
        if (location == null)
            return false;
        else
            return Pattern.matches(regexp, location);
    }
}
```

- 실제 락이 필요한 부분은 attributes.get(key); 밖에 없음
- 아래처럼 튜닝 가능

```java
package net.jcip.examples;

import java.util.*;
import java.util.regex.*;

import net.jcip.annotations.*;

/**
 * BetterAttributeStore
 * <p/>
 * Reducing lock duration
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class BetterAttributeStore {
    @GuardedBy("this") private final Map<String, String>
            attributes = new HashMap<String, String>();

    public boolean userLocationMatches(String name, String regexp) {
        String key = "users." + name + ".location";
        String location;
        synchronized (this) {
            location = attributes.get(key);
        }
        if (location == null)
            return false;
        else
            return Pattern.matches(regexp, location);
    }
}
```

- 추가적으로 HashMap을 사용하는게 아니라 자료구조 차원에서 제공하는 동기화된 자료구조를 사용하면 효율성을 더 높일 수 있이고 동기화에 대한 처리를 신경쓰지 않아도됨
- 단일연산으로 실행되어야 할 명령까지 synchronized 블록 밖으로 빼내거나 해서는 안됨



### 락 정밀도 높이기

- 또다른 방법으로 스레드에서 해당 락을 덜 사용도록 변경하는 방법이 있음
- 이런 방법에는 락 분할과 락 스트라이핑 방법이 있음 두가지 모두 하나의 락으로 여러 개의 상태 변수를 한번에 묶어두지 않고, 서로 다른 락을 사용해 여러개의 독립적인 상태 변수를 각자 묶어두는 방법
- 두가지 기법을 활용하면 락으로 묶이는 프로그램의 범위를 조밀하게 나누는 효과가 있고 결국 애플리케이션의 확장성이 높아지는 결과를 기대할 수 있음
- 반대로 락의 개수가 많아질수록 데드락의 발생 위험도 높아짐

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * ServerStatusBeforeSplit
 * <p/>
 * Candidate for lock splitting
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class ServerStatusBeforeSplit {
    @GuardedBy("this") public final Set<String> users;
    @GuardedBy("this") public final Set<String> queries;

    public ServerStatusBeforeSplit() {
        users = new HashSet<String>();
        queries = new HashSet<String>();
    }

    public synchronized void addUser(String u) {
        users.add(u);
    }

    public synchronized void addQuery(String q) {
        queries.add(q);
    }

    public synchronized void removeUser(String u) {
        users.remove(u);
    }

    public synchronized void removeQuery(String q) {
        queries.remove(q);
    }
}
```

- 비지니스에 따라 기능에 문제가 생기지 않는 범위에서 두개의 클래스로 분리해 구현할 수 있음

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * ServerStatusAfterSplit
 * <p/>
 * ServerStatus refactored to use split locks
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class ServerStatusAfterSplit {
    @GuardedBy("users") public final Set<String> users;
    @GuardedBy("queries") public final Set<String> queries;

    public ServerStatusAfterSplit() {
        users = new HashSet<String>();
        queries = new HashSet<String>();
    }

    public void addUser(String u) {
        synchronized (users) {
            users.add(u);
        }
    }

    public void addQuery(String q) {
        synchronized (queries) {
            queries.add(q);
        }
    }

    public void removeUser(String u) {
        synchronized (users) {
            users.remove(u);
        }
    }

    public void removeQuery(String q) {
        synchronized (users) {
            queries.remove(q);
        }
    }
}
```

- 위와 같이 한번에 동귀화하지 않고 각 상태 변수를 각자의 락으로 동기화시키면 락의 정밀도가 높아졌다고 볼 수 있고 분할하기 전에 정밀도가 적은 방법보다 대기상태에 들어가는 경우가 크게 줄어듦
- 락을 하나에서 둘로 분할하는 방법은 경쟁 조건이 아주 심하지는 않지만 그래도 어느정도 경쟁이 발생하고 있는 경우에 가장 큰 효과를 볼 수 있음 



### 락 스트라이핑

- 락 분할 방법은 떄에 따라 독립적인 객체를 여러가지 크기의 단위로 묶어내고 묶인 블록을 단위로 락을 나누는 방법을 사용할 수 있는데 이런 방법을 락 스트라이핑 이라고함
- ConcurrentHashMap은 16개의 락 각자가 전체 해시 범위의 1/16에 대한 락을 담당하도록 설계되었음 

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * StripedMap
 * <p/>
 * Hash-based map using lock striping
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class StripedMap {
    // Synchronization policy: buckets[n] guarded by locks[n%N_LOCKS]
    private static final int N_LOCKS = 16;
    private final Node[] buckets;
    private final Object[] locks;

    private static class Node {
        Node next;
        Object key;
        Object value;
    }

    public StripedMap(int numBuckets) {
        buckets = new Node[numBuckets];
        locks = new Object[N_LOCKS];
        for (int i = 0; i < N_LOCKS; i++)
            locks[i] = new Object();
    }

    private final int hash(Object key) {
        return Math.abs(key.hashCode() % buckets.length);
    }

    public Object get(Object key) {
        int hash = hash(key);
        synchronized (locks[hash % N_LOCKS]) {
            for (Node m = buckets[hash]; m != null; m = m.next)
                if (m.key.equals(key))
                    return m.value;
        }
        return null;
    }

    public void clear() {
        for (int i = 0; i < buckets.length; i++) {
            synchronized (locks[i % N_LOCKS]) {
                buckets[i] = null;
            }
        }
    }
}
```

- N_LOCKS만큼의 락 배열을 생성하고 각각 해시 공간에 대한 동기화를 담당함
- 모든 N_LOCKS개의 락을 확보해야하는 경우도 있지만 clear 메서드와 같이 락을 한꺼번에 확보하지 않고 처리할 수 있는 방법이 있을 수도 있음 <= ?



### 핫 필드 최소화

- 락 분할 방법과 락 스트라이핑은 여러 개의 스레드가 각자 방해받지 않으면서 독립적인 데이터를 사용할 수 있도록 해주기 때문에 애플리케이션의 확장성을 높여줌
- 애플리케이션의 내부를 살펴봤을 때 락으로 동기화시킨 데이터에 대한 경쟁보다 락 자체에 대한 경쟁이 더 심한 상태인 경우에 락 분할 방법으로 확장성에 이득을 얻을 수 있음
- 자주 계산하고 사용하는 값을 캐시에 저장해두도록 최적화한다면 확장성을 떨어뜨릴 수밖에 없는 핫 필드가 생김
- hashmap 같은 경우는 size, isEmpty 같은 값을 얻을때 연산마다 값을 변환시켜서 저장하면 쉽게 얻어낼 수 있지만 병렬 컬렉션의 경우는 다름 특정 변수 하나에 물리면 결국 스트라이핑 해도 특정 변수때문에 병목이 나타남 이런 필드를 핫 필드라고함
- ConcurrentHashMap은 전체 카운트를 하나의 변수에 두지 않고 락으로 분배된 각 부분마다 카운터 변수를 갖고 size 메서드를 호출하면 각 카운터 변수의 합을 알려주는 방법을 사용함



### 독점적인 락을 최소화하는 다른 방법

- 락 경쟁 때문에 발생하는 문제점을 줄일 수 있는 또 다른 방법으로 좀더 높은 병렬성으로 공유된 변수를 관리하는 방법을 도입해 독점적인 락을 사용하는 부분을 줄이는 것. 예를 들어 병렬 컬렉션 클래스를 사용하거나 읽기 쓰기 락, 불변 객체를 사용하기
- 읽기 전용의 데이터 구조라면 불변 클래스의 형태를 유지하는 것만으로도 동기화 코드를 완전히 제거 가능
- 단일 연산 변수를 사용하면 통계 값을 위한 카운터 변수와 같은 핫 필드의 값을 손쉽게 변경 가능 <= AtomicLong ...
- 핫필드를 단일 연산 변수로 변경하는 것만으로도 확장성에 이득을 볼 수 있음

### CPU 활용도 모니터링

- 애플리케이션의 확장성을 테스트할 때 그 목적은 대부분 cpu를 최대한 활용하는 데 있음
- 특정 cpu만 열심히 일하고 나머지는 놀고 있다면 아래의 원인을 생각해볼 수 있음

**부하가 부족함**

- 애플리케이션이 허덕거릴 만큼의 부하를 만들어 내지 못할 수 있음

**I/O제약**

- 네트웍 트래픽 수준을 모니터링하면 대역폭을 얼마나 사용하는지 쉽게 파악 가능

**외부 제약사항**

- 외부 데이터베이스, 웹서비스가 성능의 발목을 잡는 경우도 있음

**락 경쟁**

- 각종 프로파일링 도구를 활용하면 애플리케이션 내부에서 락 경쟁 조건이 얼마나 발생하는지 알아볼 수 있음
- 경쟁의 대상이 되는 락은 최소한 하나 이상의 스레드가 해당 락을 확보하기 위해 대기하고 있을 것이기 때문에 스레드 덤프에서 쉽게 확인 가능함



- vmstat으로 cpu가 모자라 실행하지 못하는 스레드의 수가 표시되는데 이런경우에 cpu를 늘림으로써 성능을 높일 수 있음

### 객체 풀링은 하지 말자

- 과거에는 객체 관련 할당과 제거 작업이 느렸을때는 객체를 더이상 사용하지 않는다 하더라도 객체풀에 넣어두는 방식을 사용했었음 이런 방식은 사용하지 말 것.
- 병렬 애플리케이션에서의 객체 풀링은 훨씬 더 많은 비용을 지불해야함.
- 스레드 동기화하는 것보다 메모리에 객체를 할당하는 일이 훨씬 부담이 적음



## 예제: Map 객체의 성능 분석

- synchronizedhashmap은 맵 전체가 하나의 락으로 동기화 되어 있다는 점. ConcurrentHashMap은 대부분 읽기 연산에는 락을 걸지 않고 쓰기, 일부 읽기에는 락 스트라이핑을 사용함.
- 



# #12 병렬 프로그램 테스트

## 정확성 테스트

## 성능 테스트

## 성능 측정의 함정 피하기

## 보조적인 테스트 방법



# #13 명시적인 락

## Lock과 ReentrantLock

## 성능에 대한 고려 사항

## 공정성

## synchronized 또는 ReentrantLock 선택

## 읽기-쓰기 락



# #14 동기화 클래스 구현

## 상태 종속성 관리

## 조건 큐 활용

## 명시적인 조건 객체

## 동기화 클래스의 내부 구조

## AbstractQueuedSynchronizer

## java.util.concurrent 패키지의 동기화 클래스에서 AQS 활용 모습

## 

# #15 단일 연산 변수와 넌블로킹 동기화

## 락의 단점

## 병렬 연산을 위한 하드웨어적인 지원

## 단일 연산 변수 클래스

## 넌블로킹 알고리즘



# #16 자바 메모리 모델

## 자바 메모리 모델은 무엇이며, 왜 사용해야 하는가?

## 안전한 공개

## 초기화 안전성



