



# 자바 병렬 프로그래밍

**소스코드**

[https://jcip.net/listings](https://jcip.net/listings)



# #1 개요

## 작업을 동시에 실행하는 일에 대한 간략한 역사

- 자원 활용, 공정성, 편의성 등 프로세스 개념을 만들어내게 된 것과 같은 동기를 갖고 스레드가 고안됨
- 스레드로 인해 한 프로세스 안에 여러개의 프로그램 제어 흐름이 공존할 수 있음
- 스레드는 메모리, 파일 핸들과 같이 프로세스에 할당된 자원을 공유함 하지만 각 스레드는 각기 별도의 프로그램 카운터, 스택, 지역변수를 가짐
- 프로그램을 스레드로 분리하면 멀티프로세서 시스템에서 자연스럽게 하드웨어 병렬성을 이용할 수 있음 즉 한 프로그램 내 여러 스레드를 동시에 여러 개의 cpu에 할당해 실행시킬 수 있음
- 스레드는 lightweight process라고 부르기도 함
- 운영체제의 대부분은 프로세스가 아니라 스레드를 기분 단위로 cpu 자원의 스케줄을 정함
- 스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드들은 같은 변수에 접근하고 같은 힙에 객체를 할당함 이때 공유된 과정을 적절하게 동기화하지 않으면 다른 스레드가 사용중인 변수를 순간적으로 수정해서 예상치 못한 결과를 얻을 수도 있음

## 스레드의 이점

- 스레드를 제대로만 사용하면 개발 및 유지보수 비용을 줄이고 복잡한 애플리케이션의 성능을 향상시킬 수 있음

### 멀티 프로세서 활용

- 여러개의 스레드를 사용하면 프로세서가 하나라 해도 처리속도를 높일 수 있음
- 프로세스가 여러개라도 스레드가 하나라면 자원 낭비임

### 단순한 모델링

### 단순한 비동기 이벤트 처리

### 더 빨리 반응하는 사용자 인터페이스

## 스레드 사용의 위험성

### 안전성 위해 요소

- 동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산의 순서를 예측하기 매우 어려움

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * UnsafeSequence
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
public class UnsafeSequence {
    private int value;

    /**
     * Returns a unique value.
     */
    public int getNext() {
        return value++;
    }
}
```

- 위 코드는 여러 스레드에서 실행될때 getNext()를 동시에 호출했을때 같은 값을 얻을 가능성이 있음
- 스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용 중일지도 모르는 변수를 읽거나 수정할 수도 있음 편리하지만 위험 요소이기도 함. 데이터가 예측 못한 시점에 변경될 수 있기 때문
- 스레드가 서로 간섭하지 않도록 공유된 변수에 접근하는 시점에 적절하게 조율해야함
- 위 클래스는 아래처럼 수정 가능함

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * Sequence
 *
 * @author Brian Goetz and Tim Peierls
 */

@ThreadSafe
public class Sequence {
    @GuardedBy("this") private int nextValue;

    public synchronized int getNext() {
        return nextValue++;
    }
}
```

### 

### 활동성 위험

- 동시 수행 코드를 개발할 때는 반드시 스레드 안전성 문제를 신경써야 함 반드시!
- 멀티 스레드 프로그램에서는 단일 스레드 프로그램에서 발생하지 않는 추가적인 위험에 노출됨
- deadlock, starvation, livelock 등등 활동성 장애



### 성능 위험

- 성능 문제는 형편없는 서비스 시간, 만응성, 처리율, 자원 소모, 규모에 따른 확장성 등 넓은 범위의 문제들을 포괄함
- 잘 설계된 병렬 프로그램은 스레드를 사용해서 궁극적으로 성능을 향상시킬 수 있으나 많은 스레드를 사용함으로써 메모리의 지역성이 손실되고 동기화 수단을 사용 하는 등의 성능 손실을 유발할 수 있음



## 스레드는 어디에나

- 모든 자바 프로그램은 기본적으로 스레드를 사용함 main 메서드를 실행하는 스레드, JVM에서 사용하는 스레드 등
- 개발자는 병렬성과 스레드 안전성에 대해 잘 알아야함



# #2 스레드 안전성

- 스레드에 안전한 코드를 작성하는 것은 근본적으로는 상태, 특히 공유되고 변경할 수 있는 상태에 대한 접근을 관리하는 것 ex static,  인스턴스 변수
- 스레드 안전성이란 데이터에 제어 없이 동시 접근을 막으려는 의미
- 객체가 스레드에 안전해야 하느냐는 해당 객체에 여러 스레드가 접근할지의 여부에 달렸음
- 객체를 스레드에 안전하게 만드려면 동기화를 통해 변경할 수 있는 상태에 접근하는 과정을 조율해야 함
- 스레드가 하나 이상 상태 변수에 접근하고 그 중 하나라도 변수에 값을 쓰면, 해당 변수에 접근할 때 관련된 모든 스레드가 동기화를 통해 조율되어야함
- 자바에서는 synchronized 키워드로 배타적인 락을 통해 보호 기능을 제공함
- volatile변수, 명시적 락, 단일 연산 변수 atomic variable을 사용하는 경우에도 동기화라는 용어를 사용함
- 동시성 관련된 문제를 해결하는 세가지 방법
  - 해당 상태 변수를 스레드 간에 공유하지 않도록 함
  - 해당 상태 변수를 변경할 수 없도록 만듬
  - 해당 상태 변수에 접근할 땐 언제나 동기화를 사용함
- 클래스 설계시점에 스레드 안전하게 설계하는것이 훨씬 쉬움
- 프로그램 상태를 잘 캡슐화할수록 스레드 안전하게 만들기 쉽고 유지보수도 쉬움
- 스레드 안전한 클래스를 설계할 땐, 바람직한 객체 지향 기법이 왕도. 캡슐화와 불변객체를 잘활용하고 불변 조건을 명확하게 기술해야함

## 스레드 안전성이란?

- 여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케줄하든 어띠에 끼워넣든, 호출하는 쪽에서추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고함
- 스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화함



### 예제: 상태없는 서블릿

```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * StatelessFactorizer
 *
 * A stateless servlet
 * 
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class StatelessFactorizer extends GenericServlet implements Servlet {

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[] { i };
    }
}
```

- 위와 같이 상태가 없는 객체는 항상 스레드에 안전함
- 서블릿 요청 간에 뭔가를 기억할 필요가 있을 때에야 스레드 안전성이 문제가 됨



## 단일 연산



```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * UnsafeCountingFactorizer
 *
 * Servlet that counts requests without the necessary synchronization
 *
 * @author Brian Goetz and Tim Peierls
 */
@NotThreadSafe
public class UnsafeCountingFactorizer extends GenericServlet implements Servlet {
    private long count = 0;

    public long getCount() {
        return count;
    }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        ++count;
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse res, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[] { i };
    }
}
```

- ++count 은 3개의 별도의 3개의 동작을 한줄로 표현한 것
- 위 클래스는 스레드에 안전하지 않음
- 병렬 프로그램의 입장에서 타이밍이 안좋을 때 결과가 잘못될 가능성은 race condition(경쟁 조건)이라는 용어를 사용함



### 경쟁 조건

- race condition이 발생하는 클래스는 결과를 신뢰할 수 없음
- 어떤 사실을 확인하고 그 관찰에 기반해 행동을 하는 류의 경쟁 조건을 점검 후 행동이라고함 해당 관찰은 관찰한 시각과 행동한 시각 사이에 더 이상 유효하지 않게 됐을 수 있음



### 예제: 늦은 초기화 시 경쟁 조건

- 점검 후 행동하는 흔한 프로그래밍 패턴으로 lazy initialization이 있음

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * LazyInitRace
 *
 * Race condition in lazy initialization
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
public class LazyInitRace {
    private ExpensiveObject instance = null;

    public ExpensiveObject getInstance() {
        if (instance == null)
            instance = new ExpensiveObject();
        return instance;
    }
}

class ExpensiveObject { }


```

- 위 클래스는 두개의 스레드가 동시에 `if (instance == null)` 에서 null을 받았을때 서로 다른 인스턴스를 생성할 수 있음

### 

### 복합 동작

- 경쟁 조건을 피하려면 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 막을 방법이 있어야하고 이런 방법으로 보호해두면 특정 스레드에서 변수를 수정할 때 다른 스레드는 수정 도중이 아닌 수정 이전이나 이후에만 상태를 읽거나 변경을 가할 수 있음

```java
package net.jcip.examples;

import java.math.BigInteger;
import java.util.concurrent.atomic.*;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * CountingFactorizer
 *
 * Servlet that counts requests using AtomicLong
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class CountingFactorizer extends GenericServlet implements Servlet {
    private final AtomicLong count = new AtomicLong(0);

    public long getCount() { return count.get(); }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = factor(i);
        count.incrementAndGet();
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse res, BigInteger[] factors) {}
    BigInteger extractFromRequest(ServletRequest req) {return null; }
    BigInteger[] factor(BigInteger i) { return null; }
}
```

- `UnsafeCountingFactorizer`을 `AtomicLong`을 사용하서 스레드 세이프하게 작성한 클래스
- java.util.concurrent.atomic 패키지에는 숫자나 객체 참조 값에 대해 상태를 단일 연산으로 변경할 수 있도록 단일 연산 변수 클래스가 준비돼 있음
- 상태 없는 클래스에 상태 요소를 하나 추가할 때 스레드 안전한 객체 하나로 모든 상태를 관리한다면 해당 클래스는 스레드에 안전함
- 가능하면 클래스 상태를 관리하기 위해 AtomicLong처럼 스레드에 안전하게 이미 만들어져 있는 객체를 사용하는 편이 좋음. 스레드 안전하지 않은 상태 변수를 선언해두고 사용하는 것보다 이미 스레드 안전하게 만들어진 클래스가 가질 수 있는 가능한 상태의 변화를 파악하는 편이 훨씬 쉽고, 스레드 안전성을 더 쉽게 유지하고 검증할 수 있음



## 락



```java
package net.jcip.examples;

import java.math.BigInteger;
import java.util.concurrent.atomic.*;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * UnsafeCachingFactorizer
 *
 * Servlet that attempts to cache its last result without adequate atomicity
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
public class UnsafeCachingFactorizer extends GenericServlet implements Servlet {
    private final AtomicReference<BigInteger> lastNumber
            = new AtomicReference<BigInteger>();
    private final AtomicReference<BigInteger[]> lastFactors
            = new AtomicReference<BigInteger[]>();

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        if (i.equals(lastNumber.get()))
            encodeIntoResponse(resp, lastFactors.get());
        else {
            BigInteger[] factors = factor(i);
            lastNumber.set(i);
            lastFactors.set(factors);
            encodeIntoResponse(resp, factors);
        }
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[]{i};
    }
}

```

- 위 클래스는 서로 다른 클라이언트가 연이어 같은 숫자를 인수분해하길 원할 경우 가장 최근 계산결과를 캐시해둬서 리턴하는 향상된 서블릿 클래스임 but 잘 동작하는 클래스가 아님
- 스레드 안전성의 정의에 따르면 여려 스레드에서 수행되는 작업의 타이밍이나 스케줄링에 따른 교차 실행과 관계 없이 불변조건이 유지되어야 스레드에 안전함
- 여러 개의 변수가 하나의 불변 조건을 구성하고 있고 이 작업들이 단일 연산 작업 내에서 변경되지 않는다면 문제가 생길 수 있음
- 상태를 일관성 있게 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야함

### 암묵적인 락

- 자바에는 단일 연산 특성을 보장하기 위해 synchronized라는 구문으로 사용할 수 있는 락을 제공함
- synchronized구문은 락으로 사용될 객체의 참조 값과 해당 락으로 보호하려는 코드 블록으로 구성됨
- synchronized는 메서드가 포함된 클래스의 인스턴스 락으로 사용하는 synchronized블록을 간략하게 표현한 것
- static으로 선언된 synchronized메서드는 해당 Class 객체를 락으로 사용
- 모든 자바 객체는 락으로 사용할 수 있음
- 자바에 내장된 락을 암묵적인 락 혹은 모니터 락이라고 함 락은 스레드가 synchronized블록에 들어가기 전에 자동으로 확보되고 정상적으로든 예외가 발생해서든 해당 블록을 벗어날 때 자동으로 해제됨
- 해당 락으로 보호된 synchronized 블록이나 메서드에 들어가야만 암묵적인 락을 확보할 수 있음
- 자바에서 암묵적인 락은 뮤텍스로 동작함 즉 한번에 한 스레드만 특정 락을 소유할 수 있음
- 같은 락으로 보호되는 synchronized 서로 다른 블력 역시 서로 단일 연산으로 실행됨
- 동시성 맥락에서 단일 연산의 특성은 트랜잭션 프로그램에서 말하는 단일 연산 특성과 같은 의미임
- 한 스레드가 synchronized 블록을 실행중이라면 같은 락으로 보호되는 synchronized블록에 다른 스레드가 들어와 있을 수 없음



```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * SynchronizedFactorizer
 *
 * Servlet that caches last result, but with unnacceptably poor concurrency
 *
 * @author Brian Goetz and Tim Peierls
 */

@ThreadSafe
public class SynchronizedFactorizer extends GenericServlet implements Servlet {
    @GuardedBy("this") private BigInteger lastNumber;
    @GuardedBy("this") private BigInteger[] lastFactors;

    public synchronized void service(ServletRequest req,
                                     ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        if (i.equals(lastNumber))
            encodeIntoResponse(resp, lastFactors);
        else {
            BigInteger[] factors = factor(i);
            lastNumber = i;
            lastFactors = factors;
            encodeIntoResponse(resp, factors);
        }
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[] { i };
    }
}

```

- 위는 UnsafeCachingFactorizer를 극단적으로 변경한 케이스, 성능이 엄청나게 떨어짐



### 재진입성

- 스레드가 다른 스레드가 가진 락을 요청하면 해당 스레드는 대기 상태에 들어감 하지만 암묵적인 락은 재진입 가능하기 때문에 특정 스레드가 자기가 이미 획득한 락을 다시 확보할 수 있음
- 재진입성은 확보 요청 단위가 아닌 스레드 단위로 락을 얻는다는 것을 의미함
- JVM이 락에 대한 소유 스레드를 기록하고 확소 횟수를 1로 지정, 계속 증가하다가 0이되면 해당 락이 해제
- 재진입 가능한 락이 없다면 중첩된 락은 데드락에 빠짐



## 락으로 상태 보호하기

- 락은 자신이 보호하는 코드 경로에 여러 스레드가 순차적으로 접근하도록 하기 때문에 공유된 상태에 배타적으로 접근할 수 있도록 보장하는 규칙을 만들 때 유용함
- 여러 스레드에서 접근할 수 있고 변경 가능한 모든 변수를 대상으로 해당 변수에 접근할 때는 항상 동일한 락을 먼저 확보한 상태여야 함. 이 경우 해당 변수는 확보된 락에 의해 보호된다고 말함
- 모든 변경할 수 있는 공유 변수는 정확하게 단 하나의 락으로 보호해야 함. 유지보수 하는 사람이 알 수 있게 어느락으로 보호하고 있는지를 명확하게 표시할 것
- 락을 활용함에 있어 일반적인 사용 예는 먼저 모든 변경 가능한 변수를 객체 안에 캡슐화하고 해당 객체의 암묵적인 락을 사용해 캡슐화한 변수에 접근하는 모든 코드 경로를 동기화함으로써 보호하는 방법 <= 이패턴은 Vector를 비롯해 여러 클래스에서 사용하는 방법
- 여러 변수에 대한 불변조건이 있으면 해당 변수들은 모두 같은 락으로 보호해야 함
- 무차별적인 synchronized 사용은 동기화가 너무 과도할 수 있음



## 활동성과 성능

- 단순하고 큰 단위로 동기화에 접근하면 안전성을 확보할 수 있지만 치러야 할 대가가 너무 큼
- synchronized블록의 범위를 줄이면 스레드 안정성을 유지하면서 쉽게 동시성을 향상시킬 수 있음 이 때 synchronized 블록의 범위를 너무 작게 줄이지 않도록 조심해야함 => 필요한 부분은 반드시 단일 연산으로 처리해야함 => 하나의 락으로

```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * CachedFactorizer
 * <p/>
 * Servlet that caches its last request and result
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class CachedFactorizer extends GenericServlet implements Servlet {
    @GuardedBy("this") private BigInteger lastNumber;
    @GuardedBy("this") private BigInteger[] lastFactors;
    @GuardedBy("this") private long hits;
    @GuardedBy("this") private long cacheHits;

    public synchronized long getHits() {
        return hits;
    }

    public synchronized double getCacheHitRatio() {
        return (double) cacheHits / (double) hits;
    }

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = null;
        synchronized (this) {
            ++hits;
            if (i.equals(lastNumber)) {
                ++cacheHits;
                factors = lastFactors.clone();
            }
        }
        if (factors == null) {
            factors = factor(i);
            synchronized (this) {
                lastNumber = i;
                lastFactors = factors.clone();
            }
        }
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[]{i};
    }
}
```

- 두 변수 모두 공유상태에 속하기 떄문에 접근할때도 항상 동기화 구문을 사용해야함
- synchronized밖이라면 스택 상의 변수만 사용하기 떄문에 동기화가 필요 없음
- 이미 동기화처리 되어있다면 AtomicX를 사용하지 않는것이 좋음 서로 다른 두가지 동기화 수단은 혼동만 주고 성능상에 이점이 없음
- 락을 얻는 작업은 어느정도 비용이 있으므로 synchronized블록을 너무 잘게 쪼개지 않는것이 중요함
- 동기화 정책을 구현할 때는 성능을 위해 조급하게 단순성을 희생하고픈 유혹을 버려야함 안전성이 가장 중요
- 락을 사용할 땐 블록 안의 코드가 무엇을 하는지, 수행하는데 얼마나 걸릴지를 파악해야함 활동성이나 성능 문제를 야기할 수 있음
- 복잡하고 오래 걸리는 계싼 작업, 네트웍 작업, 사용자 입출력 작업과 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 한 락을 잡지 말 것!





# #3 객체 공유

- 병렬 프로그램 작성은 상태가 바뀔 수 있는 내용을 프로그램 내부의 여러 부분에서 어떻게 잘 공유해 사용하도록 관리할 것인지에 대한 문제

## 가시성

- 일반적으로 특정 변수의 값을 가져갈 때 다른 스레드가 작성한 값을 가져갈 수 있다는 보장이 없음 메모리상의 공유된 변수를 여러 스레드에서 서로 사용할 수 있게 하려면 반드시 동기화 기능을 구현해야함

```java
package net.jcip.examples;

/**
 * NoVisibility
 * <p/>
 * Sharing variables without synchronization
 *
 * @author Brian Goetz and Tim Peierls
 */

public class NoVisibility {
    private static boolean ready;
    private static int number;

    private static class ReaderThread extends Thread {
        public void run() {
            while (!ready)
                Thread.yield();
            System.out.println(number);
        }
    }

    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```

- 메인 스레드와 ReaderThread는 변수를 공유하지만 동기화되지 않았음. 절대 사용하지 말 것!
- 위 코드는 어떤 스레드가 먼저 공유 변수에 접근할지 모르는 현상이 있는데 재배치 현상이라고함
- 재배치 현상은 특정 메서드의 소스코드가 100% 코딩된 순서로 동작한다는 점을 보장할 수 없다는 점에 기인하는 문제. 단일 스레드로 동작할 때는 차이점을 전혀 알아챌 수 없지만 여러 스레드가 동시에 동작하는 경우에는 확연하게 나타날 수 있음
- 동기화되지 않은 상황에서 메모리상의 변수를 대상으로 작성해둔 코드가 ''반드시 이런 순서로 동작할 것이다'' 라고 단정할 수 없음
- 병렬프로그램에서 동기화가 완벽하게 맞춰지지 않았다면 정상적으로 작동할 것인지를 추측하기가 매우 어려움
- 여러 스레드에서 공동으로 사용하는 변수에는 항상 적절한 동기화 기법을 적용해야함



### 스테일 데이터

- 변수를 사용하는 모든 경우에 동기화를 시켜주지 않으면 해당 변수에 대한 최신 값이 아닌 다른 값을 사용하게 되는 경우가 발생할 수 있음

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * MutableInteger
 * <p/>
 * Non-thread-safe mutable integer holder
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
public class MutableInteger {
    private int value;

    public int get() {
        return value;
    }

    public void set(int value) {
        this.value = value;
    }
}
```

- 동기화처리되지 않아서 스레드에 안전하지 않음

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * SynchronizedInteger
 * <p/>
 * Thread-safe mutable integer holder
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class SynchronizedInteger {
    @GuardedBy("this") private int value;

    public synchronized int get() {
        return value;
    }

    public synchronized void set(int value) {
        this.value = value;
    }
}
```

- 동기화처리되어서 스레드에 안전함



### 단일하지 않은 64비트 연산 

- 동기화되지 않은 상태에서 특정 스레드가 변수의 값을 읽어려 할때는 stale한 값을 읽어갈 가능성이 있긴 하지만 전혀 엉뚱한 값을 가져가는 것은 아니고 바로 이전 스레드에서 설정한 값을 가져가게됨
- 하지만 64비트를 사용하는 숫자형 double, long 에 volatile 키워드를 사용하지 않은 경우엔 이상한 값마저 생길 가능성이 있음



### 락과 가시성

- 값을 변경할 수 있는 변수를 여러 개의 스레드에서 동시에 사용한다면, 바로 이전 스레드에서 사용했던 변수의 값을 오류 없이 정상적으로 다음 스레드가 사용할 수 있도록 synchronized를 사용해야함
- 여러 스레드에서 사용하는 변수를 적당한 락으로 막아주지 않으면 stale 상태에 쉽게 빠질 수 있음
- 락은 상호 배제 뿐만 아니라 정상적인 메모리 가시성을 확보하기 위해서도 사용함. 변경 가능하면서 여러 스레드가 공유해 사용하는 변수를 각 스레드에서 각자 최신의 정상적인 값으로 활용하려면 동일한 락을 사용해 모두 동기화시켜야함



### volatile 변수

- 자바에서는 volatile변수로 좀더 약한 동기화 기능을 제공함
- volatile변수를 사용하면 변수의 값을 바꿨을 때 다른 스레드에서 항상 최신 값을 읽어갈 수 있도록 해줌
- volatile변수를 사용하면 컴파일러와 런타임 모두 '이 변수는 공유해 사용하고, 따라서 실행 순서를 재배치해서는 안된다' 라고 이해함 따라서 캐시되지 않고 항상 다른 스레드가 보관해둔 최신의 값을 읽어갈 수 있음
- 동기화하고자하는 부분을 명확하게 볼 수 있고, 구현하기가 훨씬 간단한 경우에만 volatile 변수를 활용할 것. 반대로 작은 부분이라도 가시성을 추론해봐야 하는 경우에는 volatile 변수를 사용하지 않는 것이 좋음. volatile 변수를 사용하는 적절한 경우는, 일반적으로 변수에 보관된 클래스의 상태에 대한 가시성을 확보하거나 중요한 이벤트가 발생했다는 등의 정보를 정확하게 전달하고자 하는 경우 등이 해당됨
- 락을 사용하면 가시성과 연산의 단일성을 모두 보장받을 수 있지만 volatile변수는 연산의 단일성을 보장하지 못하고 가시성만 보장함
- volatile변수를 쓰면 좋을때
  - 변수에 값을 저장하는 작업이 해당 변수의 현재 값과 관련이 없거나 해당 변수의 값을 변경하는 스레드가 하나만 존재할 경우
  - 해당 변수가 객체의 불변조건을 이루는 다른 변수와 달리 불변조건에 관련되어있지 않은 경우
  - 해당 변수를 사용하는 동안에는 어떤 경우라도 락을 걸어 둘 필요가 없는 경우



## 공개와 유출

- 특정 객체를 현재 코드의 스코프 범위 밖에서 사용할 수 있도록 만들면 공개되었다고 함
- 만약 클래스 내부 상태 변수를 외부에 공개해야한다면 객체 캡슐화 작업이 물거품이되거나 내부 데이터의 안전성을 해칠 수 있음 따라서 객체가 안정적이지 않은 상태에서 공개하면 스레드 안전성에 문제가 생길 수 있음
- 의도적으로 공개시키지 안았지만 외부에서 사용할 수 있게 공개된 경우를 유출 상태라고함

```java
package net.jcip.examples;

import java.util.*;

/**
 * Secrets
 *
 * Publishing an object
 *
 * @author Brian Goetz and Tim Peierls
 */
class Secrets {
    public static Set<Secret> knownSecrets;

    public void initialize() {
        knownSecrets = new HashSet<Secret>();
    }
}


class Secret {
}
```

- 위에 knownSecrets은 스코프에 관계 없이 완전히 공개됨

```java
package net.jcip.examples;

/**
 * UnsafeStates
 * <p/>
 * Allowing internal mutable state to escape
 *
 * @author Brian Goetz and Tim Peierls
 */
class UnsafeStates {
    private String[] states = new String[]{
        "AK", "AL" /*...*/
    };

    public String[] getStates() {
        return states;
    }
}
```

- 위 클래스는 getStates() 메서드를 사용해서 private 멤버변수를 직접변경할 수 있음. states 변수는 유출상태임
- 정리하자면 객체를 공개했을 때 그 객체 내부의 private이 아닌 변수나 메서드를 통해 불러올 수 있는 모든 객체는 함께 공개된다는 점을 알아둘 것
- 항상 누군가는 의도했건 의도하지 않았건 공개된 객체를 잘못 사용할 가능성에 노출이되기때문에 어떤 객체건 객체 내부에서 사용하는 값이 적절하게 캡슐화되도록 해야함

```java
package net.jcip.examples;

/**
 * ThisEscape
 * <p/>
 * Implicitly allowing the this reference to escape
 *
 * @author Brian Goetz and Tim Peierls
 */
public class ThisEscape {
    public ThisEscape(EventSource source) {
        source.registerListener(new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
        });
    }

    void doSomething(Event e) {
    }


    interface EventSource {
        void registerListener(EventListener e);
    }

    interface EventListener {
        void onEvent(Event e);
    }

    interface Event {
    }
}

```

-  위와 같은 코드는 EventListener 클래스를 포함하고 있는 ThisEscape 클래스도 함께 외부에 공개됨 안좋은 방법!



### 생성 메소드 안전성

- 일반적으로 생성 메서드가 완전히 종료하고 난 이후가 되어야 객체의 상태가 개발자가 예상한 상태로 초기화되기 때문에 생성 메서드가 실행되는 도중에 해당 객체를 외부에 공개해야 한다면 정상적이지 않은 상태의 객체를 외부에서 불러 사용할 가능성이 있음
- 생성 메서드를 실행하는 도중에는 this 변수가 외부에 유출되지 않도록 해야함 <= 먼말인지 이해가 잘 안됨
- 생성 메서드에서 this 변수를 유출시키는 가장 흔한 오류는 생성 메서드에서 스레드를 새로 만들어 시작시키는 일.

```java
package net.jcip.examples;

/**
 * SafeListener
 * <p/>
 * Using a factory method to prevent the this reference from escaping during construction
 *
 * @author Brian Goetz and Tim Peierls
 */
public class SafeListener {
    private final EventListener listener;

    private SafeListener() {
        listener = new EventListener() {
            public void onEvent(Event e) {
                doSomething(e);
            }
        };
    }

    public static SafeListener newInstance(EventSource source) {
        SafeListener safe = new SafeListener();
        source.registerListener(safe.listener);
        return safe;
    }

    void doSomething(Event e) {
    }


    interface EventSource {
        void registerListener(EventListener e);
    }

    interface EventListener {
        void onEvent(Event e);
    }

    interface Event {
    }
}


```

- 위와 같이 사용하면 생성 메서드에서 this 변수가 외부로 유촐되지 않도록 팩토리 메서드를 사용할 수 있음



## 스레드 한정

- 변경 가능한 객체를 공유해 사용하는 경우에는 항상 동기화시켜야함
- 만약 싱글 스레드에서만 사용한다고 확신할 수 있다면 해당 객체는 따로 동기화할 필요가 없음
- 이처럼 객체를 사용하는 스레드를 한정하는 방법으로 스레드 안전성을 확보할 수 있음. 객체 인스턴스를 특정 스레드에 한정시켜두면 해당하는 객체가 아니라 해도 자동으로 스레드 안전성을 확보하게 됨
- 언어적인 차원에서 특정 변수를 대상으로 락을 걸 수 있는 기능을 제공하지 않은 것처럼, 임의의 객체를 특정 스레드에 한정시키는 기능도 제공하지 않음. 스레드 한정 기법은 프로그램을 처음 설계하는 과정부터 함께 다뤄야 하며, 프로그램을 구현하는 과정 내내 한정 기법을 계속해서 적용해야 함

### 스레드 한정 - 주먹구구식

- 특정 모듈을 단일 스레드로 동작하도록 구현하면 데드락을 미연에 방지할 수 있는 장점이 있음 대부분의 gui 프로그램은 단일 스레드로 동작하도록 구현된 큰 이유.

### 스택 한정

- 스택 한정 기법은 특정 객체를 로컬 변수를 통해서만 사용할 수 있는 특별한 경우의 스레드 한정 기법이라고 할 수 있음 
- 변수를 클래스 내부에 숨겨두면 변경 상태를 관리하기가 쉬움, 또한 클래스 내부에 숨겨둔 변수는 특정 스레드에 쉽게 한정시킬 수 있음
- 로컬 변수는 모두 암묵적으로 현재 실행중인 스레드에 한정되어 있다고 볼 수 있음. 즉 로컬 변수는 현재 실행중인 스레드 내부의 스택에만 존재하기 때문.



```java
package net.jcip.examples;

import java.util.*;

/**
 * Animals
 * <p/>
 * Thread confinement of local primitive and reference variables
 *
 * @author Brian Goetz and Tim Peierls
 */
public class Animals {
    Ark ark;
    Species species;
    Gender gender;

    public int loadTheArk(Collection<Animal> candidates) {
        SortedSet<Animal> animals;
        int numPairs = 0;
        Animal candidate = null;

        // animals confined to method, don't let them escape!
        animals = new TreeSet<Animal>(new SpeciesGenderComparator());
        animals.addAll(candidates);
        for (Animal a : animals) {
            if (candidate == null || !candidate.isPotentialMate(a))
                candidate = a;
            else {
                ark.load(new AnimalPair(candidate, a));
                ++numPairs;
                candidate = null;
            }
        }
        return numPairs;
    }


    class Animal {
        Species species;
        Gender gender;

        public boolean isPotentialMate(Animal other) {
            return species == other.species && gender != other.gender;
        }
    }

    enum Species {
        AARDVARK, BENGAL_TIGER, CARIBOU, DINGO, ELEPHANT, FROG, GNU, HYENA,
        IGUANA, JAGUAR, KIWI, LEOPARD, MASTADON, NEWT, OCTOPUS,
        PIRANHA, QUETZAL, RHINOCEROS, SALAMANDER, THREE_TOED_SLOTH,
        UNICORN, VIPER, WEREWOLF, XANTHUS_HUMMINBIRD, YAK, ZEBRA
    }

    enum Gender {
        MALE, FEMALE
    }

    class AnimalPair {
        private final Animal one, two;

        public AnimalPair(Animal one, Animal two) {
            this.one = one;
            this.two = two;
        }
    }

    class SpeciesGenderComparator implements Comparator<Animal> {
        public int compare(Animal one, Animal two) {
            int speciesCompare = one.species.compareTo(two.species);
            return (speciesCompare != 0)
                    ? speciesCompare
                    : one.gender.compareTo(two.gender);
        }
    }

    class Ark {
        private final Set<AnimalPair> loadedAnimals = new HashSet<AnimalPair>();

        public void load(AnimalPair pair) {
            loadedAnimals.add(pair);
        }
    }
}


```

- loadTheArk() 메서드는 스택 변수에 복사해서 사용하기때문에 스레드의 스택에 안전하게 한정되어 있음
- 여기에서 TreeSet을 외부에 노출한다면 스택 한정 상태가 깨짐
- 스레드에 안전하지 않은 객체라 해도 특정 스레드 내부에서만 사용한다면 동기화 문제가 없기 때문에 안전함
- 이런 부분을 코드를 처음 작성한 개발자만 인식할 뿐 후임 개발자는 전달받지 못하는 경우가 많은데 정리해서 누구든지 알아볼 수 있도록 표시해두는것이 좋음 누군가 TreeSet을 외부에 노출하지 않도록.

###  ThreadLocal

- 스래드 내부의 값과 값을 갖고 있는 객체를 연결해 스레드 한정 기법을 적용할 수 있도록 도와주는 좀 더 형식적인 방법으로 ThreadLocal이 있음
- ThreadLocal클래스의 get 메서드를 호출하면 현재 실행중인 스레드에서 최근에 set 메서드를 호출해 저장했던 값을 가져올 수 있음

```java
package net.jcip.examples;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

/**
 * ConnectionDispenser
 * <p/>
 * Using ThreadLocal to ensure thread confinement
 *
 * @author Brian Goetz and Tim Peierls
 */
public class ConnectionDispenser {
    static String DB_URL = "jdbc:mysql://localhost/mydatabase";

    private ThreadLocal<Connection> connectionHolder
            = new ThreadLocal<Connection>() {
                public Connection initialValue() {
                    try {
                        return DriverManager.getConnection(DB_URL);
                    } catch (SQLException e) {
                        throw new RuntimeException("Unable to acquire Connection, e");
                    }
                };
            };

    public Connection getConnection() {
        return connectionHolder.get();
    }
}
```

- 위 클래스는 ThreadLocal하게 동작해서 스레드마다 새로운 Connection을 생성함
- 스레드 단위로 트랜잭션 컨텍스트를 관리하고자할때는 static으로 선언된 ThreadLocal변수에 트랜잭션 컨텍스트를 넣어두면 편리함 하지만 일반적인 전역 변수가 갖는 단점처럼 ThreadLocal을 사용할 때에도 재사용성을 크게 떨어뜨릴 수 있고 객체 간에 눈에 보이지 않는 연결 관계를 만들어 내기 쉽기 때문에 애플리케이션에 어떤 영향을 미치는지 정확하게 알고 써야함



## 불변성

- 직접적으로 객체를 동기화하지 않고도 안전하게 사용할 수 있는 방법은 불변객체를 사용하는것임
- 동시성에 대한 모든 문제는 변경 가능한 값을 동시에 사용하려 하기 때문에 발ㅇ생함
- 불변객체는 언제라도 스레드에 안전함
- 다음 조건을 만족하면 불변임
  - 생성되고 난 이후에는 객체의 상태를 변경할 수 없음
  - 내부의 모든 변수는 final로 설정 되어야함
  - 적절한 방법으로 생성돼야 함 (this 변수에 대한 참조가 외부로 유촐되지 않아야함)



```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * ThreeStooges
 * <p/>
 * Immutable class built out of mutable underlying objects,
 * demonstration of candidate for lock elision
 *
 * @author Brian Goetz and Tim Peierls
 */
@Immutable
 public final class ThreeStooges {
    private final Set<String> stooges = new HashSet<String>();

    public ThreeStooges() {
        stooges.add("Moe");
        stooges.add("Larry");
        stooges.add("Curly");
    }

    public boolean isStooge(String name) {
        return stooges.contains(name);
    }

    public String getStoogeNames() {
        List<String> stooges = new Vector<String>();
        stooges.add("Moe");
        stooges.add("Larry");
        stooges.add("Curly");
        return stooges.toString();
    }
}
```

- ThreeStooges 클래스의 구조를 보면 생성 메서드를 실행한 이후에는 stooges의 값을 변경하지 못하게함
- 객체가 불변이라는 것과 참조가 불변이라는 것은 반드시 구분해서 생각해야함 예를 들어 프로그램이 사용하는 데이터가 불변 객체에 들어있다 해도, 해당 객체를 가리키고 있는 참조 변수에 또 다른 불변 객체를 바꿔치기 하면 프로그램의 데이터가 언제든 바뀌는 셈



### final 변수

- final 키워드는 불변 객체를 생성할 떄도 도움을 줌
- final 키워드를 적절하게 사용하면 초기화 안전성을 보장하기 때문에 별다른 동기화 작업 없이도 불변 객체를 자유롭게 사용하고 공유할 수 있음
- 외부에서 반드시 사용할 일이 없는 변수는 private으로 선언하는 것처럼 나중에 변경할 일이 없다고 판단되는 변수는 final로 선언해두는 것도 좋은 방법임



### 예제: 불변 객체를 공개할 때 volatile 키워드를 사용

- 만약 여러개의 값이 단일하게 한꺼번에 행동해야 한다면 아래 클래스와 같이 여러개의 값을 한데 묶는 불변 클래스를 만들어 사용하는 방법이 좋음

```java
package net.jcip.examples;

import java.math.BigInteger;
import java.util.*;

import net.jcip.annotations.*;

/**
 * OneValueCache
 * <p/>
 * Immutable holder for caching a number and its factors
 *
 * @author Brian Goetz and Tim Peierls
 */
@Immutable
public class OneValueCache {
    private final BigInteger lastNumber;
    private final BigInteger[] lastFactors;

    public OneValueCache(BigInteger i,
                         BigInteger[] factors) {
        lastNumber = i;
        lastFactors = Arrays.copyOf(factors, factors.length);
    }

    public BigInteger[] getFactors(BigInteger i) {
        if (lastNumber == null || !lastNumber.equals(i))
            return null;
        else
            return Arrays.copyOf(lastFactors, lastFactors.length);
    }
}
```

- 서로 관련되어 있는 여러 개의 변수 값을 서로 읽거나 쓰는 과정에 경쟁 조건이 발생할 수 있는데 불변 객체에 해당하는 변수를 모두 모아두면 경쟁 조건을 방지할 수 있음

```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * VolatileCachedFactorizer
 * <p/>
 * Caching the last result using a volatile reference to an immutable holder object
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class VolatileCachedFactorizer extends GenericServlet implements Servlet {
    private volatile OneValueCache cache = new OneValueCache(null, null);

    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigInteger[] factors = cache.getFactors(i);
        if (factors == null) {
            factors = factor(i);
            cache = new OneValueCache(i, factors);
        }
        encodeIntoResponse(resp, factors);
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[]{i};
    }
}

```

- VolatileCachedFactorizer 클래스는 OneValueCache 클래스를 사용해 입력 값과 결과를 캐시함.
- 스레드 하나가 volatile로 선언된 cache변수에 새로 생성한 OneValueCache 인스턴스를 설정하면 다른 스레드에서도 cache변수에 설정된 새로운 값을 즉시 사용할 수 있음
- 불변 + volatile변수를 사용하면 시간적으로 가시성을 확보하기 때문에 락을 사용하지 않아도 스레드에 안전함





## 안전 공개

- 객체에 대한 참조를 public 변수에 넣어 공개하는 것은 객체를 공개하는 그다지 안전한 방법이 아님

```java
package net.jcip.examples;

/**
 * StuffIntoPublic
 * <p/>
 * Unsafe publication
 *
 * @author Brian Goetz and Tim Peierls
 */
public class StuffIntoPublic {
    public Holder holder;

    public void initialize() {
        holder = new Holde(42);
    }
}
```

- 위와 같은 단순한 방법으로 객체를 외부에 공개하면 생성 메서드가 채 끝나기도 전에 공개된 객체를 다른 스레드가 사용할 수 있음

### 적절하지 않은 공개 방법: 정상적인 객체도 문제를 일으킨다.

```java
package net.jcip.examples;

/**
 * Holder
 * <p/>
 * Class at risk of failure if not properly published
 *
 * @author Brian Goetz and Tim Peierls
 */
public class Holder {
    private int n;

    public Holder(int n) {
        this.n = n;
    }

    public void assertSanity() {
        if (n != n)
            throw new AssertionError("This statement is false.");
    }
}
```

- 위와 같이 올바르게 공개하지 않으면 문제가 생길 수 있음
- Holder 객체를 다른 스레드가 사용할 수 있도록 코드를 작성하면서 적절한 동기화 방법을 적용하지 않았으므로 올바르게 공개되지 않았다고 할 수 있음
-  객체가 올바르게 공개되지 않을때 두가지 문제
  - holder 변수에 stale 상태가 발생할 수 있음
  - 다른 스레드는 모두 holder 변수에서 정상적인 참조 값을 가져갈 수 있지만 Holder 클래스의 입장에서는 stale 상태에 빠질 수 있음 (Object 클래스와 관련있음)
- 특정 데이터를 여러 개의 스레드에서 사용하도록 공유할 때 적절한 동기화 방법을 적용하지 않는다면 굉장히 이상한 일이 발생할 가능성이 높음



### 불변 객체와 초기화 안전성

- 불변 객체를 사용하면 객체의 참조를 외부에 공개할 때 추가적인 동기화 방법을 사용하지 않았다 해도 항상 안전하게 올바른 참조 값을 사용할 수 있음
- 불변 객체가 안전하다고 보장되는 내용은 올바른 방법으로 생성한 객체의 내부에 final로 선언된 모든 변수에 적용할 수 있음
- final로 선언된 모든 변수는 별다른 동기화 작업 없이도 안전하게 사용할 수 있음 하지만 final로 선언된 변수에 변경 가능한 객체가 지정되어 있다면 해당 변수에 들어있는 객체의 값을 사용하려고 하는 부분을 모두 동기화시켜야함

### 안전한 공개 방법의 특성

- 객체를 안전하게 공개하려면 해당 객체에 대한 참조와 객체 내부의 상태를 외부 스레드에게 동시에 볼 수 있어야함. 올바르게 생성 메서드가 실행되고 난 객체는 다음과 같은 방법으로 안전하게 공개 가능

  - 객체에 대한 참조를 static 메서드에서 초기화 시킨다.
  - 객체에 대한 참조를 volatile 변수 또는 AtomicReference 클래스에 보관한다.
  - 객체에 대한 참조를 올바르게 생성된 클래스 내부의 final 변수에 보관한다.
  - 락을 사용해 올바르게 막혀 있는 변수에 객체에 대한 참조를 보관한다.

- 스레드 안전한 컬렉션

  - Hashtable, ConcurrentMap, synchronizedMap을 사용해 만든 Map 객체를 사용하면 키와 값 모두를 어느 스레드에서라도 항상 안전하게 사용 가능
  - Vector, CopyOnWriteArrayList, CopyOnWriteArraySet, synchronizedList, synchronizedSet 메서드로 만든 컬렉션은 그 안에 보관하고 있는 객체를 어느 스레드에라도 항상 안전하게 사용할 수 있음
  - BlockingQueue, ConcurrentLinkedQueue 컬렉션 안에 있는 객체는 안전

- static 변수를 선언할 때 직접 new 연산자로 생성 메서드를 실행해 객체를 생성할 수 있다면 가장 쉬우면서도 안전한 객체 공개 방법임

- ```java
  public static Holder holder = new Holder(42);
  ```

- static 초기화 방법은 jvm 에서 클래스를 초기화하는 시점에 작업이 모두 진행됨 jvm 내부에서는 동기화가 맞춰져 있어서 이런 방법은 안정함

### 결과적으로 불변인 객체

- 특정 객체를 안전한 방법으로 공개했을 경우, 해당 객체에 대한 참조를 갖고 객체를 불러와 사용하는 시점에는 공개하는 시점의 객체 상태를 정확하게 사용 가능하고 해당 객체 내부의 값이 바뀌지 않는 한 여러 스레드에서 동시에 값을 가져다 사용해도 동기화문제가 발생하지 않음
- 예를 들어 Date 클래스는 가변으로 설계되었는데 Date를 synchronizedMap에 넣고 사용하면 Date에 대한 추가적인 락 없이 스레드 안전하게 사용이 가능함

### 가변 객체

- 가변객체를 안전하게 사용하려면 안전하게 공개해야하고 또 동기화와 락을 사용해 스레드 안전성을 확보해야함
- 가변성에 따라 객체를 공개할 때 필요한점
  - 불변 객체는 어떤 방법으로 공개해도 아무 문제가 없음
  - 결과적으로 불변인 객체는 안전하게 공개해야함
  - 가변 객체는 안전하게 공개해야하고 스레드에 안전하게 만들거나 락으로 동기화시켜야함



### 객체를 안전하게 공유하기

- 언제든 객체에 대한 참조를 가져다 사용하는 부분이 있다면, 그 객체로 어느 정도의 일을 할 수 있는지를 정확하게 알고 있어야함
- 반대로 객체를 외부에서 사용할 수 있도록 공개할 때에는 해당 객체를 어떤 방법으로 사용할 수 있고 사용해야 하는지에 대해서 정확하게 설명할 수 있어야함
- 객체를 공유할때 가장 많이 사용되는 원칙 정리
  - 스레드 한정: 스레드에 한정된 객체는 오나전하게 해당 스레드 내부에 존재하면서 그 스레드에서만 호출해 사용할 수 있음
  - 읽기 전용 객체를 공유: 읽기 전용 객체를 공유해 사용한다면 동기화 작업을 하지 않더라도 여러 스레드에서 언제든지 마음껏 값을 읽어 사용할 수 있음 ex 불변객체
- 스레드에 안전한 객체를 공유
  - 스레드에 안전한 객체는 객체 내부적으로 필수적인 동기화 기능이 만들어져 있기 때문에 외부에서 동기화를 신경쓸 필요가 없고 여러 스레드에서 마음껏 호출 가능
- 동기화 방법 적용
  - 특정 객체에 동기화 방법을 적용해두면 지정한 락을 획득하기 전에는 해당 객체를 사용할 수 없음. 스레드에 안전한 객체 내부에서 사용하는 객체나 공개된 객체 가운데 특정 락을 확보해야 사용할 수 있도록 막혀 있는 객체 등에 동기화 방법이 적용되어 있다고 볼 수 있음



# #4 객체 구성

## 스레드 안전한 클래스 설계

- 객체가 갖고 있는 여러가지 정보를 해당 객체 내부에 숨겨두면 전체 프로그램을 다 뒤져볼 필요 없이 객체 단위로 스레드 안전성이 확보되어 있는지 확인할 수 있음
- 클래스가 스레드 안전성을 확보하도록 설계하고자 할 때는 다음과 같은 세가지를 고려해야함
  - 객체의 상태를 보관하는 변수가 어떤 것인가?
  - 객체의 상태를 보관하는 변수가 가질 수 있는 값이 어떤 종류, 어떤 범위에 해당하는가?
  - 객체 내부의 값을 동시에 사용하고자 할 때, 그 과정을 관리할 수 있는 정책
- 객체의 상태는 항상 객체 내부의 변수를 기반으로 함
- 객체 내부의 변수가 모두 기본 변수형으로 만들어져 있다면 해당 변수만으로 객체의 상태를 완전하게 표현할 수 있음
- 객체 내부의 여러 변수가 갖고 있는 현재 상태를 사용하고자 할 때 값이 계속해서 변하는 상황에서도 값을 안전하게 사용할 수 있도록 조절하는 방법을 동기화 정책이라고 함
- 동기화 정책에서는 객체의 불변성, 스레드 한정, 락 등을 어떻게 적절하게 활용해 스레드 안전성을 확보할 수 있으며 어떤 변수를 어떤 락으로 막아야 하는지 등의 내용을 명시해야함

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * Counter
 * <p/>
 * Simple thread-safe counter using the Java monitor pattern
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public final class Counter {
    @GuardedBy("this") private long value = 0;

    public synchronized long getValue() {
        return value;
    }

    public synchronized long increment() {
        if (value == Long.MAX_VALUE)
            throw new IllegalStateException("counter overflow");
        return ++value;
    }
}
```

- 위 Counter 클래스는 value변수만 보면 상태를 완벽하게 알 수 있음

### 동기화 요구사항 정리

- 여러 스레드가 동시에 클래스를 사용하려 하는 상황에서 클래스 내부의 값을 안정적인 상태로 유지할 수 있다면 바로 스레드 안전성을 확보했다고 말할 수 있음
- 객체와 변수가 가질 수 있는 가능한 값의 범위를 상태 범위라고 하는데 이 상태 범위가 좁으면 좁을수록 객체의 논리적인 상태를 파악하기 쉬움 (불변 객체는 상태 범위가 반드시 1임 생성 이후에는 변경되지 않음)
- 클래스가 특정 상태를 가질 수 없도록 구현해야 한다면 해당 변수는 클래스 내부에 숨겨야함. 숨기지 않으면 외부에서 올바르지 않은 값을 지정할 수 있음. 그리고 변경시 올바르지 않은 값을 지정할 가능성이 있다면 해당 연산은 단일 연산으로 구현해야함
- 서로 연관된 값은 단일 연산으로 한번에 읽거나 변경해야함
- 상태 범위에 두 개 이상의 변수가 연결되어 동시에 관여하고 있다면 이런 변수를 사용하는 모든 부분에서 락을 사용해 동기화를 맞춰야함
- 객체가 가질 수 있는 값의 범위와 변동 폭을 정확하게 인식하지 못한다면 스레드 안전성을 완벽하게 확보할 수 없음 클래스의 상태가 정상적이라는 여러가지 제약 조건이 있을 때 클래스의 상태를 정상적으로 유지하려면 여러 가지 추가적인 동기화 기법을 적용하거나 상태 변수를 클래스 내부에 적절히 숨겨야함



### 상태 의존 연산

- 현재 조건에 따라 동작 여부가 결정되는 연산을 상태 의존 연산이라고함
- 여러 스레드가 동시에 움직이는 경우라면 실행하기 시작한 이후에 선행 조건이 올바른 상태로 바뀔 수 있음
- java에서는 wait과 notice를 제공하지만 올바르게 사용하기가 쉽지 않아 주의해야함
- wait과 notify를 사용하는 대신 세마포어나 블로킹 큐와 같이 현재 알려져 있는 여러 가지 라이브러리를 사용하는 편이 훨씬 간단하고 안전함

### 상태 소유권

- 자바에서는 상태 소유권이라는 개념이 모호함 gc가 관리하기 때문
- 상태 소유권은 말그대로 이상태에 대한 소유권을 말하는 듯. 특정 변수를 외부에 공개하면 해당 변수에 대한 소유권을 외부와 공유하게되는 원리



## 인스턴스 한정

- 객체가 스레드 안전성을 확보하지 못하고 있다 하더라도, 몇 가지 기법을 활용하면 멀티 스레드 프로그램에서 안전하게 사용이 가능함
- 스레드 한정 기법을 사용하거나 해당 객체를 사용하고자 하는 부분에서 락을 사용해 동시 사용되는 경우를 막을 수 있음.
- 객체를 적절하게 캡슐화하는 것으로도 스레드 안전성을 확보할 수 있음 <= 인스턴스 한정
- 데이터를 객체 내부에 캡슐화해 숨겨두면 숨겨진 내용은 해당 객체의 메서드에서만 사용 할 수 있기 때문에 숨겨진 데이터를 사용하고자 할 때에는 항상 지정된 형태의 락이 적용되는지 쉽고 정확하게 파악할 수 있음
- 한정된 객체는 제한된 범위를 벗어나서는 안됨

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * PersonSet
 * <p/>
 * Using confinement to ensure thread safety
 *
 * @author Brian Goetz and Tim Peierls
 */

@ThreadSafe
public class PersonSet {
    @GuardedBy("this") private final Set<Person> mySet = new HashSet<Person>();

    public synchronized void addPerson(Person p) {
        mySet.add(p);
    }

    public synchronized boolean containsPerson(Person p) {
        return mySet.contains(p);
    }

    interface Person {
    }
}
```

- 위 PersonSet 클래스의 mySet 변수는 스레드 안전한 객체가 아니지만 private로 외부에 노출되어 있지 않고 myset에 접근하는 모든 메서드는 synchronized 키워드가 걸려있어서 스레드 안전성을 확보했다고 말할 수 있음
- 인스턴스 한정 기법은 클래스를 구현할 때 스레드 안전성을 확보할 수 있는 가장 쉬운 방법이라고 해도 무리가 없음
- 인스턴스 한정 기법을 사용하면 동기화를 위한 락의 방식도 마음대로 선택 가능
- 자바에서도 비슷하게 ArrayList를 감싸는 래퍼 클래스를 생성하는 Collections.synchronizedList가 있음
- 한정됐어야 할 객체를 공개하면 한정 조건이 깨질 수 있음
- 인스턴스 한정 기법을 사용하면 전체 프로그램을 다 뒤져보지 않고도 스레드 안전성을 확보하고 있는지 쉽게 분석해볼 수 있기 때문에 스레드에 안전한 객체를 좀 더쉽게 구현할 수 있음

### 자바 모니터 패턴

- 자바 모니터 패턴을 따르는 객체는 변경가능한 데이터를 모두 객체 내부에 숨긴 다음 객체의 암묵적인 락으로 데이터에 대한 동시 접근을 막음
- 아래 클래스처럼 사용하는게 자바 모니터 패턴의 전형적인 예

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * Counter
 * <p/>
 * Simple thread-safe counter using the Java monitor pattern
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public final class Counter {
    @GuardedBy("this") private long value = 0;

    public synchronized long getValue() {
        return value;
    }

    public synchronized long increment() {
        if (value == Long.MAX_VALUE)
            throw new IllegalStateException("counter overflow");
        return ++value;
    }
}
```

- 자바 모니터 패턴은 Vector, Hashtable 등 여러가지 클래스에 널리 사용하고 있음
- 자바 모니터 패턴의 가장 큰 장점은 간결함

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * PrivateLock
 * <p/>
 * Guarding state with a private lock
 *
 * @author Brian Goetz and Tim Peierls
 */
public class PrivateLock {
    private final Object myLock = new Object();
    @GuardedBy("myLock") Widget widget;

    void someMethod() {
        synchronized (myLock) {
            // Access or modify the state of widget
        }
    }
}
```

- 위 방식으로 락을 구현할 수도 있음
- 위처럼 사용할때는 락을 외부에 공개하면 절대 안됨 만약 공개한다면 락을 사용하는 코드가 올바르게 의도한 대로 동작하는지 확인해야함



### 예제: 차량 위치 추적

- 모든 차량은 String 형태의 ID로 구분하고 차량의 위치는 x y 좌표로 표시함

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * MutablePoint
 * <p/>
 * Mutable Point class similar to java.awt.Point
 *
 * @author Brian Goetz and Tim Peierls
 */
@NotThreadSafe
public class MutablePoint {
    public int x, y;

    public MutablePoint() {
        x = 0;
        y = 0;
    }

    public MutablePoint(MutablePoint p) {
        this.x = p.x;
        this.y = p.y;
    }
}
```

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * MonitorVehicleTracker
 * <p/>
 * Monitor-based vehicle tracker implementation
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
 public class MonitorVehicleTracker {
    @GuardedBy("this") private final Map<String, MutablePoint> locations;

    public MonitorVehicleTracker(Map<String, MutablePoint> locations) {
        this.locations = deepCopy(locations);
    }

    public synchronized Map<String, MutablePoint> getLocations() {
        return deepCopy(locations);
    }

    public synchronized MutablePoint getLocation(String id) {
        MutablePoint loc = locations.get(id);
        return loc == null ? null : new MutablePoint(loc);
    }

    public synchronized void setLocation(String id, int x, int y) {
        MutablePoint loc = locations.get(id);
        if (loc == null)
            throw new IllegalArgumentException("No such ID: " + id);
        loc.x = x;
        loc.y = y;
    }

    private static Map<String, MutablePoint> deepCopy(Map<String, MutablePoint> m) {
        Map<String, MutablePoint> result = new HashMap<String, MutablePoint>();

        for (String id : m.keySet())
            result.put(id, new MutablePoint(m.get(id)));

        return Collections.unmodifiableMap(result);
    }
}

```

- 위에서 사용한 MutablePoint 클래스는 스레드에 안전하지 않지만 실제 사용하는 MonitorVehicleTracker 클래스에서는 MutablePoint 에 대해서 스레드에 안전하도록 설계했음
- 외부에서 변경 가능한 데이터를 요청한 경우 그에 대한 복사본을 넘겨주는 방법을 사용하면 스레드 안전성을 부분적이나마 확보할 수 있음
- 경우에 따라 만약 호출된 시점에 해당하는 좌표값을 얻는것이 요구사항이라면 적합하나 만약 지속적으로 좌표를 추적해야하는 경우라면 위와 같은 경우 계속해서 MutablePoint를 생성하기때문에 적합하지 않음

## 스레드 안전성 위임

- 아주 간단한 몇가지 객체를 제외하고는 대부분의 객체가 둘 이상의 객체를 조합해 사용하는 합성 객체임
- 스레드 안전성이 없는 객체를 조합하더라도 내부에 있는 객체들이 스레드에 안전하다면 그 래퍼 클래스도 스레드에 안전할 수 있음

### 예제: 위임 기법을 활용한 차량 추적

- 스레드 안전성 위임방법을 통해 차량 추적 프로그램을 재설계함

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * Point
 * <p/>
 * Immutable Point class used by DelegatingVehicleTracker
 *
 * @author Brian Goetz and Tim Peierls
 */
@Immutable
public class Point {
    public final int x, y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```



```java
package net.jcip.examples;

import java.util.*;
import java.util.concurrent.*;
import java.awt.*;
import java.awt.Point;

import net.jcip.annotations.*;

/**
 * DelegatingVehicleTracker
 * <p/>
 * Delegating thread safety to a ConcurrentHashMap
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class DelegatingVehicleTracker {
    private final ConcurrentMap<String, Point> locations;
    private final Map<String, Point> unmodifiableMap;

    public DelegatingVehicleTracker(Map<String, Point> points) {
        locations = new ConcurrentHashMap<String, Point>(points);
        unmodifiableMap = Collections.unmodifiableMap(locations);
    }

    public Map<String, Point> getLocations() {
        return unmodifiableMap;
    }

    public Point getLocation(String id) {
        return locations.get(id);
    }

    public void setLocation(String id, int x, int y) {
        if (locations.replace(id, new Point(x, y)) == null)
            throw new IllegalArgumentException("invalid vehicle name: " + id);
    }

    // Alternate version of getLocations (Listing 4.8)
    public Map<String, Point> getLocationsAsStatic() {
        return Collections.unmodifiableMap(
                new HashMap<String, Point>(locations));
    }
}

```

- 위 코드에서는 어떠한 락도 없지만 ConcurrentHashMap을 사용하기때문에 스레드에 안전함
- 그리고 개인적으로 재미있는부분이 생성 시점에 locations의 인스턴스를 포함한 unmodifiableMap을 만드는데 이후에 locations에 추가가 되더라도 unmodifiableMap이 갖고 잇는 참조는 locations이기 때문에 변경 또는 추가된 좌표를 어느 스레드에서나 확인할 수 있음 unmodifiableMap얘만 갖고 있다면! 만약 특정 시점만 조회하고싶다면 getLocationsAsStatic()를 사용하면됨



### 독립 상태 변수

- 위임하고자하는 내부 변수가 두 개 이상이라 해도 두 개 이상의 변수가 서로 독립적이라면 클래스의 스레드 안전성을 위임할 수 있는데, 독립적이라는 의미는 변수가 서로의 상태 값에 대한 연관성이 없다는 말임
- 아래 두개의 eventListeners 변수들은 서로 연관이 없어서 스레드 안전성을 위임할 수 있음

```java
package net.jcip.examples;

import java.awt.event.KeyListener;
import java.awt.event.MouseListener;
import java.util.*;
import java.util.concurrent.*;

/**
 * VisualComponent
 * <p/>
 * Delegating thread safety to multiple underlying state variables
 *
 * @author Brian Goetz and Tim Peierls
 */
public class VisualComponent {
    private final List<KeyListener> keyListeners
            = new CopyOnWriteArrayList<KeyListener>();
    private final List<MouseListener> mouseListeners
            = new CopyOnWriteArrayList<MouseListener>();

    public void addKeyListener(KeyListener listener) {
        keyListeners.add(listener);
    }

    public void addMouseListener(MouseListener listener) {
        mouseListeners.add(listener);
    }

    public void removeKeyListener(KeyListener listener) {
        keyListeners.remove(listener);
    }

    public void removeMouseListener(MouseListener listener) {
        mouseListeners.remove(listener);
    }
}
```



### 위임할 때의 문제점

- 거의 모든 객체가 내부의 상태 변수 간에 의존성을 갖고 있음
- 따라서 의존성이 있는 경우에 단일 연산으로 묶어야하고 스레드 안전성 위임 방식을 사용할 수 없음

```java
package net.jcip.examples;

import java.util.concurrent.atomic.*;

/**
 * NumberRange
 * <p/>
 * Number range class that does not sufficiently protect its invariants
 *
 * @author Brian Goetz and Tim Peierls
 */

public class NumberRange {
    // INVARIANT: lower <= upper
    private final AtomicInteger lower = new AtomicInteger(0);
    private final AtomicInteger upper = new AtomicInteger(0);

    public void setLower(int i) {
        // Warning -- unsafe check-then-act
        if (i > upper.get())
            throw new IllegalArgumentException("can't set lower to " + i + " > upper");
        lower.set(i);
    }

    public void setUpper(int i) {
        // Warning -- unsafe check-then-act
        if (i < lower.get())
            throw new IllegalArgumentException("can't set upper to " + i + " < lower");
        upper.set(i);
    }

    public boolean isInRange(int i) {
        return (i >= lower.get() && i <= upper.get());
    }
}

```

- 두 변수가 독립적으로 동작하지 않은데 락이 없어서 매우 위험함
- 이런 경우에는 내부적으로 락을 사용해서 복합 연산이 단일 연산으로 처리되도록 해야함
- 클래스가 서로 의존성 없이 독립적이고 스레드 안전한 두 개 이상의 클래스를 조합해 만들어져 있고 두 개 이상의 클래스를 한번에 처리하는 복합 연산 메서드가 없는 상태라면 스레드 안전성을 내부 변수에게 모두 위임할 수 있음

### 내부 상태 변수를 외부에 공개

- 상태 변수가 스레드에 안전하고, 클래스 내부에서 상태 변수의 값에 대한 의존성을 갖고 있지 않고, 상태 변수에 대한 어떤 연산을 수행하더라도 잘못된 상태에 이를 가능성이 없다면 해당 변수는 외부에 공개해도 안전함



### 예제: 차량 추적 프로그램의 상태를 외부에 공개

- 차량 추적 프로그램의 내부 상태를 외부에 공개하는 구조로 변경해보기

```java
package net.jcip.examples;

import net.jcip.annotations.*;

/**
 * SafePoint
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class SafePoint {
    @GuardedBy("this") private int x, y;

    private SafePoint(int[] a) {
        this(a[0], a[1]);
    }

    public SafePoint(SafePoint p) {
        this(p.get());
    }

    public SafePoint(int x, int y) {
        this.set(x, y);
    }

    public synchronized int[] get() {
        return new int[]{x, y};
    }

    public synchronized void set(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

```java
package net.jcip.examples;

import java.util.*;
import java.util.concurrent.*;

import net.jcip.annotations.*;

/**
 * PublishingVehicleTracker
 * <p/>
 * Vehicle tracker that safely publishes underlying state
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class PublishingVehicleTracker {
    private final Map<String, SafePoint> locations;
    private final Map<String, SafePoint> unmodifiableMap;

    public PublishingVehicleTracker(Map<String, SafePoint> locations) {
        this.locations = new ConcurrentHashMap<String, SafePoint>(locations);
        this.unmodifiableMap = Collections.unmodifiableMap(this.locations);
    }

    public Map<String, SafePoint> getLocations() {
        return unmodifiableMap;
    }

    public SafePoint getLocation(String id) {
        return locations.get(id);
    }

    public void setLocation(String id, int x, int y) {
        if (!locations.containsKey(id))
            throw new IllegalArgumentException("invalid vehicle name: " + id);
        locations.get(id).set(x, y);
    }
}
```

- 위처럼 내부에 상태를 안전하게 공개하면서 차량 추적 프로그램을 만들 수 있음



## 스레드 안전하게 구현된 클래스에 기능 추가

- 만들어져 있는 클래스를 쓰는게 대부분 적절한 방법임
- 이미 스레드에 안전한 클래스라고 하더라도 두개의 연산을 섞어서 사용한다고 하면 동시성에 위반될 수 있음
- 스레드 안전성은 반드시 단일 연산에만 적용된다는것을 명심!

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * BetterVector
 * <p/>
 * Extending Vector to have a put-if-absent method
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class BetterVector <E> extends Vector<E> {
    // When extending a serializable class, you should redefine serialVersionUID
    static final long serialVersionUID = -3963416950630760754L;

    public synchronized boolean putIfAbsent(E x) {
        boolean absent = !contains(x);
        if (absent)
            add(x);
        return absent;
    }
}
```

- 위처럼 Vector 클래스를 상속해서 putIfAbsent() 메서드를 추가했음
- 기존 클래스를 상속받아 기능을 추가하는 방법은 문제가 생길 위험이 많음. 상위 클래스가 내부적으로 상태 변수의 스레드 안전성을 보장하는 동기화 기법을 약간만 수정해도 하위 클래스에서 전부 깨질 수 있음 참고

### 호출하는 측의 동기화

- 클래스를 상속받지 않고도 클래스에 원하는 기능을 추가할 수 있는 방법으로 도우미 클래스를 따로 구현해서 추가 기능을 구현하는 방법임

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * ListHelder
 * <p/>
 * Examples of thread-safe and non-thread-safe implementations of
 * put-if-absent helper methods for List
 *
 * @author Brian Goetz and Tim Peierls
 */

@NotThreadSafe
class BadListHelper <E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());

    public synchronized boolean putIfAbsent(E x) {
        boolean absent = !list.contains(x);
        if (absent)
            list.add(x);
        return absent;
    }
}

@ThreadSafe
class GoodListHelper <E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<E>());

    public boolean putIfAbsent(E x) {
        synchronized (list) {
            boolean absent = !list.contains(x);
            if (absent)
                list.add(x);
            return absent;
        }
    }
}
```

- BadListHelper 클래스는 동기화된것처럼 보이지만 사실 BadListHelper의 putIfAbsent()을 동기화했을뿐 내부 멤버변수인 list와는 연관이 없음.
- GoodListHelper클래스가 실제로 동시성을 보장함
- 제3의 도우미 클래스를 만들어 사용하려는 방법을 올바르게 구현하려면 클라이언트 측 락이나 외부 락을 사용해 List가 사용하는 것과 동일한 락을 사용해야함
- 이런 제 3의 도우미 클래스를 만드는 방법은 특정 클래스 내부에서 제 3의 클래스를 락을 거는거라 매우매우 위험함 반드시 동기화 전략에 대한 내용을 정확하게 구현하고 공지해야함

### 클래스 재구성

- 기존 클래스에 새로운 단일 연산을 추가하고자 할 때 안전하게 사용할 수 있는 방법은 바로 재구성임

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * ImprovedList
 *
 * Implementing put-if-absent using composition
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class ImprovedList<T> implements List<T> {
    private final List<T> list;

    /**
     * PRE: list argument is thread-safe.
     */
    public ImprovedList(List<T> list) { this.list = list; }

    public synchronized boolean putIfAbsent(T x) {
        boolean contains = list.contains(x);
        if (!contains)
            list.add(x);
        return !contains;
    }

    // Plain vanilla delegation for List methods.
    // Mutative methods must be synchronized to ensure atomicity of putIfAbsent.
    
    public int size() {
        return list.size();
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    public boolean contains(Object o) {
        return list.contains(o);
    }

    public Iterator<T> iterator() {
        return list.iterator();
    }

    public Object[] toArray() {
        return list.toArray();
    }

    public <T> T[] toArray(T[] a) {
        return list.toArray(a);
    }

    public synchronized boolean add(T e) {
        return list.add(e);
    }

    public synchronized boolean remove(Object o) {
        return list.remove(o);
    }

    public boolean containsAll(Collection<?> c) {
        return list.containsAll(c);
    }

    public synchronized boolean addAll(Collection<? extends T> c) {
        return list.addAll(c);
    }

    public synchronized boolean addAll(int index, Collection<? extends T> c) {
        return list.addAll(index, c);
    }

    public synchronized boolean removeAll(Collection<?> c) {
        return list.removeAll(c);
    }

    public synchronized boolean retainAll(Collection<?> c) {
        return list.retainAll(c);
    }

    public boolean equals(Object o) {
        return list.equals(o);
    }

    public int hashCode() {
        return list.hashCode();
    }

    public T get(int index) {
        return list.get(index);
    }

    public T set(int index, T element) {
        return list.set(index, element);
    }

    public void add(int index, T element) {
        list.add(index, element);
    }

    public T remove(int index) {
        return list.remove(index);
    }

    public int indexOf(Object o) {
        return list.indexOf(o);
    }

    public int lastIndexOf(Object o) {
        return list.lastIndexOf(o);
    }

    public ListIterator<T> listIterator() {
        return list.listIterator();
    }

    public ListIterator<T> listIterator(int index) {
        return list.listIterator(index);
    }

    public List<T> subList(int fromIndex, int toIndex) {
        return list.subList(fromIndex, toIndex);
    }

    public synchronized void clear() { list.clear(); }
}
```

- 이런식으로 구현하는 방법이 이전에 설명했던 방법들보다 조금 더 안전하게 단일 연산을 추가하는 방법임





## 동기화 정책 문서화 하기

- 구현한 클래스가 어느정도 수준까지 스레드 안전성을 보장하는지에 대해 충분히 문서를 작성해둬야함 동기화 기법이나 정책을 잘 정리해두면 유지보수 팀이 원활하게 관리할 수 있음
- 클라이언트가 추측하는 위험한 상황보다는 정리된 글로 안내해주는게 좋음



### 애매한 문서 읽어내기

# #5 구성 단위

## 동기화된 컬렉션 클래스

- 동기화되어 있는 컬렉션 클래스의 대표주자는 바로 Vector와 Hashtable 등이 있는데 이와 같은 클래스는 모두 public으로 선언된 모든 메서드를 클래스 내부에 캡슐화해 내부의 값을 한 번에 한 스레드만 사용할 수 있도록 제어하면서 스레드 안전성을 확보하고 있음

### 동기화된 컬렉션 클래스의 문제점

- 안전성을 확보하고 있지만 여러 개의 연산을 묶어서 하나의 단일 연산처럼 활용해야 할 필요성이 있을때는 주의해야함

```java
package net.jcip.examples;

import java.util.*;

/**
 * UnsafeVectorHelpers
 * <p/>
 * Compound actions on a Vector that may produce confusing results
 *
 * @author Brian Goetz and Tim Peierls
 */
public class UnsafeVectorHelpers {
    public static Object getLast(Vector list) {
        int lastIndex = list.size() - 1;
        return list.get(lastIndex);
    }

    public static void deleteLast(Vector list) {
        int lastIndex = list.size() - 1;
        list.remove(lastIndex);
    }
}

```

- 위와 같이 동일한 Vector 클래스를 놓고 따로 연산하는 경우는 올바르게 동작하지 않을 수 있음
- 절묘하게 두 메서드가 동시에 실행된다고 가정했을때는 list.size()를 얻어오는 시점이 다르기때문에 문제가 생길 수 있음
- 동기화된 컬렉션 클래스는 대부분 클라이언트 측 락을 사용할 수 있도록 만들어져 있기 때문에 컬렉션 클래스가 사용하는 락을 함께 사용한다면 새로 추가하는 기능을 컬렉션 클래스에 들어있는 다른 메서드와 같은 수준으로 동기화시킬 수 있음

```java
package net.jcip.examples;

import java.util.*;

/**
 * SafeVectorHelpers
 * <p/>
 * Compound actions on Vector using client-side locking
 *
 * @author Brian Goetz and Tim Peierls
 */
public class SafeVectorHelpers {
    public static Object getLast(Vector list) {
        synchronized (list) {
            int lastIndex = list.size() - 1;
            return list.get(lastIndex);
        }
    }

    public static void deleteLast(Vector list) {
        synchronized (list) {
            int lastIndex = list.size() - 1;
            list.remove(lastIndex);
        }
    }
}
```

- 위와 같이 synchronized 블록으로 감쌓으면 list 자체에 대한 락을 걸기 때문에 문제가 생기지 않음



### Iterator와 ConcurrentModificationException

> 책에는 예제가 있는데 사이트에 없네 왜지 ? 

- 동기화된 컬렉션 클래스에서 만들어낸 Interator를 사용한다 해도 다른 스레드가 같은 시점에 컬렉션 클래스 내부의 값을 변경하는 작업을 하려 할때 즉시 멈춤의 형태로 반응하게 되어 있음
- 즉시 멈춤이란 반복문을 실행하는 도중에 컬렉션 클래스 내부의 값을 변경하는 상황이 포착되면 그 즉시 ConcurrentModificationException 예외를 발생시키고 멈추는 처리 방법
- 컬렉션 클래스는 내부에 값 변경 횟수를 카운트하는 변수를 마련해두고 반복문 실행 동안 횟수 값이 바뀌면 ConcurrentModificationException을 발생시킴
- 반복문을 실행하는 코드 전체를 동기화하면 ConcurrentModificationException을 방지할 수 있지만 좋은 방법이 아님
- 컬렉션 내부에 요소가 많다면 락을 잡는 비용이 너무 큼
- 멀티 스레드 환경에서 컬렉션에 ConcurrentModificationException을 피하고싶다면 기존 객체를 clone해서 스레드 한정기법으로 동시성을 보장받게 할 수 있음

### 숨겨진 Iterator

- Iterator가 숨겨진 경우도 있기 때문에 컬렉션을 공유해 사용하는 모든 부분에서 동기화를 맞춰줘야함

```java
package net.jcip.examples;

import java.util.*;

import net.jcip.annotations.*;

/**
 * HiddenIterator
 * <p/>
 * Iteration hidden within string concatenation
 *
 * @author Brian Goetz and Tim Peierls
 */
public class HiddenIterator {
    @GuardedBy("this") private final Set<Integer> set = new HashSet<Integer>();

    public synchronized void add(Integer i) {
        set.add(i);
    }

    public synchronized void remove(Integer i) {
        set.remove(i);
    }

    public void addTenThings() {
        Random r = new Random();
        for (int i = 0; i < 10; i++)
            add(r.nextInt());
        System.out.println("DEBUG: added ten elements to " + set);
    }
}
```

- 믿기힘들겠지만 `System.out.println("DEBUG: added ten elements to " + set);` 이부분이 문제임 set의 toString()이 동작할때 내부적으로는 Iterator가 동작함 ..
- 개발자는 상태 변수와 상태 변수의 동기화를 맞춰주는 락이 멀리 떨어져 있을수록 동기화를 맞춰야 한다는 필요성을 잊기 쉽다는 점임. 만약 HiddenIterator 클래스에서 사용했던 것처럼 HashSet을 직접 사용하지말고 synchronizedSet메서드로 동기화된 컬렉션을 사용하면 동기화가 이미 맞춰져 있기 때문에 Iterator와 관련한 이런 문제가 발생하지 않음



## 병렬 컬렉션

- 자바5부터 병렬 컬렉션 클래스가 추가되면서 성능을 상당히 끌어올릴 수 있게됐음 

### ConcurrentHashMap

- 동기화된 컬렉션 클래스는 각 연산을 수행하는 시간 동안 항상 락을 확보하고 있어야함
- ConcurrentHashMap은 HashMap과 같이 해시를 기반으로 하는 Map임 하지만 내부적으로는 이전에 사용하던 것과 전혀 다른 동기화 기법을 채택해 병렬성과 확장성이 훨씬 나아졌음
- 이전에는 모든 연산에서 하나의 락을 사용했기 때문에 특정 시점에 하나의 스레드만이 해당 컬렉션을 사용 가능했으나 ConcurrentHashMap은 락 스트라이핑 이라 부르는 굉장히 세밀한 동기화 방법을 사용해 여러 스레드에서 공유하는 상태에 훨씬 잘 대응할 수 있게됨
- 값을 읽어가는 연산은 많은 수의 스레드라도 얼마든지 동시에 처리할 수 있고, 읽기 연산과 쓰기 연산도 동시에 처리할 수 있고 쓰기 연산은 제한된 개수만큼 동시에 수행할 수 있음
- ConcurrentHashMap이 만들어낸 Iterator는 ConcurrentModificationException을 발생시키지 않도록 설계됨
- 신경써야할 부분도 생겼는데 예를 들어 size()와 isEmpty()의 경우 정확한 값이 아니라 추정된 값인데 그렇게 크게 문제되는 부분은 아님
- ConcurrentHashMap은 독점적으로 락을 사용할 수 없음
- 만약 작업중인 애플리케이션에서 특정 Map을 완전히 독점해서 사용하는 경우가 있다면 그 부분에 ConcurrentHashMap을 사용할때는 충분히 주의할것



### Map기반의 또 다른 단일 연산

- ConcurrentHashMap에는 put-if-absent, remove-if-eqaul, replace-if-eqaul 같은 자주 필요한 몇가지 연산이 이미 구현되어 있음



### CopyOnWriteArrayList

- CopyOnWriteArrayList 클래스는 동기화된 List클래스보다 병렬성을 훨씬 높이고자 만들어짐
- 변경할 때마다 복사한다면 별다른 동기화 작업 없이 스레드 안전함. CopyOnWriteArrayList는 컬렉션 내용이 변경될 때마다 복사본을 새로 만들어 내는 전략을 취함.
- CopyOnWriteArrayList의 Iterator는 ConcurrentModificationException을 발생시키지 않음. 복사하기 때문에
- 컬렉션을 복사하는게 비용이 있어서 변경할때마다 복사하는 컬렉션은 변경 작업보다 반복문으로 읽어내는 일이 훨씬 빈번한 경우에 효과적임 ex 이벤트 리스너



## 블로킹 큐와 프로듀서-컨슈머 패턴

- 블로킹 큐는 put과 take라는 핵심 메서드가 있고 offer와 poll이라는 메서드가 있음
- 만약 큐가 가득 차 있다면 put 메서드는 값을 추가할 공간이 생길 때까지 대기함 반대로 큐가 비어있는 상태라면 take 메서드는 뽑아낼 값이 들어올 때까지 대기함
- 큐의 크기에 제한을 두지 않을 수 있기 때문에 그럴 경우엔 put 연산이 대기 상태에 들어가는 경우가 없음
- 블로킹큐는 프로듀서-컨슈머 패턴을 구현할 때 사용하기에 좋음
-  프로듀서 컨슈머 패턴을 사용하면 작업을 만들어 내는 부분과 작업을 처리하는 부분을 완전히 분리할 수 있기 때문에 개발 과정을 좀 더 명확하게 단순화시킬 수 있고, 작업을 생성하는 부분과 처리하는 부분이 각각 감당할 수 있는 부하를 조절할 수 있다는 장점이 있음
- 프로듀서는 작업을 새로 만들어 큐에 쌓아두고 컨슈머는 큐에 쌓여 있는 작업을 가져다 처리하는 구조
- 큐와 함께 스레드 풀을 사용하는 경우가 바로 프로듀서 컨슈머 패턴을 활용하는 가장 흔한 경우
- 블로킹큐는 애플리케이션이 안정적으로 동작하도록 만들고자 할 때 요긴하게 사용할 수 있는 도구임 블로킹 큐를 사용하면 처리할 수 있는 양보다 훨씬 많은 작업이 생겨 부하가 걸리는 상황에서 작업량을 조절해 애플리케이션이 안정적으로 동작하도록 유도할 수 있음



### 예제: 데스크탑 검색

- 프로듀서 컨슈머 패턴을 사용하면 데스크탑 검색 프로그램을 구현하는 것과같이 멀티스레드를 사용하는 경우에 프로그램의 세부 기능을 쉽게 컴포넌트화 할 수 있음
- 디렉토리 구조를 따라가며 파일을 읽어들이고 파일의 내용을 색인하는 기능을 두개의 클래스로 구분



### 직렬 스레드 한정

- 프로듀서 컨슈머 패턴과 블로킹 큐는 가변객체를 사용할 때 객체의 소유권을 프로듀서에서 컨슈머로 넘기는 과정에서 직렬 스레드 한정 기법을 사용함 스레드에 한정된 객체는 특정 스레드 하나만이 소유권을 가질 수 있는데 객체를 안전한 방법으로 공개하면 객체에 대한 소유권을 이전할 수 있음
- 객체 풀은 직렬 스레드 한정 기법을 잘 활용하는 예



```java
package net.jcip.examples;

import java.io.File;
import java.io.FileFilter;
import java.util.concurrent.*;

/**
 * ProducerConsumer
 * <p/>
 * Producer and consumer tasks in a desktop search application
 *
 * @author Brian Goetz and Tim Peierls
 */
public class ProducerConsumer {
    static class FileCrawler implements Runnable {
        private final BlockingQueue<File> fileQueue;
        private final FileFilter fileFilter;
        private final File root;

        public FileCrawler(BlockingQueue<File> fileQueue,
                           final FileFilter fileFilter,
                           File root) {
            this.fileQueue = fileQueue;
            this.root = root;
            this.fileFilter = new FileFilter() {
                public boolean accept(File f) {
                    return f.isDirectory() || fileFilter.accept(f);
                }
            };
        }

        private boolean alreadyIndexed(File f) {
            return false;
        }

        public void run() {
            try {
                crawl(root);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        private void crawl(File root) throws InterruptedException {
            File[] entries = root.listFiles(fileFilter);
            if (entries != null) {
                for (File entry : entries)
                    if (entry.isDirectory())
                        crawl(entry);
                    else if (!alreadyIndexed(entry))
                        fileQueue.put(entry);
            }
        }
    }

    static class Indexer implements Runnable {
        private final BlockingQueue<File> queue;

        public Indexer(BlockingQueue<File> queue) {
            this.queue = queue;
        }

        public void run() {
            try {
                while (true)
                    indexFile(queue.take());
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        public void indexFile(File file) {
            // Index the file...
        };
    }

    private static final int BOUND = 10;
    private static final int N_CONSUMERS = Runtime.getRuntime().availableProcessors();

    public static void startIndexing(File[] roots) {
        BlockingQueue<File> queue = new LinkedBlockingQueue<File>(BOUND);
        FileFilter filter = new FileFilter() {
            public boolean accept(File file) {
                return true;
            }
        };

        for (File root : roots)
            new Thread(new FileCrawler(queue, filter, root)).start();

        for (int i = 0; i < N_CONSUMERS; i++)
            new Thread(new Indexer(queue)).start();
    }
}
```



### 덱 작업 가로채기

- 자바6에는 Deque가 추가되었음 덱은 앞 뒤 어느 쪽에도 객체를 쉽게 삽입하거나 제거할 수 있도록 준비된 큐임
- 프로듀서 컨슈머 패턴에서 블로킹 큐의 기능을 그대로 가져다 사용하는 것처럼 작업 개로채기라는 패턴을 적용할 때에는 덱을 그대로 가져다 사용할 수 있음
- 작업 가로채기 패턴에서는 모든 컨슈머가 각자의 덱을 가짐
- 만약 특정 컨슈머가 자신의 덱에 있는 작업을 모두 처리하면 다른 컨슈머의 덱의 가장 마지막 작업을 가로채 올 수 있음
- 작업 가로채기 패턴은 특성상 컨슈머가 하나의 큐를 바라보면서 서로 작업을 가져가려고 경쟁하지 않기 때문에 일반적인 프로듀서 컨슈머 패턴보다 규모가 큰 시스템을 구현하기에 적당함 더군다나 누군가 가로채더라도 맨 뒤에서 작업을 가져오기 때문에 경쟁이 없음
- 작업 가로채기 패턴은 컨슈머가 프로듀서의 역할도 갖고 있는 경우에 적용하기에 좋음



## 블로킹 메소드, 인터럽터블 메소드

- 스레드는 여러가지 원인에 의해 블록당하거나 멈춰질 수 있음 ex: I/O작업이 끝나기를 기다리거나 락을 확보하기 위해 등등
- 인터럽트는 스레드가 서로 협력해서 실행하기 위한 방법임 어떤 스레드라도 다른 스레드가 하고 있는 일을 중간에 강제로 멈추라고는 할 수 없음 단지 요청하는 것일 뿐
- 인터럽트를 원활하게 처리하도록 만들어진 메서드는 실행 시간이 너무 길어질 때 일정 시간이 지난 이후 실행을 중단할 수 있도록 구성하기 좋음
- InterruptedException이 발생할 수 있는 메서드가 있다면 그 메서드를 호출하는 메서드 역시 블로킹 메서드임 따라서 InterruptedException이 발생했을때 그에 대한 대처방법을 마련해둬야함
- 두가지 방법이 있음
  - InterruptedException을 전달: 받아낸 InterruptedException을 그대로 호출한 메서드에게 넘겨버리는 방법.
  - 인터럽트를 무시하고 복구: 특정 상황에서 InterruptedException를 throw할 수 없는 경우. InterruptedException을 catch한 다음 현재 스레드의 interrupt 메서드를 호출해 인터럽트 상태를 설정해 상위 호출 메서드가 인터럽트 상황이 발생했음을 알 수 있도록 해야 함
- InterruptedException을 catch하고 아무런 일도 하지 않는 것은 절대 하지 말아야 함!

```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * TaskRunnable
 * <p/>
 * Restoring the interrupted status so as not to swallow the interrupt
 *
 * @author Brian Goetz and Tim Peierls
 */
public class TaskRunnable implements Runnable {
    BlockingQueue<Task> queue;

    public void run() {
        try {
            processTask(queue.take());
        } catch (InterruptedException e) {
            // restore interrupted status
            Thread.currentThread().interrupt();
        }
    }

    void processTask(Task task) {
        // Handle the task
    }

    interface Task {
    }
}
```

- 위 클래스처럼 인터럽트가 발생한 사실을 저장해야함



## 동기화 클래스

- 상태 정보를 사용해 스레드 간의 작업 흐름을 조절할 수 있도록 만들어진 모든 클래스를 동기화 클래스라고함
- 블로킹큐, 세마포어, 배리어, 래치 등이 있음
- 모든 동기화 클래스는 구조적인 특징을 갖고 있음 모두 동기화 클래스에 접근하려는 스레드가 어느 경우에 통과하고 어느 경우에는 대기하도록 멈추게 해야 하는지를 결정하는 상태 정보를 갖고 있고 그 상태를 변경할 수 있는 메서드를 제공하고, 동기화 클래스가 특정 상태에 진입할 때까지 효과적으로 대기할 수 있는 메서드도 제공함

### 래치

- 래치는 스스로가 터미널 상태에 이를때까지의 스레드가 동작하는 과정을 늦출 수 있도록 해주는 동기화 클래스임
- 래치는 일종의 관문과 같은 형태로 동작함 래치가 터미널 상태에 다다르면 관문이 열리고 모든 스레드가 통과함
- 래치가 한 번 터미널 상태에 다다르면 그 상태를 다시 이전으로 되돌릴 수 없음 
- 래치는 특정한 단일 동작이 완료되기 잊전에는 어떤 기능도 동작하지 않도록 막아내야 하는 경우에 요긴하게 사용할 수 있음 예를 들어 다음 과 같은 경우에
  - 특정 자원을 확보하기 전에는 작업을 시작하지 말아야 하는 경우에 사용 가능. 아주 간단한 이진 래치를 사용해 "자원R을 확보했다" 는 상태를 표현하고, 자원 R을 사용해야 하는 모든 작업은 이 래치의 관문이 열리기를 기다리도록 함
  - 의존성을 갖고 있는 다른 서비스가 시작하기 전에는 특정 서비스가 실행되지 않도록 막아야 하는 경우에 사용 가능. 각 서비스마다 이진 래치를 갖고 있으며, S라는 서비스를 시작하면 먼저 S가 의존성을 갖고 있는 모든 서비스의 래치가 열리기를 기다림 기다리던 모든 래치가 열리고 나면 서비스 S는 자신의 래치를 열어, 자신이 시작되기를 기다리는 서비스가 실행될 수 있도록 함
  - 특정 작업에 필요한 모든 객체가 실행할 준비를 갖출때까지 기다리는 경우에도 사용 가능 예를 들어 여러 사용자가 동시에 참여하는 게임을 쵲초에 시작하기 전에 모든 사용자가 게임을 시작할 준비가 끝났는지 확인하는데 요긴함. 이런 경우에는 모든 사용자가 준비됐다는 상태에 이르면 래치가 터미널 상태에 다다르게 구성할 수 있음
- CountDownLatch는 위에서 소개한 모든 경우에 쉽게 적용할 수 있는 유연한 구조를 갖고 있음 하나 또는 둘 이상의 스레드가 여러 개의 이벤트가 일어날 때까지 대기할 수 있도록 되어 있음
- 래치의 상태는 양의 정수값으로 카운터를 초기화하며, 이 값은 대기하는 동안 발생해야 하는 이벤트의 건수를 의미함
- CountDownLatch 클래스의 countDown 메서드는 대기하던 이벤트가 발생했을 때 내부에 갖고 있는 이벤트 카운터를 하나 낮춰주고 await 메서드는 래치의 내부의 카운터가 0이 될 때까지, 즉 대기하던 이벤트가 모두 발생했을 때까지 대기하도록 하는 메서드임. 외부 스레드가 wait메서드를 호출할 때 래치 내부의 카운터가 0 보다 큰 값이었다면, await메서드는 카운터가 0이 되거나. 대기하던 스레드에 인터럽트가 걸리거나, 대기 시간이 길어 타임아웃이 걸릴 때까지 대기함.

```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * TestHarness
 * <p/>
 * Using CountDownLatch for starting and stopping threads in timing tests
 *
 * @author Brian Goetz and Tim Peierls
 */
public class TestHarness {
    public long timeTasks(int nThreads, final Runnable task)
            throws InterruptedException {
        final CountDownLatch startGate = new CountDownLatch(1);
        final CountDownLatch endGate = new CountDownLatch(nThreads);

        for (int i = 0; i < nThreads; i++) {
            Thread t = new Thread() {
                public void run() {
                    try {
                        startGate.await();
                        try {
                            task.run();
                        } finally {
                            endGate.countDown();
                        }
                    } catch (InterruptedException ignored) {
                    }
                }
            };
            t.start();
        }

        long start = System.nanoTime();
        startGate.countDown();
        endGate.await();
        long end = System.nanoTime();
        return end - start;
    }
}
```

- 스레드 run 내부에서 startGate.await();을 써서 스레드가 start 되어도 시작을 안하는건가?




### FutureTask

- FutureTask 역시 래치와 비슷한 형태로 동작함FutureTask 나타내는 연산 작업은 Callable인터페이스를 구현하도록 되어 있는데 시작전 대기, 시작됨, 종료됨과 같은 세가지 상태를 가질 수 있음
- 종료된 상태는 정상적인 종료, 취소, 예외 상황 발생과 같이 연산이 끝나는 모든 종류의 상태를 의미함
- FutureTask는 한번 종료 상태가 되면 더 이상 상태가 바뀌는 일이 없음
- FutureTask.get 메서드의 동작모습도 실행 상태에 따라 다름. FutureTask의 작업이 종료된 상태라면 그 즉시 결과를 알려주고 종료상태에 이르지 못했다면 종료 상태에 이를 때까지 대기하고, 종료된 이후에 연산 결과나 예외 상황을 알려줌.
- FutureTask는 Executor 프레임웍에서 비동기적인 작업을 싱해하고자 할 때 사용하고 기타 시간이 많이 필요한 모든 작업이 있을 때 실제 결과가 필요한 시점 이전에 미리 작업을 실행시켜두는 용도로 사용함



```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * Preloader
 *
 * Using FutureTask to preload data that is needed later
 *
 * @author Brian Goetz and Tim Peierls
 */

public class Preloader {
    ProductInfo loadProductInfo() throws DataLoadException {
        return null;
    }

    private final FutureTask<ProductInfo> future =
        new FutureTask<ProductInfo>(new Callable<ProductInfo>() {
            public ProductInfo call() throws DataLoadException {
                return loadProductInfo();
            }
        });
    private final Thread thread = new Thread(future);

    public void start() { thread.start(); }

    public ProductInfo get()
            throws DataLoadException, InterruptedException {
        try {
            return future.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            if (cause instanceof DataLoadException)
                throw (DataLoadException) cause;
            else
                throw LaunderThrowable.launderThrowable(cause);
        }
    }

    interface ProductInfo {
    }
}

class DataLoadException extends Exception { }
```

- Preloader 클래스는 FutureTask를 사용해 결과 값이 필요한 시점 이전에 시간이 많이 걸리는 작업을 미리 실행시켜둠
- 이런식으로 시간이 많이 걸리는 작업을 미리 시작시켜두면 실제로 결과를 필요로 하는 시점이 됐을 때 기다리는 시간을 줄일 수 있음
- start 메서드로 상품 정보를 미리 가져오는 작업을 하고 실제로 필요할때 get을 호출해서 전부 가져온상태라면 바로 리턴, 아닌경우엔 전부 가져오는 시점까지 기다리고 리턴하게됨

```java
package net.jcip.examples;

/**
 * StaticUtilities
 *
 * @author Brian Goetz and Tim Peierls
 */
public class LaunderThrowable {

    /**
     * Coerce an unchecked Throwable to a RuntimeException
     * <p/>
     * If the Throwable is an Error, throw it; if it is a
     * RuntimeException return it, otherwise throw IllegalStateException
     */
    public static RuntimeException launderThrowable(Throwable t) {
        if (t instanceof RuntimeException)
            return (RuntimeException) t;
        else if (t instanceof Error)
            throw (Error) t;
        else
            throw new IllegalStateException("Not unchecked", t);
    }
}
```



### 세마포어

- 카운팅 세머포어는 특정 자원이나 특정 연산을 동시에 사용하거나 호출할 수 있는 스레드의 수를 제한하고자 할 때 사용
- 세마포어는 데이터베이스 연결 풀과 같은 자원 풀에서 요긴하게 사용할 수 있음
- 자원 풀을 만들 때, 모든 자원을 빌려주고 남아 있는 자원이 없을 때 요청이 들어오는 경우에 대기시키게 할 수 있음 이럴 때 카운팅 세마포어를 만들면서 최초 퍼밋의 개수로 원하는 풀의 크기를 지정하고 acquire를 호출해 퍼밋을 확보하고 다 사용한 자원을 반납하고 난 다음에는 항상 release를 호출해 퍼밋도 반납하도록 함
- 만약 풀에 자원이 없을 경우에 acquire메서드가 대기 상태에 들어가기 때문에 객체가 반납될 때까지 자연스럽게 대기하게됨
- 이와 유사하게 세마포어를 사용하면 어떤 클래스라도 크기가 제한된 컬렉션 클래스로 활용할 수 있음
- 세마포어는 해당하는 컬렉션 클래스가 가질 수 있는 최대 크기에 해당하는 숫자로 초기화함
- add 메서드는 객체를 내부 데이터 구조에 추가하기 전에 acquire를 호출해 추가할 여유가 있는지 확인하고 만약 add 메서드가 내부 데이터구조에 실제로 값을 추가하지 못했다면 그 즉시 release를 호출해 세마포어에 퍼밋을 반납해야함 

```java
package net.jcip.examples;

import java.util.*;
import java.util.concurrent.*;

/**
 * BoundedHashSet
 * <p/>
 * Using Semaphore to bound a collection
 *
 * @author Brian Goetz and Tim Peierls
 */
public class BoundedHashSet <T> {
    private final Set<T> set;
    private final Semaphore sem;

    public BoundedHashSet(int bound) {
        this.set = Collections.synchronizedSet(new HashSet<T>());
        sem = new Semaphore(bound);
    }

    public boolean add(T o) throws InterruptedException {
        sem.acquire();
        boolean wasAdded = false;
        try {
            wasAdded = set.add(o);
            return wasAdded;
        } finally {
            if (!wasAdded)
                sem.release();
        }
    }

    public boolean remove(Object o) {
        boolean wasRemoved = set.remove(o);
        if (wasRemoved)
            sem.release();
        return wasRemoved;
    }
}
```



### 배리어

- 래치를 사용하면 여러 작업을 하나로 묶어 다음 작업으로 진행할 수 있는 관문과 같이 사용할 수 있다는 점을 앞에서 살펴봤음
- 래치는 일회성 객체, 래치가 한번 터미널 상태에 다다르면 다시는 이전 상태로 회복 불가
- 배리어는 특정 이벤트가 발생할 떄까지 여러 개의 스레드를 대기 상태로 잡아둘 수 있다는 측면에서 래치와 비슷하다고 볼 수 있지만 모든 스레드가 배리어 위치에 동시에 이르러야 관문이 열리고 계속해서 실행할 수 있다는 점이 래치와 다른점
- 래치는 이벤트를 기다리기 위한 동기화 클래스이고 배리어는 다른 스레드를 기다리기 위한 동기화 클래스임
- 배리어는 사람들이 어딘가에서 만날 약속을 하고 모두 도착할때 까지 대기 후 모두 도착하면 행동하는것과 같음
- CyclicBarrier클래스를 사용하면 여러 스레드가 특정한 배리어 포인트에서 반복적으로 만나는 기능을 모델링할 수 있고, 커다란 문제 하나를 여러 개의 작은 부분 문제로 분리해 반복적으로 병렬 처리하는 알고리즘을 구현하고자 할 때 적용하기 좋음
- 스레드는 각자 배리어 포인트에 다다르면 await메서드를 호출하고 await메서드는 모든 스레드가 배리어 포인트에 도달할 때까지 대기함 모든 스레드가 배리어 포인트에 도달하면 배리어는 모든 스레드를 통과시키고 await메서드에서 대기하고 있던 스레드는 대기 상태가 모두 풀려 실행되고 배리어는 다시 초기 상태로 돌아가 다음 배리어 포인트를 준비함 만약 타임아웃이나 인터럽트가 걸리면 배리어가 깨진것으로 간주하고 BrokenBarrierException이 발생함
- 배리어가 성공적으로 통과하면 await메서드는 각 스레드별로 배리어 포인트에 도착한 순서를 알려주고 다음 배리어 포인트로 반복 작업을 하는 동안 뭔가 특별한 작업을 진행할 일종의 리더를 선출하는데 이 값을 사용할 수 있음
- CyclicBarrier는 생성 메서드를 통해 배리어 작업을 넘겨받을 수 있도록 되어 있음. 배리어 작업은 Runnable인터페이스를 구현한 클래스인데 배리어 작업은 배리어가 성공적으로 통과된 이후 대기하던 스레드를 놓아주기 직전에 실행됨
- 배리어는 대부분 실제 작업은 모두 여러 스레드에서 병렬로 처리하고 다음 단계로 넘어가기 전에 이번 단계에서 계산해야 할 내용을 모두 취합해야 하는 등의 작업이  많이 일어나는 시뮬레이션 알고리즘에서 유용하게 사용 가능
- 배리어와 약간 다른 형태로 Exchanger클래스가 있음 Exchanger는 두 개의 스레드가 연결되는 배리어이고 배리어 포인트에 도달하면 양쪽의 스레드가 서로 갖고 있던 값을 교환함
- Exchanger클래스는 양쪽 스레드가 서로 대칭되는 작업을 수행할 때 유용함
- 예를 들어 한쪽 스레드는 데이터 버퍼에 값을 채워 넣는 일을 하고 다른 스레드는 데이터 버퍼에 있는 값을 빼내어 사용하는 일을 한다고 했을때 이 두개의 스레드를 Exchanger로 묶고 배리어 포인트에 도달할 때마다 데이터 버퍼를 교환하게 할 수 있음 교환은 안전한 공개 방법으로 되기 때문에 동시성 걱정  x
- 교환이 일어나는 타이밍은 전적으로 애플리케이션에 대한 요구사항. 데이터가 모두 채워질때 교환 또는 시간으로도 할 수 있음



```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * CellularAutomata
 *
 * Coordinating computation in a cellular automaton with CyclicBarrier
 *
 * @author Brian Goetz and Tim Peierls
 */
public class CellularAutomata {
    private final Board mainBoard;
    private final CyclicBarrier barrier;
    private final Worker[] workers;

    public CellularAutomata(Board board) {
        this.mainBoard = board;
        int count = Runtime.getRuntime().availableProcessors();
        this.barrier = new CyclicBarrier(count,
                new Runnable() {
                    public void run() {
                        mainBoard.commitNewValues();
                    }});
        this.workers = new Worker[count];
        for (int i = 0; i < count; i++)
            workers[i] = new Worker(mainBoard.getSubBoard(count, i));
    }

    private class Worker implements Runnable {
        private final Board board;

        public Worker(Board board) { this.board = board; }
        public void run() {
            while (!board.hasConverged()) {
                for (int x = 0; x < board.getMaxX(); x++)
                    for (int y = 0; y < board.getMaxY(); y++)
                        board.setNewValue(x, y, computeValue(x, y));
                try {
                    barrier.await();
                } catch (InterruptedException ex) {
                    return;
                } catch (BrokenBarrierException ex) {
                    return;
                }
            }
        }

        private int computeValue(int x, int y) {
            // Compute the new value that goes in (x,y)
            return 0;
        }
    }

    public void start() {
        for (int i = 0; i < workers.length; i++)
            new Thread(workers[i]).start();
        mainBoard.waitForConvergence();
    }

    interface Board {
        int getMaxX();
        int getMaxY();
        int getValue(int x, int y);
        int setNewValue(int x, int y, int value);
        void commitNewValues();
        boolean hasConverged();
        void waitForConvergence();
        Board getSubBoard(int numPartitions, int index);
    }
}
```



## 효율적이고 확장성 있는 결과 캐시 구현

- 거의 대부분의 서버 애플리케이션은 모두 어떤 형태이건 캐시를 사용함
- 이전에 처리했던 작업의 결과를 재사용할 수 있다면, 메모리를 조금 더 사용하기는 하지만 대기 시간으 크게 줄이고 처리 용량을 높일 수 있음

```java
package net.jcip.examples;

import java.math.BigInteger;
import java.util.*;

import net.jcip.annotations.*;

/**
 * Memoizer1
 *
 * Initial cache attempt using HashMap and synchronization
 *
 * @author Brian Goetz and Tim Peierls
 */
public class Memoizer1 <A, V> implements Computable<A, V> {
    @GuardedBy("this") private final Map<A, V> cache = new HashMap<A, V>();
    private final Computable<A, V> c;

    public Memoizer1(Computable<A, V> c) {
        this.c = c;
    }

    public synchronized V compute(A arg) throws InterruptedException {
        V result = cache.get(arg);
        if (result == null) {
            result = c.compute(arg);
            cache.put(arg, result);
        }
        return result;
    }
}


interface Computable <A, V> {
    V compute(A arg) throws InterruptedException;
}

class ExpensiveFunction
        implements Computable<String, BigInteger> {
    public BigInteger compute(String arg) {
        // after deep thought...
        return new BigInteger(arg);
    }
}
```

- 일반 HashMap으로 구현한  캐시 클래스
- 이런 방법은 쉽게 동시성을 얻어낼 수 있지만 확장성 측면에서 문제가 생김 특정 시점에 여러 스레드중 한 스레드만 compute를 실행할 수 있기 때문임
- ConcurrentHashMap 을 사용하면 해결할 수 있음

```java
package net.jcip.examples;

import java.util.*;
import java.util.concurrent.*;

/**
 * Memoizer2
 * <p/>
 * Replacing HashMap with ConcurrentHashMap
 *
 * @author Brian Goetz and Tim Peierls
 */
public class Memoizer2 <A, V> implements Computable<A, V> {
    private final Map<A, V> cache = new ConcurrentHashMap<A, V>();
    private final Computable<A, V> c;

    public Memoizer2(Computable<A, V> c) {
        this.c = c;
    }

    public V compute(A arg) throws InterruptedException {
        V result = cache.get(arg);
        if (result == null) {
            result = c.compute(arg);
            cache.put(arg, result);
        }
        return result;
    }
}
```

- 이런식으로 사용하면 훨씬 개선된 형태로 병렬프로그래밍을 할 수 있음
- 하지만 위 클래스도 문제점이 있음. 동시에 여러 스레드가 compute에 접근하고 동시에 cache.get() 을 호출한다면 동시에 result를 null 로 받는 상황이 있을 수 있고 그 결과 두번의 compute작업이 수행될 수 있음
- 이런 경우에 어떤 연산 x를 다른 스레드가 작업하고 있을때 스레드 A는 다른 스레드의 작업을 모두 끝낼때까지 대기하고 있다가 작업이 끝나면 x의 결과값으로 무엇을 얻었는가 라고 물어보면됨
- 이럴때 FutureTask를 쓰면 됨 



```java
package net.jcip.examples;

import java.util.concurrent.*;

/**
 * Memoizer
 * <p/>
 * Final implementation of Memoizer
 *
 * @author Brian Goetz and Tim Peierls
 */
public class Memoizer <A, V> implements Computable<A, V> {
    private final ConcurrentMap<A, Future<V>> cache
            = new ConcurrentHashMap<A, Future<V>>();
    private final Computable<A, V> c;

    public Memoizer(Computable<A, V> c) {
        this.c = c;
    }

    public V compute(final A arg) throws InterruptedException {
        while (true) {
            Future<V> f = cache.get(arg);
            if (f == null) {
                Callable<V> eval = new Callable<V>() {
                    public V call() throws InterruptedException {
                        return c.compute(arg);
                    }
                };
                FutureTask<V> ft = new FutureTask<V>(eval);
                f = cache.putIfAbsent(arg, ft);
                if (f == null) {
                    f = ft;
                    ft.run();
                }
            }
            try {
                return f.get();
            } catch (CancellationException e) {
                cache.remove(arg, f);
            } catch (ExecutionException e) {
                throw LaunderThrowable.launderThrowable(e.getCause());
            }
        }
    }
}
```

- 위 클래스는 먼저 원하는 값에 대한 연산 작업이 시작됐는지를 확인해봄
- cache.putIfAbsent(arg, ft)가 병렬성을 보장하기 때문에 넘어오는 같은 원소에 대한 if(f == null) 에 대한 연산은 유니크하다고 생각함
- 실제 결과 값 대신 Future 객체를 캐시하는 방법은 이른바 캐시 공해를 유발할 수 있음 예를 들어 특정 시점에 시도했던 연산이 취소되거나 오류가 발생했었다면 Future 객체 역시 취소되거나 오류가 발생했던 상황을 알려줄 것임 이런 문제를 해소하기 위해 Memoizer 클래스는 연산이 취소된 경우엔 캐시에서 해당하는 Future객체를 제거함
- 만료기능은 FutureTask 클래스를 상속받아 만료된 결과인지 여부를 알 수 있는 새로운 클래스를 만들어 사용하고 결과 캐시를 주기적으로 돌아다니면서 만료된 결과 항목이 있느지 조사해 제거하는 기능을 구하는 것으로 간단하게 해결 가능함
- 아래는 실제 사용 예제

```java
package net.jcip.examples;

import java.math.BigInteger;
import javax.servlet.*;

import net.jcip.annotations.*;

/**
 * Factorizer
 * <p/>
 * Factorizing servlet that caches results using Memoizer
 *
 * @author Brian Goetz and Tim Peierls
 */
@ThreadSafe
public class Factorizer extends GenericServlet implements Servlet {
    private final Computable<BigInteger, BigInteger[]> c =
            new Computable<BigInteger, BigInteger[]>() {
                public BigInteger[] compute(BigInteger arg) {
                    return factor(arg);
                }
            };
    private final Computable<BigInteger, BigInteger[]> cache
            = new Memoizer<BigInteger, BigInteger[]>(c);

    public void service(ServletRequest req,
                        ServletResponse resp) {
        try {
            BigInteger i = extractFromRequest(req);
            encodeIntoResponse(resp, cache.compute(i));
        } catch (InterruptedException e) {
            encodeError(resp, "factorization interrupted");
        }
    }

    void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) {
    }

    void encodeError(ServletResponse resp, String errorString) {
    }

    BigInteger extractFromRequest(ServletRequest req) {
        return new BigInteger("7");
    }

    BigInteger[] factor(BigInteger i) {
        // Doesn't really factor
        return new BigInteger[]{i};
    }
}
```



# #6 작업 실행

## 스레드에서 작업 실행

## Executor 프레임웍

## 병렬로 처리할 만한 작업



# #7 중단 및 종료

## 작업 중단

## 스레드 기반 서비스 중단

## 비정상적인 스레드 종료 상황 처리

## JVM종료



# #8 스레드 풀 활용

## 작업과 실행 정책 간의 보이지 않는 연결 관계

## 스레드 풀 크기 조절

## ThreadPoolExecutor 설정

## ThreadPoolExecutor 상속

## 재귀 함수 병렬화



# #9 GUI 애플리케이션

## GUI는 왜 단일 스레드로 동작하는가?

## 짧게 실행되는 GUI 작업

## 장시간 실행되는 GUI 작업

## 데이터 공유 모델

## 다른 형태의 단일 스레드 서브 시스템



# #10 활동성을 최대로 높이기

## 데드락

## 데드락 방지 및 원인 추적

## 그 밖의 활동성 문제점



# #11 성능, 확장성

## 성능에 대해

## 암달의 법칙

## 스레드와 비용

## 락 경쟁 줄이기



## 예제: Map 객체의 성능 분석



# #12 병렬 프로그램 테스트

## 정확성 테스트

## 성능 테스트

## 성능 측정의 함정 피하기

## 보조적인 테스트 방법



# #13 명시적인 락

## Lock과 ReentrantLock

## 성능에 대한 고려 사항

## 공정성

## synchronized 또는 ReentrantLock 선택

## 읽기-쓰기 락



# #14 동기화 클래스 구현

## 상태 종속성 관리

## 조건 큐 활용

## 명시적인 조건 객체

## 동기화 클래스의 내부 구조

## AbstractQueuedSynchronizer

## java.util.concurrent 패키지의 동기화 클래스에서 AQS 활용 모습

## 

# #15 단일 연산 변수와 넌블로킹 동기화

## 락의 단점

## 병렬 연산을 위한 하드웨어적인 지원

## 단일 연산 변수 클래스

## 넌블로킹 알고리즘



# #16 자바 메모리 모델

## 자바 메모리 모델은 무엇이며, 왜 사용해야 하는가?

## 안전한 공개

## 초기화 안전성



