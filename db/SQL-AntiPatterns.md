









# #1 개요

- 전문가란 아주 좁은 분야에서 할 수 있는 실수를 모두 해본 사람이다. - 닐스 보어



## 대상 독자

## 이 책에 있는 내용

### 이 책의 구성

`논리적 데이터베이스 설계 안티 패턴`

`물리적 데이터베이스 설계 안티 패턴`

`쿼리 안티 패턴`

`애플리케이션 개발 안티 패턴`

### 안티패턴의 구조

## 이 책에 없는 내용

## 일러두기

## 예제 데이터베이스

![1-1](./images/sql-antipatterns/1-1.jpeg)





# #2 무단횡단

- 이름을 밝힐 수 없는 넷스케이프 엔지니어가 한 번은 포인터를 Javascript로 넘겼다가 문자열로 저장한 다음 나중에 다시 C로 돌려받아, 서른 명 사망함...ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ

## 목표: 다중 값 속성 저장

- 테이블의 칼럼이 하나의 값을 가질 땐 설계가 쉽다.



## 안티패턴: 쉼표로 구분된 목록에 저장

- DB 구조 변경을 최소화하기위해 ...

```sql
CREATE TABLE Products (
	product_id SERIAL PRIMARY KEY,
  product_name VARCHAR(1000),
  account_id VARCHAR(100), -- 쉼표로 구분된 목록
);
```



**특정 계정에 대한 제품 조회**

- MsSQL에서는 아래와 같이 ''사용자12' 를 찾을 수 있지만 휴먼에러, 인덱스를 사용 못하고, SQL 벤더에도 중립적이지 못하다.

```sql
SELECT * FROM Products WHERE account_id REGEXP '[[:<:]]12[[:>:]]';
```



**주어진 제품에 대한 계정 정보 조회**

```sql
SELECT * FROM Products AS p JOIN Accounts AS a
	ON p.account_id REGEXP '[[:<:]]' || a.account_id || '[[:<:]]'
WHERE p.proudct_id = 123;
```

- 이런식의 표현은 인덱스도 사용 못하고 두 테이블을 모두 읽어 카테시안 곱을 생성한 다음 모든 행의 조합에 대해 정규 표현식을 평가해야 한다.



**집계 쿼리 만들기**

- 이상한 기교

```sql
SELECT product_id, LENGTH(account_id) - LENGTH(REPLACE(account_id, ',', '')) + 1
	AS contracts_per_product
FROM Products;
```



**특정 제품에 대한 계정 갱신**

- 목록의 마지막에 문자열 연결을 통해 새로운 아이디를 추가할 수 있지만 목록이 정렬된 상태로 유지되지는 못한다.
- 삭제 역시 이상하게 한다.



**제품 아이디 유효성 검증**

- 검증도 안되고 db는 쓰레기 더미가 된다.

**구분자 문자 선택**

- 구분자 선택도 애매하다.

**목록 길이 제한**

- n개의 계정에 대한 칼럼의 크기는 예측이 불가능하다.



## 안티패턴 인식 방법

- 프로젝트에서 아래와 같은 말이 나온다면 무단횡단 안티패턴이 사용되고 있는 것이다.
  - 이 목록이 지원해야 하는 최대 항목 수는 얼마나 될까?
  - SQL에서 단어의 경계를 어떻게 알아내는지 알아?
  - 이 목록에서 절대 나오지 않을 문자가 어떤 게 있을까?



## 안티패턴 사용이 합당한 경우

- 어떤 종류의 쿼리는 데이터베이스 반정규화를 적용해 성능을 향상시킬 수 있다. 
- 반정규화를 사용하기로 결정할 때는 보수적이어야 한다. 데이터베이스를 정규화하는 것이 먼저다.
- 정규화는 애플리케이션 코드를 좀더 융툥성 있게 하고 데이터베이스의 정합성을 유지할 수 있게 해준다.



## 해법: 교차 테이블 생성

- 별도의 테이블에 저장해 account_id가 별도의 행을 차지하도록 하는 것이 좋다.

















