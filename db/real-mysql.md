# #1 소개



# #2 설치와 설정





# #3 MySQL 아키텍처



## MySQL 아키텍처



![](https://t1.daumcdn.net/cfile/tistory/26219B435902D88522)

### mysql 전체구조

- mysql은 일반 상용 rdbms에서 제공하는 대부분의 접근법을 모두 지원함

- mysql 서버는 크게 mysql 엔진, 스토리지 엔진으로 구분해볼 수 있음

**mysql 엔진**

- mysql 엔진은 클라이언트로부터의 접속 및 쿼리요청을 처리하는 커넥션 핸들러와 sql 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심

**스토리지 엔진**

-  실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 스토리지 엔진이 전담, mysql 엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용 가능

**핸들러 api**

- mysql 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에게 쓰기 또는 읽기 요청을 하는데 이러한 요청을 핸들러 요청이라고하고 여기에 사용되는 api를 핸들러 api라함

### mysql 스레딩 구조

- mysql 서버는 프로세스기반이 아니라 스레드 기반으로 작동함 크게 포그라운드와 백그라운드 스레드로 구분

**포그라운드 스레드(클라이언트 스레드)**

- mysql 서버에 접속된 클라이어트의 수 만큼 존재
- 요청하는 쿼리 문장을 처리하는 것이 임무
- 요청 종료시 다시 스레드 캐시 (thread pool)로 돌아감
- 스레드의 개수를 일정하게 유지해주는 파라미터 thread_cache_size

**백그라운드 스레드**

- innoDB는 여러가지 작업이 백그라운드로 처리 여러가지 작업을 함
- 쓰기 스레드는 innodb_write_io_threads, 읽기 스레드는 innodb_read_io_treads로 지정 가능
- 읽기스레드는 클라이언트 스레드에서 처리되는데 쓰기의 경우 일반 내장 디스크에서는 2~4, ans,san과같은 스토리지를 사용할 경우 4개 이상으로 충분히 설정하는게 좋음

<br>

- 상용 dbms에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 있고 innodb도 그러함 but myisam은 그렇지 않고 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계되어 있음
- innodb에서는 cud 쿼리로 데이터가 변경되는 경우 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 됨 . 하지만 myisam에서 일반적인 쿼리는 쓰기 버퍼링을 사용할 수 없음



### 메모리 할당 및 사용 구조

- mysql에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분 가능
- 글로벌 메모리 영역의 모든 메모리 공간은 mysql 서버가 시작되면서 무조건 운영체제로부터 할당됨 
- 글로벌 메모리 영역과 로컬 메모리 영역의 차이는 mysql 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 아닌지에 따라 구분됨

**글로벌 메모리 영역**

- 일반적으로 클라이언트 스레드의 수와 무관하게 일반적으로는 하나의 메모리 공강만 할당, 필요에 따라 2개 이상의 메모리 공간을 할당받을 수 있지만 클라이언트 스레드의 수와 무관하고 생성된 글로벌영역은 모든 스레드의 의해 공유됨

**로컬 메모리 영역**

- 세션 메모리 영역이라도 불림
- mysql 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용되는 메모리 영역
- 로컬 메모리는 각 클라이언트 스레드 별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징

### 플러그인 스토리지 엔진 모델

- mysql 독특한 구조중 하나가 바로 플러그인 모델, 직접 제작도 가능함
- sql 파서 -> sql 옵티마이저 -> sql 실행기 -> 데이터 읽기/ 쓰기 -> DB
- 위 과정에서 마지막 데이터 읽기/쓰기 과정만 스토리지 엔진에 의해 처리됨 나머지는 mysql  엔진에서 처리
- 데이터 읽기/쓰기 작업은 대부분 1건의 레크도 단위로 처리됨
- mysql 서버에서는 mysql 엔진이 사람역하을 하고 각 스토리지 엔진은 자동차 역할을 하게 됨. mysql 엔진이 스토리지 엔진을 조정하기 위해 핸들러 라는것을 사용함
- mysql 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 핸들러를 사용한다는 점만 기억하면 됨
- 실질적인 group by oder by 등 많은 복잡한 처리는 스토리지 엔진 영역이 아니라 mysql 엔진의 처리 영역인 쿼리 실행기에서 실행됨

![](https://www.dbrnd.com/wp-content/uploads/2016/01/MySQLShowEngines.png)

- 이거말고 조금 더 있음
- 플러그인형식으로 스토리지 엔진을 쉽게 설치 가능함



### 쿼리 실행 구조



**파서**

- 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미
- 쿼리 문장의 기본 문접 오류는 이 과정에서 발견되고 사용자에게 오류 메시지를 전달하게 됨

**전처리기**

- 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인함
- 실제 존재하지 않거나 권한상 사용 불가한 토큰의 경우 이 단계에서 걸러짐

**옵티마이저**

- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 담당
- 매우 중요함

**실행 엔진**

- 옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발에 비유할 수 있음

- 옵티마이저가 group by를 처리하기위해 임시테이블을 사용하기로 결정했다면 다음과 같은 과정

  1. 실행 엔진은 핸들러에게 임시 테이블을 만들라고 요청

  2. 다시 실행 엔진은 where 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청

  3. 읽어온 레코드들을 1번에서 준비한 임시테이블로 저장하라고 다시 핸들러에게 요청

  4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어오라고 핸들러에게 다시 요청

  5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

     즉 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행

**핸들러 (스토리지 엔진)**

- mysql 서버 가장 밑단에서 mysql 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당
- 핸드럴 == 스토리지 엔진
- myisam 테이블을 조장하면 핸들러가 myisam 스토리지엔진 <- 이런식임



### Replication

- 복제는 2대 이상의 mysql 서버가 동일한 데이터를 담도록 실시간으로 동기화 하는 기술
- 쓰기는 마스터 읽기는 슬레이브
- mysql 서버의 복제에서는 마스터는 반드시 1개 슬레이브는 1개 이상으로 구성될 수 있음



**마스터**

- 기술적으로는 mysql의 바이너리 로그가 활성화되면 어떤 mysql 서버든 마스터가 될 수 있음
- 데이터가 생성 및 변경, 삭제되는 주체
- dml,ddl을 바이너리 로그에 기록
- 슬레이브는 변경 내역을 요청하면 바이너리 로그에서 읽어서 슬레이브로 넘김
- 마스터의 프로세스중 "Binlog dump"라는 스레드가 이 일을 전담함 슬레이브 수대로 스레드가 존재



**슬레이브**

- 데이터를 받아올 마스터 장비의 정보를 갖고 있는 경우 슬레이브가 됨
- 슬레이브 서버는 릴레이 로그를 갖고 있음
- 슬레이브는 읽기 전용
- 슬레이브 서버의 i/o 스레드는 마스터 서버에 접속해 변경 내역을 요청하고 받아 온 변경 내역을 릴레이 로그에 기록함
- 슬레이브 서버의 sql 스레드가 릴레이 로그에 기록된 변경 내역을 재실행 함으로 마스터와 동일한 상태로 유지함
- i/o 스레드는 슬레이브에만 있음



**복제시 주의사항**

- 슬레이브는 하나의 마스터만 설정 가능
- 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정
- 슬레이브 서버용 장비는 마스터와 동일한 사양이 적합
- 복제가 불필요한 경우에는 바이너리 로그 중지
- 바이너리 로그와 트랜잭션 격리 수준

> - 5.1에서는 Statement based replcation, Row based replication이 지원됨
> - sql 기반의 복제는 아무리 많은 데이터의 변경을 유발하더라도 sql 문장 하나만 슬레이브로 전달되기때문에 네트워크 트래픽을 많이 유발하지 않음 <- but repeatable-read 이상의 트랜잭션 격리 수준을 사용해야 하고 innodb 테이블에서는 레코드 간의 간격을 잠그는 갭 락이나 넥스트 키락이필요해짐
> - 레코드 기반으로 하면 트래픽이 많아지지만 read-commited 격리수준에도 동작하며 innodb테이블에서 잠금 경합이 줄어듬

### 쿼리 캐시

- mysql에만 있음
- sql 문장을 캐시하는게 아니라 쿼리 결과를 메모리에 캐시해두는 기능
- map과 같은 데이터 구조로 구현되어 있음 키는 sql 쿼리 문장, 값은 실행 결과
- 쿼리 캐시 결과 확인 절차를 가짐
  - 요청된 쿼리 문장이 쿼리 캐시에 존재하는가?
  - 해당 사용자가 그 결과를 볼 수 있는 권한을 갖고 있는가?
  - 트랜잭션 내에서 실행된 쿼리인 경우 가시 범위 내에 있는 결과인가?
  - 호출 시점에 달라 결과가 달라지는 요소가 있는가?
  - 프리페어 스테이트먼트의 경우 변수가 결과에 영향을 미치지 않는가?
  - 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가?
  - 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가?
  - 그 밖에 쿼리 캐시를 사용하지 못하게 만드는 요소가 있는가?
- `show global status` 명령을 이용해 쿼리 캐시의 사용량과 정보를 확인 가능
- Com_select (엔진이 처리)+ Qcache_hits (캐시 hit) = mysql 서버로 요청된 모든 select 문장
- 쿼리 캐시 히트율% = Qcache_hits  / (Qcache_hits + Com_select) * 100
- 쿼리 캐시율이 20% 이상이면 좋다고 이야기하는데 그냥 시기적절하게 잘 사용하는게 중요함
- 쿼리 캐시를 사용하지 않는 설정

```
query_cache_size = 0
query_cache_type = 0
```





## InnoDB 스토리지 엔진 아키텍처

- mysql에서 사용할 수 있는 스토리지 중 거의 유일하게 레코드 기반의 잠금을 제공
- 높은 동시성처리와 안정적, 성능 또한 뛰어남

![public](https://user-images.githubusercontent.com/30790184/98905454-c75d3680-24fe-11eb-8bc6-373681f016ae.jpeg)



### InnoDB 스토리지 엔진의 특성

**프라이머리 키에 의한 클러스터링**

- InnoDB의 모든 테이블은 기본적으로 키를 기준으로 클러스터링 되어 저장됨 이로 인해 pk에 의한 레인지 스캔은 상당히 빠르게 처리됨
- 결과적으로 쿼리의 실행 계획에서 pk는 다른 보조인덱스에 비해 비중이 높음 
- 오라클의 IOT(Index organized table)과 동일한 구조가 InnoDB에서는 일반적인 테이블 구조

**잠금이 필요없는 일관된 읽기 (None-locking consistent read)**

- InnoDB 스토리지엔진은 MVCC(Multi Version Concurrency Control) 이라는 기술을 이용해 락을 걸지 않고 읽기 작업을 수행함
- 락을 걸지 않기 때문에 읽기 작업은 다른 트랜잭션이 가지고 있는 락을 기다리지도 않음 SERIALIZABLE은 제외

**외래 키 지원**

- 외래키는 myisam에서 사용불가 innodb만 가능
- innodb에서 외래키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고 변경 시에 반드시 부모 테이블이나 자식 테이블에 데이터가 있는 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고 그로 인해 데드락이 발생할 때가 많음

**자동 데드락 감지**

- InnoDB는 그래프 기반의 데드락 체크 방식을 사용함. 데드락이 발생함과 동시에 바로 감지되고 감지된 데드락은 관련 트랜잭션 중에서 rollback이 가장 용이한 트랜잭션(복구 작업이 가장 적은 트랜잭션)을 자동적으로 강제 종료해버림
- 데드락 때문에 쿼리가 제한시간에 도달한다거나 슬로우 쿼리로 기록되는 경우가 많지 않음

**자동화된 장애 복구**

- 손실이나 장애로부터 데이터를 보호하기 위한 여러가지 메커니즘이 탑재되어 있음

**오라클 아키텍처 사용**

- innodb는 오라클과 상당히 비슷한 부분이 많음 ex mvcc 기능 등등



### InnoDB 버퍼 풀

- InnoDB에서 가장 핵심적인 부분
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
- 쓰기 작업을 지연시켜 일괄 작업을 처리할 수 있는 버퍼공간
- myisam은 키 캐시가 인덱스의 캐시만을 주로 처리하는데 비해 innodb의 버퍼 풀은 데이터와 인덱스 모두 캐시하고 쓰기 버퍼링의 역할까지 모두 처리함
- innodb의 버퍼 풀은 많은 백그라운드 작업의 기반이 되는 메모리 공간임 따라서 버퍼 풀 크기를 신중하게 설정하는 것이 좋음 (innodb_buffer_pool_size)
- 적절하게 설정해야하고 일반적으로 전체 장착된 물리 메모리의 50~80% 수준에서 버퍼 풀의 메모리 크기를 결정함
- innodb 버퍼 풀은 아직 디스크에 기록되지 않은 변경된 데이터를 갖고 있음 (더티 페이지라 함 )



### undo 로그

- update 문장이나 delete 문장으로 데이터를 변경했을때 변경되기 전의 데이터를 보관하는 곳
- 사용자가 커밋하면 적용된 그대로 유지되고 롤백하면 언두 영역의 백업 데이터를 다시 데이터 파일로 복구함
- 언두 용도
  - 트랜잭션 롤백 대비용
  - 트랜잭션 격리 수준을 유지하면서 높은 동시성을 제공하는데 사용됨



### 인서트 버퍼

- rdbms에서 insert나 update에 데이터 파일을 변경하는 작업 뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요함
- 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 인덱스가 많다면 자원소모가 많음
- innodb는 변경해야할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행함 그렇지 않으면 임시 공간에 저장해두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시킴 이 때 사용하는 임시 메모리 공간을 인서트 버퍼라고함
- 유니크 인덱스는 인서트 버퍼를 사용할 수 없음
- 5.5이전까지는 insert에만 가능했으나 5.5 이후부터는 insert delete인해 키를 추가하거나 삭제하는 작업에도 버퍼링이 될 수 있게 개선
- 5.5 이후부터는 innodb_change_buffering이라는 파라미터로 종류별로 인서트 버퍼를 활성화 가능



### redo 로그 및 로그 버퍼

- 쿼리 문장으로 데이터를 변경하고 커밋하면 dbms는 데이터의 acid 보장을 위해 변경된 내용을 데이터 파일로 기록해야함 <- 상당한부하 작업
- 따라서 대부분 dbms에는 버퍼링을 위한 버퍼풀과 같은 장치가 있지만 이 장치만으로 acid를 보장할수는 없음
- 따라서 이를 위해 변경된 내용을 순차적으로 디스크에 기록하는 로그 파일을 갖고 있는데 이게 리두 로그임
- 리두로그 덕분에 dbms 데이터는 버퍼링을 통해 한꺼번에 디스크에 변경된 내용을 처리할 수 있고 성능 향상을 기대할 수 있게 됨
- 변경작업이 매우 많은 dbms 서버의 경우 이 리두 로그의 기록 작업이 큰 문제가됨 <- 이런 부분을 보완하기 위해 최대한 acid 속성을 보장하는 수준에서 버퍼링함
- 리두 로그 버퍼링에 사용되는 공간이 로그 버퍼임
- 로그 버퍼의 크기는 1~8m수준이 좋고 blob이나 text같은 큰 데이터의 변경이 많으면 더 크게



### MVCC(Multi Version Concurrency Control)

- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 dbms가 제공하는 기능
- 잠금을 사용하지 않는 일관된 읽기를 제공함
- innodb는 언두 로그를 이용해 이기능을 구현함
- 멀티 버전은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미



### 잠금 없는 일관된 읽기(Non-locking consistent read)

- innodb에서 격리수준이 serializable이 아닌 read-uncommited나 read-commited 그리고 repeatable-read 수준인 경우 inserrt와 연결하지 않은 순수한 읽기 작업은 다른 트랜잭션의 변경과 관계 없이 항상 잠금을 대기하지 않고 바로 실행됨 <- 잠금 없는 일관된 읽기
- innodb의 언두로그를 사용함
- 오랜 시간동안 활동하는 트랜잭션이 있을 경우 일관된 읽기를 위해 언두 로그를 삭제하지 못해 성능저하가 있을 수 있음 트랜잭션은 최대한 빨리 끝낼것



### innodb와 myisam 스토리지 엔진 비교

- 5.5부터는 innodb가 기본 엔진
- innodb가 짱좋음



### innodb와 memory 스토리지 엔진 비교

- memory는 모두 메모리에 저장하기때문에 작업이 매우 빠름 but 테이블락



## MyISAM 스토리지 엔진

- 생..략

## MEMORY 스토리지 엔진 아키텍처

- 생략

## NDB 클러스터 스토리지 엔진

- 생략



## TokuDB

- 빠르게 증가하는 대용량 데이터를 관리하는 것이 주 특기
- 이외 생략 



## 전문 검색 엔진

- 생략



## MySQL 로그 파일

### 에러로그파일

- mysql config 파일에 log_error 라는 파라미터로 정의된 경로의 파일이거나  없는 경우 datadir에 .err 확장자가 붙은 파일
- 시작시점, 비정상종료일때 트랜잭션 복구 메시지, 쿼리 도중 에러 메시지 등등이 자주 발생함

### 제너럴 쿼리 로그 파일

- 쿼리 전체 목록 로그 파일
- general-log 라는 이름의 파라미터에 정의된 경로에 있는 파일 5.1.12이상에서는 general_log_file

### 슬로우 쿼리 로그 

- mysql 서버의 쿼리 튜닝은 서비스가 적용되기 전에 전체적으로 튜닝하는 경우와 서비스 운영 중에 mysql 서버의 전체적인 성능 저하를 검사하거나 정기점검을 위한 튜닝으로 나눌 수 있음
- 어떤 쿼리가 문제인지 판단하기가 상당히 어려움
- 슬로우 쿼리 로그 파일에는 long_query_time 파라미터 이상 소요된 쿼리가 모두 기록됨
- 반드시 완료되어야 슬로우쿼리로그에 기록됨

### 바이너리 로그와 릴레이 로그

- 바이너리로그 파일은 마스터에 릴레이로그는 슬레이브에 생성
- 바이너리로그에는 select 같이 데이터 구조나 내용을 변경하지 않는 쿼리는 기록되지 않음
- 바이너리로그는 이진 파일로 되어있어서 직접 확인 불가능 mysqlbinlog를 사용할 것





# #4 트랜잭션과 잠금



## 트랜잭션

### MySQL에서의 트랜잭션

- innodb는 쿼리중 일부라도 오류가 발생하면 전체를 원상태로 만들어둠
- myisam에는 부분업데이트가 일어남 부분업데이트는 데이터 정합성에 큰 문제임

### 주의사항

- 트랜잭션은 필요한 최소의 코드에만 적용하는 것이 좋음
- 원격작업이 묶인 트랜잭션은 치명적일 수 있음



## MySQL 엔진의 잠금

- 스토리지 엔진 레벨과 mysql 엔진 레벨로 나뉨
- mysql 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않음\
- mysql 엔진에서는 테이블락 말고 유저락, 테이블 명에 대한 잠금을 위한 네임락도 제공함



### 글로벌 락

- 글로벌락은 FLUSH TABLES WITH READ LOCK 명령으로만 획득 가능하고 mysql에서 제공하는 잠금 가운데 가장 범위가 큼
- 세션단위로 동작함 mysql 서버 전체의 테이블에 락을 검
- select를 제외한 모든 문장이 글로벌락이 해제될 때까지 대기상태로 남음
- 잘못사용하면 큰일남
- mysqldump라는 백업프로그램에서 사용할 수도 있음 잘 체크해볼것

### 테이블 락

- 개별 테이블 단위로 설정되는 잠금, 명시적 또는 묵시적으로 테이블의 락 획득 가능
- 테이블락은 myisam, innodb 모두 사용 가능
- LOCK TABLE table_name [READ | WRITE] 으로 명시적으로 획득 가능
- UNLOCK TABLES로 잠금 반납가능
- 특별한 상황이 아니면 사용할일이 없음 잘못사용하면 큰일남
- 묵시적인 테이블락은 myisam이나 memory 테이블에 데이터를 변경하는 쿼리를 실행하면 발생함 
- 묵시적 테이블 락은 쿼리가 실해오디는 동안 자동적으로 획득됐다가 쿼리가 완료된 후 자동 해제됨
- innodb는 레코드기반 락이기때문에 묵시적 테이블락이 설정되지 않음
- 정확히는 ddl의 경우에만 테이블락이 설정됨



### 유저 락

- GET_LOCK() 함수를 이용해 임의로 잠금 설정 가능
- 유저락은 테이블, 레코드 같은 대상이 아니라 사용자가 지정한 문자열에 대해 획득 및 반납하는 잠금임
- 자주 사용되지 않음
- 많은 레코드를 한번에 변경하는 트랜잭션의 경우 유용하게 사용 가능



### 네임 락

- 데이터베이스 객체의 이름을 변경하는 경우 획득하는 잠금
- READ TABLE tab_a TO tab_b 와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금, 원본과 대상 둘다 잠금



## MyISAM과 MEMORY 스토리지 엔진의 잠금

- 이 두 엔진은 자체적인 잠금을 가지지 않고 mysql에서 제공하는 테이블락을 그대로 사용함
- 쿼리단위로 필요한 잠금을 한꺼번에 모두 요청해서 획득하기 때문에 데드락이 발생할 수 없음
- momory, archive, merge 등과 같은 스토리지 엔진에도 아래 내용이 똑같이 작동함



### 잠금 획득

**읽기잠금**

- 테이블에 쓰기 잠금이 걸려있지 않으면 바로 읽기 잠금을 획득하고 읽기 작업 시작 가능

**쓰기 잠금**

- 테이블에 아무런 잠금이 걸려있지 않아야만 쓰기 잠금 가능
- 다른 잠금이 해제될 때까지 대기



### 잠금 튜닝

- SHOW STATUS LIKE 'Table%'

```
Table_locks_immediate	12428
Table_locks_waited	0
Table_open_cache_hits	1
Table_open_cache_misses	0
Table_open_cache_overflows	0
```

- Table_locks_immediate: 다른 잠금이 풀리기를 기다리지 않고 바로 잠금을 획득한 횟수
- Table_locks_waited: 다른 잠금이 이미 해당 테이블을 사용하고 있어서 기다려야 했던 횟수를 누적해서 저장함
- 잠금 대기 쿼리 비율 = Table_locks_waited / (Table_locks_waited + Table_locks_immediate) * 100
- 잠금 대기 쿼리 비율이 높다면 innodb로 변환 방법을 고려하는게 좋음
- innodb는 레코드 락

### 테이블 수준의 잠금 확인 및 해제

- SHOW OPEN TABLES [FROM table_name];
- in_use값은 해당 테이블을 잠그고 있는 클라이언트 수 + 대기하는 클라이언트 수
- name_locked는 alter table 또는 rename
- SHOW PROCESSLIST 명령으로 실시간 잠금 현황 확인 가능
- KILL QUERY 클라이언트_id 로 클라이언트 커넥션 종료 가능



## InnoDB 스토리지 엔진의 잠금

- mysql 엔진에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 락 기능을 탑재
- myisam보다 훨씬 뛰어난 동시성 처리 제공 가능
- 이원화된 잠금 처리탓에 innodb 스토리지 엔진에서 사용되는 잠금에 대한 정보는 mysql 명령을 이용해 접근하기가 상당히 까다로움
- 5.1 이후부터 innodb의 트랜잭션,잠금, 잠김 대기중인 트랜잭션 목록 조회하는 방법이 도입됨

### InnoDB의 잠금 방식

**비관적 잠금**

- 현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식을 비관적 잠금이라함
- 일반적으로 높은 동시성 처리에는 비관적 잠금이 유리하다고 알려져 있음 innodb는 비관적 잠금



**낙관적 잠금**

- 기본적으로 각 트랜잭션이 같은 레코드를 변경할 가능성이 상당히 희박할때 낙관적 잠금이라함
- 따라서 우선 변경 이후 마지막에 잠금 충돌이 있는지 확인 후 rollback함

### innodb 의 잠금 종류

- 잠금 정보가 상당히 작기때문에 레코드락이 페이지락 또는 테이블락으로 레벨업되는 경우가 없음
- 레코드와 레코드 사이의 간격을 잠그는 것을 갭락이라고 함

**레코드 락**

- 레코드 자체만 잠그는 것을 레코드락
- innodb 스토리지 엔진은 레코드 자체가 아니라 인덱스 레코드를 잠근다는 것
- 없더라도 클러스터 인덱스를 이용해 잠금



**갭 락**

- 갭락은 레코드와 바로 인접한 레코드 사이의 간격만 잠그는 것을 의미
- 갭락은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어함
- 개념일뿐이고 자체적으로 사용되지 않음 넥스트 키 락의 일부로 사용

**넥스트 키 락**

- 레코드 락과 갭 락을 합쳐놓은 형태의 잠금을 넥스트 키 락이라고함
- statement 포맷의 바이너리 로그를 사용하는 mysql 서버에는 repeatable read 격리수준을 사용해야함
- innodb의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어 난 결과와 동일한 결과를 만들어내보도록 보장하는 것이 주 목적임
- 으외로 넥스트 키락과 갭락으로 인한 데드락이 발생하거나 트랜잭션 대기가 자주 있으
- 가능하다면 바이너리 로그 포맷을 row형태로 바꿔서 넥스트 키락이나 갭락을 줄이는 것이 좋음 <- 아직 안정성을 확인하기 어려움



**자동 증가 락**

- auto_increment락이라고 하는 테이블 수준의 잠금을 사용함
- 이 락은 트랜잭션과 관계없이 값을 가져오는 순간만 락이 걸렸다가 즉시 해제됨
- 명시적으로 락 획득 불가
- 아주 짧게 적용되기때문에 문제될일 없음
- 5.1이후에 innodb_autoinc_lock_mode로 작동 방식을 제어 가능 함



### 인덱스와 잠금

- innodb의 잠금과 인덱스는 상당히 중요한 연관관계가 있음
- innodb는 레코드를 잠그는 것이 아니라 인덱스를 잠금
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 함
- 인덱스가 걸린 레코드는 모두 잠금
- 만약 인덱스가 없다면 모든 레코드를 잠금
- 따라서 innodb에서 인덱스 설계가 매우 중요함



### 트랜잭션 격리 수준과 잠금

- 불필요한 레코드의 잠금 현상은 innodb의 넥스트 키 락 때문에 발생함
- 이 넥스트 키 락을 필요하게 만드는 주 원인은 바로 복제를 위한 바이너리 로그 때문임
- row based 로그를 사용하거나 바이너리 로그를 사용하지 않으면 갭락이나 넥스트 키 락의 사용을 대폭 줄이므로 더 많은 요청을 처리할 수 있게 됨
- 다음 조합으로 mysql 서버가 기동하는 경우에 innodb에서 사용되는 대부분의 갭락이나 넥스트키락을 제거 가능

| 버전           | 설정의 조합                                                  |
| -------------- | ------------------------------------------------------------ |
| mysql 5.0      | innodb_locks_unsafe_for_binlog=1<br /> 트랜잭션 격리 수준을 read commited로 설정 |
| mysql 5.1 이상 | 바이너리 로그를 비활성화 트랜잭션 격리수준을 read-commited로 설정<br />레코드 기반의 바이너리 로그 사용<br />innodb_locks_unsafe_for_binlog=1<br />트랜잭션 격리 수준을 read-commited로 설정 |

- 이 조합이라도 유니크키나 외래키에 대한 갭 락은 없어지지 않음



### 레코드 수준의 잠금 확인 및 해제

- 테이블락보다 레코드락이 더 복잡함
- 5.0에서는 더힘들고 5.1부터는 확인이 좀 더 수월함
- 5.0에서는 공통적으로 특정 테이블의 레코드를 변경하거나 삭제하려고 하는 쿼리가 표시되는 것이 일반적, 구 중에서 활성화상태면서 아무런 sql도 실행하지 않는 트랜잭션이 있다면 이것이 문제일 가능성이 높음
- 근본적으로 찾기 어렵다면 오래기다리고 있는 트랜잭션의 커넥션을 모두 종료하는게 빠른 해결책
- 5.1 이상에서는 INFORMATION_SCHEMA라는 DB에 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAIT라는 테이블을 사용할 것
- INNODB_LOCKS는 어떤 잠금이 존재하는지 관리, INNODB_TRX는 어떤 트랜잭션이 어떤 클라이언트에 의해 기동되며 어떤 잠금을 기다리고 있는지, INNODB_LOCK_WAITS 테이블은 잠금에 의한 프로세스 간의 의존 관계를 관리하게됨



## mysql의 격리 수준

- read uncommited, read commited, repeatable read, rerializable 4가지로 나뉨
- read uncommited, serializable 은 잘 사용되지 않음
- innodb에서 repeatable read 격리수준에서는 phantom read가 발생하지 않음
- 오라클은 read commited, mysql에는 repeatable read를 주로 사용함

### READ UNCOMMITED

- DIRTY READ, 정말 위험할 수 있음 사용하지 말 것

### READ COMMITED

-  오라클의 기본 격리 수준, 온라인 서비스에서 가장 많이 선택되는 격리 수준
-  어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있음
-  NOT REPEATABLE READ가 발생함

### REPEATABLE READ

- mysql innodb 엔진에서 기본적으로 사용, 바이너리 로그를 가진 mysql 장비에서는 최소 repeatable read 수준 이상을 사용해야함
- mvcc를 사용함 rollback 가능성을 대비해 레코드를 언두 공간에 백업해두고 실제 레코드 변경
- 어떤 트랜잭션 A와 B가 있다고 가정했을때 A 또는 B 에서 시작된 트랜잭션은 항상 같은값만 반환함
- PHANTOM READ가 발생함

### SERIALIZABLE

- 이 레벨의 경우 읽기 작업도 공유잠금을 획득해야하는 매우 엄격한 격리 수준
- mysql innodb에서는 repeatable read에서 phantom read가 발생하지 않으므로 쓸일이 없음



- 사실 READ COMMITED와 REPEATABLE READ의 성능차이는 크지 않음



# #5 인덱스

## 디스크 읽기 방식

- 데이터베이스의 성능 튜닝은 어떻게 디스크 io를 줄이느냐가 관건인것이 많음

### 저장 매체

- 일반적인 서버에 사용되는 저장 매체
  - 내장디스크
  - DAS (Direct Attached Storage)
  - NAS (Network Attached Storage)
  - SAN (Storage Area Network)
- 내장디스크는 일반적인 pc의 디스크, 용량 문제가 있음
- DAS도 내장디스크와 비슷함 대용량 디스크가 필요할때 사용가능, 본체 한대와만 연결이 가능해서 디스크 정보를 다른 컴퓨터와 공유 불가능
- DAS의 단점을 NAS와 SAN으로 해결 가능
- NAS는 TCP/IP로 연결해서 공유 가능함, DAS보다 느림
- SAN은 DAS로는 구축할 수 없는 아주 대용량의 스토리지 공간을 제공함. 컴퓨터 본체들과 광케이블로 연결되고 빠르고 안정적, 비쌈

### 디스크 드라이브와 솔리드 스테이트 드라이브

- ssd의 장점은 랜덤 io가 훨씬 빠르다는 것

### 랜덤 io와 순차 io

- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하느냐에 의해 결정됨
- 순차 io가 랜덤 io보다 빠름
- 데이터베이스의 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 mysql 서버에서는 그룹 커밋이나 버이너리 로그 버퍼 또는 inndb 로그 버퍼 기능이 내장된 것

> - 인덱스 레인지 스캔은 랜덤 io
> - 풀 테이블 스캔은 순차 io



## 인덱스란?

- 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어둠
- 키를 기반으로 정렬시켜놓아서 빠르게 찾을 수 있게 해둠
- 인덱스는 항상 정렬된 상태로 유지함
- 인덱스가 많은 테이블은 insert, update delete 문장의 처리가 늦어짐 하지만 select는 매우 빠름
- 인덱스를 구분해본다면 primary key와 secondary key가 있음
- 프라이머리키는 대표적으로 그 테이블을 대표하는 컬럼의 값으로 만들어진 인덱스고 프라이머리 키를 제외한 모든 인덱스는 보조인덱스임
- 데이터 저장방식은 대표적으로 b-tree hash 인덱스로 구분할 수 있음
- hash 방식은 값의 일부만 검색할 수 없음, 메모리기 반 db에서 많이 사용함
- Fractal-tree 알고리즘도 있는데 b-tree랑 비슷하지만 데이터 저장 삭제시 처리 비용을 상당히줄일 수 있게 설계된 것이 특징임
- 데이터 중복 허용 여부로 분류하면 유니크 인덱스와 유니크하지 인덱스로 구분 할 수 있음
- dbms의 옵티마이저에게 중복 여부는 상당히 중요함 유니크인덱스에 대해 equal 으로 검색하면 1건의 레코드만 찾으면 더이상 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효고임
- 기능별로 분류하면 전문 검색이나 공간 검색용 인덱스 등이 있음



## B-Tree 인덱스

- Balanced Tree
- b-tree는 최상위에 하나의 루트노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태
- 루트, 브랜치, 리프노드 순서로 되어있음
- b-tree에서 바라보는 파일시스템들은 정렬된 상태가아님 but 클러스터 인덱스는 pk 순서대로 정렬된 상태
- 인덱스는 테이블의 키 칼럼만 갖고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야함



### B-tree 인덱스 키 추가 및 삭제

**인덱스 키 추가**

- b-tree에 저장될 때는 저장될 키 값을 이용해 b-tree 상의 적절한 위치를 검색해야함
- 리프노드가 꽉 찼을때는 상위 브랜치노드까지 영향을 주는데 이러한 작업이 b-tree에서 쓰는 비용이 많다고 알려짐
- 비용들 대부분은 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야하기때문에 오래걸리는것
- myisam이나 memory 스토리지엔진은 insert 즉시 b-tree 인덱스에 반영하고 작업완료까지 클라이언트는 기다림
- innodb는 상황에따라 적절하게 인덱스 키 추가 작업을 지연시켜 나중에 처리할지 아니면 바로 처리할지 결정함
  1. 사용자의 쿼리 실행
  2. innodb의 버퍼 풀에 새로운 키 값을 추가해야 할 페이지가 존재(b-tree의 리프노드)한다면 즉시 키 추가 작업 처리
  3. 버퍼 풀에 b-tree 리프 노드가 없다면 인서트 버퍼에 추가할 키 값과 레코드의 주소를 임시로 기록해두고 작업 완료
  4. 백그라운드 작업으로 인덱스 페이지를 읽을 때마다 인서트 버퍼에 머지해야 할 인덱스 키 값이 있는지 확인한 후 있다면 병합
  5. db 서버 자원의 여유가 생기면 mysql 서버의 인서트 버퍼 머지 스레드가 조금씩 인서트 버퍼에 임시 저장된 인덱스 키오 ㅏ주소 값을 머지
- 5.1 이하에서는 insert만 지연처리 5.5 이사엥서는 insert delete 둘다 됨
- 5.1 이하에서는 인서트 버퍼링, 5.5이상에서는 체인지 버퍼링



**인덱스 키 삭제**

- b-tree는 키 삭제가 상당히 간단함 리프노드를 찾아서 삭제만 마크하면 작업 완료

**인덱스 키 변경**

- b-tree에서는 키 값 변경 작업은 먼저 키값을 삭제한 후 다시 새로운 키값을 추가하는 형태



**인덱스 키 검색**

- b-tree인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용 가능, 부등호 비교나 값의 뒷부분이 일치하는 경우에는 b-tree인덱스를 이용한 검색이 불가능함
- 이미 변형된 값 (함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업)은 b-tree의 장점을 이용할 수 없음
- innodb테이블에서 지원하는 레코드 잠금이나 넥스트 키 락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 되어있음 따라서 update나 delete 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠금



### b-tree 인덱스 사용에 영향을 미치는 요소

**인덱스 키값의 크기**

- innodb에서 디스크의 모든 읽기 쓰기 작업의 최소단위는 페이지 또는 블록이라고 함 또한 페이지는 innodb 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위임
- 인덱스도 결국 페이지 단위로 관리됨
- 인덱스의 페이지 크기와 키 값의 크기에 따라 자식노드의 개수가 결정됨
- 결론적으로 키 값의 크기가 커질수록 효율이 떨어짐

**B-tree 깊이**

- 깊이는 상당히 중요하지만 직접적으로 제어할 방법이 없음
- 결론적으로 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 잇는 인덱스 키값의 개수가 작아지고 그 때문에 같은 레코드 건수라 하더라도 b-tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게된다는 것을 의미함
- 인덱스의 키값의 크기는 가능하면 작은게 좋고 아무리 대용량 데이터베이스라도 깊이가 4~5이상까지 깊어지는경우는 거의 발생하지 않음

**선택도(기수성)**

- 인덱스에서 선택도 = 기수성임 카디널리티
- 전체인덱스 키값은 100개인데 유니크한 값의 수는 10개라면 기수성은 10임 
- 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리함
- 인덱스의 선택도가 높을수록 미리 걸러지는 레코드의 수가 많아짐



**읽어야 하는 레코드의 건수**

- 인덱스를 통해 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이드는 작업임
- 인데스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는것보다 4~5배정도 비용이 많이든다고 예측함
- 전체테이블의 20~25를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는 방식으로 처리하는게 좋음



### B-tree 인덱스를 통한 데이터 읽기

- mysql이 인덱스를 이용하는 대표적인 방법

**인덱스 레인지 스캔**

- 가장 대표적인 접근 방식
- 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현함
- 루트 -> 브랜치 -> 리프로 한번 전체 스캔하고 range를 정하고 range에서의 데이터를 클라이언트에게 반환함
- 별도의 정렬과정 없이 인덱스 자체의 정렬 특성때문에 정순 또는 역순으로 레코드를 불러옴
- 검색결과가 많으면 풀스캔이 나음



**인덱스 풀 스캔**

- 인덱스의 처으부터 끝까지 모두 읽는 방식
- 대표적으로 쿼리의 조거넞ㄹ에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용됨
- 예를들어 인덱스는 a,b,c 순서로 만들어졌지만 쿼리 조건절은 b, c 로시작하는 경우
- 쿼리가 인덱스에 명시된 컬럼만 조건을 처리할 수 있는 경우 이방식으로 사용되고 다른 레코드를 읽어야 한다면 절대 이방식으로 처리되지 않음
- 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 뒤 처음부터 끝까지 스캔함
- 인덱스 레인지 스캔 > 인덱스 풀 스캔 > 테이블 풀 스캔으로 검색속도가 빠른정도

**루스 인덱스 스캔**

- 오라클에 인덱스 스킵 스캔이랑 비슷함
- 루스 인덱스 스캔은 느슨하게 또는 듬성듬성하게 인덱스를 읽음
- 인덱스 레인지 스캔과 비슷하지만 필요하지 않은 인덱스 키값은 무시하고 다음으로 넘어가는 형태로 처리
- 일반적으로 group by 또는 집합 함수 가운데 max() min()함수에 대해 최적화를 하는 경우에 사용



### 다중 칼럼 인덱스

- 실무에서는 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용됨
- 다중컬럼인덱스의 순서에 따라 정렬 순서도 바뀌기때문에 다중컬럼인덱스의 순서는 매우 중요하고 상당이 신중하게 결정해야함



### B-tree 인덱스의 정렬 및 스캔 방향

- 인덱스 키값은 항상 오름차순으로 정렬되지만 역순으로도 사용될 수 있음

**인덱스의 정렬**

- 일반적인 dbms는 asc, desc 설정이 가능하지만 mysql에서는 컬럼마다 asc, desc 별개로 적용은 안됨
- mysql에선 지정한다고 하더라도 전부 무시하고 오름차순으로만 정렬됨
- 아직까지는 방법이 없으므로 order by 에 따라 역순으로 정렬하게 해야할 수 있음
- 예를들면 order by user_name asc, user_score desc일때 user_score를 음수값으로?



**인덱스 스캔 방향**

- 인덱스를 역순으로 정렬할 순 없지만 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순정렬 효과를 얻을 수 있음



### B-Tree 인덱스의 가용성과 효율성

- 쿼리의 where, group by, order by 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 알아야함



**비교 조건의 종류와 효율성**

- = < 또는 > 에 따라 인덱스 컬럼의 활용 형태가 달라짐
- 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 필터링이라고함
- 작업 범위 결정 조건은 실제 값을 읽어오는 작업이고 작업의 범위를 줄이지 못하고 필터링하는 작업을 필터링 조건이라고함 작업 범위 결정 조건이 많을수록 쿼리 처리 능력을 높일 수 있음



**인덱스의 가용성**

- b-tree 인덱스의 특징은 왼쪽 값에 기분에서 오른쪽 값이 정렬되어 있다는 것
- like를 '%mer'로 걸면 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수 없음
- 다중 컬럼 인덱스에서 (a, b) 가 있다고 가정할때 b로만 검색해도 인덱스를 효율적으로 사용할 수 없음



**가용성과 효율성 판단**

- 기본적으로 다음 조건들은 b-tree에서 사용할 수 없음 (작업 범위 결정 조건으로 사용 불가, 경우에 따라서는 체크조건으로 사용)
  - NOT-EQUAL로 비교된 경우
    - \<\>
    - NOT IN
    - IS NOT NULL
  - LIKE가 앞부분이 아닌 뒷부분의 형태로 비교된 경우
    - LIKE '%FOO'
  - 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변경된 후 비교된 경우
    - WHERE SUBSTRING ...
    - WHERE DAYOFMONTH ...
  - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
    - WHERE column = deterministic_function()
  - 데이터 타입이 서로 다른 비교 (인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
  - 문자열 데이터 타입의 콜레이션이 다른 경우
    - WHERE utf8_bin_char_column = euckr_bin_char_column



- 다른 일반적인 dbms에서 null 값은 인덱스에 저장되지 않지만 mysql에서는 null값도 인덱스로 관리됨
- WHERE cloumn IS NULL <- 인덱스를 사용함
- 다음은 다중컬럼에서 인덱스를 사용할 수 없는 경우
- INDEX ix_test (column_1, column_2, column_3, ... column_n)이 있다고 가정
  - 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
    - column_1 칼럼에 대한 조건이 없는 경우
    - column_1 칼럼의 비교 조건이 위의 인덱스 사용불가 조건 중 하나인 경우
  - 작업 범위 결정 조건으로 인덱스를 사용하는 경우 (i는 2보다 크고 n보다 작은 임의의 값을 의미)
    - column_1~ column_(i - 1) 칼럼까지 = 로 비교
    - column_i 칼럼에 대해 다음 연산자 중 하나로 비교
      -  = , <> , like 'foo%'
- 참고
  - 다음쿼리는 인덱스 사용 불가
    - where column_1 <> 2
  - 다음 쿼리는 column_1과 column_2까지 범위 결정 조건으로 사용됨
    - where column_1 = 1 and column_2 > 10
  - 다음 쿼리는 column_1, column_2, column_3 까지 범위 결정 조건으로 사용됨
    - where column_1 in (1,2) and column_2 = 2 and column_ <= 10
  - 다음 쿼리는 column_1, column_2, column_3 까지 범위 결정 조건으로, column_4는 체크 조건으로 사용됨
    - where column_1 = 1 and column_2 = 2 and column_3 in (10, 20, 30) and column_4 <> 100
  - 다음 쿼리는 column_1, column_2, column_3, column_4 까지 범위 결정 조건으로 사용됨 좌측 패턴 일치 like 비교는 크다 작다 비교 와 동급으로 생각하면 됨
    - where column_1 = 1 and column_2 in (2,4) and column_3 = 30 and column_4 like ('foo%')
  - 다음 쿼리는 column_1, column_2, column_3, column_4, column_5 칼럼까지 모두 범위 결정 조건으로 사용됨
    - where column_1 = 1 and column_2 = 2 and column_3 = 30 and column_4 = '김승환' and column_5 = '서울'
- 위 쿼리들은 b-tree인덱스의 특징이기때문에 다른 dbms에도 적용될 수 있음





## 해시 인덱스

- 해시 인덱스는 b-tree만큼 범용적이지는 않지만 고유의 특성과 용도를 지닌 인덱스임
- 해시 인덱스는 동등 비교 검색에만 최적화되어있고 범위, 정렬은 불가능
- 주로 메모리기반 테이블에 구현됨



### 구조 및 특성

- 해시 인덱스의 가장 큰 장점은 실제 키 값과는 관계 없이 인덱스 크기가 작고 검색이 빠르다는것
- 해시 장점 그대로 사용함 버킷에서 값을 꺼내옴
- 키 칼럼의 값이 아무리 길어도 4~8 바이트 수준으로 줄어들어듬
- 버킷의 수, 충돌 수에 따라 검색 성능 결정



### 해시 인덱스의 가용성 및 효율성

- 키값 자체가 변환되기때문에 원본데이터의 정렬을 할수 없음
- 다음의 경우 해시인덱스의 성능이 좋음
  - =
  - <>
  - in
  - is null
  - is not null
- 다음의 경우 해시인덱스 사용 불가
  - \>=
  - between
  - like
  - \<\>
- 다중 컬럼 인덱스를 해시인덱스로 만들면 컬럼의 개수만큼 조건을 걸어야됨 한개만걸면 안걸림



## R-Tree 인덱스

- 공간인덱스는 r-tree 인덱스 알고리즘을 사용해서 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스
- b-tree와 흡사 b-tree는 1차원 r-tree는 2차원
- 위치기반 서비스에 사용 가능



### 구조 및 특성

- mysql은 공간 정보의 저장 및 검색을 위해 여러가지 기하학적 도형(geometry) 정보를 관리할 수 있는 데이터 타입을 제공함
- point , line, polygon ?(3개의 수퍼타입 모두 저장 가능)
- mbr이라는 개념을 알고 있어야함 Minimum Bounding Rectagle의 약자고 해당 도형을 감싸는 최소 크기의 사각형을 의미함



## Fractal-Tree 인덱스

### Fractal-Tree의 특성

- b-tree의 가장 큰 문제는 디스크 랜덤 io가 상대적으로 많이 필요하다는 것
- fractal-tree는 이런 단점을 최소화하고 순차 io로 변환해서 처리할 수 있다는 것이 가장 큰 특징
- 인덱스 추가 삭제에 b-tree보다 더 많은 정렬과 리소스를 사용할지모르지만 인덱스의 단편화가 발생하지 않도록 구성할 수 있고 인덱스 키값을 클러스터링하기 때문에 b-tree 보다 대용량 테이블에서 높은 성능을 보장함 또한 b-tree는 일정 수준을 넘어서면 급격한 성능저하가 발생하는데 fractal-tree는 이런 급격한 성능 저하 현상이 없음



### fractal-tree의 가용성과 효율성

- 가장 큰 장점은 b-tree의 장점을 그대로 갖고 있다는것 b-tree의 인덱스 사용 방법 등등 ..



## 전문 검색 인덱스

- full text 검색에는 b-tree를 사용할 수 없음 키를 짤라서 저장하기 때문에
- 전문 검색 인덱스에서는 크게 구분자, n-그램으로 나눠서 생각할 수 있음



### 인덱스 알고리즘

**구분자 기법**

- 전문의 내용을 공백이나 탭 또는 마침표와 같은 문장기호로 분석하고 인덱스로 생성해둠
- 구분가 기법은 키워를 추출해 내는 작업이 추가로 필요할 뿐이고 b-tree를 그대로 사용함

**n-그램 기법**

- 무조건적으로 몇 글자씩 잘라서 인덱싱함
- 구분자 기법보다 복잡하고 인덱스 크기도 큰 편
- 2개씩 잘라서 하는 방법이 2-gram이고 많이 사용됨



## 비트맵 인덱스와 함수 기반 인덱스

- mysql 스토리지 엔진에서 비트맵 인덱스와 함수 기반 인덱스를 지원하는 스토리지 엔진은 없음
- 우회하는 방법은 있음

## 클러스터링 인덱스

- innodb와 tokudb에만 지원됨주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것

### 클러스터링 인덱스

- 클러스터링 인덱스는 프라이머리 키에만 적용되는 내용임
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라함
- 일반적으로 innodb와 같이 항상 클러스터링 인덱스로 저장되는 테이블의 프라이머리 키 값 기반 검색은 매우 빠르고 저장이나 변경이 상대적으로 느릴 수 밖에 없음
- 클러스터링 테이블의 구조 자체는 일반 b-tree와 많이 비슷한데 인덱스의 리프노드에는 레코드의 모든 컬럼이 저장되어 있는게 특징
- 즉 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되는것
- pk가 없는 innodb 테이블은 다음 우선순위대로 pk를 대체할 칼럼을 선택함
  1. pk가 있으면 기본적으로 pk 사용
  2. not null 옵션의 유니크 인덱스 중에서 첫번째 인덱스를 클러스터 키로 선택
  3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후 클러스터 키로 선택



**보조 인덱스에 미치는 영향**

- myisam이나 memory 테이블과 같이 넌 클러스터링 테이블은 한번 저정되면 공간이동이 절대 없음
- 그래서 myisam이나 memory 에선 pk나 보조인덱스나 별 차이가 없음
- innodb 테이블의 모든 보조 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어있음

```
CREATE TABLE employees (
	emp_no INT NOT NULL,
	first_name VARCHAR(20) NOT NULL,
	PRIMARY KEY(emp_no),
	INDEX ix_firstname (first_name)
);

SELECT * FROM employees WHERE first_name='Aamer';
```

- 다음의 경우에 엔진마다 검색이 조금 다름
  - myisam
    - ix_firstname 인덱스를 검색해서 실제 레코드를 검색, 레코드의 주소를 이용해서 최종 레코드를 가져옴
  - innodb
    - ix_firstname 인덱스를 검색해 레코드의 프라이머리 키 값 확인
    - pk값을 이용해 다시한번 테이블을 검색한 후 최종 레코드를 가져옴
- 위 경우 innodb가 조금 복잡하지만 pk로 레코드를 읽어오는게 상당히 빠르므로 걱정 x



### 클러스터 인덱스의 장점과 단점

- 장점

  - pk로 검색할때 처리 성능이 매우 빠름, 범위검색이 제일빠름
  - 테이블의 모든 보조 인덱스가 pk를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음

- 단점

  - 테이블의 모든 보조 인덱스가 클러스터 키를 갖기 때문에 클러스터 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
  - 보조 인덱스를 통해 검색할 때 프라이머리 키로 다시한번 검색해야 하므로 처리 성능이 조금 느림
  - insert 할때 pk 에 의해 레코드 저장 위치가 결정되기때문에 처리 성능이 느림
  - pk를 변경할때 delete , insert가 있기때문에 처리 성능이 느림

  

  

  

### 클러스터 테이블 사용시 주의사항

**클러스터 인덱스 키의 크기**

- 클러스터 테이블의 경우 모든 보조 인덱스가 프라이머리 키 값을 포함함 그래서 pk 값 크기가 커지면 보조 인덱스도 자동으로 커짐
- 레코드수가 기하급수적으로 증가하기때문에 innodb에서는 pk를 잘 정해야함

**pk는 auto-increment보다는 업무적인 컬럼으로 생성할 것 (가능한 경우)**

- innodb는 pk를 사용해 클러스터 테이블을 구성함
- 컬럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 크 컬럼을 pk로 설정하는 것이 좋음

**pk는 반드시 명시할 것**

- 가능하면 auto-increment 컬럼을 이용해서라도 지정하는게 좋음
- 아무것도 생성하지 않으면 innodb에서 사용자에게 보이지 않는 auto-increment를 생성하기때문에(but sql에서는 사용못함) 하나 안하나 똑같으니 하는게 나음

**auto-increment 컬럼을 인조 식별자로 사용할 경우**

- pk 를 여러개로 묶을때 pk 키가 커질 수 있음 but 보조인덱스를 사용하지 않으면 괜찮음
- 보조인덱스를 사용하면 auto-increment + 보조인덱스로 사용할 것
- 이런 auto-increment 컬럼을 인조 식별자 surrogate key라고함
- 조회보다는 insert 위주의 테이블들은 auto-increment를 이용한 인조 식별자를 pk로 설정하는 것이 좋음



## 유니크 인덱스

- 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미하는데 mysql에서는 인덱스 없이 유니크 제약만 설정할 방법이 없음



### 유니크 인덱스와 일반 보조 인덱스의 비교

- 유니크인덱스와 보조인덱스는 인덱스 구조상 아무런 차이가 없음

**인덱스 읽기**

- 읽는 속도에서 별 차이가 없음
- 하나의 값을 검색하는 경우 유니크 인덱스와 보조 인덱스는 사요되는 실행 계획이 다름
- 2개 이상의 레코드를 읽느냐의 차이만 있다는 것을 의미할 뿐 일겅야 할 레코드 건수가 같다면 성능상의 차이는 미미함

**인덱스 쓰기**

- 유니크 인덱스의 키값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한단계 더 필요함
- 일반 보조인덱스의 쓰기보다 느림
- mysql에서는 유니크 인덱스에서 중복값을 체크할때 읽기잠금, 쓰기잠금을 쓰는데 이 과정에서 데드락이 아주 빈번하게 발생함



### 유니크 인덱스 사용 시 주의사항

- 꼭 필요하면 사용하고 성능을 생각하면 생성하지 않는게 좋음
- 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하기 때문에 중복생성이 필요 없음



## 외래키

- mysql 왜래키는 innodb에서만 가능
- 외래키가 설정되면 연관되는 테이블 칼럼에 인덱스까지 생성됨
- innodb의 외래키 관리에는 중요한 두가지 특성
  - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금대기)이 발생함
  - 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않음

### 자식 테이블의 변경이 대기하는 경우

- 자식 테이블의 외래키 칼럼의 변경은 부모 테이블의 확인이 필요한데 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다림
- 자식테이블의 외래키가 아닌 칼럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않음

### 부모 테이블의 변경 작업이 대기하는 경우

- 자식에서 먼저 로우락을 얻고 부모에서 cascade delete 제약의 자식 로우와 연관된 부모를 지우면 잠금됨
- 외래키를 물리적으로 생성하려면 이러한 현상으로 인한 잠금 경합까지 고려해 개발을 진행하는 것이 좋음



## 기타 주의사항

**스토리지 엔진별 지원 인덱스 목록**

- myisam: b-tree, r-tree, fulltext-index
- innodb: b-tree
- memory: b-tree, hash
- tokudb, factal-tree
- ndb: hash, b-tree

**analyze와 optimize의 필요성**

- myisam이나 innodb의 경우 인덱스에 대한 통계 정보를 관리하고 각 통계 정보를 기반으로 쿼리의 실행계획을 수립함
- innodb와 myisam 모두 칼럼의 cardinality에 의존해서 실행 계획을 수립함
- 쿼리의 실행계획이 의도했던 것과는 너무 다르게 만들어 질 때는 인덱스의 통계 정보가 실제와 너무 다르게 수집될 경우에 그럼 이 경우 analyze 명령으로 통계 정보를 다시 수집해보는 것이 좋음
  - 테이블의 데이터가 별로 없는 경우
  - 단시간에 대량의 데이터가 늘어나거나 줄어든 경우





# #6 실행 계획

## 개요

### 쿼리 실행 절차

- mysql 서버에서 쿼리가 실행되는 과정 3가지
  1. 사용자로부터 요청된 sql 문장을 잘게 쪼개서 mysql 서버가 이해할 수 있는 수준으로 분리함
  2. sql의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
  3. 두번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴
- 첫번째 단계를 sql 파싱이라고하고 mysql 서버의 sql 파서라는 모듈로 처리함 만약 sql 문장이 문법적으로 잘못되었다면 여기서 걸러짐, 이 단계에서 sql 파스 트리가 만들어지고 sql 서버는 파스 트리를 이용해 쿼리를 실행
- 두번째 단계에서는 다음 내용 처리
  - 불필요한 조건의 제거 및 복잡한 연산의 단순화
  - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
  - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
  - 가져온 레코드들은 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
- 두번째 단계는 최적화 및 실행 계획 수립단계고 mysql 옵티마이저에서 처리함
- 세번째 단계는 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고 mysql 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행함
- 첫번째 두번째 단계는 거의 mysql 엔진에서 처리하며 세번째 단계는 mysql 엔진과 스토리지 엔진이 동시에 참여해서 처리함



### 옵티마이저의 종류

- 옵티마이저는 db에서 두뇌와 같은 역할을 담당
- 대부분의 dbms는 비용 기반 최적화 방법과 예전 오라클에서 많이 사용했던 기반 최적화 방법으로 크게 나눠볼 수 있음
- 규칙 기반 최적화
  - 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
  - 통계정보를 조사하지 않고 실행 계획이 수립되기 때문에 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어냄
  - 거의 안쓰고 업데이트도 안됨 지원도 잘 안됨
- 비용 기반 최적화
  - 쿼리를 처리하기 위해 여러 가지 가능한 방법을 만들고 각 단위 작업의 비용 정보와 테이블의 예측된 통계 정보를 이용해 각 실행 계획별 비용을 산출함 이렇게 산촐된 각 실행 방법별로 최소 비용이 소요되는 처리 방식을 선택해 최종 쿼리를 실행함
- mysql은 비용 기반 최적화



### 통계 정보

- 비용 기반 최적화에서 가장 중요한 것은 통계 정보임
- 기본적으로 mysql에서 관리되는 통계 정보는 대략 레코드 건수와 인덱스의 유니쿠한 값의 개수
- 통계정보가 부족하면 analyze 명령으로 강제 갱신
- 서비스 실행도중 analzye 실행은 안하는게 좋음 innodb의 경우 읽기 쓰기 모두 불가



## 실행 계획 분석

- mysql 쿼리 실행 계획 확인은 explain 명령을 사용하면 됨
- explain extended나 explain partitions 명령을 이용해 더 상세한 실행 계획을 확인할 수도 있음
- explain select ... 를 실행하면 나오는 로우 수는 쿼리에 사용된 테이블의 수만큼 나옴 (서브쿼리로 인한 테이블 포함)
- update, insert, delete의 경우 where절을 기반으로 대략적인 계획을 확인 가능함



### id 칼럼

- 실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 select 쿼리별로 부여되는 식별자 값임
- 만약 하나의 같은 select 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id를 가짐, 서브쿼리는 다른 id select가 두번이여서



### select_type 컬럼

**SIMPLE**

- UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT일 경우
- 쿼리 문장이 아무리 복잡해도 SIMPLE인 단위쿼리는 반드시 하나만 존재함
- 일반적으로 제일 바깥쪽에 있는 select 단위 쿼리가 primary



**PRIMARY**

- UNION이나 서브쿼리가 포함된 SELECT 쿼리의 실행계획에서 가장 바깥에 있는 단위쿼리
- 한개만 있음 쿼리의 제일 바깥 쪽에 있는 select 단위 쿼리가 primary로 표시됨



**UNION**

- union으로 결합하는 단위 select 쿼리 중 첫번째를 제외한 두 번째 select 부터는 select type이 union임

```sql
EXLPAIN
SELECT * FROM (
	(SELECT EMP_NO FROM EMPLOYEES E1 LIMIT 10)
	UNION ALL
    (SELECT EMP_NO FROM EMPLOYEES E2 LIMIT 10)
    UNINO ALL
    (SELECT EMP_NO FROM EMPLOYEES E3 LIMIT 10)
)
```

- 위 쿼리중 E1 select만 DERIVED 타입이고 나머지는 UNION 타입으로 설정됨



**DEPENDENT UNION**

- 여기서 DEPENDENT는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부의 영향을 받은 것을 의미

```sql
SELECT E.FIRST_NAME,
	(SELECT CONCAT('...') ...) FROM salaries s WHERE s.emp_no = e.emp_no
	UNION
    (SELECT CONCAT('...') ...) FROM dept_emp de WHERE s.emp_no = e.emp_no
    ...
FROM employees e
WHERE e.emp_no=10001;
```

- 여기서 union은 외부 e 테이블의 emp_no에 의존하므로 DEPENDENT 타입
- 일반적으로 서브쿼리는 먼저 실행되는 경향이 있는데 이 DEPENDENT는 절대 먼저 실행될 수 없기 때문에 서버 쿼리는 비효율적인 경우가 많음





**UNION RESULT**

- union 결과를 담아두는 테이블
- mysql 에서 unon all이나 union 쿼리는 모두 union의 결과를 임시 테이블로 생성하게 되는데 실행 계획상에서 이 임시 테이블을 가리키는 라인의 select_type이 UNION RESULT임



**SUBQUERY**

- FROM 절 이외의 서브쿼리
- FROM 절에 사용된 서브쿼리는 DERIVED라고 표시
- SELECT 에 사용되는 쿼리를 네스티드 쿼리
- WHERE 절에 사용되는 경우 서브쿼리
- FROM 절에 사용되는 경우 파생테이블, 인라인뷰, 서브 셀렉트 라고함
- 하나의 값만 반환하면 스칼라 서브쿼리
- 컬럼 개수에 관계 없이 하나의 레코드만 반환하면 로우 서브 쿼리



**DEPENDENT SUBQUERY**

- 바깥쪽 테이블에 의존할 경우 DEPENDENT 서브쿼리라고함
- 일반 서브쿼리보다 처리속도가 느릴떄가 많음



**DERIVED**

- 서브쿼리가 FROM절에 사용된 경우
- 파생 테이블에는 인덱스가 없기 때문에 다른 테이블과 조인할 때 성능상 불리할 때가 많음
- 가능하다면 DERIVED 형태의 실행 계획을 조인으로 해결할 수 있게 바꿔주는게 좋음
- 쿼리 튜닝전 반드시 DERIVED 확인 불가피한 상황이 아니면 반드시 조인으로 풀것



**UNCACHEABLE SUBQUERY**

- 조건이 똑같은 서브쿼리는 다시 사용할 수 있게 캐시공간에 담아둠
- 여기서 언급하는 서브 쿼리 캐시는 쿼리 캐시나 파생 테이블과는 전혀 무관한 기능
- select type이 SUBQUERY인 경우 한번 캐시되면 계속 캐시된거 사용함
- select type이 UNCACHEABLE SUBQUERY인 경우엔 캐시를 사용 못함
  - 사용자 변수가 서브쿼리에 사용된 경우
  - NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
  - UUID()나 RAND()와 같이 호출할때마다 달라지는 함수가 서브쿼리에 사용된 경우



**UNCACHEABLE UNION**

- UNCACHEABLE + UNION



### table 칼럼

- mysql의 실행 계획은 단위 selet 쿼리 기준이 아니라 테이블 기준으로 표시됨
- 테이블 없이 select하면 null이 나옴

```sql
select now()
```

- \<\> 으로 감싸졌다면 임시테이블임
- `<derived2>` id가 2인 쿼리에서 생성된 임시테이블





### type 컬럼

- 쿼리의 실행 계획(explain 명령어)에서 type 이후의 칼럼들은 mysql 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 의미함
- 일반적으로 쿼리 튜닝시 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 실행계획에서 type 칼럼은 반드시 체크해야함
- type에 표시될 수 있는 버전 아래 순서대로 가장 빠른것부터 
  - system
  - const
  - eq_ref
  - ref
  - fulltext
  - ref_or_null
  - unique_subquery
  - index_subquery
  - range
  - index_merge
  - index
  - all
- 12가지 방법중 all을 제외한 모두는 인덱스를 활용함 all은 인덱스를 사용하지 않고 풀스캔함
- 하나의 단위 select 쿼리는 위의 접근 방법 중에서 단 하나만 사용 가능
- 아래 설명은 가장 빠른순서대로 설명할 것이고 mysql 옵티마이저는 이런 접근 방식 + 비용을 함께 계싼해서 최소의 비용 드는 접근 방식을 선택함



**system**

- 레코드가 1건만 존재하는 테이블 또는 한건도 존재하지 않는 테이브을 참조하는 형태의 접근방법을 system이라함
- innodb에서는 없고 myisam이나 memory에서 사용
- 거의 안나옴



**const**

- 테이블의 레코드 건수에 관계 없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 where 조건절을 가지고 있으며 반드시 1건을 반환하는 쿼리의 처리 형식을 contst라함
- 다른 dbms에서는 이것을 유니크 인덱스 스캔이라고도 표현함
- 다중칼럼의 경우 const를 사용할 수 없고 ref로 표시됨
- 다중칼럼도 전부 = 조건으로 걸면 const를 사용함
- 실행계획이 const인 경우 mysql의 옵티마이저가 쿼리를 최적화하는 단계에서 모두 상수화 시킴.. 오



**eq_ref**

- eq_ref 접근 방법은 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시됨
- 조인에서 처음 읽은 테이블의 칼럼 값을 그 다음 읽어야 할 테이블의 pk나 유니크 키 칼럼의 검색 조건에 사용할 떄를 eq_ref라 함
- 이때 두번째 이후에 읽는 테이블의 type 칼럼에 eq_ref가 표시됨 두번째 이후에 읽히는 테이블을 유니크 키로 검색할 떄 그 유니크 인덱스는 not null 이어야 하며 다중 컬럼으로 만들어진 다중 칼럼으로 만들어진 pk나 유니크 인덱스라면 인덱스의 모든 칼럼이 비교 조건에 사용 되어야만 eq_ref 접근 방법이 사용될 수 있음
- 즉 조인에서 두번쨰 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법

```sql
SELECT * FROM dept_emp de, employees e
WHERE e.emp_no=de.emp_no AND de.dept_no 'd005';
```

- 여기서 e의 실행계획이 eq_ref가 됨





**ref**

- eq_ref와는 달리 조인의 순서와 관계 없이 사용되고 pk나 유니크키의 제약조건도 없음
- 인덱스 종류와 관계없이 동등 조건으로 검색할 때는 ref접근 방법이 사용됨
- 반환되는 레코드가 반드시 1건이라는 보장이 없기 때문에 const, eq_ref보다는 느리지만 그래도 매우 빠름



**언급한 const, eq_ref, ref 는 매우 좋은 접근 방법이고 쿼리튜닝의 대상이아님**



**fulltext**

- mysql의 전문검색 인덱스를 사용해 레코드를 읽는 접근 방법을 의미함
- 전문 검색 인덱스는 통계 정보과 관리되지 않고 전혀 다른 sqld을 사용해야함
- MATCH ... AGAINST ... 구문을 사용함
- 일반적으로 쿼리에 전문 검색 조건을 사용하면 MYSQL은 아무런 주저없이 fulltext 접근 방식을 사용하는 경향이 있지만 일반 인덱스를 이용하는 range 접근 방법이 더 빨리 처리되는경우가 많음



**ref_or_null**

- ref와 같은데 null 비교가 추가됨



**unique_subquery**

- where에 in 형태의 쿼리를 위한 접근 방식
- 서브쿼리에서 중복되지 않은 유니크한 값만 반환할 때 이 접근 방법을 사용함



**index_subquery**

- IN 연산자의 특성상 IN 또는 IN 형태의 조건은 괄호 안에 있는 값의 목록에서 중복된 값이 먼저 제거되어야 함
- 중복된 값을 인덱스를 이용해 제거할 수 있을 때 index_subquery 접근 방법이 사용됨
- index_subquery, unique_subquery는 모두 IN절 안에 있는 중복 값을 아주 낮은 비용으로 제거함



**range**

- 인덱스 레인지 스캔 형태의 접근 방법
- `<>` IS NULL, BETWEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색할 떄 사용
- mysql접근 방법중에서 상당히 우선순위가 낮지만 이 접근 방식도 빠르고 어느정도 성능 보장이됨



**인덱스 레인지 스캔이라고하면 보통 const, ref, range 라는 세가지 접근 방법을 모두 먺어서 지칭하는 것**



**index_merge**

- 2개의 인덱스를 이용해 각각의 검색 결과를 만들어 낸 후 그 결과를 병합하는 처리 방식
- 그다지 효율적이지 않음
- 특징
  - 여러 인덱스를 읽어야 하므로 일반 range 스캔보다는 효율성이 떨어짐
  - and와 or 연산이 복잡하겨 연결된 쿼리에서는 제대로 죄적화하지 못할때가 많음
  - 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않음 
  - index_merge 접근 방식으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합 또는 중복 제거와같은 부가적인 작업이 더필요함



**index**

- 인덱스 풀 스캔
- 그다지 효율적이지 않음 테이블 풀 스캔보다는 빠름
- range나 const 또는 ref와 같은 접근 방식으로 인덱스를 사용하지 못하는 경우
- 인덱스에 포함된 칼럼으로 처리할 수 있는 쿼리인 경우 즉, 데이터 파일을 읽지 않아도 되는 경우
- 인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우 즉, 별도의 정렬 작업을 피할 수 있는 경우
- index + limit 같은 경우 성능이 상당히 효율적임



**all**

- 풀 테이블 스캔
- 가장 성능안나옴
- 다른 dbms와 같이 innodb도 풀 테이블 스캔, 인덱스 풀 스캔같은 대량의 io를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어들이는 기능을 제공함. 이 기능을 리드 어헤드 read ahead 라 함



### possible_keys

- mysql 옵티마이저는 쿼리를 가장 낮은 비용을 예상한 실행계획을 선택해서 실행함
- 그중에서 사용될법한 인덱스의 목록이 possible_key 칼럼에 나오는데 쿼리튜닝에 아무런 도움이 되지 않음
- 그냥 무시



### key

- possible_keys 칼럼의 인덱스가 사용 후보였던 반면 key 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미
- 의도했던 인덱스가 여기에 나오는지 확인하는것이 중요함
- index_merge 실행계획의 경우 , 로 구분되어 나열됨
- all같이 인덱스를 전혀 사용 못하면 null로 표현됨



### key_len

- 많이 무시하는데 사실 매우 중요한 정보
- 실무에서는 단일 칼럼보다는 다중 칼럼으로 설정된 인덱스가 많음
- 실행 계획의 key_len 칼럼은 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇개의 칼럼까지 사용했는지 알려줌
- 더 정확하게는 인덱스의 각 레코드에서 몇바이트까지 사용했는지 알려주는 값
- 버전별로 조금 다르게 표시되는데 5.0 에서 5.1에서 많은 변화가 있었기 때문임 <- 참고



### ref

- 접근 방법이 ref 방식이면 참조 조건(=) 으로 어떤 값이 제공됐는지 보여줌
- const ... 등등이 나오는데 func이라고 나오면 주의해야함 ex 산술표현식
- 가능하다면 조인시 서버가 변환을 하지 않아도 되도록 조인 칼럼의 타입을 일치시키는게 좋음 



### rows

- mysql 실행 계획의 rows 칼럼은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여줌
- 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 mysql 옵티마이저가 산출해낸 예상 값이라 정확하지는 않음
- 반환하는 레코드의 값이 아닌 디스크로부터 읽고 체크해야하는 값의 수를 의미함
- 잘하면 쿼리 튜닝으로 range로 바꿀 수 있음



### Extra

- 성능 관련된 내용이 extra 칼럼에 자주 표시됨

**counst row not found (mysql 5.1 이상)**

- 쿼리의 실행 계획에서 const 접근 방식으로 읽었지만 레코드가 1개도 없다면

**Distinct**

- 쿼리의 distinct를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 꼭 필요한 것만 조인하고 꼭 필요한 레코드만 읽음



**Full scan on NULL key**

- 이 처리는 `col IN (SELECT col2 FROM ...)` 과같은 쿼리에서 자주 발생하는데 만약 col1의 값이 NULL이 된다면 결과적으로 조건은 `NULL IN (SELECT col2 FROM) ...` 이됨

  - 서브쿼리가 1건이라도 결과 레코드를 가진다면 최종 비교 결과는 null
  - 서브쿼리가 1건도 결과 레코드를 가지지 않는다면 최종 비교 결과는 false

- 이 비교 결과에서 col1이 null이면 풀스캔해야됨

- extra에서 Full scan on NULL key은 null이나왔을때 풀스캔할꺼라고 알려주는거임

- col1 IS NOT NULL 조건을 WHERE에 섞어주면 mysql 옵티마이저에게 알려주므로 extra에서 Full scan on NULL key 나와도 안전함

  ### 

  

**Impossible HAVING (mysql 5.1 이상)**

- 쿼리에 사용된 having 절의 조건을 만족하는 레코드가 없을때 extra 컬럼에서 나옴



**Impossible WHERE (mysql 5.1 이상)**

- WHERE 조건이 항상 FALSE가 될 수 밖에 없는 경우
- 제약사항을기반으로



**impossible WHERE noticed after reading const tables**

- 실제로 실행되었을때 아무겂도 없으면 이렇게나옴



**No matching min/max row (MYSQL 5.1 이상)**

- 쿼리의 WHERE 조건절을 만족하는 레코드가 한 건도 없는 경우 일반적으로 impossible where ... 문장이 exist 칼럼에 표시됨
- 만약 min(), max()가 없을때는 No matching min/max row 로 표시



**no matching row in const table (mysql 5.1 이상)**

- const 방식으로 접근할떄 일치하는 레코드가 없으면 exist에 no matching row in const table 로 표시



**no tables used **

- from에 dual이나 없을 경우 no tables used 



**Not exists**

- not in이나 not exist를 안티 조인이라고함 똑같은 처리를 아우터 조인으로 풀 수 있음
- 레코드의 건수가 많을때는 아우터 조인을 이용하면 빠른 성능을 낼 수 있음
- 안티 조인은 일반 조인을 했을 때 나오지 않는 결과만 가져오는 방법임

```SQL
EXPLAIN
SELECT *
FROM dept_emp de
	LEFT JOIN departments d ON de.dept_no=d.dept_no
WHERE d.dept_no IS NULL;
```

- 이런식으로 사용하면 extra 컬럼에 not exists로 표시됨



**Range checked for each recode (index map: N)**

- 두 개의 테이블을 조인하면서 조인 조건에 상수가 없고 둘다 변수일 경우 1, 1+1, 1+2, 1+n ... n 이런식으로 매 레코드마다 인덱스 레인지 스캔을 체크함

```sql
EXPLAIN
SELECT *
FROM employees e1, employees e2
WHERE e2.emp_no >= e1.emp_no;
```



**Scanned N databases(mysql 5.1이상)**

- mysql 5.0부터는 기본적으로 INFORMATION_SCHEMA라는 db가 제공됨 이 db는 mysql 서버 내에 존재하는 db의 메타정보를 모아둔 db임, read only
- Scanned N databases에서 N은 0, 1, N이 됨
  - 0: 특정 테이블의 정보만 요청되어 데이터베이스 전체의 메타 정보를 읽지 않음
  - 1: 특정 데이터베이스내의 모든 스키마 정보가 요청되어 해당 데이터베이스의 모든 스키마 정보를 읽음
  - all: mysql 서버 내의 모든 스키마 정보를 당릭음

```sql
EXPLAIN
SELECT table_name
FROM information_schema.tables
WHERE table_schema = 'employees' AND table_name = 'employees';
```



**Select tables optimized away**

- MIN, MAX만 select절에 사용되거나 group by로 MIN, MAX를 조회하는 쿼리가 적절한 인덱스를 사용할 수 없을 때 인덱스를 오름차순 또는 내림차순으로 1건만 일는 형태의 최적화가 적용된다면 Extra 칼럼에 Select tables optimized away 가 표시됨
- myisam 테이블은 count(*) 만 select할떄도 적용됨 but where가 붙으면 안됨



**Skip_open_table, Open_frm_only, Open_trigger_only, Open_full_table (mysql 5.1 이상)**

- 메타정보를 조회하는 select 쿼리에만 표시되는 내용임
- 테이블의 메타 정보가 저장된 파일과 트리거가 저장된 파일 또는 데이터 파일 중에서 필요한 파일만 읽었는지 또는 불가피하게 모든 파일을 다 읽었는지 등의 정보를 보여줌
  - skip_open_table: 테이블의 메타 정보가 저장된 파일을 별도로 읽을 필요가 없음
  - open_frm_only: 테이블의 메타 정보가 저장된 파일만 열어서 읽음
  - open_trigger_only: 트리거 정보가 저장된 파일만 열어서 읽음
  - open_full_table: 최적화 되지 못해서 테이블의 메타 정보 파일과 데이터 및 인덱스 파일까지 모두 읽음





**unique row not found (mysql 5.1 이상)**

- 두 개의 테이블이 각각 유니크 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 조재하지 않을때 extra 칼럼에 이 코멘트가 표시됨





**Using filesort**

- ORDER BY를 처리하기 위해 인덱스를 이용할 수도 있지만 적절한 인덱스를 찾지 못할 때는 MYSQL 서버가 조회된 레코드를 다시 한 번 정렬해야함 ORDER BY 처리가 인덱스를 사용하지 못할때만 실행 계획의 EXTRA 칼럼에 Using filesort 코멘트가 표시되며 이는 조회된 레코드르 정렬용 메모리 버퍼에 복사해 퀵 소트 알고리즘을 수행하는 것



**Using index (커버링 인덱스)**

- 데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 Extra 칼럼에 Using index가 표시됨
- 인덱스 레인지 스캔을 사용한다고 하더라도 나머지 레코드를 가져올때 인덱스 처리가 되지 않았다면 디스크에서 읽어올 수밖에 없기때문에 쿼리 성능이 안나올 경우 인덱스에 있는 칼럼만 사용하도록 쿼리를 변경해 큰 성능 향상을 볼 수 있음
- 레코드 건수에 따라 차이는 있겠지만 커버링 인덱스를 사용할때 아닐때 성능은 수십 수백배가 날 수 있음
- 그러나 커버링 인덱스를 위해 너무 과도하게 인덱스 칼럼이많아지면 인덱스의 크기가 커져서 메모리 낭비가 심해지기때문에 너무 커버링 인덱스 위주는 좋지 않음
- 접근 방법이 eq_ref, ref_ range 등과 같이 인덱스를 사용하는 실행 계획에서는 모두 extra 칼럼에 using index가 표시될 수 있음, 즉 인덱스 레인지 스캔을 사용할 때만 커버링 인덱스로 처리되는 것은 아님 인덱스를 풀 스캔 할 때도 커버링 인덱스로 처리될 수 있는데 이떄도 똑같은 인덱스 풀 스캔의 접근 방법이라면 커버링 인덱스가 아닌 경우보다 훨씬 빠르게 처리됨 



**Using index for group-by**

- group by 처리를 위해 mysql 서버는 그룹핑 기준 칼럼을 이용해 정렬 작업을 수행하고 다시 정렬된 결과를 그룹핑하는 형태의 고부하작업을 피요로함
- 하지만 group by 처리가 인덱스를 이용하면 정렬된 인덱스 칼럼을 순서대로 읽으면서 그룹핑 작업만 수행하기 때문에 효율적이고 빠르게 처리됨
- group by 처리가 인덱스를 사용할때 Using index for group-by 가 표시됨 이 방법을 루스 인덱스 스캔이라고함
- 인덱스를 이용해 group by를 처리해도 avg나 sum 또는 count같은 함수를 사용하면 필요한 레코드만 읽는 루스 인덱스 스캔을 사용할 수 없음
- min, max 또는 인덱스를 활용한 group by는 루스 인덱스 스캔을 사용할 수 있음
- where 절에 사용하는 인덱스에 의해서도 사용 여부가 영향을 받음
  - where가 없을 경우
    - where 절의 조건이 전혀 없다면 group by만 루스 인덱스 스캔을 사용할 조건만 갖추면 됨
  - where 절이 있지만 검색을 위해 인덱스를 사용 못하는 경우
    - group by는 인덱스를 쓰지만 where는 불가능할 경우 타이트 인덱스 스캔을 통해 group by가 처리됨
  - where 절의 조건이 있으며, 검색을 위해 인덱스를 사용하는 경우
    - index_merge 이외의 접근 방법에서는 단 하나의 인덱스만 사용할 수 있음. where절에 사용된 인덱스 + group by 인덱스가 동일하다면 루스 인덱스 스캔이 가능함 만약 다르다면 where 조건절이 인덱스를 사용하도록 실행 계획을 수립하는 경향이 있음
    - 같은 인덱스를 사용한다고 하더라두 루스 인덱스 스캔을 안할 수 있음 where절 조건에서 검색된 데이터가 적을 경우 이미 빠르기 때문에

**Using join buffer (mysql 5.1 이상)**

- 일반적으로 빠른 쿼리 실행을 위해 조인이 되는 칼럼은 인덱스를 생성함 실제로 조인에 필요한 인덱스는 조인 되는 양쪽 테이블 칼럼 모두가 필요한 것이 아니라 조인에서 뒤에 읽는 테이블의 칼럼에만 필요함
- mysql 옵티마이저도 조인되는 두 테이블에 있는 각 칼럼에서 인덱스를 조사하고, 인덱스가 없는 테이블이 있으면 그 테이블을 먼저 읽어서 조인을 실행함 뒤에 읽는 테이블은 검색 위조로 사용되기 때문에 인덱스가 없으면 성능에 미치는 영향이 매우큼

- rdbms에서 조인을 처리하는 방법이 2~3가지정도 되지만 mysql에서는 중첩 루프 조인 방식만 지원함 from 절에 아무리 테이블이 많아도 조인을 수행할 때 반드시 두 개의 테이블이 비교되는 방식으로 처리됨 먼저 읽히는 테이블을 드라이빙 테이블, 뒤에 읽히는 테이블을 드리븐 테이블이라 함 A , B 일때 A는 드라이빙, B는 드리븐
- 조인이 수행될 때 드리븐 테이블의 조인 칼럼에 적절한 인덱스가 있다면 아무런 문제가되지 않는데 없으면 드라이빙 테이블로부터 읽은 레코드의 건수만큼 매번 드리븐 테이블을 풀 테이블 스캔이나 인덱스 풀 스캔을 해야함 이 경우 드리븐 테이블의 비효율적인 검색을 보완하기 위해 mysql 서버는 드라이빙 테이블에서 읽은 레코드를 임시 공간에 보관해두고 필요할 때 재사용할 수 있게 해줌 이 공간을 조인 버퍼라고함
- join_buffer_zise 로 변경 가능하고 조인되는 인덱스가 적절하게 되었다면 크게 신경쓰지 않아도 되지만 너무 부족하거나 너무 과다하지 않도록 제한하는게 좋음
- 온라인 웹 서비스용 mysql 서버라면 join buffer는 1m으로 충분함



**Using sort_union(...), Using union(...), Using intersect(...)**

- 쿼리가 index_merge 접근 방식으로 실행되는 경우에는 2개 이상의 인덱스가 동시에 사용될 수 있음
- 이때 결과를 어떻게 병합했는지 3가지 메시지
  - Using intersect
    - 각각의 인덱스를 사용할 수 있는 조건이 AND로 연결된 경우 각 처리 결과에서 교집합을 추출해내는 작업을 수행했다는 의미
  - Using union
    - 각 인덱스를 사용할 수 있는 조건이 or로 연결된 경우 각 처리 결과에서 합집합을 추출해내는 작업을 수행했다는 의미
  - Using sort_union
    - Using union과 같은 작업을 수행하지만 Using union으로 처리될수 없는 경우 이방식으로 처리됨 이 방식은 pk만 만저 읽어서 정렬하고 병합한 후에야 비로소 레코드를 읽어서 반환 할 수 있다는 것



**Using temporary**

- mysql이 쿼리를 처리하는 동안 중간 결과를 담아 두기 위해 임시 테이블을 사용함 임시테이블은 메모리 또는 디스크에 생성될 수 있음 <- 판단 불가 
- from 절에 사용된 서버쿼리는 무조건 임시테이블 파생 테이블이라고도함
- union union all 같은 쿼리도 항상 임시테이블을 사용함
- count(distinct column1) 를 포함하는 쿼리도 인덱스를 사용할 수 없는 경우에는 임시 테이블이 만들어짐



**Using Where**

- 스토리지 엔진이 아니라 mysql 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우에만 이 코멘트가 표시됨
- 일반적으로 using where가 표시된 경우에는 mysql 엔진에서 한번 필터링 작업을 한 것임 그와 동시에 스토리지 엔진에서 쓸모 없는 일을 추가로 시켰다는 것을 의미함
- 5.0에서 성능상의 이슈가 있고 5.1에서 어느정도 해소됨 mysql에서 이런 기능을 condition push down이라고함



**Using where with pushed condition**

- Condition push down이 적용됐을때 나오는 메시지
- 이메시지는 ndb 클러스터 스토리지 엔진을 사용하는 테이블에서만 나타나므로 생략





### EXPLAIN EXTENDED (Filtered 칼럼)

- 조인과 같은 여러가지 이유로 여전히 각 스토리지 엔젠에서 읽어 온 레코드를 mysql 엔진에서 필터링하는데 5.1.12 이상부터 필터링이 얼마나 효율적으로 실행됐는지 알려주기위해 Filtered라는 컬럼이 추가됨
- Filtered 칼럼을 추가하려면 EXPLAIN 명령 뒤에 EXTENDED라는 키워드를 지정하면 됨

```sql
EXPLAIN EXTENED
SELECT * FROM employees
WHERE emp_no BETWWEN 10001 AND 10100 AND gender= 'f';
```

- 여기에나오는 숫자는 %를 의미함 실제 값이 아니라 단순히 통계 정보로부터 예측된 값





### EXPLAIN EXTENDED(추가 옵티마이저 정보)

- EXPLAIN 명령의 EXTENE 옵션은 의 숨은 기능은 분석된 파스트리를 재조합해서 쿼리 문장과 비슷한 순서대로 나열해서 보여주는 것
- EXPLAIN EXTENDED 이후에 SHOW WARNINGS을 실행하면 옵티마이저가 재조합한 쿼리 문장을 확인할 수 있음 알아두면 유용





### EXPLAIN PARTITIONS(Partitions 칼럼)

- EXPLAIN 명령 뒤에 PARTITIONS 옵션을 사용하면 쿼리를 실행하기 위해 테이블의 파티션 중에서 어떤 파티션을 사용했는지 등의 정보를 조회할 수 있음
- 파티션이 여러개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 파티션 프루닝이라고함
- 실제 이 파티션에서만 데이터를 읽어오는지 확인할 수 있음





## MySQL의 주요 처리 방식

- 아래 설명하는 내용은 풀 테이블 스캔을 제외한 나머지 모두 스토리지 엔진이 아니라 mysql 엔진에서 처리되는 내용임
- mysql 엔진에서 부가적으로 처리하는 작업은 대부분 성능에 취약함
- mysql 엔진에서 처리하는 작업을 알아두면 쿼리 튜닝에 상당히 도움이 됨



### 풀 테이블 스캔

- 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지읽어서 요청된 작업을 처리하는 작업
- 다음 조건이 일치할때 사용
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀테이블 스캔을 하는 편이 더 빠른 경우
  - where 절이나 on 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
  - 반대로 max_seeks_for_key 변수를 특정 값으로 설정하면 mysql 옵티마이저는 인덱스의 기수성이나 선택도를 무시하고 최대 n건만 읽으면 된다고 판단하게 함 이 값을 작게 설정할 수록 mysql 서버가 인덱스를 더 사용하도록 유도함
- 일반적으로 풀테이블 스캔은 인덱스보다 느림
- 풀 테이블 스캔 속도를 늘리기 위해 한번에 몇 개씩 페이지를 읽어올지 설정하는데 innodb의 경우 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 시작됨
- 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 innodb 버퍼 풀에 가져다 두는 것을 의미함



### ORDER BY 처리(using filesort)

- 레코드 1~2 건을 가져오는 쿼리를 제외하면 select 쿼리에서 정렬은 필수적으로 사용됨
- 정렬하기위해 인덱스와 fiesort라는 별도의 처리를 이용하는 방법으로 나눌 수 있음
- 인덱스를 이용
  - 장점: insert, update, delete 쿼리가 실행될 때 이미 인덱스가 정렬되어 있어서 순서대로 읽기만하면 매우 빠름
  - 단점: insert, update, delete 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느림. 인덱스 때문에 디스크 공간이 더 많이 필요하고 인덱스 개수가 늘어날수로 버퍼풀이나 메모리가 많이 필요함
- filesort 이용
  - 장점: 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 떄의 단점이 장점으로 바뀜. 정렬해야 할 레코드가 많지 않으면 메모리에서 filesort가 처리되므로 충분히 빠름
  - 당점: 정렬 작업이 퀄 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리 응답 속도가 느림
- 다음과같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능함
  - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
    - group by 의 결과 또는 distinct와 같은 처리의 결과를 정렬해야 하는 경우
    - union의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
    - 랜덤하게 결과 레코드를 가져와야하는 경우 
- mysql이 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 extra 칼럼에 using filesort 라는 코멘트가 표시되는지로 판단 가능함 
- mysql 정렬 특성을 이해하면 쿼리를 튜닝할 때 어떻게 하면 조금이라도 더 빠른 쿼리가 될지 쉽게 판단할 수 있음



**소트 버퍼(sort buffer)**

- mysql은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데 이 메모리 공간을 소트버퍼라고함
- 소트 버퍼는 정렬이 필요한 경우에만 할당되고 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만 최대 사용 가능한 소트 버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있음 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시트템으로 반납됨



- 정렬해야할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 레코드 여러 조각의로 나눠서 처리하는데 이때 임시저장을 위한 디스크를 사용함
- 정렬과 기록을 반복적으로 하고 병합하면서 정렬을 수행하는데 이 병합 작업을 멀티 머지라고 표현하고 수행된 멀티 머지 횟수는 sort_merge_passes라는 상태변수에 누적됨
- 소트버퍼의 크기를 늘린다고하더라도 성능상 크게 다른점은 없음
- 소트버퍼 크기는 56kb에서 1mb미만이 적절함
- 소트버퍼는 커넥션마다 개별적으로 같기 때문에 만약 크기가 크다면 oom이 발생할 수 있음





**정렬 알고리즘**

- 레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 2가지로 정렬 알고리즘을 나눠볼 수 있음

**싱글 패스 알고리즘**

- 소트 버퍼에 정렬 기준을 포함해 select 되는 칼럼 전부를 담아서 정렬을 수행하는 방법, mysql 5.0 이후 최근 버전에서 도입된 정렬 방법

**투패스 알고리즘**

- 정렬 대상 칼럼과 pk값만을 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 select 할 칼럼을 가져오는 알고리즘, 예전 버전의 mysql에서 사용하던 방법. 하지만 5.0, 5.1, 5.5에서도 특정 조건이 되면 이 방법을 사용함



- 두번읽기때문에 싱글 패스 알고리즘을 사용하지만 싱글패스 알고리즘은 더 많은 소트 버퍼 공간을 필요로함
- 최근 버전에서는 싱글 패스 방식을 사용함 예외도 있음



**정렬의 처리 방식**

- 쿼리에 order by가 사용되면 반드시 다음 3가지 처리 방식중 하나로 정렬이 처리됨 아래로 갈수록 처리가 느려짐
- 인덱스를 사용한 정렬 -> 드라이빙 테이블만 정렬 -> 조인 결과를 임시 테이블로 저장한 후 임시 테이블에서 정렬
- 옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있을지 검토하고 가능하다면 filesort 과정 없이 인덱스를 순서대로 읽어서 결과를 반환함
- 인덱스를 사용할 수 없으면 mysql 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 다음 두가지 방법중 하나를 선택함
  - 드라이빙 테이블만 정렬 후 다음 조인 수행
  - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬 수행
- 전자가 더 효율적임



**인덱스를 이용한 정렬**

- 인덱스를 이용한 정렬을 위해서는 반드시 order by에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고 order by의 순서대로 생성된 인덱스가 있어야함 또한 WHERE 절에 첫번쨰 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 함
- B-TREE 계열에서만 사용 가능함
- 여러 테이블이 조인되는 경우엔 네스티드 루프 방식의 조인에서만 이 방식을 사용 가능함
- 인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값을 읽기만하면 되기 때문에 별도의 추가 작업을 하지 않음
- ORDER BY없이 정렬 되더라도 반드시 명시할 것
- 조인버퍼가 사용되면 순서가 흐트러질 수 있음





**드라이빙 테이블만 정렬**

- 일반적으로 조인이 수행되면 결과 레코드의 건수가 몇 배로 불어남 그래서 조인 실행 전에 드라이빙 테이블만 정렬 하고 조인하는 것이 차선책
- 이 방법은 조인에서 첫번째 읽히는 테이블의 칼럼만으로 ORDER BY 절이 작성되어야함





**임시 테이블을 이용한 정렬**

- 임시테이블을 사용하면 가장 느림
- 드리븐테이블에 있는 컬럼을 ORDER BY 할 때
- 쿼리 실행 계획에 using temporary; Using filesort가 표시됨



**정렬 방식의 성능 비교**

- ORDER BY나 GROUP BY같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼 가져와서 처리될 수 없음
- 먼저 조건을 만족하는 레코드를 가져와서 정렬 및 그룹핑 작업을 해야만 LIMIT로 건수 제한을 할 수 있음
- WHERE 조건은 아무리 인덱스를 잘활용하도록 튜닝해도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생함
- 쿼리가 처리되는 두가지 방법
  - 스트리밍 방식
    - 서버 쪽에서 처리해야 할 데이터가 얼마나 될지에 관계없이 조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트로 전송해주는 방식을 의미함. 이 방식으로 쿼리를 처리할 경우 클라이언트는 쿼리를 요청하고 곧바로 원했던 첫 번째 레코드를 전달받을 것임 
    - 스트리밍 방식으로 처리되는 쿼리는 얼마나 많은 레코드를 조회하느냐가 아니라 빠른 응답 시간을 보장해줌
    - 스트리밍 방식에서 LIMIT로 처리되는 쿼리는 성능이 매우 좋음
  - 버퍼링 방식
    - ORDER BY나 GROUP BY는 쿼리의 결과가 스트리밍 되는 것을 불가능하게 함
    - 먼저 결과를 모아서 MYSQL 서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진으로부터 가져올 떄까지 기다려야 함





- 인덱스를 활용한 방법만 스트리밍 형태고 나머지는 모두 버퍼링 된 후에 정렬됨
- 인덱스를 활용하면 LIMIT로 제한된 건수만큼만 읽으면서 바로 클라이언트로 전송해줄 수 있음
- 어느 테이블이 먼저 드라이빙 되어 조인되는지도 주용하지만 어떤 정렬 방식으로 처리되는지는 더 큰 성능 차이를 만들어냄
- 가능하다면 인덱스를 사용한 정렬로 유도하고 그렇지 못하다면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하는 것도 좋은 튜닝 방법임
- 인덱스를 사용하지 못하는 쿼리를 페이징 처리에 사용하는 경우 LIMIT로 5~10건만 조회해도 쿼리가 기대만큼 아주 빨라지지는 않음



**정렬 관련 상태 변수**

- MYSQL 서버는 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장하고 있음
- 몇건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼 간의 병합 작업은 몇번이나 발생했는지 ..
- SHOW SESSION STATUS LIKE 'Sort%'
- 각 상태값
  - Sort_merge_passes는 멀티 머지 처리 횟수를 의미함
  - Sort_range는 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
  - Sort_scan은 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
  - Sort_rows는 지금까지 정렬한 전체 레코드 건수를 의미함



### GROUP BY 처리

- 일반적으로 group by 처리 결과는 임시 테이블이나 버퍼에 존재하는 값을 필터링하는 역학을 수행함

  































































































