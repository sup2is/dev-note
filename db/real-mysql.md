# #1 소개



# #2 설치와 설정





# #3 MySQL 아키텍처



## MySQL 아키텍처



![](https://t1.daumcdn.net/cfile/tistory/26219B435902D88522)

### mysql 전체구조

- mysql은 일반 상용 rdbms에서 제공하는 대부분의 접근법을 모두 지원함

- mysql 서버는 크게 mysql 엔진, 스토리지 엔진으로 구분해볼 수 있음

**mysql 엔진**

- mysql 엔진은 클라이언트로부터의 접속 및 쿼리요청을 처리하는 커넥션 핸들러와 sql 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심

**스토리지 엔진**

-  실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 스토리지 엔진이 전담, mysql 엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용 가능

**핸들러 api**

- mysql 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에게 쓰기 또는 읽기 요청을 하는데 이러한 요청을 핸들러 요청이라고하고 여기에 사용되는 api를 핸들러 api라함

### mysql 스레딩 구조

- mysql 서버는 프로세스기반이 아니라 스레드 기반으로 작동함 크게 포그라운드와 백그라운드 스레드로 구분

**포그라운드 스레드(클라이언트 스레드)**

- mysql 서버에 접속된 클라이어트의 수 만큼 존재
- 요청하는 쿼리 문장을 처리하는 것이 임무
- 요청 종료시 다시 스레드 캐시 (thread pool)로 돌아감
- 스레드의 개수를 일정하게 유지해주는 파라미터 thread_cache_size

**백그라운드 스레드**

- innoDB는 여러가지 작업이 백그라운드로 처리 여러가지 작업을 함
- 쓰기 스레드는 innodb_write_io_threads, 읽기 스레드는 innodb_read_io_treads로 지정 가능
- 읽기스레드는 클라이언트 스레드에서 처리되는데 쓰기의 경우 일반 내장 디스크에서는 2~4, ans,san과같은 스토리지를 사용할 경우 4개 이상으로 충분히 설정하는게 좋음

<br>

- 상용 dbms에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 있고 innodb도 그러함 but myisam은 그렇지 않고 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계되어 있음
- innodb에서는 cud 쿼리로 데이터가 변경되는 경우 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 됨 . 하지만 myisam에서 일반적인 쿼리는 쓰기 버퍼링을 사용할 수 없음



### 메모리 할당 및 사용 구조

- mysql에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분 가능
- 글로벌 메모리 영역의 모든 메모리 공간은 mysql 서버가 시작되면서 무조건 운영체제로부터 할당됨 
- 글로벌 메모리 영역과 로컬 메모리 영역의 차이는 mysql 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 아닌지에 따라 구분됨

**글로벌 메모리 영역**

- 일반적으로 클라이언트 스레드의 수와 무관하게 일반적으로는 하나의 메모리 공강만 할당, 필요에 따라 2개 이상의 메모리 공간을 할당받을 수 있지만 클라이언트 스레드의 수와 무관하고 생성된 글로벌영역은 모든 스레드의 의해 공유됨

**로컬 메모리 영역**

- 세션 메모리 영역이라도 불림
- mysql 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용되는 메모리 영역
- 로컬 메모리는 각 클라이언트 스레드 별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징

### 플러그인 스토리지 엔진 모델

- mysql 독특한 구조중 하나가 바로 플러그인 모델, 직접 제작도 가능함
- sql 파서 -> sql 옵티마이저 -> sql 실행기 -> 데이터 읽기/ 쓰기 -> DB
- 위 과정에서 마지막 데이터 읽기/쓰기 과정만 스토리지 엔진에 의해 처리됨 나머지는 mysql  엔진에서 처리
- 데이터 읽기/쓰기 작업은 대부분 1건의 레크도 단위로 처리됨
- mysql 서버에서는 mysql 엔진이 사람역하을 하고 각 스토리지 엔진은 자동차 역할을 하게 됨. mysql 엔진이 스토리지 엔진을 조정하기 위해 핸들러 라는것을 사용함
- mysql 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 핸들러를 사용한다는 점만 기억하면 됨
- 실질적인 group by oder by 등 많은 복잡한 처리는 스토리지 엔진 영역이 아니라 mysql 엔진의 처리 영역인 쿼리 실행기에서 실행됨

![](https://www.dbrnd.com/wp-content/uploads/2016/01/MySQLShowEngines.png)

- 이거말고 조금 더 있음
- 플러그인형식으로 스토리지 엔진을 쉽게 설치 가능함



### 쿼리 실행 구조



**파서**

- 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미
- 쿼리 문장의 기본 문접 오류는 이 과정에서 발견되고 사용자에게 오류 메시지를 전달하게 됨

**전처리기**

- 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인함
- 실제 존재하지 않거나 권한상 사용 불가한 토큰의 경우 이 단계에서 걸러짐

**옵티마이저**

- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 담당
- 매우 중요함

**실행 엔진**

- 옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발에 비유할 수 있음

- 옵티마이저가 group by를 처리하기위해 임시테이블을 사용하기로 결정했다면 다음과 같은 과정

  1. 실행 엔진은 핸들러에게 임시 테이블을 만들라고 요청

  2. 다시 실행 엔진은 where 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청

  3. 읽어온 레코드들을 1번에서 준비한 임시테이블로 저장하라고 다시 핸들러에게 요청

  4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어오라고 핸들러에게 다시 요청

  5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

     즉 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행

**핸들러 (스토리지 엔진)**

- mysql 서버 가장 밑단에서 mysql 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당
- 핸드럴 == 스토리지 엔진
- myisam 테이블을 조장하면 핸들러가 myisam 스토리지엔진 <- 이런식임



### Replication

- 복제는 2대 이상의 mysql 서버가 동일한 데이터를 담도록 실시간으로 동기화 하는 기술
- 쓰기는 마스터 읽기는 슬레이브
- mysql 서버의 복제에서는 마스터는 반드시 1개 슬레이브는 1개 이상으로 구성될 수 있음



**마스터**

- 기술적으로는 mysql의 바이너리 로그가 활성화되면 어떤 mysql 서버든 마스터가 될 수 있음
- 데이터가 생성 및 변경, 삭제되는 주체
- dml,ddl을 바이너리 로그에 기록
- 슬레이브는 변경 내역을 요청하면 바이너리 로그에서 읽어서 슬레이브로 넘김
- 마스터의 프로세스중 "Binlog dump"라는 스레드가 이 일을 전담함 슬레이브 수대로 스레드가 존재



**슬레이브**

- 데이터를 받아올 마스터 장비의 정보를 갖고 있는 경우 슬레이브가 됨
- 슬레이브 서버는 릴레이 로그를 갖고 있음
- 슬레이브는 읽기 전용
- 슬레이브 서버의 i/o 스레드는 마스터 서버에 접속해 변경 내역을 요청하고 받아 온 변경 내역을 릴레이 로그에 기록함
- 슬레이브 서버의 sql 스레드가 릴레이 로그에 기록된 변경 내역을 재실행 함으로 마스터와 동일한 상태로 유지함
- i/o 스레드는 슬레이브에만 있음



**복제시 주의사항**

- 슬레이브는 하나의 마스터만 설정 가능
- 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정
- 슬레이브 서버용 장비는 마스터와 동일한 사양이 적합
- 복제가 불필요한 경우에는 바이너리 로그 중지
- 바이너리 로그와 트랜잭션 격리 수준

> - 5.1에서는 Statement based replcation, Row based replication이 지원됨
> - sql 기반의 복제는 아무리 많은 데이터의 변경을 유발하더라도 sql 문장 하나만 슬레이브로 전달되기때문에 네트워크 트래픽을 많이 유발하지 않음 <- but repeatable-read 이상의 트랜잭션 격리 수준을 사용해야 하고 innodb 테이블에서는 레코드 간의 간격을 잠그는 갭 락이나 넥스트 키락이필요해짐
> - 레코드 기반으로 하면 트래픽이 많아지지만 read-commited 격리수준에도 동작하며 innodb테이블에서 잠금 경합이 줄어듬

### 쿼리 캐시

- mysql에만 있음
- sql 문장을 캐시하는게 아니라 쿼리 결과를 메모리에 캐시해두는 기능
- map과 같은 데이터 구조로 구현되어 있음 키는 sql 쿼리 문장, 값은 실행 결과
- 쿼리 캐시 결과 확인 절차를 가짐
  - 요청된 쿼리 문장이 쿼리 캐시에 존재하는가?
  - 해당 사용자가 그 결과를 볼 수 있는 권한을 갖고 있는가?
  - 트랜잭션 내에서 실행된 쿼리인 경우 가시 범위 내에 있는 결과인가?
  - 호출 시점에 달라 결과가 달라지는 요소가 있는가?
  - 프리페어 스테이트먼트의 경우 변수가 결과에 영향을 미치지 않는가?
  - 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가?
  - 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가?
  - 그 밖에 쿼리 캐시를 사용하지 못하게 만드는 요소가 있는가?
- `show global status` 명령을 이용해 쿼리 캐시의 사용량과 정보를 확인 가능
- Com_select (엔진이 처리)+ Qcache_hits (캐시 hit) = mysql 서버로 요청된 모든 select 문장
- 쿼리 캐시 히트율% = Qcache_hits  / (Qcache_hits + Com_select) * 100
- 쿼리 캐시율이 20% 이상이면 좋다고 이야기하는데 그냥 시기적절하게 잘 사용하는게 중요함
- 쿼리 캐시를 사용하지 않는 설정

```
query_cache_size = 0
query_cache_type = 0
```





## InnoDB 스토리지 엔진 아키텍처

- mysql에서 사용할 수 있는 스토리지 중 거의 유일하게 레코드 기반의 잠금을 제공
- 높은 동시성처리와 안정적, 성능 또한 뛰어남

![public](https://user-images.githubusercontent.com/30790184/98905454-c75d3680-24fe-11eb-8bc6-373681f016ae.jpeg)



### InnoDB 스토리지 엔진의 특성

**프라이머리 키에 의한 클러스터링**

- InnoDB의 모든 테이블은 기본적으로 키를 기준으로 클러스터링 되어 저장됨 이로 인해 pk에 의한 레인지 스캔은 상당히 빠르게 처리됨
- 결과적으로 쿼리의 실행 계획에서 pk는 다른 보조인덱스에 비해 비중이 높음 
- 오라클의 IOT(Index organized table)과 동일한 구조가 InnoDB에서는 일반적인 테이블 구조

**잠금이 필요없는 일관된 읽기 (None-locking consistent read)**

- InnoDB 스토리지엔진은 MVCC(Multi Version Concurrency Control) 이라는 기술을 이용해 락을 걸지 않고 읽기 작업을 수행함
- 락을 걸지 않기 때문에 읽기 작업은 다른 트랜잭션이 가지고 있는 락을 기다리지도 않음 SERIALIZABLE은 제외

**외래 키 지원**

- 외래키는 myisam에서 사용불가 innodb만 가능
- innodb에서 외래키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고 변경 시에 반드시 부모 테이블이나 자식 테이블에 데이터가 있는 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고 그로 인해 데드락이 발생할 때가 많음

**자동 데드락 감지**

- InnoDB는 그래프 기반의 데드락 체크 방식을 사용함. 데드락이 발생함과 동시에 바로 감지되고 감지된 데드락은 관련 트랜잭션 중에서 rollback이 가장 용이한 트랜잭션(복구 작업이 가장 적은 트랜잭션)을 자동적으로 강제 종료해버림
- 데드락 때문에 쿼리가 제한시간에 도달한다거나 슬로우 쿼리로 기록되는 경우가 많지 않음

**자동화된 장애 복구**

- 손실이나 장애로부터 데이터를 보호하기 위한 여러가지 메커니즘이 탑재되어 있음

**오라클 아키텍처 사용**

- innodb는 오라클과 상당히 비슷한 부분이 많음 ex mvcc 기능 등등



### InnoDB 버퍼 풀

- InnoDB에서 가장 핵심적인 부분
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
- 쓰기 작업을 지연시켜 일괄 작업을 처리할 수 있는 버퍼공간
- myisam은 키 캐시가 인덱스의 캐시만을 주로 처리하는데 비해 innodb의 버퍼 풀은 데이터와 인덱스 모두 캐시하고 쓰기 버퍼링의 역할까지 모두 처리함
- innodb의 버퍼 풀은 많은 백그라운드 작업의 기반이 되는 메모리 공간임 따라서 버퍼 풀 크기를 신중하게 설정하는 것이 좋음 (innodb_buffer_pool_size)
- 적절하게 설정해야하고 일반적으로 전체 장착된 물리 메모리의 50~80% 수준에서 버퍼 풀의 메모리 크기를 결정함
- innodb 버퍼 풀은 아직 디스크에 기록되지 않은 변경된 데이터를 갖고 있음 (더티 페이지라 함 )



### undo 로그

- update 문장이나 delete 문장으로 데이터를 변경했을때 변경되기 전의 데이터를 보관하는 곳
- 사용자가 커밋하면 적용된 그대로 유지되고 롤백하면 언두 영역의 백업 데이터를 다시 데이터 파일로 복구함
- 언두 용도
  - 트랜잭션 롤백 대비용
  - 트랜잭션 격리 수준을 유지하면서 높은 동시성을 제공하는데 사용됨



### 인서트 버퍼

- rdbms에서 insert나 update에 데이터 파일을 변경하는 작업 뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요함
- 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 인덱스가 많다면 자원소모가 많음
- innodb는 변경해야할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행함 그렇지 않으면 임시 공간에 저장해두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시킴 이 때 사용하는 임시 메모리 공간을 인서트 버퍼라고함
- 유니크 인덱스는 인서트 버퍼를 사용할 수 없음
- 5.5이전까지는 insert에만 가능했으나 5.5 이후부터는 insert delete인해 키를 추가하거나 삭제하는 작업에도 버퍼링이 될 수 있게 개선
- 5.5 이후부터는 innodb_change_buffering이라는 파라미터로 종류별로 인서트 버퍼를 활성화 가능



### redo 로그 및 로그 버퍼

- 쿼리 문장으로 데이터를 변경하고 커밋하면 dbms는 데이터의 acid 보장을 위해 변경된 내용을 데이터 파일로 기록해야함 <- 상당한부하 작업
- 따라서 대부분 dbms에는 버퍼링을 위한 버퍼풀과 같은 장치가 있지만 이 장치만으로 acid를 보장할수는 없음
- 따라서 이를 위해 변경된 내용을 순차적으로 디스크에 기록하는 로그 파일을 갖고 있는데 이게 리두 로그임
- 리두로그 덕분에 dbms 데이터는 버퍼링을 통해 한꺼번에 디스크에 변경된 내용을 처리할 수 있고 성능 향상을 기대할 수 있게 됨
- 변경작업이 매우 많은 dbms 서버의 경우 이 리두 로그의 기록 작업이 큰 문제가됨 <- 이런 부분을 보완하기 위해 최대한 acid 속성을 보장하는 수준에서 버퍼링함
- 리두 로그 버퍼링에 사용되는 공간이 로그 버퍼임
- 로그 버퍼의 크기는 1~8m수준이 좋고 blob이나 text같은 큰 데이터의 변경이 많으면 더 크게



### MVCC(Multi Version Concurrency Control)

- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 dbms가 제공하는 기능
- 잠금을 사용하지 않는 일관된 읽기를 제공함
- innodb는 언두 로그를 이용해 이기능을 구현함
- 멀티 버전은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미



### 잠금 없는 일관된 읽기(Non-locking consistent read)

- innodb에서 격리수준이 serializable이 아닌 read-uncommited나 read-commited 그리고 repeatable-read 수준인 경우 inserrt와 연결하지 않은 순수한 읽기 작업은 다른 트랜잭션의 변경과 관계 없이 항상 잠금을 대기하지 않고 바로 실행됨 <- 잠금 없는 일관된 읽기
- innodb의 언두로그를 사용함
- 오랜 시간동안 활동하는 트랜잭션이 있을 경우 일관된 읽기를 위해 언두 로그를 삭제하지 못해 성능저하가 있을 수 있음 트랜잭션은 최대한 빨리 끝낼것



### innodb와 myisam 스토리지 엔진 비교

- 5.5부터는 innodb가 기본 엔진
- innodb가 짱좋음



### innodb와 memory 스토리지 엔진 비교

- memory는 모두 메모리에 저장하기때문에 작업이 매우 빠름 but 테이블락



## MyISAM 스토리지 엔진

- 생..략

## MEMORY 스토리지 엔진 아키텍처

- 생략

## NDB 클러스터 스토리지 엔진

- 생략



## TokuDB

- 빠르게 증가하는 대용량 데이터를 관리하는 것이 주 특기
- 이외 생략 



## 전문 검색 엔진

- 생략



## MySQL 로그 파일

### 에러로그파일

- mysql config 파일에 log_error 라는 파라미터로 정의된 경로의 파일이거나  없는 경우 datadir에 .err 확장자가 붙은 파일
- 시작시점, 비정상종료일때 트랜잭션 복구 메시지, 쿼리 도중 에러 메시지 등등이 자주 발생함

### 제너럴 쿼리 로그 파일

- 쿼리 전체 목록 로그 파일
- general-log 라는 이름의 파라미터에 정의된 경로에 있는 파일 5.1.12이상에서는 general_log_file

### 슬로우 쿼리 로그 

- mysql 서버의 쿼리 튜닝은 서비스가 적용되기 전에 전체적으로 튜닝하는 경우와 서비스 운영 중에 mysql 서버의 전체적인 성능 저하를 검사하거나 정기점검을 위한 튜닝으로 나눌 수 있음
- 어떤 쿼리가 문제인지 판단하기가 상당히 어려움
- 슬로우 쿼리 로그 파일에는 long_query_time 파라미터 이상 소요된 쿼리가 모두 기록됨
- 반드시 완료되어야 슬로우쿼리로그에 기록됨

### 바이너리 로그와 릴레이 로그

- 바이너리로그 파일은 마스터에 릴레이로그는 슬레이브에 생성
- 바이너리로그에는 select 같이 데이터 구조나 내용을 변경하지 않는 쿼리는 기록되지 않음
- 바이너리로그는 이진 파일로 되어있어서 직접 확인 불가능 mysqlbinlog를 사용할 것





# #4 트랜잭션과 잠금



## 트랜잭션

### MySQL에서의 트랜잭션

- innodb는 쿼리중 일부라도 오류가 발생하면 전체를 원상태로 만들어둠
- myisam에는 부분업데이트가 일어남 부분업데이트는 데이터 정합성에 큰 문제임

### 주의사항

- 트랜잭션은 필요한 최소의 코드에만 적용하는 것이 좋음
- 원격작업이 묶인 트랜잭션은 치명적일 수 있음



## MySQL 엔진의 잠금

- 스토리지 엔진 레벨과 mysql 엔진 레벨로 나뉨
- mysql 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않음\
- mysql 엔진에서는 테이블락 말고 유저락, 테이블 명에 대한 잠금을 위한 네임락도 제공함



### 글로벌 락

- 글로벌락은 FLUSH TABLES WITH READ LOCK 명령으로만 획득 가능하고 mysql에서 제공하는 잠금 가운데 가장 범위가 큼
- 세션단위로 동작함 mysql 서버 전체의 테이블에 락을 검
- select를 제외한 모든 문장이 글로벌락이 해제될 때까지 대기상태로 남음
- 잘못사용하면 큰일남
- mysqldump라는 백업프로그램에서 사용할 수도 있음 잘 체크해볼것

### 테이블 락

- 개별 테이블 단위로 설정되는 잠금, 명시적 또는 묵시적으로 테이블의 락 획득 가능
- 테이블락은 myisam, innodb 모두 사용 가능
- LOCK TABLE table_name [READ | WRITE] 으로 명시적으로 획득 가능
- UNLOCK TABLES로 잠금 반납가능
- 특별한 상황이 아니면 사용할일이 없음 잘못사용하면 큰일남
- 묵시적인 테이블락은 myisam이나 memory 테이블에 데이터를 변경하는 쿼리를 실행하면 발생함 
- 묵시적 테이블 락은 쿼리가 실해오디는 동안 자동적으로 획득됐다가 쿼리가 완료된 후 자동 해제됨
- innodb는 레코드기반 락이기때문에 묵시적 테이블락이 설정되지 않음
- 정확히는 ddl의 경우에만 테이블락이 설정됨



### 유저 락

- GET_LOCK() 함수를 이용해 임의로 잠금 설정 가능
- 유저락은 테이블, 레코드 같은 대상이 아니라 사용자가 지정한 문자열에 대해 획득 및 반납하는 잠금임
- 자주 사용되지 않음
- 많은 레코드를 한번에 변경하는 트랜잭션의 경우 유용하게 사용 가능



### 네임 락

- 데이터베이스 객체의 이름을 변경하는 경우 획득하는 잠금
- READ TABLE tab_a TO tab_b 와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금, 원본과 대상 둘다 잠금



## MyISAM과 MEMORY 스토리지 엔진의 잠금

- 이 두 엔진은 자체적인 잠금을 가지지 않고 mysql에서 제공하는 테이블락을 그대로 사용함
- 쿼리단위로 필요한 잠금을 한꺼번에 모두 요청해서 획득하기 때문에 데드락이 발생할 수 없음
- momory, archive, merge 등과 같은 스토리지 엔진에도 아래 내용이 똑같이 작동함



### 잠금 획득

**읽기잠금**

- 테이블에 쓰기 잠금이 걸려있지 않으면 바로 읽기 잠금을 획득하고 읽기 작업 시작 가능

**쓰기 잠금**

- 테이블에 아무런 잠금이 걸려있지 않아야만 쓰기 잠금 가능
- 다른 잠금이 해제될 때까지 대기



### 잠금 튜닝

- SHOW STATUS LIKE 'Table%'

```
Table_locks_immediate	12428
Table_locks_waited	0
Table_open_cache_hits	1
Table_open_cache_misses	0
Table_open_cache_overflows	0
```

- Table_locks_immediate: 다른 잠금이 풀리기를 기다리지 않고 바로 잠금을 획득한 횟수
- Table_locks_waited: 다른 잠금이 이미 해당 테이블을 사용하고 있어서 기다려야 했던 횟수를 누적해서 저장함
- 잠금 대기 쿼리 비율 = Table_locks_waited / (Table_locks_waited + Table_locks_immediate) * 100
- 잠금 대기 쿼리 비율이 높다면 innodb로 변환 방법을 고려하는게 좋음
- innodb는 레코드 락

### 테이블 수준의 잠금 확인 및 해제

- SHOW OPEN TABLES [FROM table_name];
- in_use값은 해당 테이블을 잠그고 있는 클라이언트 수 + 대기하는 클라이언트 수
- name_locked는 alter table 또는 rename
- SHOW PROCESSLIST 명령으로 실시간 잠금 현황 확인 가능
- KILL QUERY 클라이언트_id 로 클라이언트 커넥션 종료 가능



## InnoDB 스토리지 엔진의 잠금

- mysql 엔진에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 락 기능을 탑재
- myisam보다 훨씬 뛰어난 동시성 처리 제공 가능
- 이원화된 잠금 처리탓에 innodb 스토리지 엔진에서 사용되는 잠금에 대한 정보는 mysql 명령을 이용해 접근하기가 상당히 까다로움
- 5.1 이후부터 innodb의 트랜잭션,잠금, 잠김 대기중인 트랜잭션 목록 조회하는 방법이 도입됨

### InnoDB의 잠금 방식

**비관적 잠금**

- 현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식을 비관적 잠금이라함
- 일반적으로 높은 동시성 처리에는 비관적 잠금이 유리하다고 알려져 있음 innodb는 비관적 잠금



**낙관적 잠금**

- 기본적으로 각 트랜잭션이 같은 레코드를 변경할 가능성이 상당히 희박할때 낙관적 잠금이라함
- 따라서 우선 변경 이후 마지막에 잠금 충돌이 있는지 확인 후 rollback함

### innodb 의 잠금 종류

- 잠금 정보가 상당히 작기때문에 레코드락이 페이지락 또는 테이블락으로 레벨업되는 경우가 없음
- 레코드와 레코드 사이의 간격을 잠그는 것을 갭락이라고 함

**레코드 락**

- 레코드 자체만 잠그는 것을 레코드락
- innodb 스토리지 엔진은 레코드 자체가 아니라 인덱스 레코드를 잠근다는 것
- 없더라도 클러스터 인덱스를 이용해 잠금



**갭 락**

- 갭락은 레코드와 바로 인접한 레코드 사이의 간격만 잠그는 것을 의미
- 갭락은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어함
- 개념일뿐이고 자체적으로 사용되지 않음 넥스트 키 락의 일부로 사용

**넥스트 키 락**

- 레코드 락과 갭 락을 합쳐놓은 형태의 잠금을 넥스트 키 락이라고함
- statement 포맷의 바이너리 로그를 사용하는 mysql 서버에는 repeatable read 격리수준을 사용해야함
- innodb의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어 난 결과와 동일한 결과를 만들어내보도록 보장하는 것이 주 목적임
- 으외로 넥스트 키락과 갭락으로 인한 데드락이 발생하거나 트랜잭션 대기가 자주 있으
- 가능하다면 바이너리 로그 포맷을 row형태로 바꿔서 넥스트 키락이나 갭락을 줄이는 것이 좋음 <- 아직 안정성을 확인하기 어려움



**자동 증가 락**

- auto_increment락이라고 하는 테이블 수준의 잠금을 사용함
- 이 락은 트랜잭션과 관계없이 값을 가져오는 순간만 락이 걸렸다가 즉시 해제됨
- 명시적으로 락 획득 불가
- 아주 짧게 적용되기때문에 문제될일 없음
- 5.1이후에 innodb_autoinc_lock_mode로 작동 방식을 제어 가능 함



### 인덱스와 잠금

- innodb의 잠금과 인덱스는 상당히 중요한 연관관계가 있음
- innodb는 레코드를 잠그는 것이 아니라 인덱스를 잠금
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 함
- 인덱스가 걸린 레코드는 모두 잠금
- 만약 인덱스가 없다면 모든 레코드를 잠금
- 따라서 innodb에서 인덱스 설계가 매우 중요함



### 트랜잭션 격리 수준과 잠금

- 불필요한 레코드의 잠금 현상은 innodb의 넥스트 키 락 때문에 발생함
- 이 넥스트 키 락을 필요하게 만드는 주 원인은 바로 복제를 위한 바이너리 로그 때문임
- row based 로그를 사용하거나 바이너리 로그를 사용하지 않으면 갭락이나 넥스트 키 락의 사용을 대폭 줄이므로 더 많은 요청을 처리할 수 있게 됨
- 다음 조합으로 mysql 서버가 기동하는 경우에 innodb에서 사용되는 대부분의 갭락이나 넥스트키락을 제거 가능

| 버전           | 설정의 조합                                                  |
| -------------- | ------------------------------------------------------------ |
| mysql 5.0      | innodb_locks_unsafe_for_binlog=1<br /> 트랜잭션 격리 수준을 read commited로 설정 |
| mysql 5.1 이상 | 바이너리 로그를 비활성화 트랜잭션 격리수준을 read-commited로 설정<br />레코드 기반의 바이너리 로그 사용<br />innodb_locks_unsafe_for_binlog=1<br />트랜잭션 격리 수준을 read-commited로 설정 |

- 이 조합이라도 유니크키나 외래키에 대한 갭 락은 없어지지 않음



### 레코드 수준의 잠금 확인 및 해제

- 테이블락보다 레코드락이 더 복잡함
- 5.0에서는 더힘들고 5.1부터는 확인이 좀 더 수월함
- 5.0에서는 공통적으로 특정 테이블의 레코드를 변경하거나 삭제하려고 하는 쿼리가 표시되는 것이 일반적, 구 중에서 활성화상태면서 아무런 sql도 실행하지 않는 트랜잭션이 있다면 이것이 문제일 가능성이 높음
- 근본적으로 찾기 어렵다면 오래기다리고 있는 트랜잭션의 커넥션을 모두 종료하는게 빠른 해결책
- 5.1 이상에서는 INFORMATION_SCHEMA라는 DB에 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAIT라는 테이블을 사용할 것
- INNODB_LOCKS는 어떤 잠금이 존재하는지 관리, INNODB_TRX는 어떤 트랜잭션이 어떤 클라이언트에 의해 기동되며 어떤 잠금을 기다리고 있는지, INNODB_LOCK_WAITS 테이블은 잠금에 의한 프로세스 간의 의존 관계를 관리하게됨



## mysql의 격리 수준

- read uncommited, read commited, repeatable read, rerializable 4가지로 나뉨
- read uncommited, serializable 은 잘 사용되지 않음
- innodb에서 repeatable read 격리수준에서는 phantom read가 발생하지 않음
- 오라클은 read commited, mysql에는 repeatable read를 주로 사용함

### READ UNCOMMITED

- DIRTY READ, 정말 위험할 수 있음 사용하지 말 것

### READ COMMITED

-  오라클의 기본 격리 수준, 온라인 서비스에서 가장 많이 선택되는 격리 수준
-  어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있음
-  NOT REPEATABLE READ가 발생함

### REPEATABLE READ

- mysql innodb 엔진에서 기본적으로 사용, 바이너리 로그를 가진 mysql 장비에서는 최소 repeatable read 수준 이상을 사용해야함
- mvcc를 사용함 rollback 가능성을 대비해 레코드를 언두 공간에 백업해두고 실제 레코드 변경
- 어떤 트랜잭션 A와 B가 있다고 가정했을때 A 또는 B 에서 시작된 트랜잭션은 항상 같은값만 반환함
- PHANTOM READ가 발생함

### SERIALIZABLE

- 이 레벨의 경우 읽기 작업도 공유잠금을 획득해야하는 매우 엄격한 격리 수준
- mysql innodb에서는 repeatable read에서 phantom read가 발생하지 않으므로 쓸일이 없음



- 사실 READ COMMITED와 REPEATABLE READ의 성능차이는 크지 않음



# #5 인덱스

## 디스크 읽기 방식

- 데이터베이스의 성능 튜닝은 어떻게 디스크 io를 줄이느냐가 관건인것이 많음

### 저장 매체

- 일반적인 서버에 사용되는 저장 매체
  - 내장디스크
  - DAS (Direct Attached Storage)
  - NAS (Network Attached Storage)
  - SAN (Storage Area Network)
- 내장디스크는 일반적인 pc의 디스크, 용량 문제가 있음
- DAS도 내장디스크와 비슷함 대용량 디스크가 필요할때 사용가능, 본체 한대와만 연결이 가능해서 디스크 정보를 다른 컴퓨터와 공유 불가능
- DAS의 단점을 NAS와 SAN으로 해결 가능
- NAS는 TCP/IP로 연결해서 공유 가능함, DAS보다 느림
- SAN은 DAS로는 구축할 수 없는 아주 대용량의 스토리지 공간을 제공함. 컴퓨터 본체들과 광케이블로 연결되고 빠르고 안정적, 비쌈

### 디스크 드라이브와 솔리드 스테이트 드라이브

- ssd의 장점은 랜덤 io가 훨씬 빠르다는 것

### 랜덤 io와 순차 io

- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하느냐에 의해 결정됨
- 순차 io가 랜덤 io보다 빠름
- 데이터베이스의 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 mysql 서버에서는 그룹 커밋이나 버이너리 로그 버퍼 또는 inndb 로그 버퍼 기능이 내장된 것

> - 인덱스 레인지 스캔은 랜덤 io
> - 풀 테이블 스캔은 순차 io



## 인덱스란?

- 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어둠
- 키를 기반으로 정렬시켜놓아서 빠르게 찾을 수 있게 해둠
- 인덱스는 항상 정렬된 상태로 유지함
- 인덱스가 많은 테이블은 insert, update delete 문장의 처리가 늦어짐 하지만 select는 매우 빠름
- 인덱스를 구분해본다면 primary key와 secondary key가 있음
- 프라이머리키는 대표적으로 그 테이블을 대표하는 컬럼의 값으로 만들어진 인덱스고 프라이머리 키를 제외한 모든 인덱스는 보조인덱스임
- 데이터 저장방식은 대표적으로 b-tree hash 인덱스로 구분할 수 있음
- hash 방식은 값의 일부만 검색할 수 없음, 메모리기 반 db에서 많이 사용함
- Fractal-tree 알고리즘도 있는데 b-tree랑 비슷하지만 데이터 저장 삭제시 처리 비용을 상당히줄일 수 있게 설계된 것이 특징임
- 데이터 중복 허용 여부로 분류하면 유니크 인덱스와 유니크하지 인덱스로 구분 할 수 있음
- dbms의 옵티마이저에게 중복 여부는 상당히 중요함 유니크인덱스에 대해 equal 으로 검색하면 1건의 레코드만 찾으면 더이상 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효고임
- 기능별로 분류하면 전문 검색이나 공간 검색용 인덱스 등이 있음



## B-Tree 인덱스

- Balanced Tree
- b-tree는 최상위에 하나의 루트노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태
- 루트, 브랜치, 리프노드 순서로 되어있음
- b-tree에서 바라보는 파일시스템들은 정렬된 상태가아님 but 클러스터 인덱스는 pk 순서대로 정렬된 상태
- 인덱스는 테이블의 키 칼럼만 갖고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야함



### B-tree 인덱스 키 추가 및 삭제

**인덱스 키 추가**

- b-tree에 저장될 때는 저장될 키 값을 이용해 b-tree 상의 적절한 위치를 검색해야함
- 리프노드가 꽉 찼을때는 상위 브랜치노드까지 영향을 주는데 이러한 작업이 b-tree에서 쓰는 비용이 많다고 알려짐
- 비용들 대부분은 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야하기때문에 오래걸리는것
- myisam이나 memory 스토리지엔진은 insert 즉시 b-tree 인덱스에 반영하고 작업완료까지 클라이언트는 기다림
- innodb는 상황에따라 적절하게 인덱스 키 추가 작업을 지연시켜 나중에 처리할지 아니면 바로 처리할지 결정함
  1. 사용자의 쿼리 실행
  2. innodb의 버퍼 풀에 새로운 키 값을 추가해야 할 페이지가 존재(b-tree의 리프노드)한다면 즉시 키 추가 작업 처리
  3. 버퍼 풀에 b-tree 리프 노드가 없다면 인서트 버퍼에 추가할 키 값과 레코드의 주소를 임시로 기록해두고 작업 완료
  4. 백그라운드 작업으로 인덱스 페이지를 읽을 때마다 인서트 버퍼에 머지해야 할 인덱스 키 값이 있는지 확인한 후 있다면 병합
  5. db 서버 자원의 여유가 생기면 mysql 서버의 인서트 버퍼 머지 스레드가 조금씩 인서트 버퍼에 임시 저장된 인덱스 키오 ㅏ주소 값을 머지
- 5.1 이하에서는 insert만 지연처리 5.5 이사엥서는 insert delete 둘다 됨
- 5.1 이하에서는 인서트 버퍼링, 5.5이상에서는 체인지 버퍼링



**인덱스 키 삭제**

- b-tree는 키 삭제가 상당히 간단함 리프노드를 찾아서 삭제만 마크하면 작업 완료

**인덱스 키 변경**

- b-tree에서는 키 값 변경 작업은 먼저 키값을 삭제한 후 다시 새로운 키값을 추가하는 형태



**인덱스 키 검색**

- b-tree인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용 가능, 부등호 비교나 값의 뒷부분이 일치하는 경우에는 b-tree인덱스를 이용한 검색이 불가능함
- 이미 변형된 값 (함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업)은 b-tree의 장점을 이용할 수 없음
- innodb테이블에서 지원하는 레코드 잠금이나 넥스트 키 락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 되어있음 따라서 update나 delete 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠금



### b-tree 인덱스 사용에 영향을 미치는 요소

**인덱스 키값의 크기**

- innodb에서 디스크의 모든 읽기 쓰기 작업의 최소단위는 페이지 또는 블록이라고 함 또한 페이지는 innodb 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위임
- 인덱스도 결국 페이지 단위로 관리됨
- 인덱스의 페이지 크기와 키 값의 크기에 따라 자식노드의 개수가 결정됨
- 결론적으로 키 값의 크기가 커질수록 효율이 떨어짐

**B-tree 깊이**

- 깊이는 상당히 중요하지만 직접적으로 제어할 방법이 없음
- 결론적으로 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 잇는 인덱스 키값의 개수가 작아지고 그 때문에 같은 레코드 건수라 하더라도 b-tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게된다는 것을 의미함
- 인덱스의 키값의 크기는 가능하면 작은게 좋고 아무리 대용량 데이터베이스라도 깊이가 4~5이상까지 깊어지는경우는 거의 발생하지 않음

**선택도(기수성)**

- 인덱스에서 선택도 = 기수성임 카디널리티
- 전체인덱스 키값은 100개인데 유니크한 값의 수는 10개라면 기수성은 10임 
- 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리함
- 인덱스의 선택도가 높을수록 미리 걸러지는 레코드의 수가 많아짐



**읽어야 하는 레코드의 건수**

- 인덱스를 통해 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이드는 작업임
- 인데스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는것보다 4~5배정도 비용이 많이든다고 예측함
- 전체테이블의 20~25를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는 방식으로 처리하는게 좋음



### B-tree 인덱스를 통한 데이터 읽기

- mysql이 인덱스를 이용하는 대표적인 방법

**인덱스 레인지 스캔**

- 가장 대표적인 접근 방식
- 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현함
- 루트 -> 브랜치 -> 리프로 한번 전체 스캔하고 range를 정하고 range에서의 데이터를 클라이언트에게 반환함
- 별도의 정렬과정 없이 인덱스 자체의 정렬 특성때문에 정순 또는 역순으로 레코드를 불러옴
- 검색결과가 많으면 풀스캔이 나음



**인덱스 풀 스캔**

- 인덱스의 처으부터 끝까지 모두 읽는 방식
- 대표적으로 쿼리의 조거넞ㄹ에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용됨
- 예를들어 인덱스는 a,b,c 순서로 만들어졌지만 쿼리 조건절은 b, c 로시작하는 경우
- 쿼리가 인덱스에 명시된 컬럼만 조건을 처리할 수 있는 경우 이방식으로 사용되고 다른 레코드를 읽어야 한다면 절대 이방식으로 처리되지 않음
- 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 뒤 처음부터 끝까지 스캔함
- 인덱스 레인지 스캔 > 인덱스 풀 스캔 > 테이블 풀 스캔으로 검색속도가 빠른정도

**루스 인덱스 스캔**

- 오라클에 인덱스 스킵 스캔이랑 비슷함
- 루스 인덱스 스캔은 느슨하게 또는 듬성듬성하게 인덱스를 읽음
- 인덱스 레인지 스캔과 비슷하지만 필요하지 않은 인덱스 키값은 무시하고 다음으로 넘어가는 형태로 처리
- 일반적으로 group by 또는 집합 함수 가운데 max() min()함수에 대해 최적화를 하는 경우에 사용



### 다중 칼럼 인덱스

- 실무에서는 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용됨
- 다중컬럼인덱스의 순서에 따라 정렬 순서도 바뀌기때문에 다중컬럼인덱스의 순서는 매우 중요하고 상당이 신중하게 결정해야함



### B-tree 인덱스의 정렬 및 스캔 방향

- 인덱스 키값은 항상 오름차순으로 정렬되지만 역순으로도 사용될 수 있음

**인덱스의 정렬**

- 일반적인 dbms는 asc, desc 설정이 가능하지만 mysql에서는 컬럼마다 asc, desc 별개로 적용은 안됨
- mysql에선 지정한다고 하더라도 전부 무시하고 오름차순으로만 정렬됨
- 아직까지는 방법이 없으므로 order by 에 따라 역순으로 정렬하게 해야할 수 있음
- 예를들면 order by user_name asc, user_score desc일때 user_score를 음수값으로?



**인덱스 스캔 방향**

- 인덱스를 역순으로 정렬할 순 없지만 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순정렬 효과를 얻을 수 있음



### B-Tree 인덱스의 가용성과 효율성

- 쿼리의 where, group by, order by 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 알아야함



**비교 조건의 종류와 효율성**

- = < 또는 > 에 따라 인덱스 컬럼의 활용 형태가 달라짐
- 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 필터링이라고함
- 작업 범위 결정 조건은 실제 값을 읽어오는 작업이고 작업의 범위를 줄이지 못하고 필터링하는 작업을 필터링 조건이라고함 작업 범위 결정 조건이 많을수록 쿼리 처리 능력을 높일 수 있음



**인덱스의 가용성**

- b-tree 인덱스의 특징은 왼쪽 값에 기분에서 오른쪽 값이 정렬되어 있다는 것
- like를 '%mer'로 걸면 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수 없음
- 다중 컬럼 인덱스에서 (a, b) 가 있다고 가정할때 b로만 검색해도 인덱스를 효율적으로 사용할 수 없음



**가용성과 효율성 판단**

- 기본적으로 다음 조건들은 b-tree에서 사용할 수 없음 (작업 범위 결정 조건으로 사용 불가, 경우에 따라서는 체크조건으로 사용)
  - NOT-EQUAL로 비교된 경우
    - \<\>
    - NOT IN
    - IS NOT NULL
  - LIKE가 앞부분이 아닌 뒷부분의 형태로 비교된 경우
    - LIKE '%FOO'
  - 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변경된 후 비교된 경우
    - WHERE SUBSTRING ...
    - WHERE DAYOFMONTH ...
  - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
    - WHERE column = deterministic_function()
  - 데이터 타입이 서로 다른 비교 (인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
  - 문자열 데이터 타입의 콜레이션이 다른 경우
    - WHERE utf8_bin_char_column = euckr_bin_char_column



- 다른 일반적인 dbms에서 null 값은 인덱스에 저장되지 않지만 mysql에서는 null값도 인덱스로 관리됨
- WHERE cloumn IS NULL <- 인덱스를 사용함
- 다음은 다중컬럼에서 인덱스를 사용할 수 없는 경우
- INDEX ix_test (column_1, column_2, column_3, ... column_n)이 있다고 가정
  - 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
    - column_1 칼럼에 대한 조건이 없는 경우
    - column_1 칼럼의 비교 조건이 위의 인덱스 사용불가 조건 중 하나인 경우
  - 작업 범위 결정 조건으로 인덱스를 사용하는 경우 (i는 2보다 크고 n보다 작은 임의의 값을 의미)
    - column_1~ column_(i - 1) 칼럼까지 = 로 비교
    - column_i 칼럼에 대해 다음 연산자 중 하나로 비교
      -  = , <> , like 'foo%'
- 참고
  - 다음쿼리는 인덱스 사용 불가
    - where column_1 <> 2
  - 다음 쿼리는 column_1과 column_2까지 범위 결정 조건으로 사용됨
    - where column_1 = 1 and column_2 > 10
  - 다음 쿼리는 column_1, column_2, column_3 까지 범위 결정 조건으로 사용됨
    - where column_1 in (1,2) and column_2 = 2 and column_ <= 10
  - 다음 쿼리는 column_1, column_2, column_3 까지 범위 결정 조건으로, column_4는 체크 조건으로 사용됨
    - where column_1 = 1 and column_2 = 2 and column_3 in (10, 20, 30) and column_4 <> 100
  - 다음 쿼리는 column_1, column_2, column_3, column_4 까지 범위 결정 조건으로 사용됨 좌측 패턴 일치 like 비교는 크다 작다 비교 와 동급으로 생각하면 됨
    - where column_1 = 1 and column_2 in (2,4) and column_3 = 30 and column_4 like ('foo%')
  - 다음 쿼리는 column_1, column_2, column_3, column_4, column_5 칼럼까지 모두 범위 결정 조건으로 사용됨
    - where column_1 = 1 and column_2 = 2 and column_3 = 30 and column_4 = '김승환' and column_5 = '서울'
- 위 쿼리들은 b-tree인덱스의 특징이기때문에 다른 dbms에도 적용될 수 있음





## 해시 인덱스

- 해시 인덱스는 b-tree만큼 범용적이지는 않지만 고유의 특성과 용도를 지닌 인덱스임
- 해시 인덱스는 동등 비교 검색에만 최적화되어있고 범위, 정렬은 불가능
- 주로 메모리기반 테이블에 구현됨



### 구조 및 특성

- 해시 인덱스의 가장 큰 장점은 실제 키 값과는 관계 없이 인덱스 크기가 작고 검색이 빠르다는것
- 해시 장점 그대로 사용함 버킷에서 값을 꺼내옴
- 키 칼럼의 값이 아무리 길어도 4~8 바이트 수준으로 줄어들어듬
- 버킷의 수, 충돌 수에 따라 검색 성능 결정



### 해시 인덱스의 가용성 및 효율성

- 키값 자체가 변환되기때문에 원본데이터의 정렬을 할수 없음
- 다음의 경우 해시인덱스의 성능이 좋음
  - =
  - <>
  - in
  - is null
  - is not null
- 다음의 경우 해시인덱스 사용 불가
  - \>=
  - between
  - like
  - \<\>
- 다중 컬럼 인덱스를 해시인덱스로 만들면 컬럼의 개수만큼 조건을 걸어야됨 한개만걸면 안걸림



## R-Tree 인덱스

- 공간인덱스는 r-tree 인덱스 알고리즘을 사용해서 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스
- b-tree와 흡사 b-tree는 1차원 r-tree는 2차원
- 위치기반 서비스에 사용 가능



### 구조 및 특성

- mysql은 공간 정보의 저장 및 검색을 위해 여러가지 기하학적 도형(geometry) 정보를 관리할 수 있는 데이터 타입을 제공함
- point , line, polygon ?(3개의 수퍼타입 모두 저장 가능)
- mbr이라는 개념을 알고 있어야함 Minimum Bounding Rectagle의 약자고 해당 도형을 감싸는 최소 크기의 사각형을 의미함



## Fractal-Tree 인덱스

### Fractal-Tree의 특성

- b-tree의 가장 큰 문제는 디스크 랜덤 io가 상대적으로 많이 필요하다는 것
- fractal-tree는 이런 단점을 최소화하고 순차 io로 변환해서 처리할 수 있다는 것이 가장 큰 특징
- 인덱스 추가 삭제에 b-tree보다 더 많은 정렬과 리소스를 사용할지모르지만 인덱스의 단편화가 발생하지 않도록 구성할 수 있고 인덱스 키값을 클러스터링하기 때문에 b-tree 보다 대용량 테이블에서 높은 성능을 보장함 또한 b-tree는 일정 수준을 넘어서면 급격한 성능저하가 발생하는데 fractal-tree는 이런 급격한 성능 저하 현상이 없음



### fractal-tree의 가용성과 효율성

- 가장 큰 장점은 b-tree의 장점을 그대로 갖고 있다는것 b-tree의 인덱스 사용 방법 등등 ..



## 전문 검색 인덱스

- full text 검색에는 b-tree를 사용할 수 없음 키를 짤라서 저장하기 때문에
- 전문 검색 인덱스에서는 크게 구분자, n-그램으로 나눠서 생각할 수 있음



### 인덱스 알고리즘

**구분자 기법**

- 전문의 내용을 공백이나 탭 또는 마침표와 같은 문장기호로 분석하고 인덱스로 생성해둠
- 구분가 기법은 키워를 추출해 내는 작업이 추가로 필요할 뿐이고 b-tree를 그대로 사용함

**n-그램 기법**

- 무조건적으로 몇 글자씩 잘라서 인덱싱함
- 구분자 기법보다 복잡하고 인덱스 크기도 큰 편
- 2개씩 잘라서 하는 방법이 2-gram이고 많이 사용됨



## 비트맵 인덱스와 함수 기반 인덱스

- mysql 스토리지 엔진에서 비트맵 인덱스와 함수 기반 인덱스를 지원하는 스토리지 엔진은 없음
- 우회하는 방법은 있음

## 클러스터링 인덱스

- innodb와 tokudb에만 지원됨주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것

### 클러스터링 인덱스

- 클러스터링 인덱스는 프라이머리 키에만 적용되는 내용임
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라함
- 일반적으로 innodb와 같이 항상 클러스터링 인덱스로 저장되는 테이블의 프라이머리 키 값 기반 검색은 매우 빠르고 저장이나 변경이 상대적으로 느릴 수 밖에 없음
- 클러스터링 테이블의 구조 자체는 일반 b-tree와 많이 비슷한데 인덱스의 리프노드에는 레코드의 모든 컬럼이 저장되어 있는게 특징
- 즉 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되는것
- pk가 없는 innodb 테이블은 다음 우선순위대로 pk를 대체할 칼럼을 선택함
  1. pk가 있으면 기본적으로 pk 사용
  2. not null 옵션의 유니크 인덱스 중에서 첫번째 인덱스를 클러스터 키로 선택
  3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후 클러스터 키로 선택



**보조 인덱스에 미치는 영향**

- myisam이나 memory 테이블과 같이 넌 클러스터링 테이블은 한번 저정되면 공간이동이 절대 없음
- 그래서 myisam이나 memory 에선 pk나 보조인덱스나 별 차이가 없음
- innodb 테이블의 모든 보조 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어있음

```
CREATE TABLE employees (
	emp_no INT NOT NULL,
	first_name VARCHAR(20) NOT NULL,
	PRIMARY KEY(emp_no),
	INDEX ix_firstname (first_name)
);

SELECT * FROM employees WHERE first_name='Aamer';
```

- 다음의 경우에 엔진마다 검색이 조금 다름
  - myisam
    - ix_firstname 인덱스를 검색해서 실제 레코드를 검색, 레코드의 주소를 이용해서 최종 레코드를 가져옴
  - innodb
    - ix_firstname 인덱스를 검색해 레코드의 프라이머리 키 값 확인
    - pk값을 이용해 다시한번 테이블을 검색한 후 최종 레코드를 가져옴
- 위 경우 innodb가 조금 복잡하지만 pk로 레코드를 읽어오는게 상당히 빠르므로 걱정 x



### 클러스터 인덱스의 장점과 단점

- 장점

  - pk로 검색할때 처리 성능이 매우 빠름, 범위검색이 제일빠름
  - 테이블의 모든 보조 인덱스가 pk를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음

- 단점

  - 테이블의 모든 보조 인덱스가 클러스터 키를 갖기 때문에 클러스터 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
  - 보조 인덱스를 통해 검색할 때 프라이머리 키로 다시한번 검색해야 하므로 처리 성능이 조금 느림
  - insert 할때 pk 에 의해 레코드 저장 위치가 결정되기때문에 처리 성능이 느림
  - pk를 변경할때 delete , insert가 있기때문에 처리 성능이 느림

  

  

  

### 클러스터 테이블 사용시 주의사항

**클러스터 인덱스 키의 크기**

- 클러스터 테이블의 경우 모든 보조 인덱스가 프라이머리 키 값을 포함함 그래서 pk 값 크기가 커지면 보조 인덱스도 자동으로 커짐
- 레코드수가 기하급수적으로 증가하기때문에 innodb에서는 pk를 잘 정해야함

**pk는 auto-increment보다는 업무적인 컬럼으로 생성할 것 (가능한 경우)**

- innodb는 pk를 사용해 클러스터 테이블을 구성함
- 컬럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 크 컬럼을 pk로 설정하는 것이 좋음

**pk는 반드시 명시할 것**

- 가능하면 auto-increment 컬럼을 이용해서라도 지정하는게 좋음
- 아무것도 생성하지 않으면 innodb에서 사용자에게 보이지 않는 auto-increment를 생성하기때문에(but sql에서는 사용못함) 하나 안하나 똑같으니 하는게 나음

**auto-increment 컬럼을 인조 식별자로 사용할 경우**

- pk 를 여러개로 묶을때 pk 키가 커질 수 있음 but 보조인덱스를 사용하지 않으면 괜찮음
- 보조인덱스를 사용하면 auto-increment + 보조인덱스로 사용할 것
- 이런 auto-increment 컬럼을 인조 식별자 surrogate key라고함
- 조회보다는 insert 위주의 테이블들은 auto-increment를 이용한 인조 식별자를 pk로 설정하는 것이 좋음



## 유니크 인덱스

- 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미하는데 mysql에서는 인덱스 없이 유니크 제약만 설정할 방법이 없음



### 유니크 인덱스와 일반 보조 인덱스의 비교

- 유니크인덱스와 보조인덱스는 인덱스 구조상 아무런 차이가 없음

**인덱스 읽기**

- 읽는 속도에서 별 차이가 없음
- 하나의 값을 검색하는 경우 유니크 인덱스와 보조 인덱스는 사요되는 실행 계획이 다름
- 2개 이상의 레코드를 읽느냐의 차이만 있다는 것을 의미할 뿐 일겅야 할 레코드 건수가 같다면 성능상의 차이는 미미함

**인덱스 쓰기**

- 유니크 인덱스의 키값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한단계 더 필요함
- 일반 보조인덱스의 쓰기보다 느림
- mysql에서는 유니크 인덱스에서 중복값을 체크할때 읽기잠금, 쓰기잠금을 쓰는데 이 과정에서 데드락이 아주 빈번하게 발생함



### 유니크 인덱스 사용 시 주의사항

- 꼭 필요하면 사용하고 성능을 생각하면 생성하지 않는게 좋음
- 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하기 때문에 중복생성이 필요 없음



## 외래키

- mysql 왜래키는 innodb에서만 가능
- 외래키가 설정되면 연관되는 테이블 칼럼에 인덱스까지 생성됨
- innodb의 외래키 관리에는 중요한 두가지 특성
  - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금대기)이 발생함
  - 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않음

### 자식 테이블의 변경이 대기하는 경우

- 자식 테이블의 외래키 칼럼의 변경은 부모 테이블의 확인이 필요한데 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다림
- 자식테이블의 외래키가 아닌 칼럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않음

### 부모 테이블의 변경 작업이 대기하는 경우

- 자식에서 먼저 로우락을 얻고 부모에서 cascade delete 제약의 자식 로우와 연관된 부모를 지우면 잠금됨
- 외래키를 물리적으로 생성하려면 이러한 현상으로 인한 잠금 경합까지 고려해 개발을 진행하는 것이 좋음



## 기타 주의사항

**스토리지 엔진별 지원 인덱스 목록**

- myisam: b-tree, r-tree, fulltext-index
- innodb: b-tree
- memory: b-tree, hash
- tokudb, factal-tree
- ndb: hash, b-tree

**analyze와 optimize의 필요성**

- myisam이나 innodb의 경우 인덱스에 대한 통계 정보를 관리하고 각 통계 정보를 기반으로 쿼리의 실행계획을 수립함
- innodb와 myisam 모두 칼럼의 cardinality에 의존해서 실행 계획을 수립함
- 쿼리의 실행계획이 의도했던 것과는 너무 다르게 만들어 질 때는 인덱스의 통계 정보가 실제와 너무 다르게 수집될 경우에 그럼 이 경우 analyze 명령으로 통계 정보를 다시 수집해보는 것이 좋음
  - 테이블의 데이터가 별로 없는 경우
  - 단시간에 대량의 데이터가 늘어나거나 줄어든 경우





# #6 실행 계획

## 개요

### 쿼리 실행 절차

- mysql 서버에서 쿼리가 실행되는 과정 3가지
  1. 사용자로부터 요청된 sql 문장을 잘게 쪼개서 mysql 서버가 이해할 수 있는 수준으로 분리함
  2. sql의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
  3. 두번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴
- 첫번째 단계를 sql 파싱이라고하고 mysql 서버의 sql 파서라는 모듈로 처리함 만약 sql 문장이 문법적으로 잘못되었다면 여기서 걸러짐, 이 단계에서 sql 파스 트리가 만들어지고 sql 서버는 파스 트리를 이용해 쿼리를 실행
- 두번째 단계에서는 다음 내용 처리
  - 불필요한 조건의 제거 및 복잡한 연산의 단순화
  - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
  - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
  - 가져온 레코드들은 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
- 두번째 단계는 최적화 및 실행 계획 수립단계고 mysql 옵티마이저에서 처리함
- 세번째 단계는 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고 mysql 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행함
- 첫번째 두번째 단계는 거의 mysql 엔진에서 처리하며 세번째 단계는 mysql 엔진과 스토리지 엔진이 동시에 참여해서 처리함



### 옵티마이저의 종류

- 옵티마이저는 db에서 두뇌와 같은 역할을 담당
- 대부분의 dbms는 비용 기반 최적화 방법과 예전 오라클에서 많이 사용했던 기반 최적화 방법으로 크게 나눠볼 수 있음
- 규칙 기반 최적화
  - 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
  - 통계정보를 조사하지 않고 실행 계획이 수립되기 때문에 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어냄
  - 거의 안쓰고 업데이트도 안됨 지원도 잘 안됨
- 비용 기반 최적화
  - 쿼리를 처리하기 위해 여러 가지 가능한 방법을 만들고 각 단위 작업의 비용 정보와 테이블의 예측된 통계 정보를 이용해 각 실행 계획별 비용을 산출함 이렇게 산촐된 각 실행 방법별로 최소 비용이 소요되는 처리 방식을 선택해 최종 쿼리를 실행함
- mysql은 비용 기반 최적화



### 통계 정보

- 비용 기반 최적화에서 가장 중요한 것은 통계 정보임
- 기본적으로 mysql에서 관리되는 통계 정보는 대략 레코드 건수와 인덱스의 유니쿠한 값의 개수
- 통계정보가 부족하면 analyze 명령으로 강제 갱신
- 서비스 실행도중 analzye 실행은 안하는게 좋음 innodb의 경우 읽기 쓰기 모두 불가



## 실행 계획 분석

- mysql 쿼리 실행 계획 확인은 explain 명령을 사용하면 됨
- explain extended나 explain partitions 명령을 이용해 더 상세한 실행 계획을 확인할 수도 있음
- explain select ... 를 실행하면 나오는 로우 수는 쿼리에 사용된 테이블의 수만큼 나옴 (서브쿼리로 인한 테이블 포함)
- update, insert, delete의 경우 where절을 기반으로 대략적인 계획을 확인 가능함



### id 칼럼

- 실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 select 쿼리별로 부여되는 식별자 값임
- 만약 하나의 같은 select 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id를 가짐, 서브쿼리는 다른 id select가 두번이여서



### select_type 컬럼

**SIMPLE**

- UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT일 경우
- 쿼리 문장이 아무리 복잡해도 SIMPLE인 단위쿼리는 반드시 하나만 존재함
- 일반적으로 제일 바깥쪽에 있는 select 단위 쿼리가 primary



**PRIMARY**

- UNION이나 서브쿼리가 포함된 SELECT 쿼리의 실행계획에서 가장 바깥에 있는 단위쿼리
- 한개만 있음 쿼리의 제일 바깥 쪽에 있는 select 단위 쿼리가 primary로 표시됨



**UNION**

- union으로 결합하는 단위 select 쿼리 중 첫번째를 제외한 두 번째 select 부터는 select type이 union임

```sql
EXLPAIN
SELECT * FROM (
	(SELECT EMP_NO FROM EMPLOYEES E1 LIMIT 10)
	UNION ALL
    (SELECT EMP_NO FROM EMPLOYEES E2 LIMIT 10)
    UNINO ALL
    (SELECT EMP_NO FROM EMPLOYEES E3 LIMIT 10)
)
```

- 위 쿼리중 E1 select만 DERIVED 타입이고 나머지는 UNION 타입으로 설정됨



**DEPENDENT UNION**

- 여기서 DEPENDENT는 UNION이나 UNION ALL로 결합된 단위 쿼리가 외부의 영향을 받은 것을 의미

```sql
SELECT E.FIRST_NAME,
	(SELECT CONCAT('...') ...) FROM salaries s WHERE s.emp_no = e.emp_no
	UNION
    (SELECT CONCAT('...') ...) FROM dept_emp de WHERE s.emp_no = e.emp_no
    ...
FROM employees e
WHERE e.emp_no=10001;
```

- 여기서 union은 외부 e 테이블의 emp_no에 의존하므로 DEPENDENT 타입
- 일반적으로 서브쿼리는 먼저 실행되는 경향이 있는데 이 DEPENDENT는 절대 먼저 실행될 수 없기 때문에 서버 쿼리는 비효율적인 경우가 많음





**UNION RESULT**

- union 결과를 담아두는 테이블
- mysql 에서 unon all이나 union 쿼리는 모두 union의 결과를 임시 테이블로 생성하게 되는데 실행 계획상에서 이 임시 테이블을 가리키는 라인의 select_type이 UNION RESULT임



**SUBQUERY**

- FROM 절 이외의 서브쿼리
- FROM 절에 사용된 서브쿼리는 DERIVED라고 표시
- SELECT 에 사용되는 쿼리를 네스티드 쿼리
- WHERE 절에 사용되는 경우 서브쿼리
- FROM 절에 사용되는 경우 파생테이블, 인라인뷰, 서브 셀렉트 라고함
- 하나의 값만 반환하면 스칼라 서브쿼리
- 컬럼 개수에 관계 없이 하나의 레코드만 반환하면 로우 서브 쿼리



**DEPENDENT SUBQUERY**

- 바깥쪽 테이블에 의존할 경우 DEPENDENT 서브쿼리라고함
- 일반 서브쿼리보다 처리속도가 느릴때가 많음



**DERIVED**

- 서브쿼리가 FROM절에 사용된 경우
- 파생 테이블에는 인덱스가 없기 때문에 다른 테이블과 조인할 때 성능상 불리할 때가 많음
- 가능하다면 DERIVED 형태의 실행 계획을 조인으로 해결할 수 있게 바꿔주는게 좋음
- 쿼리 튜닝전 반드시 DERIVED 확인 불가피한 상황이 아니면 반드시 조인으로 풀것



**UNCACHEABLE SUBQUERY**

- 조건이 똑같은 서브쿼리는 다시 사용할 수 있게 캐시공간에 담아둠
- 여기서 언급하는 서브 쿼리 캐시는 쿼리 캐시나 파생 테이블과는 전혀 무관한 기능
- select type이 SUBQUERY인 경우 한번 캐시되면 계속 캐시된거 사용함
- select type이 UNCACHEABLE SUBQUERY인 경우엔 캐시를 사용 못함
  - 사용자 변수가 서브쿼리에 사용된 경우
  - NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내에 사용된 경우
  - UUID()나 RAND()와 같이 호출할때마다 달라지는 함수가 서브쿼리에 사용된 경우



**UNCACHEABLE UNION**

- UNCACHEABLE + UNION



### table 칼럼

- mysql의 실행 계획은 단위 selet 쿼리 기준이 아니라 테이블 기준으로 표시됨
- 테이블 없이 select하면 null이 나옴

```sql
select now()
```

- \<\> 으로 감싸졌다면 임시테이블임
- `<derived2>` id가 2인 쿼리에서 생성된 임시테이블





### type 컬럼

- 쿼리의 실행 계획(explain 명령어)에서 type 이후의 칼럼들은 mysql 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 의미함
- 일반적으로 쿼리 튜닝시 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 실행계획에서 type 칼럼은 반드시 체크해야함
- type에 표시될 수 있는 버전 아래 순서대로 가장 빠른것부터 
  - system
  - const
  - eq_ref
  - ref
  - fulltext
  - ref_or_null
  - unique_subquery
  - index_subquery
  - range
  - index_merge
  - index
  - all
- 12가지 방법중 all을 제외한 모두는 인덱스를 활용함 all은 인덱스를 사용하지 않고 풀스캔함
- 하나의 단위 select 쿼리는 위의 접근 방법 중에서 단 하나만 사용 가능
- 아래 설명은 가장 빠른순서대로 설명할 것이고 mysql 옵티마이저는 이런 접근 방식 + 비용을 함께 계싼해서 최소의 비용 드는 접근 방식을 선택함



**system**

- 레코드가 1건만 존재하는 테이블 또는 한건도 존재하지 않는 테이브을 참조하는 형태의 접근방법을 system이라함
- innodb에서는 없고 myisam이나 memory에서 사용
- 거의 안나옴



**const**

- 테이블의 레코드 건수에 관계 없이 쿼리가 프라이머리 키나 유니크 키 칼럼을 이용하는 where 조건절을 가지고 있으며 반드시 1건을 반환하는 쿼리의 처리 형식을 contst라함
- 다른 dbms에서는 이것을 유니크 인덱스 스캔이라고도 표현함
- 다중칼럼의 경우 const를 사용할 수 없고 ref로 표시됨
- 다중칼럼도 전부 = 조건으로 걸면 const를 사용함
- 실행계획이 const인 경우 mysql의 옵티마이저가 쿼리를 최적화하는 단계에서 모두 상수화 시킴.. 오



**eq_ref**

- eq_ref 접근 방법은 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시됨
- 조인에서 처음 읽은 테이블의 칼럼 값을 그 다음 읽어야 할 테이블의 pk나 유니크 키 칼럼의 검색 조건에 사용할 때를 eq_ref라 함
- 이때 두번째 이후에 읽는 테이블의 type 칼럼에 eq_ref가 표시됨 두번째 이후에 읽히는 테이블을 유니크 키로 검색할 때 그 유니크 인덱스는 not null 이어야 하며 다중 컬럼으로 만들어진 다중 칼럼으로 만들어진 pk나 유니크 인덱스라면 인덱스의 모든 칼럼이 비교 조건에 사용 되어야만 eq_ref 접근 방법이 사용될 수 있음
- 즉 조인에서 두번쨰 이후에 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 사용할 수 있는 접근 방법

```sql
SELECT * FROM dept_emp de, employees e
WHERE e.emp_no=de.emp_no AND de.dept_no 'd005';
```

- 여기서 e의 실행계획이 eq_ref가 됨





**ref**

- eq_ref와는 달리 조인의 순서와 관계 없이 사용되고 pk나 유니크키의 제약조건도 없음
- 인덱스 종류와 관계없이 동등 조건으로 검색할 때는 ref접근 방법이 사용됨
- 반환되는 레코드가 반드시 1건이라는 보장이 없기 때문에 const, eq_ref보다는 느리지만 그래도 매우 빠름



**언급한 const, eq_ref, ref 는 매우 좋은 접근 방법이고 쿼리튜닝의 대상이아님**



**fulltext**

- mysql의 전문검색 인덱스를 사용해 레코드를 읽는 접근 방법을 의미함
- 전문 검색 인덱스는 통계 정보과 관리되지 않고 전혀 다른 sqld을 사용해야함
- MATCH ... AGAINST ... 구문을 사용함
- 일반적으로 쿼리에 전문 검색 조건을 사용하면 MYSQL은 아무런 주저없이 fulltext 접근 방식을 사용하는 경향이 있지만 일반 인덱스를 이용하는 range 접근 방법이 더 빨리 처리되는경우가 많음



**ref_or_null**

- ref와 같은데 null 비교가 추가됨



**unique_subquery**

- where에 in 형태의 쿼리를 위한 접근 방식
- 서브쿼리에서 중복되지 않은 유니크한 값만 반환할 때 이 접근 방법을 사용함



**index_subquery**

- IN 연산자의 특성상 IN 또는 IN 형태의 조건은 괄호 안에 있는 값의 목록에서 중복된 값이 먼저 제거되어야 함
- 중복된 값을 인덱스를 이용해 제거할 수 있을 때 index_subquery 접근 방법이 사용됨
- index_subquery, unique_subquery는 모두 IN절 안에 있는 중복 값을 아주 낮은 비용으로 제거함



**range**

- 인덱스 레인지 스캔 형태의 접근 방법
- `<>` IS NULL, BETWEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색할 때 사용
- mysql접근 방법중에서 상당히 우선순위가 낮지만 이 접근 방식도 빠르고 어느정도 성능 보장이됨



**인덱스 레인지 스캔이라고하면 보통 const, ref, range 라는 세가지 접근 방법을 모두 먺어서 지칭하는 것**



**index_merge**

- 2개의 인덱스를 이용해 각각의 검색 결과를 만들어 낸 후 그 결과를 병합하는 처리 방식
- 그다지 효율적이지 않음
- 특징
  - 여러 인덱스를 읽어야 하므로 일반 range 스캔보다는 효율성이 떨어짐
  - and와 or 연산이 복잡하겨 연결된 쿼리에서는 제대로 죄적화하지 못할때가 많음
  - 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않음 
  - index_merge 접근 방식으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에 그 두 집합의 교집합이나 합집합 또는 중복 제거와같은 부가적인 작업이 더필요함



**index**

- 인덱스 풀 스캔
- 그다지 효율적이지 않음 테이블 풀 스캔보다는 빠름
- range나 const 또는 ref와 같은 접근 방식으로 인덱스를 사용하지 못하는 경우
- 인덱스에 포함된 칼럼으로 처리할 수 있는 쿼리인 경우 즉, 데이터 파일을 읽지 않아도 되는 경우
- 인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우 즉, 별도의 정렬 작업을 피할 수 있는 경우
- index + limit 같은 경우 성능이 상당히 효율적임



**all**

- 풀 테이블 스캔
- 가장 성능안나옴
- 다른 dbms와 같이 innodb도 풀 테이블 스캔, 인덱스 풀 스캔같은 대량의 io를 유발하는 작업을 위해 한꺼번에 많은 페이지를 읽어들이는 기능을 제공함. 이 기능을 리드 어헤드 read ahead 라 함



### possible_keys

- mysql 옵티마이저는 쿼리를 가장 낮은 비용을 예상한 실행계획을 선택해서 실행함
- 그중에서 사용될법한 인덱스의 목록이 possible_key 칼럼에 나오는데 쿼리튜닝에 아무런 도움이 되지 않음
- 그냥 무시



### key

- possible_keys 칼럼의 인덱스가 사용 후보였던 반면 key 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미
- 의도했던 인덱스가 여기에 나오는지 확인하는것이 중요함
- index_merge 실행계획의 경우 , 로 구분되어 나열됨
- all같이 인덱스를 전혀 사용 못하면 null로 표현됨



### key_len

- 많이 무시하는데 사실 매우 중요한 정보
- 실무에서는 단일 칼럼보다는 다중 칼럼으로 설정된 인덱스가 많음
- 실행 계획의 key_len 칼럼은 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇개의 칼럼까지 사용했는지 알려줌
- 더 정확하게는 인덱스의 각 레코드에서 몇바이트까지 사용했는지 알려주는 값
- 버전별로 조금 다르게 표시되는데 5.0 에서 5.1에서 많은 변화가 있었기 때문임 <- 참고



### ref

- 접근 방법이 ref 방식이면 참조 조건(=) 으로 어떤 값이 제공됐는지 보여줌
- const ... 등등이 나오는데 func이라고 나오면 주의해야함 ex 산술표현식
- 가능하다면 조인시 서버가 변환을 하지 않아도 되도록 조인 칼럼의 타입을 일치시키는게 좋음 



### rows

- mysql 실행 계획의 rows 칼럼은 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여줌
- 각 스토리지 엔진별로 가지고 있는 통계 정보를 참조해 mysql 옵티마이저가 산출해낸 예상 값이라 정확하지는 않음
- 반환하는 레코드의 값이 아닌 디스크로부터 읽고 체크해야하는 값의 수를 의미함
- 잘하면 쿼리 튜닝으로 range로 바꿀 수 있음



### Extra

- 성능 관련된 내용이 extra 칼럼에 자주 표시됨

**counst row not found (mysql 5.1 이상)**

- 쿼리의 실행 계획에서 const 접근 방식으로 읽었지만 레코드가 1개도 없다면

**Distinct**

- 쿼리의 distinct를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 꼭 필요한 것만 조인하고 꼭 필요한 레코드만 읽음



**Full scan on NULL key**

- 이 처리는 `col IN (SELECT col2 FROM ...)` 과같은 쿼리에서 자주 발생하는데 만약 col1의 값이 NULL이 된다면 결과적으로 조건은 `NULL IN (SELECT col2 FROM) ...` 이됨

  - 서브쿼리가 1건이라도 결과 레코드를 가진다면 최종 비교 결과는 null
  - 서브쿼리가 1건도 결과 레코드를 가지지 않는다면 최종 비교 결과는 false

- 이 비교 결과에서 col1이 null이면 풀스캔해야됨

- extra에서 Full scan on NULL key은 null이나왔을때 풀스캔할꺼라고 알려주는거임

- col1 IS NOT NULL 조건을 WHERE에 섞어주면 mysql 옵티마이저에게 알려주므로 extra에서 Full scan on NULL key 나와도 안전함

  ### 

  

**Impossible HAVING (mysql 5.1 이상)**

- 쿼리에 사용된 having 절의 조건을 만족하는 레코드가 없을때 extra 컬럼에서 나옴



**Impossible WHERE (mysql 5.1 이상)**

- WHERE 조건이 항상 FALSE가 될 수 밖에 없는 경우
- 제약사항을기반으로



**impossible WHERE noticed after reading const tables**

- 실제로 실행되었을때 아무겂도 없으면 이렇게나옴



**No matching min/max row (MYSQL 5.1 이상)**

- 쿼리의 WHERE 조건절을 만족하는 레코드가 한 건도 없는 경우 일반적으로 impossible where ... 문장이 exist 칼럼에 표시됨
- 만약 min(), max()가 없을때는 No matching min/max row 로 표시



**no matching row in const table (mysql 5.1 이상)**

- const 방식으로 접근할때 일치하는 레코드가 없으면 exist에 no matching row in const table 로 표시



**no tables used **

- from에 dual이나 없을 경우 no tables used 



**Not exists**

- not in이나 not exist를 안티 조인이라고함 똑같은 처리를 아우터 조인으로 풀 수 있음
- 레코드의 건수가 많을때는 아우터 조인을 이용하면 빠른 성능을 낼 수 있음
- 안티 조인은 일반 조인을 했을 때 나오지 않는 결과만 가져오는 방법임

```SQL
EXPLAIN
SELECT *
FROM dept_emp de
	LEFT JOIN departments d ON de.dept_no=d.dept_no
WHERE d.dept_no IS NULL;
```

- 이런식으로 사용하면 extra 컬럼에 not exists로 표시됨



**Range checked for each recode (index map: N)**

- 두 개의 테이블을 조인하면서 조인 조건에 상수가 없고 둘다 변수일 경우 1, 1+1, 1+2, 1+n ... n 이런식으로 매 레코드마다 인덱스 레인지 스캔을 체크함

```sql
EXPLAIN
SELECT *
FROM employees e1, employees e2
WHERE e2.emp_no >= e1.emp_no;
```



**Scanned N databases(mysql 5.1이상)**

- mysql 5.0부터는 기본적으로 INFORMATION_SCHEMA라는 db가 제공됨 이 db는 mysql 서버 내에 존재하는 db의 메타정보를 모아둔 db임, read only
- Scanned N databases에서 N은 0, 1, N이 됨
  - 0: 특정 테이블의 정보만 요청되어 데이터베이스 전체의 메타 정보를 읽지 않음
  - 1: 특정 데이터베이스내의 모든 스키마 정보가 요청되어 해당 데이터베이스의 모든 스키마 정보를 읽음
  - all: mysql 서버 내의 모든 스키마 정보를 당릭음

```sql
EXPLAIN
SELECT table_name
FROM information_schema.tables
WHERE table_schema = 'employees' AND table_name = 'employees';
```



**Select tables optimized away**

- MIN, MAX만 select절에 사용되거나 group by로 MIN, MAX를 조회하는 쿼리가 적절한 인덱스를 사용할 수 없을 때 인덱스를 오름차순 또는 내림차순으로 1건만 일는 형태의 최적화가 적용된다면 Extra 칼럼에 Select tables optimized away 가 표시됨
- myisam 테이블은 count(*) 만 select할때도 적용됨 but where가 붙으면 안됨



**Skip_open_table, Open_frm_only, Open_trigger_only, Open_full_table (mysql 5.1 이상)**

- 메타정보를 조회하는 select 쿼리에만 표시되는 내용임
- 테이블의 메타 정보가 저장된 파일과 트리거가 저장된 파일 또는 데이터 파일 중에서 필요한 파일만 읽었는지 또는 불가피하게 모든 파일을 다 읽었는지 등의 정보를 보여줌
  - skip_open_table: 테이블의 메타 정보가 저장된 파일을 별도로 읽을 필요가 없음
  - open_frm_only: 테이블의 메타 정보가 저장된 파일만 열어서 읽음
  - open_trigger_only: 트리거 정보가 저장된 파일만 열어서 읽음
  - open_full_table: 최적화 되지 못해서 테이블의 메타 정보 파일과 데이터 및 인덱스 파일까지 모두 읽음





**unique row not found (mysql 5.1 이상)**

- 두 개의 테이블이 각각 유니크 칼럼으로 아우터 조인을 수행하는 쿼리에서 아우터 테이블에 일치하는 레코드가 조재하지 않을때 extra 칼럼에 이 코멘트가 표시됨





**Using filesort**

- ORDER BY를 처리하기 위해 인덱스를 이용할 수도 있지만 적절한 인덱스를 찾지 못할 때는 MYSQL 서버가 조회된 레코드를 다시 한 번 정렬해야함 ORDER BY 처리가 인덱스를 사용하지 못할때만 실행 계획의 EXTRA 칼럼에 Using filesort 코멘트가 표시되며 이는 조회된 레코드르 정렬용 메모리 버퍼에 복사해 퀵 소트 알고리즘을 수행하는 것



**Using index (커버링 인덱스)**

- 데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 Extra 칼럼에 Using index가 표시됨
- 인덱스 레인지 스캔을 사용한다고 하더라도 나머지 레코드를 가져올때 인덱스 처리가 되지 않았다면 디스크에서 읽어올 수밖에 없기때문에 쿼리 성능이 안나올 경우 인덱스에 있는 칼럼만 사용하도록 쿼리를 변경해 큰 성능 향상을 볼 수 있음
- 레코드 건수에 따라 차이는 있겠지만 커버링 인덱스를 사용할때 아닐때 성능은 수십 수백배가 날 수 있음
- 그러나 커버링 인덱스를 위해 너무 과도하게 인덱스 칼럼이많아지면 인덱스의 크기가 커져서 메모리 낭비가 심해지기때문에 너무 커버링 인덱스 위주는 좋지 않음
- 접근 방법이 eq_ref, ref_ range 등과 같이 인덱스를 사용하는 실행 계획에서는 모두 extra 칼럼에 using index가 표시될 수 있음, 즉 인덱스 레인지 스캔을 사용할 때만 커버링 인덱스로 처리되는 것은 아님 인덱스를 풀 스캔 할 때도 커버링 인덱스로 처리될 수 있는데 이때도 똑같은 인덱스 풀 스캔의 접근 방법이라면 커버링 인덱스가 아닌 경우보다 훨씬 빠르게 처리됨 



**Using index for group-by**

- group by 처리를 위해 mysql 서버는 그룹핑 기준 칼럼을 이용해 정렬 작업을 수행하고 다시 정렬된 결과를 그룹핑하는 형태의 고부하작업을 피요로함
- 하지만 group by 처리가 인덱스를 이용하면 정렬된 인덱스 칼럼을 순서대로 읽으면서 그룹핑 작업만 수행하기 때문에 효율적이고 빠르게 처리됨
- group by 처리가 인덱스를 사용할때 Using index for group-by 가 표시됨 이 방법을 루스 인덱스 스캔이라고함
- 인덱스를 이용해 group by를 처리해도 avg나 sum 또는 count같은 함수를 사용하면 필요한 레코드만 읽는 루스 인덱스 스캔을 사용할 수 없음
- min, max 또는 인덱스를 활용한 group by는 루스 인덱스 스캔을 사용할 수 있음
- where 절에 사용하는 인덱스에 의해서도 사용 여부가 영향을 받음
  - where가 없을 경우
    - where 절의 조건이 전혀 없다면 group by만 루스 인덱스 스캔을 사용할 조건만 갖추면 됨
  - where 절이 있지만 검색을 위해 인덱스를 사용 못하는 경우
    - group by는 인덱스를 쓰지만 where는 불가능할 경우 타이트 인덱스 스캔을 통해 group by가 처리됨
  - where 절의 조건이 있으며, 검색을 위해 인덱스를 사용하는 경우
    - index_merge 이외의 접근 방법에서는 단 하나의 인덱스만 사용할 수 있음. where절에 사용된 인덱스 + group by 인덱스가 동일하다면 루스 인덱스 스캔이 가능함 만약 다르다면 where 조건절이 인덱스를 사용하도록 실행 계획을 수립하는 경향이 있음
    - 같은 인덱스를 사용한다고 하더라두 루스 인덱스 스캔을 안할 수 있음 where절 조건에서 검색된 데이터가 적을 경우 이미 빠르기 때문에

**Using join buffer (mysql 5.1 이상)**

- 일반적으로 빠른 쿼리 실행을 위해 조인이 되는 칼럼은 인덱스를 생성함 실제로 조인에 필요한 인덱스는 조인 되는 양쪽 테이블 칼럼 모두가 필요한 것이 아니라 조인에서 뒤에 읽는 테이블의 칼럼에만 필요함
- mysql 옵티마이저도 조인되는 두 테이블에 있는 각 칼럼에서 인덱스를 조사하고, 인덱스가 없는 테이블이 있으면 그 테이블을 먼저 읽어서 조인을 실행함 뒤에 읽는 테이블은 검색 위조로 사용되기 때문에 인덱스가 없으면 성능에 미치는 영향이 매우큼

- rdbms에서 조인을 처리하는 방법이 2~3가지정도 되지만 mysql에서는 중첩 루프 조인 방식만 지원함 from 절에 아무리 테이블이 많아도 조인을 수행할 때 반드시 두 개의 테이블이 비교되는 방식으로 처리됨 먼저 읽히는 테이블을 드라이빙 테이블, 뒤에 읽히는 테이블을 드리븐 테이블이라 함 A , B 일때 A는 드라이빙, B는 드리븐
- 조인이 수행될 때 드리븐 테이블의 조인 칼럼에 적절한 인덱스가 있다면 아무런 문제가되지 않는데 없으면 드라이빙 테이블로부터 읽은 레코드의 건수만큼 매번 드리븐 테이블을 풀 테이블 스캔이나 인덱스 풀 스캔을 해야함 이 경우 드리븐 테이블의 비효율적인 검색을 보완하기 위해 mysql 서버는 드라이빙 테이블에서 읽은 레코드를 임시 공간에 보관해두고 필요할 때 재사용할 수 있게 해줌 이 공간을 조인 버퍼라고함
- join_buffer_zise 로 변경 가능하고 조인되는 인덱스가 적절하게 되었다면 크게 신경쓰지 않아도 되지만 너무 부족하거나 너무 과다하지 않도록 제한하는게 좋음
- 온라인 웹 서비스용 mysql 서버라면 join buffer는 1m으로 충분함



**Using sort_union(...), Using union(...), Using intersect(...)**

- 쿼리가 index_merge 접근 방식으로 실행되는 경우에는 2개 이상의 인덱스가 동시에 사용될 수 있음
- 이때 결과를 어떻게 병합했는지 3가지 메시지
  - Using intersect
    - 각각의 인덱스를 사용할 수 있는 조건이 AND로 연결된 경우 각 처리 결과에서 교집합을 추출해내는 작업을 수행했다는 의미
  - Using union
    - 각 인덱스를 사용할 수 있는 조건이 or로 연결된 경우 각 처리 결과에서 합집합을 추출해내는 작업을 수행했다는 의미
  - Using sort_union
    - Using union과 같은 작업을 수행하지만 Using union으로 처리될수 없는 경우 이방식으로 처리됨 이 방식은 pk만 만저 읽어서 정렬하고 병합한 후에야 비로소 레코드를 읽어서 반환 할 수 있다는 것



**Using temporary**

- mysql이 쿼리를 처리하는 동안 중간 결과를 담아 두기 위해 임시 테이블을 사용함 임시테이블은 메모리 또는 디스크에 생성될 수 있음 <- 판단 불가 
- from 절에 사용된 서버쿼리는 무조건 임시테이블 파생 테이블이라고도함
- union union all 같은 쿼리도 항상 임시테이블을 사용함
- count(distinct column1) 를 포함하는 쿼리도 인덱스를 사용할 수 없는 경우에는 임시 테이블이 만들어짐



**Using Where**

- 스토리지 엔진이 아니라 mysql 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 처리한 경우에만 이 코멘트가 표시됨
- 일반적으로 using where가 표시된 경우에는 mysql 엔진에서 한번 필터링 작업을 한 것임 그와 동시에 스토리지 엔진에서 쓸모 없는 일을 추가로 시켰다는 것을 의미함
- 5.0에서 성능상의 이슈가 있고 5.1에서 어느정도 해소됨 mysql에서 이런 기능을 condition push down이라고함



**Using where with pushed condition**

- Condition push down이 적용됐을때 나오는 메시지
- 이메시지는 ndb 클러스터 스토리지 엔진을 사용하는 테이블에서만 나타나므로 생략





### EXPLAIN EXTENDED (Filtered 칼럼)

- 조인과 같은 여러가지 이유로 여전히 각 스토리지 엔젠에서 읽어 온 레코드를 mysql 엔진에서 필터링하는데 5.1.12 이상부터 필터링이 얼마나 효율적으로 실행됐는지 알려주기위해 Filtered라는 컬럼이 추가됨
- Filtered 칼럼을 추가하려면 EXPLAIN 명령 뒤에 EXTENDED라는 키워드를 지정하면 됨

```sql
EXPLAIN EXTENED
SELECT * FROM employees
WHERE emp_no BETWWEN 10001 AND 10100 AND gender= 'f';
```

- 여기에나오는 숫자는 %를 의미함 실제 값이 아니라 단순히 통계 정보로부터 예측된 값





### EXPLAIN EXTENDED(추가 옵티마이저 정보)

- EXPLAIN 명령의 EXTENE 옵션은 의 숨은 기능은 분석된 파스트리를 재조합해서 쿼리 문장과 비슷한 순서대로 나열해서 보여주는 것
- EXPLAIN EXTENDED 이후에 SHOW WARNINGS을 실행하면 옵티마이저가 재조합한 쿼리 문장을 확인할 수 있음 알아두면 유용





### EXPLAIN PARTITIONS(Partitions 칼럼)

- EXPLAIN 명령 뒤에 PARTITIONS 옵션을 사용하면 쿼리를 실행하기 위해 테이블의 파티션 중에서 어떤 파티션을 사용했는지 등의 정보를 조회할 수 있음
- 파티션이 여러개인 테이블에서 불필요한 파티션을 빼고 쿼리를 수행하기 위해 접근해야 할 것으로 판단되는 테이블만 골라내는 과정을 파티션 프루닝이라고함
- 실제 이 파티션에서만 데이터를 읽어오는지 확인할 수 있음





## MySQL의 주요 처리 방식

- 
- 
- 아래 설명하는 내용은 풀 테이블 스캔을 제외한 나머지 모두 스토리지 엔진이 아니라 mysql 엔진에서 처리되는 내용임
- mysql 엔진에서 부가적으로 처리하는 작업은 대부분 성능에 취약함
- mysql 엔진에서 처리하는 작업을 알아두면 쿼리 튜닝에 상당히 도움이 됨



### 풀 테이블 스캔

- 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지읽어서 요청된 작업을 처리하는 작업
- 다음 조건이 일치할때 사용
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀테이블 스캔을 하는 편이 더 빠른 경우
  - where 절이나 on 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
  - 반대로 max_seeks_for_key 변수를 특정 값으로 설정하면 mysql 옵티마이저는 인덱스의 기수성이나 선택도를 무시하고 최대 n건만 읽으면 된다고 판단하게 함 이 값을 작게 설정할 수록 mysql 서버가 인덱스를 더 사용하도록 유도함
- 일반적으로 풀테이블 스캔은 인덱스보다 느림
- 풀 테이블 스캔 속도를 늘리기 위해 한번에 몇 개씩 페이지를 읽어올지 설정하는데 innodb의 경우 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 시작됨
- 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 innodb 버퍼 풀에 가져다 두는 것을 의미함



### ORDER BY 처리(using filesort)

- 레코드 1~2 건을 가져오는 쿼리를 제외하면 select 쿼리에서 정렬은 필수적으로 사용됨
- 정렬하기위해 인덱스와 fiesort라는 별도의 처리를 이용하는 방법으로 나눌 수 있음
- 인덱스를 이용
  - 장점: insert, update, delete 쿼리가 실행될 때 이미 인덱스가 정렬되어 있어서 순서대로 읽기만하면 매우 빠름
  - 단점: insert, update, delete 작업시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느림. 인덱스 때문에 디스크 공간이 더 많이 필요하고 인덱스 개수가 늘어날수로 버퍼풀이나 메모리가 많이 필요함
- filesort 이용
  - 장점: 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀜. 정렬해야 할 레코드가 많지 않으면 메모리에서 filesort가 처리되므로 충분히 빠름
  - 당점: 정렬 작업이 퀄 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리 응답 속도가 느림
- 다음과같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기란 거의 불가능함
  - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
    - group by 의 결과 또는 distinct와 같은 처리의 결과를 정렬해야 하는 경우
    - union의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
    - 랜덤하게 결과 레코드를 가져와야하는 경우 
- mysql이 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 extra 칼럼에 using filesort 라는 코멘트가 표시되는지로 판단 가능함 
- mysql 정렬 특성을 이해하면 쿼리를 튜닝할 때 어떻게 하면 조금이라도 더 빠른 쿼리가 될지 쉽게 판단할 수 있음



**소트 버퍼(sort buffer)**

- mysql은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데 이 메모리 공간을 소트버퍼라고함
- 소트 버퍼는 정렬이 필요한 경우에만 할당되고 버퍼의 크기는 정렬해야 할 레코드의 크기에 따라 가변적으로 증가하지만 최대 사용 가능한 소트 버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있음 소트 버퍼를 위한 메모리 공간은 쿼리의 실행이 완료되면 즉시 시트템으로 반납됨



- 정렬해야할 레코드의 건수가 소트 버퍼로 할당된 공간보다 크다면 레코드 여러 조각의로 나눠서 처리하는데 이때 임시저장을 위한 디스크를 사용함
- 정렬과 기록을 반복적으로 하고 병합하면서 정렬을 수행하는데 이 병합 작업을 멀티 머지라고 표현하고 수행된 멀티 머지 횟수는 sort_merge_passes라는 상태변수에 누적됨
- 소트버퍼의 크기를 늘린다고하더라도 성능상 크게 다른점은 없음
- 소트버퍼 크기는 56kb에서 1mb미만이 적절함
- 소트버퍼는 커넥션마다 개별적으로 같기 때문에 만약 크기가 크다면 oom이 발생할 수 있음





**정렬 알고리즘**

- 레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 2가지로 정렬 알고리즘을 나눠볼 수 있음

**싱글 패스 알고리즘**

- 소트 버퍼에 정렬 기준을 포함해 select 되는 칼럼 전부를 담아서 정렬을 수행하는 방법, mysql 5.0 이후 최근 버전에서 도입된 정렬 방법

**투패스 알고리즘**

- 정렬 대상 칼럼과 pk값만을 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 select 할 칼럼을 가져오는 알고리즘, 예전 버전의 mysql에서 사용하던 방법. 하지만 5.0, 5.1, 5.5에서도 특정 조건이 되면 이 방법을 사용함



- 두번읽기때문에 싱글 패스 알고리즘을 사용하지만 싱글패스 알고리즘은 더 많은 소트 버퍼 공간을 필요로함
- 최근 버전에서는 싱글 패스 방식을 사용함 예외도 있음



**정렬의 처리 방식**

- 쿼리에 order by가 사용되면 반드시 다음 3가지 처리 방식중 하나로 정렬이 처리됨 아래로 갈수록 처리가 느려짐
- 인덱스를 사용한 정렬 -> 드라이빙 테이블만 정렬 -> 조인 결과를 임시 테이블로 저장한 후 임시 테이블에서 정렬
- 옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있을지 검토하고 가능하다면 filesort 과정 없이 인덱스를 순서대로 읽어서 결과를 반환함
- 인덱스를 사용할 수 없으면 mysql 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 다음 두가지 방법중 하나를 선택함
  - 드라이빙 테이블만 정렬 후 다음 조인 수행
  - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬 수행
- 전자가 더 효율적임



**인덱스를 이용한 정렬**

- 인덱스를 이용한 정렬을 위해서는 반드시 order by에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고 order by의 순서대로 생성된 인덱스가 있어야함 또한 WHERE 절에 첫번쨰 읽는 테이블의 칼럼에 대한 조건이 있다면 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 함
- B-TREE 계열에서만 사용 가능함
- 여러 테이블이 조인되는 경우엔 네스티드 루프 방식의 조인에서만 이 방식을 사용 가능함
- 인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값을 읽기만하면 되기 때문에 별도의 추가 작업을 하지 않음
- ORDER BY없이 정렬 되더라도 반드시 명시할 것
- 조인버퍼가 사용되면 순서가 흐트러질 수 있음





**드라이빙 테이블만 정렬**

- 일반적으로 조인이 수행되면 결과 레코드의 건수가 몇 배로 불어남 그래서 조인 실행 전에 드라이빙 테이블만 정렬 하고 조인하는 것이 차선책
- 이 방법은 조인에서 첫번째 읽히는 테이블의 칼럼만으로 ORDER BY 절이 작성되어야함





**임시 테이블을 이용한 정렬**

- 임시테이블을 사용하면 가장 느림
- 드리븐테이블에 있는 컬럼을 ORDER BY 할 때
- 쿼리 실행 계획에 using temporary; Using filesort가 표시됨



**정렬 방식의 성능 비교**

- ORDER BY나 GROUP BY같은 작업은 WHERE 조건을 만족하는 레코드를 LIMIT 건수만큼 가져와서 처리될 수 없음
- 먼저 조건을 만족하는 레코드를 가져와서 정렬 및 그룹핑 작업을 해야만 LIMIT로 건수 제한을 할 수 있음
- WHERE 조건은 아무리 인덱스를 잘활용하도록 튜닝해도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생함
- 쿼리가 처리되는 두가지 방법
  - 스트리밍 방식
    - 서버 쪽에서 처리해야 할 데이터가 얼마나 될지에 관계없이 조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트로 전송해주는 방식을 의미함. 이 방식으로 쿼리를 처리할 경우 클라이언트는 쿼리를 요청하고 곧바로 원했던 첫 번째 레코드를 전달받을 것임 
    - 스트리밍 방식으로 처리되는 쿼리는 얼마나 많은 레코드를 조회하느냐가 아니라 빠른 응답 시간을 보장해줌
    - 스트리밍 방식에서 LIMIT로 처리되는 쿼리는 성능이 매우 좋음
  - 버퍼링 방식
    - ORDER BY나 GROUP BY는 쿼리의 결과가 스트리밍 되는 것을 불가능하게 함
    - 먼저 결과를 모아서 MYSQL 서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진으로부터 가져올 때까지 기다려야 함





- 인덱스를 활용한 방법만 스트리밍 형태고 나머지는 모두 버퍼링 된 후에 정렬됨
- 인덱스를 활용하면 LIMIT로 제한된 건수만큼만 읽으면서 바로 클라이언트로 전송해줄 수 있음
- 어느 테이블이 먼저 드라이빙 되어 조인되는지도 주용하지만 어떤 정렬 방식으로 처리되는지는 더 큰 성능 차이를 만들어냄
- 가능하다면 인덱스를 사용한 정렬로 유도하고 그렇지 못하다면 최소한 드라이빙 테이블만 정렬해도 되는 수준으로 유도하는 것도 좋은 튜닝 방법임
- 인덱스를 사용하지 못하는 쿼리를 페이징 처리에 사용하는 경우 LIMIT로 5~10건만 조회해도 쿼리가 기대만큼 아주 빨라지지는 않음



**정렬 관련 상태 변수**

- MYSQL 서버는 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장하고 있음
- 몇건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼 간의 병합 작업은 몇번이나 발생했는지 ..
- SHOW SESSION STATUS LIKE 'Sort%'
- 각 상태값
  - Sort_merge_passes는 멀티 머지 처리 횟수를 의미함
  - Sort_range는 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
  - Sort_scan은 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
  - Sort_rows는 지금까지 정렬한 전체 레코드 건수를 의미함



### GROUP BY 처리

- 일반적으로 group by 처리 결과는 임시 테이블이나 버퍼에 존재하는 값을 필터링하는 역학을 수행함
- group by 또한 order by와 같이 스트리밍 처리가 불가능함
- group by에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 튜닝의 대상이 아님
- group by도 인덱스를 사용 또는 사용안하는 경우가 있음
- group by도 타이트인덱스 스캔과 루스 인덱스 스캔이 있고 인덱스를 사용 못하면 임시테이블로 작업함





**인덱스 스캔을 이용하는 group by (타이트 인덱스 스캔)**

- ORDER BY와 마찬가지로 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그룹핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그룹핑 작업을 수행하고 그 결과로 조인을 처리함



**루스 인덱스 스캔을 이용하는 group by**

- 인덱스의 레코드를 건너 뛰면서 필요한 부분만 가져옴
- SALARIES 테이블의 인덱스에 emp_no + from_date 로 인덱스가 잡혔다고 가정할때

```sql
EXPLAIN
SELECT emp_no
FROM salaries
WHERE from_date = '1985-03-01'
GROUP BY emp_no
```

- 이 쿼리의 실행방식
  1. emp_no + from_date 인덱스를 차례대로 스캔하면서 emp_no의 첫번째 유일한 값을 찾아냄
  2. 유일값 + where 조건으로 마치 emp_no = 10001 AND from_date='1985-03-01' 과 같은 형태로 인덱스를 검색하는 것과 거의 흡사함 
  3. emp_no + from_date 인덱스에서 emp_no의 다음 유니크한 값을 찾고 계속 이 1~2 과정을 반복함
- mysql 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 group by에만 사용할 수 있음
- 인덱스 레인지 스캔은 유니크한 값이 많을수록 성능이 향상되는 반면 루스 인덱스 스캔은 분포도가 좋지 않은 인덱스일 수록 더 빠른 결과를 만들어냄
- 루스인덱스스캔은 임시테이블을 사용하지 않음
- 루스인덱스스캔 사용에 대한 판단은 어려움
- 루스 인덱스 스캔을 사용할 수 없는 패턴
  - MIN, MAX 이외의 집합 함수가 사용
  - GROUP BY에 사용된 칼럼이 인덱스 구성 칼럼의 왼쪽부터 일치하지 않는 경우
  - SELECT 절의 칼럼이 GROUP BY와 일치하지 않을때



**임시 테이블을 사용하는 GROUP BY**

- 인덱스를 전혀 사용하지 못할 때 사용





### DISTINCT 처리

- 특정 컬럼의 유니크한 값만을 조회할때 사용함
- DISTINCT는 MIN, MAX COUNT 같은 집합함수를 사용할때와 아닐때로 나뉨
- DISTINCT가 사용되는 쿼리에서 DISTINCT 처리에 인덱스를 사용 못하면 임시테이블을 사용함





**SELECT DISTINCT ...**

- 단순 SELECT DISTINCT의 경우 GROUP BY와 매우 유사하게 처리됨
- 단지 SELECT DISTINCT는 정렬을 보장하지 않는다는 것 뿐 <- 인덱스를 사용 못 할때
- SELECT 절에 사용된 DISTINCT 키워드는 조회되는 모든 칼럼에 영향을 미침 절대로 여러 칼럼 중에서 일부 칼럼만 유니크하게 조회하는 방법은 없음 단, 집계함수의 경우는 조금 다름 



**집합 함수와 함께 사용된 DISTINCT**

- 집합 함수 내에 사용된 DISTINCT는 그 집합 함수의 인자로 전달된 칼럼 값이 유니크한 것들을 가져옴

```sql
EXPLAIN
SELECT COUNT(DISTINCT s.salary)
FROM employees e, salaries s
WHERE e.emp_no=s.emp_no
AND e.emp_no BETWEEN 100001 AND 100100;
```

- 이 쿼리는 내부적으로 COUNT(DISTINCT s.salary)를 처리할 때 임시 테이블을 사용함
- employees와 salaires를 조인한 결과에서 salary 칼럼만 저장하기 위한 임시 테이블을 만들고 이 임시 테이블의 salary 칼럼에는 유니크 인덱스가 생성되기 때문에 레코드 건수가 많아진다면 상당히 느려질 수 있음
- 만약 저기에 COUNT(DISTINCT e.last_name) 가 추가되면 임시테이블을 총 두개 사용함 
- 인덱스를 사용할 수 있으면 임시테이블 없이 최적화된 처리가 가능함



### 임시 테이블

- mysql 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그룹핑 할 때는 내부적인 임시 테이블을 사용함
- 일반적으로 mysql 엔진이 사용하는 임시테이블은 처음엔 메모리에 있따가 크기가 커지면 디스크로 옮겨짐
- mysql이 내부적으로 사용하기때문에 이 임시 테이블은 다른 세션이나 다른 쿼리에서 볼 수 없고 사용도 불가능함 그리고 자동으로 삭제됨



**임시 테이블이 필요한 쿼리**

- 다음 패턴은 임시 테이블을 생성하는 케이스
  - ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
  - ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
  - DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 DISTINCT가 인덱스로 처리되지 못하는 쿼리 
  - UNION이나 UNION DISTINCT가 사용된 쿼리 (select_type 칼럼이 UNION RESULT인 경우)
  - UNION ALL이 사용된 쿼리 (select_type 칼럼이 UNION RESULT인 경우)
  - 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리
- 임시테이블을 사용하는 경우 Extra 칼럼에 Using temporary 라는 키워드를 확인하면 됨
- 위의 예에서 마지막 3개 패턴이 Using temporary 가 없음



**임시 테이블이 디스크에 생성되는 경우 (MyISAM)**

- 내부 임시 테이블은 기본적으로 메모리에 만들어지지만 다음 조건을 만족하면 임시 테이블을 생성할 수 없으므로 디스크상에 MyISAM 테이블로 만들어짐
  - 임시 테이블에 저장해야 하는 내용 중 blob이나 text 와 같은 대용량 칼럼이 있는 경우
  - 임시 테이블에 저장해야 하는 레코드의 전체 크기나 UNION  UNION ALL에서 SELECT 되는 칼럼 중에서 길이가 512 바이트 이상인 크기의 칼럼이 있는 경우
  - GROUP BY 나 DISTINCT 칼럼에서 512 바이트 이상인 크기의 칼럼이 있는 경우
  - 임시 테이블에 저장할 데이터의 전체 크기가 tmp_table_size 또는 max_heap_table_size 시스템 설정 값보다 큰 경우
- 첫번째부터 세번쨰까지는 처음부터 디스크에 MyISAM 스토리지 엔진을 사용해서 내부 임시 테이블이 만들어짐
- 네번째는 처음엔 memory에 만들어지지만 테이블의 크기가 시스템 설정 값으로 넘어가는 순간 디스크의 MyISAM 테이블로 변환됨



**임시 테이블 관련 상태 변수**

- 임시테이블이 메모리에 처리됐는지 디스크에 처리됐는지는 알 수 없음 몇개를 사용했는 지도 모름
- SHOW SESSION STATUS LIKE 'Created_tmp%'로 확인하면 됨
  - Created_tmp_tables
    - 쿼리의 처리를 위해 만들어진 내부 임시 테이블의 개수를 누적하는 상태 값. 이 값은 내부 임시 테이블이 메모리에만 만들어졌는지 디스크에 만들어졌는지를 구분하지 않고 모두 누적함
  - Created_tmp_disk_tables
    - 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 가지고 있는 상태 값



**임시 테이블 관련 주의사항**

- 레코드 건수가 많지 않으면 내부 임시 테이블이 메모리에 생성되고 mysql 서버의 부하에 크게 영향을 미치지는 않음
- 가능하면 인덱스를 반드시 사용하고 어렵다면 가공 대상 레코드를 적게 만드는 것이 좋음



### 테이블 조인

- 조인방식은 네스티드 루프방식의 형태만 지원함



**조인의 종류**

- INNER JOIN, OUTER JOIN으로 구분하고 OUTER JOIN은 다시 LEFT, RIGHT, FULL OUTER JOIN으로 구불 가능함
- 조인의 처리에서 어떤 테이블을 먼저 읽을지가 상당히 중요함
- INNER JOIN은 어느 테이블을 먼저 읽을지를 옵티마이저가 순서를 조절해 다양한 방법으로 최적화를 수행할 수 있음
- OUTER JOIN은 반드시 OUTER가 되는 테이블을 먼저 읽어야 하기 때문에 조인 순서를 옵티마이저가 선택 불가능함







**JOIN (INNER JOIN)**

- 네스티드 루프 방식으로 동작하고 네스티드 루프 방식은 두개의 for나 while같은 반복 루프 문장을 실행하는 형태로 조인이 처리되는것을 의미함
- 바깥 for문이 드라이빙 테이블, 안쪽 for문이 드리븐 테이블로 2중 중첩구조인 형태



**OUTER JOIN**

- OUTER 되는 테이블을 기준으로 검색하기 때문에 드리븐테이블에 일치하는 칼럼이 없어도 드라이빙 테이블 기준으로 검색됨
- MYSQL 에서는 FULL OUTER JOIN은 지원하지 않음 하지만 INNER JOIN이랑 OUTER JOIN을 조금만 섞어서 활용하면 같은 기능을 할 수 있음
- OUTER JOIN에서 레코드가 없을 수도 있는 쪽의 테이블에 대한 조건은 반드시 LEFT JOIN의 ON절에 모두 명시할 것 옵티마이저가 INNER JOIN으로 변경시킬 수 있음
- LEFT OUTER JOIN의 ON 절에 명시되는 조건은 조인되는 레코드가 있을 때만 적용됨
- 하지만 WHERE 절에 명시되는 조건은 OUTER JOIN이나 INNER JOIN에 관계없이 조인된 결과에 대해 모두 적용됨
- OUTER JOIN으로 연결되는 테이블이 있는 쿼리는 가능한 모던 조건에 ON절에 명시하는 습관을 들이는 게 좋음



```sql

-- bad
SELECT *
FROM employees e
	INNER JOIN salaries s ON s.emp_no = emp_no
WHERE s.salary > 5000;

-- good
SELECT * FROM
	LEFT OUTER JOIN salaires s ON s.emp_no=e.emp_no AND s.salary > 5000;
	

-- 순수하게 INNER JOIN으로 변환
SELECT *
FROM employees e
INNER JOIN salaries s ON s.emp_no=e.emp_no
WHERE s.salary > 5000;

```

- LEFT OUTER JOIN이 아닌 쿼리에서는 ON, WHERE 어느곳이든 상관없이 사용해도됨



**카테시안 조인**

- FULL JOIN 또는 CROSS JOIN 이라고도 함
- 카테시안 조인은 레코드 건수가 많아지면 기하급수적으로 늘어나므로 주의할 것
- N개의 테이블이 조인이 수행되는 쿼리에서는 반드시 조인 조건은 N-1개 또는 그 이상이 필요하고 모든 테이블은 반드시 1번 이상 조인 조건에 사용돼야 카테시안 조인을 피할 수 있음
- 조인되는 테이블이 많아질때 주의할 것





**NATURAL JOIN**

- NATURAL JOIN은 테이블간 서로 매칭되는 칼럼이 모두 조인 조건으로 사용됨
- 사용하지말것





**Single-sweep multi join**

- 반복 루프를 돌면서 레코드 단위로 모든 조인 대상 테이블을 차례대로 읽는 방식을 single-sweep multi join이라 함
- 조인의 결과는 드라이빙 테이블을 읽은 순서대로 레코드가 정렬되어 반환됨



**조인 버퍼를 이용한 조인 Using join buffer**

- 조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리됨
- 드라이빙 테이블은 한번에 쭉읽지만 드리븐 테이블은 여러번 읽음
- 드리븐 테이블을 검색할 때 인덱스를 사용할 수 없는 쿼리는 상당히 느리고 mysql 옵티마이저는 최대한 드리븐 테이블의 검색이 인덱스를 사용할 수 있게 실행 계획을 수립함
- 어떤 방식으로도 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리함
- 이때 사용되는 메모리의 캐시를 조인 버퍼라함

```sql
SELECT *
FROM dept_emp de, employees e
WHERE de.from_date > '2000-01-01' AND e.emp_no < 109004
```

- 조인버퍼가 사용될때는 다음 과정이 있음
  1. dept_emp 테이블의 ix_fromdate 인덱스를 사용해 조건을 만족하는 레코드를 먼저 검색
  2. 조인에 필요한 나머지 칼럼을 모두 dept_emp 테이블로부터 읽어서 조인 버퍼에 저장
  3. employees 테이블의 프라이머리키를 이용해 조건을 만족하는 레코드를 검색
  4. 3번에서 검색된 결과에 2번의 캐시된 조인 버퍼의 레코드를 결합해서 반환
- 조인 버퍼에는 조인 쿼리에서 필요로 하는 칼럼만 저장되고 레코드에 포함된 모든 칼럼은 저장되지 않으므로 효율적으로 사용됨



**조인 관련 주의사항**

- 실행 결과의 정렬 순서
- inner join과 outer join의 선택

**조인 실행 결과의 정렬 순서**

- 일반적으로 드라이빙 테이블로부터 레코드를 읽는 순서가 결과의 순서 <- 네스티드 루프 조인방식의 특징
- 옵티마이저가 선택하는 실행 계획에 의존한 정렬은 피하는것이 좋음
- 정렬이 필요하다면 반드시 order by 붙일 것



**INNER JOIN과 OUTER JOIN의 선택**

- OUTER JOIN과 INNER JOIN은 실제 가져와야하는 레코드가 같다면 쿼리의 성능은 거의 차이가 없음
- INNER JOIN과 OUTER JOIN은 성능을 교로해서 선택할 것이 아니라 업무 요건에 따라 선택하는 것이 바람직함





## 실행 계획 분석 시 주의사항

- 특별히 주의해야하는 경우 



### SELECT_TYPE 칼럼의 주의 대상

**DERIVED**

- FROM 절에 사용된 임시테이블
- 메모리에 저장될 수도 있고 디스크에 저장될 수도 있지만 데이터 크기가 커서 임시 테이블에 디스크를 저장하면 성능이 떨어짐

**UNCACHEABLE SUBQUERY**

- 쿼리의 FROM절 이외의 부분에서 사용하는 서브쿼리는 가능하면 MYSQL 옵티마이저가 최대한 캐시되어 재사용될 수 있게 유도하는데 못할 경우 성능이 안좋음 
- 사용자 변수를 제거하거나 다른 함수로 대체해서 사용 검토

**DEPENDENT SUBQUERY**

- 쿼리의 FROM 절 이외의 부분에서 사용하는 서브 쿼리가 자체적으로 실행되지 못하고 외부 쿼리에서 값을 전달받아 실행되는 경우 
- 서브쿼리가 먼저 실행되지 못하고 스버쿼리가 외부 쿼리의 값에 의존적이기 때문에 전체 쿼리의 성능을 느리게 만듬 가능하다면 외부 쿼리와의 의존도를 제거하는것이 좋음



### TYPE 칼럼의 주의 대상

**ALL, index**

- index는 인덱스 풀 스캔 all은 테이블 풀 스캔
- 성능 안좋음
- 새로운 인덱스를 추가하거나 쿼리의 요건을 변경해서 제거할 것





### Key 칼럼의 주의 대상

- 쿼리가 인덱스를 사용하지 못할 때 실행 계획의 Key에 아무런 값도 표시되지 않음
- 쿼리가 인덱스를 사용할 수 있게 인덱스를 추가하거나 WHERE 조건 변경



### Rows 칼럼의 주의 대상

- 쿼리가 실제 가져오는 레코드 수보다 훨씬 더 큰 값이 Rows에 있는 경우 인덱스를 정상으로 사용하고 있는지, 그리고 그 인덱스가 충분히 작업 범위를 좁혀줄 수 있는 칼럼으로 구성됐는지 검토해보는 것이 좋음
- 인덱스가 효율적이지 않다면 충분히 식별성을 가지고 있는 칼럼을 선정해 인덱스를 다시 설정할것
- Rows 칼럼의 수치 판단시 limit가 포함된 쿼리라 하더라도 limit의 제한은 rows 의 고려 대상에서 제외된다는 것
- 위와 같은 경우는 성능ㅇ상 아무런 문제가 없고 최적화된 쿼리일 수도 있다는 것 참고





### Extra 칼럼의 주의 대상

- 튜닝시 중요한 당서



**쿼리가 요건을 제대로 반영하고 있는지 확인해야 하는 경우**

- Full scan on NULL key
- Impossible HAVING (5.1)
- Impossible WHERE (5.1)
- Impossible WHERE noticed after reading const tables
- No matching min/max row (5.1)
- No matching row in const table (5.1)
- Unique row not found(5.1)
- 이런 코멘트가 Extra 칼럼에 표시되면 우선 쿼리가 요건을 제대로 반영해서 작성됐거나 버그가 생길 가능성은 없는지 확인해야함
- 이 항목들은 성능과 관계까 깊지 않고 단지 그런 레코드가 없음이라는 의미가 강하기 때문에 버그 가능성이 있을지 검토해야함





**쿼리의 실행 계획이 좋지 않은 경우**

- Range checked for each recode (index map: N)
- Using filesort
- Using join buffer (5.1)
- Using temporary
- Using where

- 위 코멘트가 나오면 쿼리를 더 최적화 할 수 있는지 검토
- Using where 의 경우 대부분 나와서 그냥 넘어가는 경향이 있는데 실행 계획의 Rows 칼럼의 값과 실제 select 되는 레코드의 수의 차이를 최대한 줄이는 것이 중요함



**쿼리의 실행 계획이 좋은 경우**

- Distinct
- Using index
- Using index for group-by

- 이 경우 쿼리가 최적화되어 처리되고 있음을 알려주는 지표라고 생각할 것
- Using index는 쿼리가 커버링 인덱스로 처리되고 있음을 알려주는것인데 mysql 제공할 수 있는 최고의 성능을 보여줌





# #7 쿼리 작성 및 최적화

- 데이터베이스나 테이블의 구조를 변경하기 위한 문장을 ddl
- 테이블의 데이터를 읽고 쓰기 위한 문장을 dml
- 이 둘을 합쳐서 sql이라고함
- ansi 표준에서는 select를 쿼리라고하고 데이터를 변경하는 insert update delete 같은 sql을 스테이트먼트라고 구분함





## 쿼리와 연관된 시스템 설정



### SQL 모드

- MYSQL 서버의 sql_mode라는 시스템 설정에는 여러개의 값이 ,를 기준으로 들어올 수 있음



**STRICT_ALL_TABLES**

- 일반적으로 mysql에서는 저장하려는 값의 길이가 칼럼의 길이보다 더 긴 경우라 하더라도 에러가 발생하지 않음 그 뒤는 짤라서 버림
- 이 설정을 하면 오류가남

**STRICT_TRANS_TABLES**

- 칼럼의 타입과 호환되지 않는 값을 저장할 때 mysql 서버는 비슷한 값으로 바꿔서 저장하려고 함
- 이 설정을 하면 데이터 타입이 변환이 필요할 때 서버가 강제로 변환하지 않고 에러를 발생시킴

**TRADITIONAL**

- Mysql 서버가 조금 더 ANSI 표준 모드로 작동하도록 유도함

**ANSI_QUOTES**

- 설정하면 홑따옴표만 문자열 값 표기로 사용할 수 있고 쌍따옴표는 칼럼명이나 테이블명과 같은 식별자를 표기하는 데만사용할 수 있음

**ONLY_FULL_GROUP_BY**

- MYSQL에서는 GROUP BY 절에 포함되지 않은 칼럼이라도 집합 함수의 사용 없이 그대로 SELECT 절이나 HAVING에 사용할 수 있음
- 설정하면 조금 더 엄격하게 관리함

**PIPE_AS_CONCAT**

- `||`의 경우 OR로 사용하지만 설정하면 ORACLE의 CONCAT처럼 사용 가능함

**PAD_CHAR_TO_FULL_LENGTH**

- MYSQL에서 CHAR타입이라 하더라도 VARCHAR와 같이 유효 문자열 뒤의 공백 문자는 제거되어 반환됨
- 뒤 쪽 공백이 제거되지 않고 반환되어야 한다면 이 값을 설정

**NO_BACKSLASH_ESCAPES**

- 역 슬래시를 이스케피으 용도로 사용하지 못하게함

**IGNORE_SPACE**

- MYSQL에서는 스토어드 프로시저나 함수명과 괄호 상에 있는 공백까지도 스토어드 프로시저 함수의 이름으로 간주함.
- 이 동작이 기본 모드임 
- 이 값을 추가하면 프로시저나 함수명 괄호 사이 공백은 무시함

**ANSI**

- MYSQL 서버가 최대한 SQL 표준에 맞게 동작하게 만들어줌



### 영문 대소문자 구분

- MYSQL 서버는 설치된 운영체제에 따라 테이블의 대소문자를 구분함 이는 디스크의 디렉터리나 파일과 매칭되기 때문
- 윈도우는 대소문자를 구분하지 않지만 유닉스 계열의 운영체제는 대소문자를 구분함
- 대소문자 구분을 영향받지 않게 하려면 lower_cases_table_names 변수를 설정해야함 1로하면 모두 소문자 기본값은 0
- 이러한 설정 자체를 떠나서 가능하면 초기 db나 테이브을 생성할 때 대문자만 또는 소문자만으로 통일해서 사용하는 편이 좋음



### MySQL 예약어

- 항상 테이블을 생성할 때는 역따옴표 \` 를 사용해서 생성할 것
- 예약어인지 아닌지를 mysql이 알려줌



## 매뉴얼의 SQL 문법 표기를 읽는 방법

- 해당 버전에 맞는 sql 문법을 참조하기에는 매뉴얼만큼 정확한 자료가 없음

... 스킵





## MySQL 연산자와 내장 함수

- 가능하다면 sql의 가독성을 높이기 위해 ansi 표준 형태를 사용할 것

### 리터럴 표기법

**문자열**

- sql 표준에서는 항상 홑따옴표를 사용해서 표시함 
- mysql은 쌍따옴표 가능
- mysql에서는 역 따옴표로 가싸서 사용하면 예약어와의 충돌을 피할 수 있음



**숫자**

- mysql 서버가 문자열 값을 숫자값 또는 반대로 자동으로 변환해줌
- select * from ... where number_column = '10001' 이건 문제가안됨
- select * from ... where string_column = 10001
- 위와 같은 쿼리는 string_column이 인덱스로 잡혀있다고 해도 string_column 내용을 전부 숫자값으로 변환해서 비교수행해야하므로 매우 주의할 것



**날짜**

- mysql에서는 정해진 형태의 날짜 포맷으로 표기하면 mysql 서버가 자동으로 date나 datetime 값으로 변환하기 때문에 복잡하게 STR_TO_DATE과 같은 함수를 사용하지 않아도 됨



**불리언**

- BOOLEAN 이라는 타입은 INIYINT 타입에 대한 동의어일 뿐
- TRUE FALSE 형태로 비교하거나 값을 저장할 수 있음
- 0 OR 1만 표시함
- 만약 불리언 타입을 꼭 사용하고 싶다면 ENUM 타입으로 관리하는 것이 조금 더 명확하고 실수할 가능성도 줄일 수 있음



### MySQL 연산자



**동등 비교 = <=>**

-  <=>은 null까지 비교하는 연산자임 null을 하나의 값으로 봄

**부정 비교 <>, !=**

- 혼용하지말고 하나만 사용할 것

**NOT 연산자 !**

- 부정

**AND와 OR 연산자**

- &&와 || 도 사용 가능함 BUT 자제



**나누기 / DIV 와 나머지 % MOD 연산자**

**REGEXP연산자**

- RLIKE는 정규표션식을 비교하는 연산자임
- REGEXP로 사용 가능
- REGEXP의 조건 비교는 인덱스 레인지 스캔을 사용 불가능함 따라서 WHERE 조건절에 REGEXP연산자를 사용한 조건을 단독으로 사용하는 것은 성능상 좋지 않음  가능하다면 범위를 줄일 수 있는 조건과 함께 REGEXP 연산자를 사용할 것

**LIKE 연산자**

- LIKE는 인덱스를 이용해 처리할 수도 있음
- %가 뒤에있으면 인덱스를 사용 가능하고 %가 앞에있으면 인덱스 풀 스캔 방식으로 처리됨



**BETWEEN 연산자**

- BETWEEN연산자는 크거나 같다 && 작거나 같다라는 두개의 연산자를 하나로 합친 연산자임
- BETWEEN보다 IN연산자가 더 괜찮을 수 있음 상황에 따라 풀어 쓰면 좋음
- BETWEEN은 선형으로 인덱스를 검색해야하고 IN은 동등 비교를 여러번 수행하는 것과 같은 효과가 있음
- 그렇다고 SUBQUERY 형태는 더 안좋을 수 있음
- <= >= 를 섞어쓰는것보다 BETWEEN이 빠르지만 CPU의 연산 차이로 발생하는것이라 크게 고려하지 않아도 되긴 함 일관성있게만 할 것



**IN 연산자**

- IN은 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자
- MYSQL 에서 IN 연산자는 사용법에 따라 상당히 비효율적으로 처리될 때도 있음 다른 DBMS는 최적화해서 수행함
- IN 연산자가 상수로 들어오면 최적화되어서 실행되나 서브쿼리로 들어오면 상당히 느려질 수 있음
- 서브쿼리가 먼저실행되어야 정상이나 서브쿼리의 외부가 먼저 실행되고 IN은 체크 조건으로 사용되기 때문임
- 상수로만 사용할 것
- IN으로 NULL값 검사 불가
- NOT IN의 실행 계획은 인덱스 풀 스캔으로 표시되는데 동등이 아닌 부정형 비교라서 인덱스를 이용해 처리 범위를 줄이는 조건으로는 사용할 수 없기 때문임



### MySQL 내장 함수

**NULL 값 비교 및 대체 IFNULL, ISNULL**

- IFNULL()은 칼럼이나 표션식의 값이 NULL인지 비교하고 NULL이면 다른 값으로 대체하는 용도로 사용할 수 있는 함수
- ISNULL()은 전달한 표현시이나 칼럼의 값이 NULL인지 아닌지를 비교하는 함수

**현재 시각 조회 NOW, SYSDATE**

- 두 함수 모두 현재의 시간을 반환하는 함수로서 같은 기능을 수행하지만 작동 방식에는 큰 차이가 있음
- 하나의 SQL에서 모든 NOW()는 같은 값을 가지지만 SYSDATE()는 하나의 SQL 내에서도 호출되는 시점에 따라 결과 값이 달라짐
- SYSDATE() 문제점
  - MYSQL의 슬레이브에서 안정적으로 복제되지 못함
  - SYSDATE()와 비교되는 칼럼은 인덱스를 효율적으로 사용하지 못함
- SYSDATE()는 상수가 아니기 때문에 인덱스를 검색할 때 매전 다른 값을 반환함
- MYSQL 설정에서 sysdate-is-now 설정을 넣어주면 NOW()와 같아짐
- SYSDATE()는 사용하지 말 것



**날짜와 시간의 포맷(DATE_FORMAT, STR_TO_DATE)**

- DATETIME 타입의 칼럼이나 값을 원하는 형태의 문자열로 변환해야할때는 DATE_FORMAT() 함수를 사용
- 반대는 STR_TO_DATE()



**날짜와 시간의 연산 DATE_ADD, DATE_SUB**

- 특정 날짜에서 년도나 월일 또는 시간 등을 더하거나 뺄 때는 DATE_ADD() 함수나 DATE_SUB() 함수를 사용



**타임스탬프 연산 UNIX_TIMESTAMP, FROM_UNIXTIME**

- 1970-01-01 00:00:00부터 경과된 의 수를 반환하는 함수





**문자열 처리 (RPAD, LPAD / RTRIM, LTRIM, TRIM)**

- RPAD(), LPAD()는 좌측 또는 우측에 문자를 덧붙여서 지정된 길이의 문자열로 만드는 함수
- RTRIM() LTRIM(), TRIM() 함수는 문자열의 우측 또는 좌측, 전체에 연속된 공백 문자를 제거하는 함수



**문자열 결합(CONCAT)**

- 문자열 결합하는 함수



**GROUP BY 문자열 결합 (GROUP_CONCAT)**

- GROUP_CONCAT() 함수는 값들을 먼저 정렬한 후 연결하거나 각 값의 구분자 설정도 가능하고 여러 값 중에서 중복을 제거하고 연결하는 것도 가능하므로 상당히 유용하게 사용되는 함수임
- GROUP_CONCAT() 함수는 지정한 칼럼의 값들을 연결하기 위해 제한적인 메모리 버퍼 공간을 사용함
- JDBC로 실행될때 지정된 버퍼 크기를 초과하면 경고가 아니라 에러로 출력되니 주의



**값의 비교와 대체(CASE WHEN .. THEN ..END)**

- CASE WHEN은 함수가 아니라 SQL 구문임
- 서브쿼리가 필요한 경우에만 사용하면 성능 효과를 볼 수 있음



**타입의 변환 (CAST, CONVERT)**

- 프리페어 스테이트먼트를 제외하면 SQL은 텍스트 기반으로 작동하기 때문에 SQL에 포함된 모든 입력 값은 문자열처럼 취급됨
- 이럴 때 만약 명시적으로 타입의 변환이 필요하면 CAST() 를 사용하면 됨



**이진값과 16진수 문자열 변환**

- HEX() 함수는 이진값을 사람이 읽을 수 있는 형태의 16진수 문자열로 변환하는 함수고 UNHEX()는 반대



**암호화 및 해시 함수 (MD5, SHA)**

- 둘 다 모두 비대칭 알고리즘 



**처리 대기**

- 프로그래밍언어의 SLEEP을 SLEEP()함수로 구현 가능함
- 레코드 건수 만큼의 SLEEP을 검



**벤치 마크**

- BENCHMARK() 함수는 디버깅이나 간단한 함수의 성능 테스트용으로 아주 유용한 함수
- 첫번째 인자는 반복할 회수 두번쨰 인자는 반복해서 실행할 표현식
- 실제 SELECT expr와 SELECT BENCHMARK(10 , expr)는 차이가 있음 벤치마크의 경우 횟수에 관계없이 단 1번의 네트워크, 쿼리 파싱 및 최적화 비용이 소요된다는 점을 고려할것
- BENCHMARK() 함수로 얻은 쿼리나 함수의 성능은 그 자체로는 별로 의미가 없으며 두 개의 동일 기능을 상대적으로 비교 분석하는 용도로 사용할 것을 권장함



**IP 주소 변환 (INET_ATON, INENT_NTOA)**



**MYSQL 전용 암호화(PASSWORD, OLD_PASSWORD)**

- 4.0이하에서 사용되던 함수 PASSWORD()는 이후에 OLD_PASSWORD() 임을 참고



**VALUES()**

- PK나 유니크 키가 중복되는 경우에 UPDATE 아니면 INSERT 하는 쿼리에 사용

```sql
INSER INTO t (m , v)
SELECT m, COUNT(*) AS cnt
	FROM t
	GROUP BY m
ON DUPLICATE KEY
	UPDATE visit_count = visit_count + COUNT(*);
```





**COUNT(*)**

- 결과 레코드 건수를 반환하는 함수
- MyISAM스토리지 엔진에서는 결과 레코드 건수를 관리하고 있어서 count(*)이 매우 빠르게 처리됨 where조건에서는 안됨
- 매우 큰 테이블에서 WHERE 없는 COUNT(*)는 조심해야됨
- COUNT(\*)에서 가장 많이 하는 실수는 ORDER BY나 LEFT JOIN 과 같은 레코드 건수와 관련 없는 작업임 COUNT(\*)에는 ORDER BY가 필요 없음 LEFT JOIN 역시 아우터 테이블 기준이므로 체크할 필요 없음
- 인덱싱 못한 COUNT(*)는 성능이 매우 안좋음 생각보다 많이 간과하는 문제
- NULL이 아닌 레코드의 개수만 반환한다는점 참고



### SQL 주석

- `--` 으로 한줄 전체 `/*BLA BLA */` 형태로 여러줄 형태 가능함
- MYSQL에선 #도 한줄 주석이 가능함
- MYSQL에서 `/*! SELECT ... */` 로도 사용 가능함 <- 자세한 설명은 생략함 필요할때 찾아볼 것



## SELECT

### SELECT 각 절의 처리 순서

```sql
SELECT s.emp_no, COUNT(DISTINCT e.first_name) AS cnt
FROM salaries s
	INNER JOIN employyes e ON e.emp_nos.emp_no
WHERE s.emp_no IN (100001, 100002)
GROUP BY s.emp_no
HAVING AVG(s.salary) > 000
ORDER BY AVG(s.salary)
LIMIT 10;
```

- 위 경우에 쿼리 순서는 다음과 같음
  - FROM 에서 WHERE 및 JOIN 실행
  - GROUP BY
  - DISTINCT
  - HAVING
  - ORDER BY
  - LIMIT
- 대부분 위 쿼리처럼 실행됨
- GROUP BY 없는 ORDER BY 쿼리의 경우 다음과 같은 순서도 가능함
  - FROM
  - ORDER BY
  - WHERE 및 JOIN
  - LIMIT
- 위에 소개한 쿼리 실행 순서를 벗어나려면 서브쿼리 인라인 뷰를 써야함
- 인라인뷰는 임시테이블을 사용하므로 주의해야함
- MYSQL의 LIMIT은 WHERE 조건으로 사용하지 않고 항상 모든 처리 결과에 대해 레코드 건수를 제한하는 형태로 사용함을 참고



### WHERE 절과 GROUP BY절, 그리고 ORDER BY 절의 인덱스 사용

**인덱스를 사용하기 위한 기본 규칙**

- WHERE 절이나 ORDER BY, GROUP BY가 인덱스를 사용하려면 기본적으로 인덱스된 칼럼의 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야함
- 인덱스가 잡힌 순수한 칼럼으로 검색해야만 인덱스의 효과를 볼 수 있음
- 칼럼값 여러개를 곱하거나 더해서 비교해야 하는 복잡한 연산이 필요할 때는 미리 계산된 값을 저장할 별도의 칼럼을 추가하고 그 칼럼에 인덱스를 생성하는 것이 유일한 해결책임
- 추가적으로 WHERE 절에 사용되는 비교 조건에서 양쪽의 두 비교 대상 값은 데이터 타입이 일치해야함



**WHERE 절의 인덱스 사용**

- WHERE 조건이 인덱스를 사용하는 방법은 크게 범위 제한 조건과 체크 조건으로 두가지 방식으로 구분해 볼 수 있음
- 둘 중에서 범위 제한 조건은 동등 비교 조건이나 IN으로 구성된 조건이 인덱스를 구성하는 칼럼과 얼마나 좌측부터 일치하는가에 따라 달라짐
- WHERE 절에서의 각 조건이 명시된 순서는 중요치 않고, 그 칼럼에 대한 조건이 있는지 없는지가 중요함
- WHERE에서 OR는 테이블 풀 스캔이 날 수 있으므로 매우 주의해야함
- 범위 제한 조건이 실제 값을 읽어오는 작업이고 체크작업은 그냥 체크하는 작업임 참고



**GROUP BY 절의 인덱스 사용**

- GROUP BY 절의 각 칼럼읜 비교 연산자를 갖지 않으므로 범위 제한 조건이나 체크 조건과 같이 구분해서 생각할 필요는 없음
- GROUP BY 절에 명시된 칼럼의 순서가 인덱스를 구성하는 칼럼의 수와 같으면 GROUP BY 절은 일단 인덱스를 사용할 수 있음
- 다중컬럼 인덱스나 단일 칼럼 인덱스에도 똑같이 적용됨
  - GROUP BY 절에 명시된 칼럼이 인덱스 칼럼의 순서와 위치가 같아야함
  - 인덱스를 구성하는 칼럼 중에서 뒷쪽에 있는 칼럼은 GROUP BY 절에 명시되지 않아도 인덱스를 사용할 수 있지만 인덱스의 앞쪽에 있는 칼럼이 GROUP BY 절에 명시되어 있지 않으면 인덱스를 사용할 수 없음
  - WHERE 조건절과는 달리 GROUP BY 절에 명시된 칼럼이 하나라도 인덱스에 없으면 GROUP BY 절은 전혀 인덱스를 이용하지 못함
- WHERE절에서 이미 상수값으로 조건검색을 했다면 GROUP BY에서 제외되도 인덱스를 사용할 수 있음



**ORDER BY 절의 인덱스 사용**

- MYSQL에서 GROUP BY와 ORDER BY는 처리 방법이 상당히 비슷함
- ORDER BY의 경우 ASC, DESC 옵션이 인덱스와 같거나 또는 정반대의 경우에만 사용할 수 있음
- MYSQL의 경우 인덱스는 모든 칼럼이 오름차순으로만 정렬돼 있기 때문에 ORDER BY 절의 모든 칼럼이 오름차순이거나 내림차순일 때만 인덱스를 사용할 수 있음
- 인덱스의 정의된 칼럼의 왼쪽부터 일치해야함



**WHERE 조건과 ORDER BY (또는 GROUP BY) 절의 인덱스 사용**

- 실무에서는 인덱스를 한개만 사용할만큼 단순하지 않음
- 다음 WHERE 절과 ORDER BY 절이 같이 사용된 하나의 쿼리 문장은 다음 3가지중 한가지 방법으로만 인덱스를 이용함
  - WHERE 절과 ORDER BY 절이 동시에 같은 인덱스를 이용
    - 이 방법이 가장빠름 이 방식으로 쿼리를 튜닝할 수 있다면 제일 좋음
  - WHERE 절만 인덱스를 사용
    - ORDER BY 절은 인덱스를 이용한 정렬이 불가능하며, 인덱스를 통해 검색된 결과 레코드를 별도의 정렬 처리 과정을 거쳐서 정렬을 수행함 주로 이 방법은 WHERE 절의 조건에 일치하는 레코드의 건수가 많지 않을 때 효율적인 방식
  - ORDER BY 절만 인덱스를 이용
    - ORDER BY 절의 순서대로 인덱스를 읽으면서 레코드 한 건씩을 WHERE 절의 조건에 일치하는지 비교해 일치하지 않을 때는 버리는 형태로 처리함 주로 아주 많은 레코드를 조회해서 정렬해야 할 때 사용
- WHERE 절에서 동등비교조건으로 비교된 칼럼과 ORDER BY 절에 명시된 칼럼이 순서대로 빠짐없이 인덱스 칼럼의 왼쪽부터 일치해야함
- 가능하면 WHERE 절과 ORDER BY 절의 인덱스 컬럼을 명시해주는게 좋을듯 함
- 범위 조건 < > 일 경우 ORDER BY 절의 인덱스 컬럼을 반드시 명시해줘야 인덱스 사용이 가능함
- GROUP BY 도 위 내용 전부 똑같은 기준이 적용됨
- WHERE 절과 ORDER BY, GROUP BY절의 조합에서 인덱스 사용 여부를 판단하는 능력은 매우매우 중요함



**GROUP BY 절과 ORDER BY절의 인덱스 사용**

- GROUP BY와 ORDER BY 절 모두에 인덱스를 사용하려면 명시된 칼럼이 순서와 내용이 모두 같아야함
- 이 둘중 하나라도 인덱스를 사용하지 못하면 둘 다 사용 못함



**WHERE 조건과 ORDER BY 절, 그리고 GROUP BY 절의 인덱스 사용**

![KakaoTalk_20201204_143209937](https://user-images.githubusercontent.com/30790184/101125866-970c4200-363d-11eb-99d1-4470680fc190.jpg)



### WHERE 절의 비교 조건 사용 시 주의사항

- WHERE절에 사용되는 비교 조건의 표현식은 상당히 중요함!

**NULL 비교**

- 다른 DBMS와는 조금 다르게 MYSQL에서는 NULL값이 포함된 레코드도 인덱스로 관리됨
- MYSQL에서는 NULL도 하나의 값으로 인정해서 관리함 인덱스로 관리함
- IS NULL을 통해 NULL 값을 검사할 수 있음
- ISNULL() 함수도 있지만 가급적 IS NULL 연산자를 사용할 것



**문자열이나 숫자 비교**

- 문자열 칼럼이나 숫자 칼럼을 비교할 때는 반드시 그 타입에 맞춰서 상수를 사용할 것을 권장함
- 그렇지 않을 경우 인덱스를 적절하게 사용하지 못함



**DATE나 DATETIME과 문자열 비교**

- DATE나 DATETIME과 문자열 비교를 할 때는 문자열 값을 자동으로 DATETIME 타입의 값으로 변환해서 비교를 수행함
- 문자열로 사용해도 인덱스를 잘타니 성능 고려 안해도됨
- DATE나 DATETIME 칼럼을 DATE_FORMAT() 함수로 문자열 변환시켜서 하는 경우에는 인덱스를 활용 못함
- 추가적으로 DATE_ADD(), DATE_SUB() 같은 함수를 사용해도 인덱스 활용 못함



**DATE와 DATETIME비교**

- DATETIME값에서 시간 부분만 떼어 버리고 비교하려면 DATE_TIME > DATE(NOW())처럼 DATE() 함수를 사용하면 됨
- DATETIME과 DATE타입의 비교에서 타입 변환은 인덱스의 사용 여부에 영향을 미치지 않음



**DATETIME과 TIMESTAMP의 비교**



### DISTINCT

- 특정한 칼럼에 유니크한 값을 조회하려면 SELECT 쿼리에 DISTINCT를 사용함
- DISTINCT는 집계함수와 함꼐 사용하는 경우와 아닌경우가 있음
- 집합 함수와 같이 DISTINCT가 사용되는 쿼리의 실행 계획에서 DISTINCT 처리가 인덱스를 사용하지 못할 때에는 항상 임시테이블을 사용하는데 이때 Extra 컬럼에서 Using temporary가 출력되지않음



**SELECT DISTINCT ...**

- 단순히 SELECT되는 레코드 중에서 유니크한 레코드만 가지려면 SELECT DISTNCT .. 형태의 쿼리 문장을 이용함
- 이 경우엔 GROUP BY와 거의 같은 방식으로 처리됨
- 단지 DISTINCT는 정렬을 보장하지 않음, <- 인덱스를 사용하지 못할 경우
- DISTINCT 뒤에 괄호가 있는 형태는 무시함 절대 일부 칼럼만 유니크하게 조회하는 경우는 없음



**집합 함수와 함께 사용된 DISTINCT**

- COUNT(), MAX(), MIN()과 같은 집합 함수 내에서 DISTINCT는 좀 다르게 동작함
- 집합 함수 내에서 사용된 DISTINCT는 그 함수의 인자의 조합 가운데 유일한 값만 가져옴
- 인덱스가 없는 상태에서 COUNT( DISTINCT s.salary ) 형태로 사용하면 인덱스를 활용하지 못하기 때문에 임시테이블을 만들어서 처리함. 이때 Extra 컬럼에 Using temporary가 출력되지 않음



### LIMIT n

- LIMIT은 MYSQL에만 존재하는 키워드 오라클의 ROUNUM, MS-SQL의 TOP n과 비슷함 BUT 작동 방식은 조금 다름

```sql
SELECT * FROM employees
WHERE emp_no BETWEEN 10001 AND 10010
ORDER BY first_name
LIMIT 0,5;
```

- 위 쿼리는 다음과 같은 순서로 실행됨
  - employees 테이블에서 WHERE 절의 검색 조건에 일치하는 레코드를 전부 읽어옴
  - 1번에서 읽어온 레코드를 first_name 칼럼 값에 따라 정렬함
  - 정렬된 결과에서 상위 5건만 사용자에게 반환함
- 항상 쿼리의 마지막에 실행되는게 LIMIT, 즉 위 쿼리에서 모든 레코드의 정렬이 완료되지 않았다 하더라도 상위 5건까지만 정렬이 되면 작업을 멈춘다는 얘기임
- 정렬이나 그룹핑 또는 DISTICNT가 없는 쿼리에서 LIMIT 조건을 사용하면 쿼리가 상당히 빨리 끝남
- LIMIT과 GROUP BY를 함께 사용하면 실질적인 서버의 작업 내용을 크게 줄여주지는 못함
- DISTINCT와 ㅣLIMIT은 실질적인 중복 제거 작업의 범위를 줄이는 역할을 함
- GROUP BY나 ORDER BY와 같이 전체 범위 작업이 선행되더라도 LIMIT 옵션이 있다면 크진 않지만 나름의 성능 향상은 볼 수 있음
- 만약 GROUP BY, ORDER BY, DISTINCT 모두 인덱스를 사용할 수 있으면 LIMIT을 통해 상당히 빠르게 처리할 수 있음
- LIMIT의 인자로 표현식이나 별도의 서브쿼리는 불가함
- LIMIT 0 과 같은 형태로 사용하면 MYSQL 옵티마이저는 쿼리를 최적화 실행만하고 응답하기 때문에 커넥션 풀에서 커넥션의 유효성을 체크할 때 유용하게 사용할 수 있음



### JOIN

**JOIN의 순서와 인덱스**

- 인덱스 스캔으로 레코드를 읽는 작업
  1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾음, 이과정을 인덱스 탐색이라고함
  2. 1번에서 탐색된 위치부터 필요한 만큼 인데스를 쭉 읽음. 이 과정을 인덱스 스캔이라고함
  3. 2번에서 읽어들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어옴
- 인덱스 레인지 스캔 작업에서는 가져오는 레코드의 건수가 소량이기 때문에 인덱스 스캔 과정은 부하가 작지만 특정 인덱스 키를 찾는 인덱스 탐색 과정이 상대적으로 부하가 높은편임
- 조인 작업에서 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단한 번만 수행하고 그 이후부터는 스캔만 실행하면 됨
- 드리븐 테이블이 더 많은 부하를 얻게 되어 있음

```sql
SELECT *
FROM employees e, dept_emp de
WHERE e.emp_no = de.emp_no;
```

- 두 칼럼 모두 인덱스가 있을 경우
  - 두 테이블 emp_no에 인덱스가 있을 경우 어느 테이블로 처리하던지 작업이 빠르게 처리됨
  - 옵티마이저가 드라이빙 테이블을 알아서 선택
- employees.emp_no에만 인덱스가 있을 경우
  - employees가 드라이빙 테이블이 된 경우 employees 테이블에서 선택된 레코드만큼 dept_emp 테이블을 풀스캔해야함
- dept_em.emp_no에만 인덱스가 있을 경우
  - 반대로 처리됨
- 두 칼럼 모두 인덱스가 없는 경우
  - 옵티마이저가 알아서 드라이빙 테이블을 선택함 레코드 건수가 적은 테이블이 효과적임
  - 드리븐 테이블을 읽을때 조인버퍼가 사용되기 때문에 extra 칼럼에 using join buffer 가 표시됨



- 드라이빙 테이블은 풀 테이블 스캔을 사용할 수는 있어도 드리븐 테이블을 풀 테이블 스캔으로 접근하는 실행계획은 옵티마이저가 거의 만들어내지 않음





**JOIN 칼럼의 데이터 타입**

- 조인 칼럼 간의 비교에서 각 칼럼의 데이터 타입이 일치하지 않으면 인덱스를 효율적으로 이용할 수 없음
- 인덱스 사용에 영향을 미치는 데이터 타입 불일치는 CHAR <-> VARCHAR, INT <-> BIGINT, DATE <-> DATETIME에서는 발생하지 않음
- 다음 경우 조심
  - CHAR타입과 INT 타입의 비교와 같이 데이터 타입의 종류가 완전히 다른 경우
  - 같은 CHAR 타입이더라도 문자 집합이나 콜레이션이 있는 경우
  - 같은 INT 타입이더라도 부호가 있는지 여부가 다른 경우



**OUTER JOIN의 주의사항**

- OUTER JOIN에서 OUTER로 조인되는 테이블에 칼럼에 대한 조건은 모두 ON 절에 명시해야함 (MYSQL)
- WHERE 조건 역시 반드시 ON 절에 명시해야함 WHERE 를 따로 쓰면 옵티마이저가 INNER JOIN으로 변경함



**OUTER JOIN과 COUNT(*)**

- OUTER JOIN 을 제거할 수 있는 경우에는 제거하는게 좋음 예를들어 1:N 상황에서 N 테이블을 기준으로 잡는 경우엔 사실 OUTER JOIN이 필요 없음



**OUTER JOIN을 이용한 ANTI JOIN**

```sql
SELECT t1.id
FROM tab_test1 t1
	LEFT JOIN tab_test2 t2 ON t1.id= t2.id
WHERE t2.id IS NULL;
```

- 위와 같은 쿼리를 ANTI JOIN 이라함
- 책 참고



**INNER JOIN과 OUTER JOIN의 선택**

- OUTER JOIN과 INNER JOIN은 실제 가져오는 레코드가 같다면 쿼리의 성능은 거의 차이가 없음
- INNER JOIN과 OUTER JOIN은 성능 고려가 아니라 업무적 요건에 따라 선택할 것



**FULL OUTER JOIN 구현**

- MYSQL 에서는 FULL OUTER JOIN은 제공하지 않고 UNION으로 묶어야함
- UNION이나 UNION ALL은 모두 내부적임 임시 테이블을 사용하므로 결과가 버퍼링되어야 하고 그로 인해 쿼리가 느리게 처리됨
- 성능이 걱정되면 뮤텍스 테이블을 사용할 것 뮤텍스 테이블이란 copy_t라고도 많이 알려져 있는데 단순히 레코드를 n개 만큼 복제하는 역할을 하는 테이블임
- 뮤텍스 테이블은 추가 검색할 것 생략





**조인 순서로 인한 쿼리 실패**



**JOIN과 FOREIGN KEY**

- FOREIGN KEY는 JOIN과 연관이 없음 데이터 무결성을 위해서 존재함



**지연된 조인**

- 조인이 실행되기 이전에 GROUP BY나 ORDER BY를 처리하는 방식
- 일반적으로 지연된 조인으로 쿼리를 개선했을 때 FROM 절의 서브 쿼리 결과가 저장되는 임시 테이블이 드라이빙 테이블이 되어 나머지 테이블과 조인을 수행하므로 임시 테이블에 저장되는 레코드 건수가 작업량에 커다란 영햐을 미치게됨
- 파생 테이블에 저장돼야 할 레코드의 건수가 적으면 적을수록 지연된 조인의 효과가 커짐 따라서 GROUP BY나 DISTINCT 등과 LIMIT 절이 함께 사용된 쿼리에서 상당히 효과적임
- 지연된 조인은 경우에 따라서 상당한 성능 향상을 가져올 수 있지만 OUTER JOIN과 INNER JOIN의 특정 조건이 있어야함
  - LEFT JOIN인 경우 드라이빙 테이블과 드리븐 테이블이 1:1 또는 M:1 관계여야함
  - INNER JOIN인 경우 드라이빙 테이블과 드리븐 테이블은 1:1 또는 M:1 관계임과 동시에 드라이빙 테이블에 있는 레코드는 드리븐 테이블에 모두 존재해야함 두 번쨰와 세 번째 조건은 드라이빙 테이블을 서브쿼리로 만들고 이 서브쿼리에 LIMIT을  추가해도 최종 결과의 건수가 변하지 않는다는 보증을 해주는 조건이기 때문에 반드시 정확히 확인한 후 적용해야함
- 성능차이를 비교해보고 결정할 것

```sql
SELECT *
FROM (SELECT * FROM employees e LIMIT 990, 10) e
	LEFT JOIN dept_emp de ON de.emp_no = e.emp_no
		AND NOW() BETWEEN de.from_date AND de.to_date;
```

- 지연된 조인은 조인의 개수를 줄이는 것 뿐만아니라 group by나 order by 처리가 필요한 레코드의 전체 크기를 줄이는 역할도 함 



**조인 버퍼 사용으로 인한 정렬 흐트러짐**

- 조인 버퍼를 사용하면 그 결과는 드라이빙 테이블의 pk나 인덱스에 대한 정렬로 이뤄지지 않음
- 조인 버퍼를 사용한 조인은 드라이빙 테이블과 드리븐 테이블을 읽은 순서와는 거의 무관하게 결과를 출력함



### GROUP BY

**GROUP BY 사용시 주의사항**

- MYSQL에서는 GROUP BY를 사용하도 SELECT 하는 칼럼에 집합 또는 집합함수가 없더라도 실행됨 <- 매우 안좋음
- 설정에서 변경할 수 있음



**GROUP BY .. ODER BY NULL**

- MYSQL에서 GROUP BY가 불필요한 정렬 작업을 하지 않게 하려면 GROUP BY를 수행할 때 ORDER BY NULL 이라는 키워드를 사용해야함
- GROUP BY의 결과 건수가 많아지면 많아질수록 정렬 작업으로 인한 성능 저하가 커짐



**GROUP BY col1 ASC col2 DESC**

- 거의 사용하지 않지만 GROUP BY에 칼럼 정렬 순서를 명시할 수 있음
- MYSQL의 GROUP BY가 정렬까지 수행하기 때문임
- GROUP BY 절의 칼럼 나열에 인덱스 순서를 꼭 지키고 ORDER BY를 사용할 것



**GROUP BY ..WITH ROLLUP**

- GROUP BY가 사용된 쿼리에는 그룹핑된 그룹별로 소계를 가져올 수 있는 롤업 기능을 사용할 수 있음
- ORDER BY와 함께사용 안됨
- 찾아볼 것



**레코드를 칼럼으로 변환**

**하나의 칼럼을 여러 칼럼으로 분리**

- 둘다 CASE문으로 다시 읽어서 통계하거나 분리하는 쿼리로 할 수 있음





### ORDER BY

- 인덱스를 사용하면 인덱스의 정렬순서대로, 풀테이블스캔이라면 디스크에 저장된 순서대로, InnoDB는 사용자가 지정했던 아니던 클러스터링되어있기 때문에 pk기반으로 가져옴
- 반드시 정렬이 필요하면 ORDER BY를 사용할 것
- ORDER BY에서 인덱스를 사용못하면 Using filesort가 출력됨



**ORDER BY 사용법 및 주의사항**

- 문자 리터럴을 사용하지 말 것



**ORDER BY RAND()**

- 이벤트 성격의 단순한 추첨 또는 임의의 사용자 조회와 같은 기능을 사용할 때 ORDER BY RAND()가 유용함
- 랜덤하게 정렬을 수행함
- 이 방법은 절대 인덱스를 사용할 수 없음
- 나중에 다시 설명



**여러 방향으로 동시 정렬**

- MYSQL은 내림차순과 오름차순이 혼용된 인덱스를 지원하지 않음
- ASC와 DESC가 혼용된 정렬이 인덱스를 사용하게 하려면 칼럼의 값 자체를 변형시켜 테이블에 저장하는 것이 유일한 해결책
- 숫자 타입을 음수로 변경해서 사용할 수 있음
- NULL은 항상 최소값으로 간주하고 정렬함
- 여러 방향으로 동시 정렬이 필요한 경우 애플리케이션의 도움을 받을 수 있음
- 쿼리를 분리하는 방법은 다음과 같은 상황에 유용함
  - 정렬해야 할 레코드 건수가 너무 많아서 디스크를 이용해야 할 경우
  - 첫번째 정렬 칼럼에 중복된 값이 많아서 두 번쨰 쿼리의 반복 실행 횟수가 적은 경우



**함수나 표현식을 이용한 정렬**

- 연산결과, 함수를 사용하면 인덱스를 사용할 수 없음



**표현식의 결과 순서가 칼럼의 원본 값 순서와 동일할 때**

**표현식의 정렬 순서가 칼럼의 원본 값과 다른 경우 (연산의 결과가 칼럼의 값에만 의존적인 경우)**

- 테이블의 원본 칼럼으로부터 어떤 연산의 결과를 따로 저장하는 칼럼인 추출칼럼을 두는 방법밖에 없음



**표현식의 정렬 순서가 칼럼의 원본 값과 다른 경우(연산의 결과가 칼럼 이외의 값에 의존적인 경우)**

- 일반적으로 인덱스를 이용해 정렬할 수 없을 때는 쿼리가 가져오는 값의 크기가 크면 클수록 느리므로 select 되는 칼럼을 최소화하는 것이 좋음



### 서브 쿼리

- mysql은 서브쿼리를 최적으로 실행하지 못할 때가 많음 가장 대표적으로 from, where에 사용되는 서브쿼리들
- 상관 서브쿼리
  - 서브쿼리 외부에서 정의된 테이블의 칼럼을 참조해서 검색을 수행할 때 상관 서브쿼리라 함
  - 상관 서브쿼리는 외부 쿼리보다 먼저 실행되지 못하기 때문에 일반적으로 범위 제한 조건이 아니라 체크조건으로 사용됨
- 독립 서브쿼리
  - 외부 쿼리의 칼럼을 사용하지 않고 서브 쿼리에서 정의된 칼럼만 참조할 때 독립 서브쿼리라 함
  - 외부 쿼리보다 먼저 실행되기 때문에 범위 제한 조건으로 사용됨
  - mysql에서는 독립 서브쿼리라 하더라도 효율적으로 처리되지 못할 때가 많음

**서브쿼리의 제약사항**

- 서브쿼리는 대부분의 쿼리 문장에서 사용할 수 있지만 LIMIT 절과 LOAD DATA INFILE의 파일 명에는 사용할 수 없음
- 서브 쿼리를 IN 연산자와 함께 사용할 때에는 효율적으로 처리되지 못함.
- IN연산자 안에 사용하는 서브쿼리에는 ORDER BY와 LIMIT을 동시에 사용할 수 없음
- FROM 절에 사용하는 서브쿼리는 상관 서브쿼리형태로 사용할 수 없음. 
- 서브쿼리를 이용해 하나의 테이블에 대해 읽고 쓰기를 동시에 할 수 없음



**SELECT 절에 사용된 서브 쿼리**

- SELECT 절에 사용된 서브 쿼리는 내부적으로 임시테이블을 만들거나 쿼리를 비효율적으로 실행하지 않기 때문에 서브쿼리가 인덱스를 사용할 수 있다면 크게 주의할 사항은 없음
- 서브쿼리보다 조인이 훨씬 빠르기 때문에 가능하면 조인으로 쿼리를 작성할 것





**WHERE 절에 단순 비교를 위해 사용된 서브 쿼리**

- 상관 서브쿼리는 범위 제한 조건으로 사용되지 못함 모든 RDBMS에 적용
- 일반적으로 독립 서브쿼리는 그 결과가 상수로 변환되고 실행됨
- MYSQL 독립 서브 쿼리는 조금 다름

```sql
SELECT * FROM dept_emp de
WHERE de.emp_no=
	(SELECT e.emp_no
	FROM employees e
	WHERE e.first_name='Georgi' AND e.last_name='Facello' LIMIT 1)
```

- 위 쿼리는 dept_emp 테이블을 풀 테이블 스캔으로 레코드를 한 건씩읽으면서 서브쿼리를 매번 실행한 뒤 그 결과를 비교함
- mysql에서는 절대 위와 같이 사용하면 안될 듯 ....
- 5.5 이하에서는 위와 같이 정말 안좋고 5.5이상에서는 최적화 되어서 사용할 수 있음



**WHERE 절에 IN과 함께 사용된 서브쿼리 - IN (subquery)**

- mysql에서 in절에 서브쿼리를 사용하면 드라이빙 테이블은 풀 테이블 스캔을 함
- 서브쿼리도 독립 서브쿼리라고 작성해도 상관 서브쿼리로 변경해서 날라감
- 반드시 다른 형태로 사용할 것
- IN 쿼리는 옵티마이저가 Exists 로 변경해서 사용함
- 바깥쪽 테이블과 서브 쿼리 테이블의 관계 1:1이거나 M:1인 경우
  - 바깥 쪽 쿼리와 서브 쿼리를 조인으로 풀어서 작성해도 같은 결과가 보장되기 떼문에 조인으로 풀어서 작성할 것
- 바깥쪽 테이블과 서브 쿼리 테이블의 관계가 1:M인 경우
  - 조인컬럼으로 GROUP BY해서 가져오기, 이 방법은 반드시 GROUP BY가 인덱스를 사용할 수 있어야함





**WHERE 절에 NOT IN과 함께 사용된 서브쿼리 - NOT IN (subquery)**

- IN 보다 더 비효율적으로 처리됨
- IN 형태의 쿼리는 MYSQL 옵티마이저가 Exists로 변경하는 것처럼 NOT IN은 NOT EXISTS 형태로 변경해서 실행함
- MYSQL에서 NOT IN 형태의 최적화는 왼쪽의 값이 NULL인지 아닌지에 따라 NOT EXISTS로 최적화를 적용할지 말지가 결정됨 왼쪽 값이 실제 NULL이아니면 특별히 문제가안되는데 NULL일 경우에는 오른쪽에 위치한 서브 쿼리가 결과를 한 건이라도 가지는지 판단해야함 이때 서브쿼리를 실행해 결과가 한 건이라도 있는지 판단해야 할 때는 절대 인덱스를 사용할 수 없음
- 옵티마이저가 NOT IN 을 최적화 하기 위해 trigcond 라는 선택적인 최적화 방법을 사용하기 때문임
- 결론적으로 mysql 옵티마이저는 NOT IN (subquery) 조건으로 인해 매우 많은 작업들이 내부적으로 처리됨 이러한 복잡성을 피하려면 MYSQL의 옵티마이저가 NULL에 대한 고려 없이 쿼리 최적화하기 위해 컬럼이 NOT NULL인게 좋음
- NOT IN도 OUTER JOIN으로 풀어서 사용하면 됨
- 비교적 서브쿼리보다 빠르게 실행되지만 그래도 벤치마킹해서 성능 차이를 직접 확인해보는게 좋음



**FROM 절에 사용된 서브 쿼리**

- FROM 절의 서브쿼리는 반드시 JOIN으로 사용할 것!
- 인라이뷰는 반드시 임시 테이블 형태로 사용됨 이는 디스크 병목지점의 원인이 될 수 있음



### 집합 연산

- 집합 연산은 여러 테이블의 레코드를 연결하는 방법임
- UNION, INTERSECT, MINUS가 있음
- 이들 집합연산 역시 임시 테이블을 사용함

**UNION (DISTINCT와 ALL)**

- UNION뒤에 아무것도 명시하지 않으면 기본적으로 DISTINCT가 적용됨
- UNION ALL은 두 개 의 집합에서 중복된 레코드에 대한 별도의 처리 과정 없이 반환함
- UNION을 수행해야 할 대상은 이미 임시 테이블로 만들어 졌기 때문에 PK같은 중복체크의 기준이 없어서 모든 칼럼을 비교해야 중복 처리를 할 수 있음 대상 레코드의 건수가 많아져도 처리 성능이 떨어지지만 비교해야하는 칼럼 값의 길이가 길면 더 느려짐
- UNION (DISTINCT)는 유니크 인덱스를 생성해서 성능이 더 안좋음
- 중복레코드가 발생할 가능성이 없음에도 불구하고 UNION ALL이 아니라 UNION이 사용된 경우가 의외로 많음 만약 중복이 없음을 보장할 수 있다면 UNION ALL을 사용하는게 성능상 매우 빠르게 처리됨
- 가능하다면 UNION ALL을 제거하고 UNION ALL로 바꿀것



**INTERSECT**

- INTERSECT는 교집합 부분만을 가져오는 쿼리임
- INTERSECT는 사실 INNER JOIN이랑 동일함
- MYSQL에서는 INTERSECT를 제공하지 않음 JOIN으로 풀어서 사용할 것



**MINUS**

- MINUS는 첫번째 결과 집합에서 두 번째 결과 집합의 내용을 빼는 것
- MYSQL에서 지원하지 않지만 JOIN이나 EXISTS로 바꿔서 구현할 수 있음
- JOIN으로 풀어서 사용할 것





### LOCK IN SHARE MODE와 FOR UPDATE

- InnoDB에서 레코드를 SELECT 할 때는 아무런 잠금도 걸지 않음
- 레코드를 읽으면서 강제로 잠금을 걸어둘 필요가 있는데 이때 사용하는 명령이 LOCK IN SHARE MODE와 FOR UPDATE임
- 이 두가지 명령은 전부 AUTO-COMMIT이 비활성화 된 상태 또는 BEGIN 명령이나 START TRANSACTION명령으로 트랜잭션이 시작된 상테에서만 잠금이 유지됨
  - LOCK IN SHARE MODE: SELECT 된 레코드에 대해 읽기 잠금 을 설정하고 다른 세션에서 해당 레코드를 변경하지 못하게 함, 다른 세션에서 읽는 것은 가능함
  - FOR UPDATE: 쓰기 잠금을 설정하고 다른 트랜잭션에는 그 레코드를 변경하는 것뿐만 아니라 읽지도 못하게 함

```sql
SELECT * FROM employees WHERE emp_no = 10001 LOCK IN SHARE MODE;
SELECT * FROM employees WHERE emp_no = 10001 FOR UPDATE;
```

- 위와 같은 쿼리로 잠긴 레코드는 COMMIT이나 ROLLBACK 명령과 함께 해제됨
- 데드락을 일으키는 경우가 있으므로 참고할것





### SELECT INTO OUTFILE

- SELECT INTO .. OUTFILE 명령은 파일로 저장할 수 있음
- SELECT INTO .. OUTFILE 명령 시 주의사항
  - SELECT 결과는 MYSQL 클라이언트가 아니라 MYSQL 서버가 기동중인 장비의 디스크로 저장됨
  - SELECT INTO .. OUTFILE 명령의 결과를 저장할 파일. 그리고 파일이 저장되는 디렉터리는 MYSQL 서버를 기동중인 운영체제의 계정이 쓰기 권한을 가지고 있어야함
  - 이미 동일 디렉터리에 동일한 파일이 있을때 기존 파일을 덮어쓰지 않고 에러를 발생시킴
- 이하 생략





## INSERT



### INSERT와 AUTO_INCREMENT



### AUTO_INCREMENT 제약 및 특성

- AUTO_INCREMENT 속성으로 정의된 칼럼은 별도로 값을 할당하지 않고 사용하는 것이 일방적
- 값을 지정한다면 AUTO_INCREMENT속성과 관계 없이 강제로 값을 넣을 수 있음 이때 만약 들어오는 값이 현재 AUTO_INCREMENT 값보다 작다면 변하지 않지만 AUTO_INCREMENT 값보다 더 큰 값이 들어온다면 그 값이 AUTO_INCREMENT에 셋팅됨 
- 반드시 나열하고싶다면 NULL이나 0을 지정하면 AUTO_INCREMENT속성에 의해 알아서 생성됨
- AUTO_INCREMENT 사용시 규칙
  - AUTO_INCREMENT 가진 칼럼은 반드시 PK나 유니크 키의 일부로 정의되어야함
  - AUTO_INCREMENT 속성을 가진 칼럼 하나로 PK를 생성할 때는 아무런 제약이 없음
  - 여러개의 칼럼으로 PK를 생성할 때
    - AUTO_INCREMENT 속성의 칼럼이 제일 앞일 때
      - 아무런 제약 없음
    - AUTO_INCREMENT 속성이 제일 앞이 아닐 때
      - MYISAM에서는 가능한데 InnoDB에서는 UNIQUE INDEX(fd2)와 같이 fd2로 시작하는 UNIQUE 키를 하나 더 생성해야만 함
- AUTO_INCREMENT 일반 칼럼이랑 합쳐서 PK로 생성하면 myisam이랑 innodb랑 조금 다르게 동작함
  - innodb는 선형적으로 쭉 증가하고
  - myisam은 묶여진 컬럼에 대한 pk를 생성함
- AUTO_INCREMENT값이 항상 1씩 증가하는 것은 아니고 MYSQL 서버에 auto_increment_increment와 auto_increment_offset 변수가 있는데 이 값에 따라 결정됨



**AUTO_INCREMENT 잠금**

- 여러 커넥션에서 AUTO_INCREMENT를 동시에 사용할 때 동기화 처리가 필요함. mysql에서는 AutoIncrement 잠금이라는 테이블 단위의 잠금을 사용함
- AutoIncrement 잠금은 반드시 하나의 커넥션만 가질 수 있고 COMMIT이나 ROLLBACK으로 트랜잭션을 반환해야 잠금이 풀림
- 이 잠금은 현재 값을 가져올 때만 잠금이 걸렸다가 즉시해제됨 테이블 락이지만 성능상 문제될 때는 거의 없음
- 이 값이 INSERT 문장으로 한번 증가하면 해당 INSERT 문장이 롤백되어도 원래의 값으로 되돌아가지 않음
- innodb_autoinc_lock_mode를 통해 잠금 방식을 변경할 수 있음 , 생략





**AUTO_INCREMENT 증가 값 가져오기**

- 가장 마지막에 사용된 AUTO_INCREMENT 값은  LAST_INSERT_ID() 라는 함수를 통해 가져올 수 있음
- SELECT MAX() 형태로 가져오지 말 것
- LAST_INSERT_ID()는 네트워크 전송이나 쿼리 실행 시간이 추가적으로 소요되기때문에 JDBC 3.0 이상이라면 다음과 같이 자바의 Statement.getGeneratedKeys()라는 함수를 이용해 추가적인 네트워크 통신 없이 저장된 AUTO_INREMENT 값을 가져올 수 있음
- AUTO_INCREMENT 칼럼이 있는 테이블에 INSERT를 한 번도 수행하지 않은 커넥션에서 AUTO_INCREMENT LAST_INSERT_ID() 함수를 실행하면 항상 0이 반환되므로 주의해야함
- 강제로 넣을때도 0이나 NULL이 아니라면 LAST_INSERT_ID() 함수로 가져올 수 없음





### INSERT IGNORE

- 로그같은 성격의 테이블은 PK나 유니크 키가 중복될때 그냥 버려도 무방할 때가 있음
- 이때 INSERT 문장에 IGNORE 옵션만 추가하면 중복 에러가 발생해도 그냥 무시하고 계속 진행함
- INSERT IGNORE 문장에서 에러가 발생할 때와 발생하지 않을 때
  - INSERT IGNORE 문장이 실패하고 에러가 발생할 때
    - 칼럼 값의 수가 전혀 일치하지 않는 경우가 대표적
  - INSERT IGNORE 문장이 에러 없이 완료되지만 저장되지 않거나 값이 변형되어 저장되는 경우
    - 값이 저장되지 않는 경우
      - 이미 테이블에 PK나 유니크 키가 중복인 레코드가 존재한다면 레코드는 저장되지 않지만 쿼리 자체가 에러로 중지되지 않음
    - 값이 변형되어 저장되는 경우
      - 칼럼에 입력해야 할 값의 칼럼의 타입과 다르거나 NOT NULL 칼럼에 NULL을 저장하려고 할때 알아서 변환해서 저장함
- 값이 의도와 맞게 변형되고 저장되는 건수가 알맞은지 반드시 확인해볼 것





### REPLACE

- MYSQL 고유의 기능인데 유용해서 다른 DBMS도 비슷한 기능이 있음
- INSERT + UPDATE
- REPLACE 문장은 저장하려는 레코드가 중복된 레코드면 UPDATE를 실행하고 중복되지 않으면 INSERT를 수행함. 더 명확하게 따져보면 중복 레코드가 있으면 DELETE하고 새로운 레코드를 INSERT
- REPLACE에서 중복을 판정하는 것은 테이블의 모든 유니크 키에서 동일한 값이 존재하는지를 비교함 PK가 있으면 PK + 유니크키 중복되는 모든 키들을 삭제함 .. pk 따로 유니크 따로



### INSERT INTO ... ON DUPLICATE KEY UPDATE ...

- REPLACE와 거의 흡사한데 DELETE하지 않고 중복된 레코드들을 UPDATE함
- 레코드의 중복 판정은 REPLACE와 같음
- VALUES() 함수가 있는데 생략



### INSERT SELECT

- 특정 테이블로부터 레코드를 읽어 그 결과를 INSERT하는 것
- JOIN, GROUP BY 등 가능
- INSERT 대상 테이블과 SELECT 대상 테이블이 동일한 테이블이면 오류가 발생함
- 이 INSERT SELECT 쿼리는 레코드에 읽기 잠금이 필요함



### LOAD DATA(LOCAL) INFILE ...

- SELECT INTO OUTFILE에 대응하는 적재 기능의 쿼리임
- 생략



## UPDATE



**UPDATE ... ORDER BY ... LIMIT N**

- 정렬 후 상위 몇건만 업데이트도 가능함
- 마스터 슬레이브 관계에서는 조심할 것



### JOIN UPDATE

- 두 개 이상의 테이블을 조인해 조인된 결과 레코드를 업데이터 하는 쿼리를 JOIN UPDATE라 함
- 일반적으로 JOIN UPDATE는 조인되는 모든 테이블에 대해 읽기 참조만 되는 테이블은 읽기 잠금이 걸리고 칼럼이 변경되는 테이블을 쓰기 잠금이 걸림
- 웹서비스, OLTP 같은 환경에서는 데드락 유발 가능성이 높아서 권장 x
- 배치 프로그램이나 통계용 UPDATE문장에서는 유용함
- 테이블의 조인 순서에 따라 성능이 좌우됨 
- UPDATE를 SELECT로 변경해서 쿼리 실행계획을 확인할 수 있음





## DELETE

### DELETE ... ORDER BY ... LIMIT N



### JOIN DELETE



## 스키마 조작

### 데이터베이스

- 너무 기본이라 생략



### 테이블

**SHOW CREATE TABLE**

- SHOW CREATE TABLE [TABLE_NAME]; 을 사용하면 MYSQL서버가 테이블의 메타정보를 읽어서 CREAT TABLE 스크립트를 작성해줌



**RENAME TABLE**

- 테이블의 이름 변경
  - 생략
- 테이블의 DB 변경
  - RENAME TABLE db1.employees TO db2.employees
  - 레코드 수에 관계 없이 특별한 경우가 아니면 빠르게완료됨 <- 같은 물리적 위치일때





**테이블의 상태 조회**

- 테이블이 만들어진 시간, 대략의 레코드 건수, 데이터 파일의 크기, 데이터 파일의 버전이나 레코드 포맷 등 중요한 정보를 조회할 수 있음
- SHOW TABLE STATUS LIKE [TABLE_NAME]



**테이블 구조 복사**

- CREATE TABLE [COPY_NAME] LIKE [TARGET_NAME]
- INSERT INTO temp_employees SELECT * FROM employees;



**테이블 구조 및 데이터 복사**

- CREATE TABLE .. AS SELECT 명령을 이용하면 다른 테이블로 부터 SELECT 된 결과를 이용해 새로운 테이블을 만들 수 있음
- 이때 주의해야할 것이 CREATE TABLE 절에 칼럼 이름을 직접 명시해서 생성하는 경우 SELECT 하는 칼럼의 이름을 그대로 이용해야함



**테이블 삭제**

- 레코드 건수가 많은 테이블을 삭제하는 작업은 상당히 부하가 큰 작업임 서비스중에 삭제는 하지 말 것
- 5.0, 5.1에서 테이블 삭제는 LOCK_open, 글로벌 잠금임 다른 테이블도 블러킹할 수 있음





### 칼럼 변경

- 기본적인건 생략



**칼럼명 이외의 타입이나 NULL 여부를 변경하는 경우**

- CHANGE COLUMN 말고 MODIFY COLUMN 키워드를 사용해야함

**칼럼 변경을 위한 ALTER TABLE 진행 상황**

- MYSQL 서버의 상태 값을 확인해보면 현재 어느정도 ALTER TABLE이 진행됐는지 알 수 있음
- SHOW GLOBAL STATUS LIKE 'Handler%';
  - Handler_read_rdn_next 상태 값은 풀 테이블 스캔 방식으로 테이블의 모든 레코드를 읽을 때 읽은 레코드 건수를 보여줌
  - Handler_writer 상태값은 테이블에 INSERT 되는 레코드 건수를 보여줌



### 인덱스 변경

**인덱스 추가**

- 5.1버전 이상의 innoDB테이블에 대해서는 플러그인 버전부터 데이터 자체는 그대로 두고, 인덱스만 생성하는 형태로 개선됨 그래서 5.0보다는 훨씬 빠름 예외적으로 pk가 추가되면 5.0처럼 모든 레코드들을 복사함
- 추가 가능한 인덱스
  - PRIMARY KEY: 테이블의 PK를 생성하는 키워드, 테이블이 어떤 스토리지 엔진이든지 사용할 수 있음
  - UNIQUE INDEX: 키 값의 중복을 허용하지 않는 인덱스를 생성하는 키워드, 테이블의 스토리지 엔진에 관계없이 사용 가능
  - FULLTEXT INDEX: 전문 검색 인덱스 MyISAM만 가능
  - SPATIAL INDEX: 공간 검색 인덱스를 생성하는 키워드, MyISAM만 가능
  - INDEX: 특별한 키워드를 명시하지 않고 INDEX키워드만 사용하면 중복이 허용되는 일반 보조 인덱스를 생성
- USING 키워드로 인덱스 알고리즘을 사용할 지 명시할 수 있음 FULLTEXT, SPATIAL 제외
- MYSQL의 각 컬럼의 정렬 순서는 무시하고 모두 ASC로 인덱스를 생성함

**인덱스 조회**

- SHOW INDEX FROM [TABLE_NAME];
- 인덱스의 칼럼 단위로 한 라인씩 표시, 콜레이션이나 인덱스 알고리즘, 인덱스 기수성도 표시됨



**인덱스 삭제**

- 5.0이하에서는 테이블 자체를 복사하면서 처리해서 느리게 삭제됐으나 5.1이상의 InnoDB에서는 플러그인버전, 데이터 자체는 그대로 두고 인덱스만 삭제해서 매우 빠름 예외적으로 pk의 삭제는 오래걸림



**칼럼 및 인덱스 변경을 모아서 실행**

- 가능하다면 스키마 변경을 테이블 단위로 모아서 실행

```SQL
ALTER TABLE employees
	DROP INDEX ix_firstname,
	ADD INDEX ix_new_firstname (first_name),
	ADD COLUMN emp_telno VARCHAR(15);
```



### 프로세스 조회

- SHOW PROCESSLIST
- MYSQL 서버에 접속된 클라이언트의 요청을 처리하고 있는 스레드 수만큼의 레코드가 표시됨



### 프로세스 강제 종료

- KILL QUERY 4288;
  - 해당 스레드가 실행하고 있는 쿼리를 강제 종료
- KILL 4288;
  - 해당 스레드를 강제 종료



### 시스템 변수 조회 및 변경

- my.cnf, my.ini 같은 시스템변수를 SHOW VARIABLES라는 명령으로 조회 가능

```SQL
SHOW GLOBAL VARIABLES;
SHOW GLOBAL VARIABLES LIKE ...
SHOW SESSION VARIABLE ...
SHOW VARIABLES ...
```

- MYSQL 시스템 변수 중에서는 동적으로 변경이 가능함 
- SET GLOBAL, SET [variable_name] = 1000;



### 경고나 에러 조회

- 경고 메시지는 프로그램에서 간과해서는 안됨
- SHOW WARNINGS 명령을 사용하면 경고메시지 확인 가능
- 에러는 SHOW ERRORS



**권한 조회**

- SHOW PRIVILEGES



## SQL 힌트

- mysql 에서 4~5개가 사용할만한 힌트인데 쿼리 힌트로 성능을 상당히 개선할 수 있음
- mysql은 이 힌트가 옵티마이저에게 영향을 끼치는 정도가 크므로 성능이 더 악화될수도 있음



### 힌트의 사용법

- mysql은 힌트가 sql의 일부로해석되어서 잘못쓰면 에러

```sql
SELECT * FROM employees USE INDEX (PRIMARY) WHERE emp_no=10001;
SELECT * FROM employees /*! USE INDEX (PRIMARY)*/ WHERE emp_no=10001;
```

- 주석을 사용하면 다른 dbms에서에서도 사용할 수 있음





### STRAIGHT_JOIN

- STRAIGHT_JOIN은 옵티마이저 힌트이기도하면서 조인 키워드이기도함
- STRAIGHT_JOIN은 SELECT나 UPDATE, DELETE 쿼리에서 여러 개의 테이블이 조인될 때 조인의 순서를 고정하는 역할을 함
- 드리븐테이블, 드라이빙테이블에 대한 결정은 옵티마이저가 하는데 STRAIGHT_JOIN키워드를 쓰면 나열한 순서대로 조인을 수행함
- STRAIGHT_JOIN조인은 신중하게 사용해야함
  - 임시 테이블과 일반 테이블의 조인
    - 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋음 일반 테이블의 조인 칼럼에 인덱스가 없는 경우에는 레코드 건수가 적은 쪽을 드라이빙으로 선택하는게 좋음 예상과 반대로 되었을때만 STRAIGHT_JOIN를 사용할 것
  - 임시 테이블끼리의 조인
    - 일반적으로 크기가 작은 테이블을 드라이빙으로 선택하는 것이 좋음
  - 일반 테이블끼리의 조인
    - 레코드 건수가 적은 테이블을 드라이빙 으로 선택하는것이 좋음 
    - 조인 칼럼에 인덱스가 없는 테이블을 드라이빙으로 선택하는 것이 좋음
- 여기서 언급하는 레코드 건수라는 것은 조건을 만족하는 레코드 건수를 의미함



### USE INDEX / FORCE INDEX /IGNORE INDEX

- 2~3개의 칼럼이 포함된 인덱스는 MYSQL 옵티마이저가 최적의 인덱스를 충분히 선택할 수 있을 정도로 똑똑하기 때문에 너무 걱정하지 않아도 됨
- 복잡한 인덱스에 대해 USE INDEX나 FORCEINDEX로 옵티마이저가 다른 인덱스를 선택하도로 유도할 수 있음
  - USE INDEX
    - 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장
  - FORCE INDEX
    - USE INDEX보다 옵티마이저게에 미치는 영향이 더 강한 힌트임
    - 거의 사용할일이 없음
  - IGNORE INDEX
    - 인덱스를 무시할때 사용
  - USE INDEX FOR JOIN
    - 테이블간의 조인, 레코드 검색하는 용도로 INDEX를 사용을 옵티마이저에게 알려줄 때
  - USE INDEX FOR ORDER BY
    - 명시된 인덱스를 ORDER BY 용도로만 사용하도록 제한함
  - USE INDEX FOR GROUP BY
    - 명시된 인덱스를 GROUP BY 용도로만 사용하도록 제한함
- 가능하면 그때그때 옵티마이저가 실행 시점의 통계 정보를 가지고 실행 계호기을 선택하게 해주는 것이 가장 좋음



### SQL_CACHE / SQL_NO_CACHE

- SELECT 결과를 캐시에 담아둘지 여부를 쿼리에서 직접 선택할 수도 있는데 이때 SQL_CACHE/ SQL_NO_CACHE를 사용할 수 있음
- 시스템 변수의 query_cache_type 에 따라 기본값이 변경됨
- 일반적으로 쿼리 캐시를 사용하기때문에 SQL_CACHE보단 캐시를 사용하지 않는 SQL_NO_CACHE 명령어를 사용함



### SQL_CALC_FOUND_ROWS

- SELECT 쿼리에 LIMIT절이 사용될 때 조건을 만족하는 레코드가 LIMIT절에 명시된 수보다 많다면 LMIT에 명시된 건수만큼만 레코드를 찾고 즉시 쿼리 수행을 멈춤 
- SQL_CALC_FOUND_ROWS를 사용하면 실제 반환하는 LIMIT 건수에 관계 없이 FOUND_ROWS() 라는 함수의 세션변수에 저장함
- SQL_CALC_FOUND_ROWS 힌트를 사용하기보단 쿼리 튜닝하는데 집중할 것



## 쿼리 성능 테스트

**캐시**

- 운영체제의 캐시

  - MYSQL 서버는 운영체제의 파일 시스템 관련 기능을 이용해 데이터 파일을 읽어옴

  - 일반적으로 대부분의 운영체제는 한번 읽은 데이터는 운영체제가 관리하는 별도의 캐시영역에 보관해뒀다가 반환함 

  - 운영체제가 가지고 있는 캐시나 버퍼가 전혀 없는 상태에서 쿼리의 성능을 테스트하려면 MYSQL 서버를 재시작하거나 캐시 삭제 명령어를 실행하고 테스트하는것이 좋음

  - ```shell
    ##캐시나 버퍼의 내용을 디스크와 동기화함
    shell> sync
    ## 운영체제에 포함된 캐시의 내용을 초기화함
    shell> echo 3 > /proc/sys/vm/drop_caches
    ```

- MySQL 서버의 버퍼 풀 (innodb 버퍼풀, myisam의 키 캐시)

  - 운영처제의 버퍼나 캐시와 마찬가지로 mysql 서버에도 데이터 파일의 내용을 페이지 단위로 캐시하는 기능을 제공함
  - innodb는 버퍼 풀, myisam은 키 캐시
  - mysql 서버에 포함된 키 캐시나 버퍼 풀을 초기화하려면 mysql서버를 재시작해야함
  - 처음 실행했을 때의 결과는 버리고 여러번 테스트해서 그결과를 기준으로 판단하느 ㄴ것이 좋음

- MySQL 쿼리 캐시

  - SQL_NO_CACHE힌트를 추가해서 쿼리 성능을 테스트할 것
  - RESET QUERY CACHE는 가급적 자제

- 독립된 MYSQL 서버

  - 네트워크 등등의 고려사항을 제외하고 실제 순수 쿼리성능을 직접 테스트해보는게 좋음







- 실제 쿼리 성능테스트는 워밍업상태, 콜드상태에서 진행할지도 고려해야함
- 일반적으로 워밍업상태에서 테스트하는편
- 간단한 쿼리의 성능 비교 테스트에서는 특별히 영향을 미칠만한 프로세스나 다른 쿼리가 실행되고 있는지 확인한 후 쿼리 캐시만 사용하지 않도록 설정하고 테스트를 진행해도 괜찮음



### 쿼리의 성능 테스트

- 전체 레코드 수가 많다면 LMIT 0;을 사용해서 실제 쿼리의 수행시간만 나타내는 방법이 있음

```SQL
SELECT SQL_CACL_FOUND_ROWS SQL_NO_CACHE STRAIGHT_JOIN
e.first_name, d.dept_name
FROM departments d, dept_emp de, employees e
WHERE e.emp_no=de.emp_no AND d.dept_no=de.dept_no
LIMIT 0
```

- 클라이언트에게 쿼리를 제공하지 않기때문에 네트워크 통신 비용을 배재할수밖에 없음
- MYSQL PAGER 옵션으로 어느정도 테스트 가능함 생략



### 쿼리 프로파일링

- MYSQL에서 쿼리가 처리되는 동안 각 단계별 작업에 시간이 얼마나 걸렸는지 확인할 수 있다면 쿼리의 성능을 예측하거나 개선하는데 많은 도움이 될 것임
- 5.1 이상에서만 지원되고 프로파일링 활성화를 해야함
- SET PROFILING=1;
- SHOW PROFILES으로 최근 15개 쿼리에 대해서만 저장되고 profiling_history_size로 100개까지 저장할 수 있음
- SHOW PROFILE로 가장 최근 1개의 쿼리에 대한 프로파일링 정보를 볼 수 있고 SHOW PROFILE FOR QUERY [QUERY_NUMBER]로 프로파일링 할 쿼리 번호를 직접 지정할 수 있음
- CPU, MEMORY, SOURCE 등등의 키워드도 사용할 수 있음





# #8 확장기능

- 패스







# #9 사용자 정의 변수

- mysql 변수는 누가 생성하는가에 따라 크게 시스템 변수와 사용자 변수로 구분함 범위가 mysql 서버 전체인지 아니면 커넥션에 종속적인지에 따라 글보벌 변수, 세선변수로 나뉨 서버가 재시작되지 않고 변수를 변경할수있느냐로 동적변수, 정적변수가 있음
- 사용자변수는 해당 커넥션에서만 유효하기때문에 항상 세션변수로 취급됨 그리고 동적변수임



## 사용자 정의 변수 소개

- 프로시저 함수 뿐 아니라 sql 문장에서도 사용할 수 있음
- 해당 커넥션 내부에서만 산용 가능
- @ 로 시작함
- 타입을 정의하지 않고 저장하는 값에 의해서 그 타입이 정해짐
- null도 지정 가능 초기화하지 않은 사용자 변수는 null임
- SET 문장으로 값이 할당되고 생성도됨 = 또는 :=을 사용함

```sql
SET @var := 'My first user variable';
SET @var = 'My first', @var2 = 'user variable';

SELECT @var AS var1, CONCAT(@var1, ' ', @var2) AS var2;

```

- sql 문장에서의 연산 결과를 다시 사용자 변수에 할당하는것도 가능하고 sql 문장에서 표현식을 사용할 수 있는 곳에서는 언제나 사용자 변수를 사용할 수 있음

```SQL
SET @rownum=0;

SELECT (@rownum:= @rownum+1) AS rownum, emp_no, first_name FROM employees LIMIT 5;

```

- 절대 동일 SQL 문장에서 변수에 값을 할당하고 동시에 값을 참조하지 말것
- 사용자 정의 변수는 버전에 따라 일관되게 작동하지 않을 수 있다는 점을 항상 기억할 것
- 사용자 변수는 애플리케이션처럼 고정적인 로직보다 일회성의 대량 작업에 더 적합할 때가 많음 예를 들어 일회성으로 데이터를 마이그레이션 하는 작업은 여러 차례 테스트를 진행하고 준비해서 단 한번 실행하지만 한번에 처리해야하는 레코드 건수가 많음 이럴때 사용자 변수를 사용하면 좋음
- 사용자 정의 변수 사용시 고려사항
  - MYSQL 5.0 미만의 버전에서는 변수명의 대소문자를 구분했지만 그 이상에선 구분하지 않음
  - 사용자 정의 변수를 사용하는 쿼리는 MYSQL 쿼리 캐시 기능을 사용하지 못함
  - 초기화되지 않은 변수는 문자열 타입의 NULL을 가짐
  - 사용자 정의 변수의 연산 순서는 정해져있지 않음 MYSQL 보장하지 않음
  - MYSQL의 버전에 따른 작동 방식이나 순서에 차이가 있기 때문에 여러 버전에 걸쳐서 사용은 주의할것





## 사용자 변수의 기본 사용

- 사용자변수는 커넥션간에 공유되지않지만 하나의 커넥션안에서는 공유됨
- 커넥션 풀을 사용하는 일반적인 웹 프로그램에서 변수를 사용할 때마다 초기화하지 않으면 웹 프로그램 코드가 상호 영향을 미칠 수 있음
- 사용자 변수를 초기화 하기 위해 항상 SELECT 쿼리 이전에 실행했어야했는데 FROM절에 넣어도 사용이 가능함





## 사용자 변수의 적용 예제

### N번째 레코드만 가져오기

- 실제 1건의 레코드만 디스크에서 읽어오는 것은 아님
- 레코드 건수가 많은 테이블에서는 주의

```sql
SELECT * FROM departments, (SELECT @rn:=0) x
WHERE (@rn:=@rn+1) = 3
ORDER BY dept_name;
```



###  누적 합계 구하기



```SQL
SELECT emp_no, salary, (@acc_salary:=@acc_salary+salary) AS acc_salary
FROM salaries, (SELECT @acc_salary:=0) x
LIMIT 10
```



### 그룹별 랭킹 구하기

```sql
SELECT
	emp_no, first_anme, last_name, IF(@prev_firstname=first_name, @rank:=@rank+1, @rank:=1+LESAT(0, @prev_firstname:=first_name)) rank
FROM employees, (SELECT @rank:=0) x1, (SELECT @prev_firstname:='DUMMY') x2
WHERE first_name IN ('Georgi', 'Bezalel')
ORDER BY first_name, last_name;
```



### 랭킹 업데이트하기

- 생략

### GROUP BY와 ORDER BY가 인덱스를 사용하지 못하는 쿼리

- 생략



## 주의사항

- mysql에서 하나의 변수에대한 할당과 참조를 동시에하는데 있어서 안정적인 결과를 보장하지 않음





# #10 파티션

- 파티션이란 mysql 서버의 입장에서는 데이터를 별도의 테이블로 분리해서 저장하지만 사용자 입장에서는 여전히 하나의 테이블로 읽기와 쓰기를 할 수 있게 해주는 솔루션
- 일반적으로 dbms의 파티션은 하나의 서버에서 테이블을 분산하는 것이고 원격 서버간에 분산을 지원하느 ㄴ것은 아님
- 5.1이상에서부터 사용
- 해시와 리스트, 키, 레인지 4가지 파티션 방법을 제공하고 서브 파티셔닝 기능까지 사용할 수 있음 

## 개요

### 파티션을 사용하는 이유

- 테이블의 데이터가 너무 많아진다고 해서 무조건 파티션을 적용하는 것이 효율적인 것은 아님
- 하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 훨씬 크거나, 데이터 특성상 주기적인 삭제 작업이 필요한 경우 등이 파티션이 필요한 대표적인 예임



**단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리**

- 인덱스는 SELECT 뿐만아니라 UPDATE, DELETE, INSERT쿼리를 위해 필요할 때도 많음
- 특히 한 테이블의 인덱스 크기가 물리적으로 MYSQL이 사용 가능한 메모리 공간보다 크다면 그 영향이 더 심함
- 인덱스의 워킹 셋이 실질적인 물리 메모리보다 크다면 쿼리 처리가 상당히 느려질 것
- 결과적으로 파티션은 데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할 수 있게 만들어



**데이터의 물리적인 저장소를 분리**

- 데이터 파일이나 인덱스 파일이 파일 시스템에서 차지하는 공간이 크다면 그만큼 백업이나 관리 작업이 어려워짐



**이력 데이터의 효율적인 관리**

- 로그라는 이렉 데이터는 단기간에 대량으로 누적됨과 동시에 일정 기간이 지나면 쓸모가 없어짐
- 로그 테일블을 파티션 테이블로 관리하면 불필요한 데이터 삭제 작업은 단순히 파티션을 추가하거나 삭제하는 방식으로 간단하고 빠르게 해결 가능



### MYSQL 파티션의 내부 처리

```SQL
CREATE TABLE tb_article (
	article_id INT NOT NULL,
	reg_date DATETIME NOT NULL,
	...
	PRIMARY KEY(article_id)
)
PARTITION BY RANGE (YEAR (reg_date)) (
	PARTITION p2009 VALUES LESS THAN (2010),
	PARTITION p2010 VALUES LESS THAN (2011),
	PARTITION p2011 VALUES LESS THAN (2012),
	PARTITION p2012 VALUES LESS THAN (2013),
)

```



### 파티션 테이블의 레코드 INSERT

- INSERT 쿼리가 실행되면 서버는 INSERT 되는 칼럼의 값 중에서 파티션 키인 reg_date 칼럼의 값을 이용해 파티션 표현식을 평가하고 그결과를 이용해 레코드가 저장될 적절한 파티션을 결정함
- INSERT 파티션이 결저오디면 일반 테이블과 마찬가지로 처리됨



**파티션 테이블의 UPDATE**

- UPDATE 쿼리를 실행하려면 변경 대상 레코드가 어느 파티션에 저장돼 있는지 찾아야함
- WHERE 조건에 파티션 키 칼럼이 조건으로 존재하면 그 값을 이용해서 레코드가 저장된 파티션에서 빠르게 대상 레코드를 검색 가능 만약 없다면 모든 파티션에서 레코드를 찾아야함
- 실제 업데이트 되는 레코드의 칼럼에 따라 과정에 큰 차이가 있음
  - 파티션 키가 아닌 칼럼을 업데이트하면 그냥 일반 UPDATE와 똑같음
  - 파티션 키 칼럼이 변경되면 해당 레코드를 삭제하고 다시 파티션 표현식으로 평가되고 다시 INSERT됨



**파티션 테이블의 검색**

- SQL이 수행되기 위해 파티션 테이블을 검색할 때 성능에 크게 영향을 미치는 조건은 다음과 같음
  - WHERE 절의 조건으로 검색해야 할 파티션을 선택할 수 있는가?
  - WHERE 절의 조건이 인덱스를 효율적으로 사용할 수 있는가?
- 조합들
  - 파티션 선택 가능 + 인덱스 효율적 사용 가능
    - 쿼리가 가장 효율적으로 처리됨 파티션 개수에 관계 없이 검색을 위해 꼭 필요한 파티션의 인덱스만 레인지 스캔함
  - 파티션 선택 불가 + 인덱스 효율적 사용 가능
    - 테이블의 모든 파티션을 대상으로 검색함
    - 인덱스 레인지 스캔으로 검색할 수 있음
  - 파티션 선택 가능 + 인덱스 효율적 사용 불가
    - 해당 파티션에서 풀테이블 스캔 파티션에 데이터 많으면 느림
  - 파티션 선택 불가 + 인덱스 효율적 사용 불가
    - 모든 파티션에 대해서 풀 테이블 스캔
- 3, 4번은 절대 하면 안됨



**파티션 테이블의 인덱스 스캔과 정렬**

- MYSQL 파티션 테이블에서 인덱스는 전부 로컬 인덱스에 해당함
- 모든 인덱스는 파티션 단위로 생성되고 파티션에 관계없이 테이블 전체 다우니로 글로벌한 인덱스는 지원하지 않음
- 실제 MYSQL 서버는 여러 파티션에 대해 인덱스 스캔을 수행할 때 각 파티션으로부터 조건에 일치하는 레코드를 정렬된 순서대로 읽으면서 우선순위 큐에 임시로 저장함
- 결론적으로 파티션 테이블에서 인덱스 스캔을 통해 레코드를 읽을 때 MYSQL 서버가 별도의 정렬 작업을 수행하지는 않음
- 일반 테이블처럼 바로 반환하는 것은 아니고 내부적으로 큐 처리가 한번 필요한 것



**파티션 프루닝**

- 3개의 파티션 가운데 2개만 읽어도 된다고 판단되면 불필요한 파티션에는 전혀 접근하지 않음
- 옵티마이저가 최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 실행 계획에서 배제하는 것을 파티션 프루닝이라고함
- 파티션 푸르닝에 관련된 실행 계획을 확인할 때는 EXPLAIN PARTITIONS 명령을 사용해야함



## 주의사항

### 파티션의 제한 사항

- 숫자 값 (INTEGER 타입 칼럼 또는 INTEGER 타입을 반환하는 함수 및 표현식)에 의해서만 파티션이 가능함 5.5 이상부터는 숫자타입 뿐 아니라 문자열이나 날짜 타입 모두 사용할 수 있도록 개선됨
- 키 파티션은 해시 함수를 MYSQL이 직접 선택하기 때문에 칼럼 타입 제한이 없음
- 최대 1024개의 파티션을 가질 수 있음 서브파티션 포함
- 스토어드 루틴이나 UDF그리고 사용자 변수 등을 파티션 함수나 식에 사용할 수 없음
- 파티션 생성 이후 SQL 서버의 sql_mode 파라미터 변경은 추천하지 않음
- 파티션 테이블에서는 외래키 사용 불가
- 파티션 테이블은 전문 검색 인덱스 생성 불가
- 공간 확장 기능에서 제공되는 칼럼 타입은 파티션 테이블에서 사용 불가
- 임시 테이블은 파티션 기능 사용 불가
- MyISAM 파티션 테이블의 경우 키 캐시를 사용할 수 없음 5.5이상부터는 보안됨
- 파티션 키의 표현식은 일반적으로 칼럼 그 자체 또는 mysql 내장 함수를 사용할 수 있는데 일부만 사용 가능함
- 모든 파티션은 같은 구조의 인덱스만 가질 수  있음 별도로 파티션마다 추가 불가



### 파티션 사용시 주의사항

- 파티션 테이블의 경우 프라이머리 키를 포함한 유니크 키에 대해서는 상당히 머리를 아프게 하는 제약사항이 있음
- 파티션의 목적이 작업의 범위를 좁히기 위함인데 유니크 인덱스는 중복 레코드에 대한 체크 작업 때문에 범위가 좁혀지지 않기 때문임mysql 파티션 또한 테이블과 같이 별도의 파일로관리되기 때문에 mysql 서버가 조작할 수 있는 파일의 개수와도 연관사항이 있음



**파티션 유니크 키**

- 종류에 고나계 없이 테이블에 유니크 인덱스 pk 포함 해서 있으면 파티션 키는 모든 유니크 인덱스의 일부 또는 모든 칼럼을 포함해야함
- 파티션 키를 직접 선택해야할 때
  1. 테이블에서 중복을 허용하지 않는 프라이머리 키와 유니크 인덱스만 선별함
  2. 프라이머리 키와 유니크 인덱스에 공통적으로 포함돼 있는 칼럼만 수집함. 테이블에 pk가 있다면 pk를 구성하는 칼럼만 수집함
  3. 2번에서 수집한 칼럼중에서 일부 또는 전체를 사용한 표현식은 파티션 표현식으로 사용할 수 있음 2번에서 수집한 칼럼을 별도의 표현식 없이 그대로 파티션 키로 사용할 수도 있음



**파티션과 open_files_limit 파라미터**

- mysql에서 일반적으로 테이블을 파일 단위로 관리하기 때문에 mysql 서버에서 동시에 오픈된 파일의 개수가 사당히 많아질 수 있음
- open-files-limit 시스템 변수를 통해 설정 가능



**파티션 테이블과 잠금**

- mysql에서는 파티션 테이블이 가지는 파티션의 개수가 늘어날수록 성능이 더 떨어질 수도 있음 
- 파티션 테이블에 쿼리가 실행되면 mysql은 파티션 개수에 관계 없이 모든 파티션을 열고 잠금을 걸게 됨
- 만약 파티션이 많이 포함된 테이블에 한번에 많은 레코드를 insert하거나 update한다면 lock tables 명령으로 테이블을 잠그고 insert나 update를 수행하면 조금은 빠르게 처리할 수 있음



## MySQL 파티션의 종류

- 레인지 파티션
- 리스트 파티션
- 해시 ㅍ타ㅣ션
- 키 파티션



### 레인지 파티션

- 파티션 키의 연속된 범위로 파티션을 정의하는 방법
- 일반적으로 가장많이 사용함

**레인지 파티션의 용도**

- 다음과 같은 성격을 지닌 테이블에 좋음
  - 날짜를 기반으로 데이터가 누적되고 년도나 월 또는 일 단위로 분석하고 삭제해야 할 때
  - 범위를 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
  - 파티션 키 위주로 검색이 자주 실행될 때



**레인지 파티션 테이블 생성**

```SQL
CREATE TABLE tb_article (
	article_id INT NOT NULL,
	reg_date DATETIME NOT NULL,
	...
	PRIMARY KEY(article_id)
)
PARTITION BY RANGE (YEAR (reg_date)) (
	PARTITION p2009 VALUES LESS THAN (2010),
	PARTITION p2010 VALUES LESS THAN (2011),
	PARTITION p2011 VALUES LESS THAN (2012),
	PARTITION p2012 VALUES LESS THAN (2013),
)

```

- PARTITION BY RANGE 키워드로 레인지 파티션을 정의함
- VALUES LESS THAN MAXVVALUE는 선택사항임 
- 스토리지 엔진을 적용하지 않으면 자동으로 테이블의 스토리지 엔진이 자동으로 적용됨



**레인지 파티션의 분리와 병합**



- 단순 파티션의 추가

  - ```sqlite
    ALTER TABLE employees ADD PARTITION (PARTITION p4 VALUES LESS THAN (2011))
    ```

  - MAXVALUE 파티션이 이미 정의돼있을경우 사용 불가, 아래 분리하는 방법으로 넣어야함

  

  

- 단순 파티션 삭제

  - ```sqlite
    ALTER TABLE employees DROP PARTITION p0;
    ```

  - 매우 빠르게 처리됨

  

- 기존 파티션의 분리

  - 하나의 파티션을 두 개 이상의 파티션으로 분리하고자 할 때는 reorganize partition 명령을 사용하면 됨

  - ```sql
    ALTER TABLE employees
    	REORGANIZE PARTITION p3 INTO (
    	PARTITION p3 VALUES LESS THAN (2012),
    	PARTITION p4 VALUES LESS THAN MAXVALUE
    );
    ```

  

  

- 기존 파티션의 병합

```sql
ALTER TABLE employees
	REORGANIZE PARTITION p3 , p4 INTO (
	PARTITION p3 VALUES LESS THAN (2012),
);
```



**레인지 파티션의 주의사항**

- null은 어떤 값보다 작은 값으로 간주됨 주의할것
- 다음과 같은 파티션 키는 피하는것이 좋음
  - UNIX_TIMESTAMP()를 이용한 변환 식을 파티션 키로 사용
  - 날짜를 문자열로 포맷팅한 형태의 파티션키
  - YEAR()이나 TO_DATES()함수 이외의 함수가 사용된 파티션 키
- 권장하는 파티션 키
  - YEAR(date_column)
  - TO_DAYS(date_column)



### 리스트 파티션

- 레인지파티션이랑 비슷함
- 둘의 가장 큰 차이는 레인지 파티션은 파티션 키 값이 연속된 값의 범위로 파티션을 구성할 수 있지만 리스트 파티션은 파티션 키 값 하나하나를 리스트로 나열해야함
- MAXVALUE 같은건 사용불가함



**리스트 파티션의 용도**

- 파티션 키 값이 코드값이나 카테고리와 같이 고정적일 때
- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야 할 때
- 파티션 키 값을 기준으로 레코드의 건수가 균일하고, 검색 조건에 파티션 키가 자주 사용될 때



**리스트 파티션 테이블 생성**

```sql
CREATE TABLE product(
	id INT NOT NULL,
	name VARCHAR(30),
	category_id INT NOT NULL
...
)
PARTITION BY LIST (category_id) (
	PARTITION pappliance VALUES IN (3),
	PARTITION pcomputer VALUES IN (1, 9),
	PARTITION petc VALUES IN (4, 5, 8, null),
...
);


```

- PARTITION BY LIST 키워도르 리스트 파티션 선언
- NULL값도 지정 가능
- 카 값의 목록을 지정 가능
- 5.1에서는 정수타입만 가능한데 5.5부터는 문자열 타입도 가능함



**리스트 파티션의 분리와 병합**

- 파티션 정의에서 VALUES IN을 사용한다는 것 말고는 레인지 파티션의 추가 삭제 병합 작업이 모두 같음

**리스트 파티션 주의사항**

- 명시되지 않은 나머지 값을 저장하난 MAXVALUE를 사용할 수 없음
- 레인지 파티션과는 달리 NULL을 저장하는 파티션을 별도로 생성 가능
- 5.1은 정수타입 5.5는 문자열 타입도 가능





### 해시 파티션

- MYSQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법
- MYSQL 정의한 해시 함수는 파티션 표현식의 결과값을 파티션 개수로 나눈 나머지로 저장될 파티션을 결정하는 방식
- 해시 파티션은 항상 정수타입이거나 정수를 반환하는 표현식만 사용 가능
- 해시 파티션에서 파티션의 개수가 곧 파티션에 할당하는 알고리즘과 연관되어 있기 때문에 추가 삭제 작업에 레코드를 재 분배하는 작업이 있음

**해시 파티션의 용도**

- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는 것이 어려울 때
- 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야 할 때
- 대표적으로 회원 테이블



**해시 파티션 테이블의 생성**

```SQL
--파티션의 개수만 지정할 때
CREATE TABLE employees (
	id INT NOT NULL,
	first_name VARCHAR(30),
	last_name VARCHAR(30),
	hired DATE NOT NULL DEFAULT ' ... '
    ...
)
PARTITION BY HASH(id)
PARTITIONS 4;

--파티션 이름도 지정할때
CREATE TABLE employees (
	id INT NOT NULL,
	first_name VARCHAR(30),
	last_name VARCHAR(30),
	hired DATE NOT NULL DEFAULT ' ... '
    ...
)
PARTITION BY HASH(id)
PARTITIONS 4 (
	partition p0 ENGINE=INNODB,
	partition p1 ENGINE=INNODB,
...
)

```

- PARTITION BY HASH 키워드로 파티션 종류를 해시 파티션으로 지정
- 5.1, 5.5 이상 모두 HASH 키값이 정수타입이어야함
- 파티션을 몇개를 생성할 것인지 명시해야함
- 기본적으로 아무 이름도 지정하지 않으면 p0, pn 형태로 지어짐
- 해시나 키 파티션에서는 특정 파티션을 삭제하거나 병합하는 작업이 거의 불필요하기때문에 파티션의 이름을 부여하는 것이 크게 의미는 없음 



**해시 파티션의 분리와 병합**

- 모든 레코드들을 재분배해야함
- 추가 삭제 분할 병합은 스킵



**해시 파티션 주의사항**

- 특정 파티션만 drop 하는 것이 불가능함
- 새로운 파티션을 추가하는 작업은 단순히 파티션만 추가하는 것이 아니라 기존의 모든 데이터의 재배치 작업이 필요함
- 해시 파티션은 레인지 파티션이나 리스트 파티션과는 상당히 다른 방식으로 관리하기 때문에 해시 파티션이 용도에 적합한 해결책인지 확인이 필요함
- 일반적으로 리스트나 레인지 파티션을 사용하기때문에 조작할때는 주의할 것



### 키 파티션

- 키 파티션은 해시파티션과 사용법 특성이 거의 같음
- 해시 파티션은 해시 값을 계산하는 방법을 파티션 키나 표현식에 사용자가 명시함
- 대부분의 데이터 값에 대해서 파티션 키를 적용 가능함
- 키파티션도 스킵

### 서브파티션

- 스킵



### 파티션 테이블의 실행계획





### 파티션 기능에 대한 결론

- mysql에서 파티션은 그다지 오래되거나 성숙된 기술이 아님
- select 쿼리의 성능에는 그다지 큰 도움은 못주며 insert에는 어느정도 도움이됨
- 대부분의 rdb는 레코드건수가 어느정도 커지면 insert update delete 성능이 매우 안좋아짐 어떤 파티션 종류를 사용하든 모든 파티션을 골고루 읽고 써야하는 테이블이라면 절대 파티션을 이용해 select 성능을 향상시키기는 어려움 하지만 레코드 건수가 너무 많아져서 insert delete같은 쓰기 작업이 심각하게 느려지고 있다면 파티션 적용을 고려해보는것이 좋음
- 만약 날짜 칼럼을 이용해 레인지 파티션을 사용할 수 있고 읽기나 쓰기 작업을 일부 파티션으로 모을 수 있다면 테이블의 크기에 상관없이 항상 파티션을 적용하는 것이 쓰기 및 읽기 그리고 관리작업에도 도움이 됨





# #11 스토어드 프로그램

- 스토어드 루틴이라고도함
- 스토어드 프로시저와 스토어드 함수 그리고 트리거, 이벤트 등을 모두 아우르는 명칭



## 스토어드 프로그램의 장단점

### 스토어드 프로그램의 장점

**데이터베이스의 보안 향상**

- mysql의 스토어드 프로그램은 자체적인 보안 설정 기능을 갖고 있고 스토어드 프로그램 단위로 실행 권한을 부여할 수 있음
- 이런 보안 기능을 조합해서 특정 테이블의 읽기와 쓰기 또는 특정 칼럼에 대해서만 권한을 설정하는 등의 세밀할 설정도 가능
- 주요 기능을 스토어드 프로그램으로 작성하면 sql 인젝션같은 기본 보안 사고는 피할 수 있음 스토어드 프로그램은 입력값의 유효성을 체크한 이후 동적으로 sql문장을 생성하기 때문임





**기능의 추상화**

- 예를 들어 일련번호 생성용 프로그램을 스토어드 프로그램으로 구현하고 애플리케이션에서 호출만하면됨



**네트워크 소요 시간 절감**

- 하나의 프로그램에서 100번 200번씩 실행해야 하는 쿼리를 스토어드 프로그램으로 구현한다면 스토어드 프로그램을 호출할 때 한 번만 네트워크를 경유하면 되기 때문에 네트워크 소요 시간을 줄이고 성능을 개선할 수 있음



**절차적 기능 구현**

- 스토어드 프로그램에서 절차적인 기능을 구현한다면 최소한 네트워크 경유에 걸리는 시간을 줄이고 애플리케이션의 코드를 줄일 수 있음



**개발 업무의 구분**

- 애플리케이션 로직과 스토어드 프로그램 로직을 구분해서 관리할 수 있음





### 스토어드 프로그램의 단점

**낮은 처리 성능**

- 절차적 코드 처리가 주 목적이 아니라 다른 프로그램언어에 비해 처리성능이 안좋음

**애플리케이션 코드의 조각화**

- 애플리케이션 코드와 스토어드 프로그램이 분리되어있기 때문에 설치나 배포가 더 복잡해지고 유지보수가 어려워질 수 있음



## 스토어드 프로그램의 문법

- 스토어드 프로그램도 헤더부문과 본문 부분으로 나눌 수 있음
- 헤더부분은 정의부라고하고 프로그램의 이름과 입출력값을 명시하는 부분 추가적으로 보안이나 작동 방식에 관련되 옵션도 명시할 수 있음
- 본문 부분은 바디라고도하고 실제 실행하는 내용을 작성



### 스토어드 프로시저

- 스토어드 프로시저는 서로 데이터를 주고받아야 하는 여러 쿼리를 하나의 그룹으로 묶어서 독립적으로 실행하기 위해 사용하는 것
- 배치에서 첫번째 쿼리 결과를 이용해 두번째 실행해야할 때를 대표적으로 들 수 있음
- mysql 서버와 클라이언트간의 네트워크 전송을 최소화하고 수행시간을 줄일 수 있음
- 스토어드 프로시저는 반드시 독립적으로 호출되어야 하며 select나 update같은 문장에서 스토어드 프로시저를 참조할 수 없음



**스토어드 프로시저 생성 및 삭제**

```SQL
CREATE PROCEDURE sp_sum (IN param1 INTERGER, IN param2 INTERGER, OUT param3 INTEGER)
BEGIN
	SET param3 = param1 + param2;
END
```

- 위 프로시저의 이름은 sp_sum이고 3개의 파라미터를 받음
- BEGIN 부터 END까지 바디 임
- 프로시저를 생성할때 두가지 주의사항
  - 스토어드 프로시저는 기본 반환값이 없음 스토어드 프로시저 내부에서는 값을 반환하는 RETURN문을 사용할 수 없음
  - 스토어드프로시ㅈ의 각 파라미터는 아래의 3가지 특성중 하나를 가짐
    - IN 타입으로 정의된 파라미터는 입력 전용 파라미터를 의미함. IN 파라미터는 외부에서 스토어드 프로그램을 호출할 때 프로시저에 값을 전달하는 용도로 사용하고 값을 반환하는 용도로 사용하지 않음 읽기전용
    - OUT 타입으로 정의된 파라미터는 출력 전용 파라미터임 스토어드 프로시저의 실행이 완료되면 외부 호출자로 결과 값을 전달하는 용도로만 사용함
    - INOUT타입은 입력 및 출력 용도로 모두 사용 가능함
- 스토어드 프로그램을 사용할 때는 SQL 문장의 구분자를 변경해야함 일반적으로 ; 가 쿼리의 끝을 의미하는데 DELIMTER 를 사용해서 구분자를 변경해줄 수 있음 일반적으로 ;; 또는 // 와같이 연속된 문자열을 사용함 스토어드 프로그램이 끝나면 다시 DELIMITER ; 로 원래 구분자를 설정해 줄 것
- 스토어드 프로시저를 변경할 때는 ALTER PROCEDURE 명령을 사용하고 DROP으로 삭제하면 됨
- 스토어드 프로시저의 파라미터나 프로시저의 처리 내용을 변경할 때는 ALTER PROCEDURE로 변경이 불가능해서 다시 삭제후 생성해야함



**스토어드 프로시저 실행**

- 스토어드 프로시저와 스토어드 함수의 가장큰 차임저 가운데 하나가 프로그램을 실행하는 방법임
- 스토어드 프로시저는 반드시 CALL 명령어로 실행해야함
- IN 타입은 파라미터는 상수값을 그대로 전달해도 무방하지만 OUT이나 INOUT 타입의 파라미터는 세션 변수를 이용해 값을 주고받아야함

```SQL
SET @result:=0;
SELECT @result;
 -> 0

CALL sp_sum(1,2,@result)
SELECT @result;
 -> 3
```

- IN타입은 세션변수, 리터럴 모두 가능함



**스토어드 프로시저의 커서 반환**

- 스토어드 프로시저 내에서 SELECT 쿼리의 결과 셋을 FETCH하지 않으면 해당 쿼리의 결과 셋은 클라이언트로 바로 전송됨





### 스토어드 함수

- 스토어드 함수는 SQL 문장으로 작성이 불가능한 기능을 하나의 SQL 문장으로 구현해야 할 때 사용함
- SQL 문장과 관계 없이 별도로 실행되는 기능이라면 굳이 스토어드 함수를 개발할 필요가 없음 독립적으로 실행해도 된다면 스토어드 프로시저를 사용하는 것이 좋음
- 스토어드 프로시저와 스토어드 함수의 유일한 차이점은 SQL 문장의 일부로 사용할 수 있다는 것

**스토어드 함수 생성 및 삭제**

- CREATE FUNCTION 으로 생성하고 모든 입력 파라미터는 읽기 전용이라 IN이나 OUT, INOUT을 사용 불가
- 스토어드함수와 스토어드 프로시저의 차이
  - RETURN으로 반환되는 값의 타입을 명시해야함
  - 함수 본문 마지막에 정의부에 지정된 타입과 동일한 타입의 값을 RETURN으로 반환해야함

```sql
CREATE FUNCTION f_sum(param1 INTEGER, param2 INTEGER)
	RETURN INTEGER
BEGIN
	DECLARE param3 INTEGER DEFAULT 0;
	SET para3 = param1 + param2;
	RETURN param3;
END;;
```

- 스토어드 프로시저와는 달리 스토어드 프로그램의 본문에는 다음과 같은 사항을 사용하지 못함
  - PREPARE와 EXECUTE 명령을 이용한 프리페어 스테이트먼트 사용 불가
  - 명시적 또는 묵시적 ROLLBACK/COMMIT을 유발하는 SQL 사용 불가
  - 재귀 호출 사용 불가
  - 스토어드 함수 내에서 프로시저 호출 불가
  - 결과 셋을 반환하는 SQL 문장 사용 불가



**스토어드 함수 실행**

- 스토어드 함수는 CALL 명령으로 실행할 수 없고 SELECT로만 실행함



### 트리거

- 테이블의 레코드가 저장되거나 변경될 때 미리 저으이해둔 작업을 자동으로 실행해주는 스토어드 프로그램
- MYSQL 트리거는 테이블의 레코드가 INSERT나 UPDATE 또는 DELETE 될 때 시작되도록 설정할 수 있음
- 대표적으로 칼럼의 유효성 체크나 다른 테이블로의 복사나 백업을 위해 트리거를 자주 사용함
- AUTO_INCREMENT 속성의 칼럼이 포함된 테이블에 INSERT 하는 트리거는 마스터 슬레이브 데이터를 다르게 만들 가능성이 상당히 높으므로 주의
- 5.1.6 이하에선 SUPER 유저만 가능했지만 그 이후에서는 TRIGGER 권한을 가진 사용자는 모두 생성 가능
- 테이블당 하나의 이벤트에 대해 2개 이상의 트리거 등록 불가

**트리거 생성**

```sql
CREATE
TRIGGER on_delete BEFORE DELETE ON employees
	FOR EACH ROW
BEGIN
	DELETE FROM salaries WHERE emp_no=old.emp_no;
END;;
```

- FOR EACH ROW명 로우마다 트리거 실행
- FOR EACH STATEMENT면 SQL 문장 단위로 트리거 실행
- MYSQL은 INSERT UPDATE DELETE만 지원함
- 트리거를 사용하면 SQL 문장이 어떤 이벤트를 발생시키는지 명확히 알아야 함

| SQL 종류                 | 발생하는 트리거 이벤트 (-> 발생하는 이벤트의 순서를 의미함)  |
| ------------------------ | ------------------------------------------------------------ |
| INSERT                   | BEFORE INSERT -> AFTER INSERT                                |
| LOAD DATA                | BEFORE INSERT -> AFTER INSERT                                |
| REPLACE                  | 중복이 없을 때 : BEFORE INSERT -> AFTER INSERT<br />중복이 있을 떄 : BEFORE DELETE -> AFTER DELETE -> BEFORE INSERT -> AFTER INSERT |
| INSERT INTO ON DUPLICATE | 중복이 없을 때 : BEFORE INSERT -> AFTER INSERT<br />중복이 있을 떄 : BEFORE UPDATE -> AFTER UPDATE |
| UPDATE                   | BEFORE UPDATE -> AFTER UPDATE                                |
| DELETE                   | BEFORE DELETE -> AFTER DELETE                                |
| TRUNCATE                 | 이벤트 발생 안함                                             |
| DROP TABLE               | 이벤트 발생 안함                                             |

- 트리거의 BEGIN ... END의 코드 블록에서 사용하지 못하는 작업
  - PREPARE 와 EXECUTE 명령을 이용한 프리페어 스테이트먼트를 사용 불가
  - 복제에 의해 슬레이브에 업데이트되는 데이터는 레코드 기반 복제에서는 슬레이브 트리거를 기동시키지 않지만 문장 기반의 복제 에서는 슬레이브에서도 트리거를 기동시킴
  - 명시적 또는 묵시적인 ROLLBACK/COMMIT을 유발하는 SQL 문장 사용 불가
  - RETURN 사용 불가 종료할때는 LEAVE명령을 사용
  - MYSQL DB에 존재하는 테이블에 대해서는 트리거 생성 불가
  - 스토어드 함수 내에서 프로시저 호출 불가
- *.TRG 확장자로 생성
- 서버 복사나 백업할때 *.TRG 파일도 반드시 백업해야함
- 트리거가 있으면 RENAME TABLE 명령이 에러가남 트리거 생성후에 RENAME TABLE 할 것



### 이벤트

- 주어진 특정한 시간에 스토어드 프로그램을 실행할 수 있는 스케줄러 기능을 이벤트라함
- 5.1.6이상에서 사용 가능
- 이벤트의 스케줄링을 담당하는 스레드를 활성화해야 사용 가능 event_scheduler라는 시스템변수 확인

이하 이벤트는 생략





### 스토어드 프로그램 본문 작성

- 스토어드 프로시저에서 이벤트까지 모든 프로그램은 BEGIN ... END 라는 모두 똑같은 문법을 사용함

**BEGIN .. END 블록과 트랜잭션**

- 하나의 BEGIN ...END 블록은 또 다른 여러개의 BEGIN ... END 블록을 중첩해서 포함할 수 있음
- 스토어드 프로그램 내부에서 트랜잭션을 실행할 때는 START TRANSACTION을 사용해야함
- 스토어드 프로시저 내부에서 트랜잭션을 선언할지 아니면 실행하는 외부에서 선언할지는 중요한 문제이므로 주의해야함



**변수**

- BEGIN .. END 내부에 있는 변수는 사용자 변수가 아니고 로컬 변수임
- 사용자 변수는 커넥션 내부에서 공유되고 로컬 변수는 스토어드 프로그램 내부에서만 정의되고 사용**
- 로컬 변수는 반드시 타입과 함께 정의되기때문에 컴파일러 수전의 타입 오류 체크 가능

**DECLARE**

- 스토어드 프로그램의 로컬 변수는 DECLARE를 사용해야함

```
DECLARE v_name VVARCHAR(50) DEFAULT 'LEE';
```

- DEFAULT 명시하지않으면 기본이 NULL

**SET**

- DECLARE로 정의한 변수에 값을 할당하는 명령

```
SET v_name = 'Kim', v_email = 'kim@email.com';
```

**SELECT ... INTO**

- SELECT한 칼럼을 로컬 변수에 할당하는 명령
- 반드시 1개만 리턴해야함
- SELECT에 LIMIT 1섞어서 사용하는게 좋음 



- 스토어드 프로그램에서 변수가 어떤 변수인지 헷갈릴 수 있으니 입력 파라미터는 p\_형태, 로컬 변수는 v\_ 형태로 구분지어서 프리픽스를 지정하면서 프로그래밍 하면 됨

**제어문**

- 조건 비교 및 반복과 같은 절차적인 처리를 위해 여러 가지 제어 문장을 이용할 수 있음

**IF ... ELSEIF ... ELSE .. END IF**

```sql
DELIMITER ;;

CREATE FNCTION sf_greatest(p_value INT, p_value2 INT)
	RETURN INT
BEGIN
	IF p_value1 NULL THEN
		RETURN p_value2;
	ELSE IF p_value 2 IS NULL THEN
		RETURN p_value1;

...
	ELSE
		RETURN p_value2;
	END IF;
END;;
```



**CASE WHEN ... THEN ... ELSE ... END CASE**

```sql
DELIMITER ;;

CREATE FUNCTION sf_greatest (p_value1 INT, p_value2 INT)
	RETURN INT
EGIN
	CASE
		WHEN p_value1 IS NULL THEN
			RETURN p_value2;
		WHEN p_value2 NULL THEN
			RETURN p_value1;
...
		ELSE
			RETURN p_value2;
	END CASE;
END;;
```



**반복 루프**

```sql
DELIMITER ;;

CREATE FUNCTION sf_factorial1 (p_max INT)
	RETURN INT
BEGIN
	DECLARE v_factorial INT DEFAULT 1;
	
	factorial_loop : LOOP
		SET v_factorial = v_factorial * p_max;
		SET p_max = p_max -1;
		IF p_max <=1 THEN
			LEAVE factorial_loop;
		END IF;
	END LOOP;
RETURN v_factorial;
END;;
```



**핸들러와 컨디션을 이용한 에러 핸들링**

- 안정적이고 견고한 스토어드 프로그램을 작성하려면 반드시 핸들러를 이용해 예외를 처리해야함
- 스킵





**시그널을 이용한 예외 발생(5.5 이상)**

- 스킵



## 스토어드 프로그램의 권한 및 옵션

### DEFINER와 SQL SECURITY 옵션

### 스토어드 프로그램의 권한

### DETERMINISTIC과 NOT DETERMINISTIC 옵션



## 스토어드 프로그램의 참고 및 주의사항

### 한글 처리

### 스토어드 프로그램과 세션 변수

### 스토어드 프로시저와 재귀 호출

### 중첩된 커서 사용





# #12 쿼리 종류별 잠금

- innodb기준으로 정리



## InnoDB의 기본 잠금 방식

- innodb를 제외한 스토리지 엔진은 대부분 테이블락이라 이해가 어렵지 않음
- innodb는 각 쿼리의 패턴별로 사용하는 잠금이 다름



### SELECT

- REPEATABLE-READ 이하의 트랜잭션 격리 수준에서 INNODB 테이블에 대한 SELECT 쿼리는 기본적으로 아무런 잠금을 사용하지 않음
- SERIALIZABLE 에서는 SELECT에 LOCK IN SHARE MODE가 덧붙여져서 실행되는 효과를 내기 때문에 MYSQL 성능이 매우 떨어짐

```sql
SELECT * FROM employees WHERE emp_no=10001 LOCK IN SHARE MODE; --읽기 잠금
SELECT * FROM employees WHERE emp_no=10001 FOR UPDATE; --쓰기 잠금
```

- LOCK IN SHARE MODE는 읽기 잠금만 걸기 때문에 잠금을 획득한 트랜잭션에서도 변경하려면 쓰기 잠금을 다시 획득해야함
- 읽기 잠금을 가진 상태에서 다시 쓰기 잠금을 획득하는 과정은 데드락을 유발하는 가장 일반적인 형태임
- 레코드를 읽고 쓰기까지한다면 FOR UPDATE를 사용하고 이는 트랜잭션에 대한 영향도가 크기 때문에 받느시 읽은 레코드를 변경해야 할 때만 사용하는 것이 좋음
- LOCK IN SHARE MODE, FOR UPDATE 모두 COMMIT이나 ROLLBACK이 실행되만 잠금이 해제되므로 반드시 하나의 트잭션에서만 유효하다는점도 기억해야함
- LOCK IN SHARE MODE, FOR UPDATE를 사용하는 잠금 읽기는 TRY - FINALLY 구문으로 작성하고 반드시 트랜잭션 종료가 보장되도록 작성하는 것이 좋음
- 모든 잠금을 사용하는 트랜잭션은 반드시 해제와 커밋 처리를 할것



### INSERT, UPDATE, DELETE

- INSERT, UPDATE, DELETE 모두 기본적으로 쓰기 잠금을 사용함
- AUTOCOMMIT 모드에서는 각 SQL 문장별로 자동으로 트랜잭션이 시작되고 종료되는것임
- InnoDB에서 UPDATE와 DELETE 문장을 실행할 때 SQL 문장이 조건에 일치하는 레코드를 찾기 위해 참조하는 인덱스의 모든 레코드에 잠금을 검. 실제 sql 문장이 레코드를 검색하기 위한 조건을 10개 가지고 있더라도 innoDB는 인덱스를 이용해 조건에 일치하는 레코드를 찾을 때 10개의 조건을 전부 사용하지 않을 수도 있음
- SELECT 쿼리에서는 필요하지 않더라도 UPDATE나 DELETE 문장을 위해 인덱스를 만들어야 할 때도 있음
- 인덱스를 사용할 수 있다면 해당 인덱스에 해당하는 레코드들을 전부 잠그고 실제 WHERE조건과 일치하는 레코드 건수에만 UPDATE, DELETE를 실행함 만약 인덱스를 사용할 수없다면 테이블 전체에 대한 락이 걸림
- 트랜잭션 격리 수준이 READ-COMMITED라면 인덱스와 관계없이 실제 변경되는 레코드만 잠금을 걸게 됨 <- 복제를 사용하지 않는 바이너리 로그를 사용하지 않는다면 READ-COMMITED를 사용할 수 있음



## SQL 문장별로 사용하는 잠금

### SELECT 쿼리의 잠금

**SELECT ... FROM ...**

- SELECT는 기본적으로 잠금이 없음
- SERIALIZABLE에서는 LOCK IN SHARE MODE 옵션이 자동으로 붙음



**SELECT ... FROM ... LOCK IN SHARE MODE**

- WHERE 절에 일치하는 레코드 뿐 아니라 검색을 위해 접근한 모든 레코드에 대한 공유 넥스트 키 락을 필요로함
- 다른 쓰기잠금의 경우 락 해제까지 기다리지만 다른 읽기잠금의 경우 상호 호환이되므로 별도의 대기 없이 읽기 잠금 획득 가능함
- COMMIT이나 ROLLBACK으로 자동 해제됨 DDL도 해제됨



**SELECT ... FROM ... FOR UPDATE**

- WHERE 조건절에 일치하는 레코드를 검색하기 위해 접근한 모든 레코드에 대해 배타적 넥스트 키 락을 걸게됨
- 다른 읽기 잠금 다른 쓰기 잠금 모두 이 락을 기다려야함



### INSERT 쿼리의 잠금

- 기본적으로 배타적 레코드 잠금을 사용함
- PK나 유니크 키가 존재하면 중복 체크를 위해 공유 레코드 잠금을 먼저 획득해야함
- INSERT문장은 추가적으로 INSERT INTENTION LOCK이라는 락 방식도 사용함 인서트 인서트 락은 insert를 실행할 의도를 지닌 쿼리가 획득해야 하는 잠금으로 모든 insert 쿼리는 인서트 인텐션 락을 획득한 후 insert를 실행함 그리고 insert된 레코드에 대해서는 베터작 레코드 잠금을 자동으로 획득하게 됨 인서트 인텐션 략은 갭락의 일종으로 인서트 인텐션 락끼리는 서로 호환됨, 즉 여러 트랜잭션이 동시에 인서트 인텐션 략을 획득할 수 있다는 것을 의미함 하지만 이미 다른 트랜잭션이 레코드나 갭 락을 걸고 있다면 인서트 인텐션 락을 걸기 위해 기다려야함
- 프라이머리 키나 유니크 키가 존재하는 테이블에 insert할 경우 공유 잠금을 걸어야 하는 이유는 insert를 전제로 한 읽기 작업 중에 다른 트랜잭션에서 레코드를 변경하거나 삭제하면 일관성이 깨지게됨

**INSERT INTO ... ON DUPLICATE KEY UPDATE ...**

- INSERT 하려는 레코드에 대해 중복된 키 값이 이미 있는지 판단하기 위해 공유 잠금을 걸어야함
- 레코드가 존재하면 배타적잠금을 걸고 업데이트 레코드가 없다면 INSERT 문장과 같이 인서트 인텐션 락을 걸고 INSERT를 실행함 이후에 INSERT된 레코드에 대해서는 배타적 잠금을 획득함



**REPLACE**

- REPLACE 문장에서는 중복된 키 값이 이미 있는지 판단하기 위해 공유 잠금을 걸어야 함
- 그리고 중복된 레코드가 존재하면 배타적 잠금을 걸고 레코드를 삭제함 그리고 나머지 과정은 INSERT문장과 마찬가지로 처리됨



**INSERT INTO tb_new SELECT FROM tb_old**

- tb_new 테이블에는 insert되는 레코드에 대해 배타적 락을 획득하고 tb_old에는 공유 넥스트 키락을 설정함
- tb_old 테이블은 데이터의 무결성을 위해 락이 설정되는데 테이블의 내용이 빈번하게 변경된다면 다음과같이 세가지 경우로 테이블의 공유 잠금을 피할수 있음
  - 트랜잭션 격리 수준을 READ-COMMITED로 변경하고 innodb_locks_unsafe_binlog를 활성화하기. 마스터 슬레이브 서버는 사용 불가 바이너리 로그 사용 불가
  - mysql의 복제 방식을 statement based replication이 아닌 recode based replication으로 변경하는것 적용이 쉽지 않음
  - insert into select 쿼리를 두 개의 쿼리로 나눠서 실행하는 방법. 생략



**REPLACE INTO tb_new ... SELECT ... FROM tb_old**

- tb_old에는 공유잠금, tb_new 테이블 레코드는 배타적 레코드 락





### UPDATE 쿼리의 잠금

**UPDATE ... WHERE ...**

- 단순 UPDATE 문장은 WHERE 조건에 일치하는 레코드를 찾기 위해 스캔한 모든 레코드에 배타적 넥스트 키 락을 걸게 됨
- 단순 레코드만 잠그지 않고 간격까지 잠그는 것은 팬텀 리드를 막기 위함임



**UPDATE tb_test1 a, tb_Test2 ON ... SET a.column = b.column**

- JOIN UPDATE에서 UPDATE 되는 칼럼이 포함된 모든 테이블의 레코드에는 배타적 넥스트 키 락이 걸리고 단순 참조테이블은 공유 넥스트 키 락이 걸림 <- 팬텀 리드, 복제에서 마스터와 슬레이브의 데이터 동기화를 유지하기 위해서임



### DELETE 쿼리의 잠금

**DELETE FROM ... WHERE ...**

- 단순 DELETE는 UPDATE 문장과 똑같이 WHERE 조건에 일치하는 레코드를 찾기 위해 참조한 모든 레코드에 대해 배타적 넥스트 키 락을 검 

**DELETE a FROM tb_test1 a, tb_test2 b ...**

- delete 되는 레코드가 포함된 모든 테이블의 레코드에는 배타적 넥스트 키 락이 걸리고 그 이외의 단순 참조용으로만 사용되는 테이블에는 공유 넥스트 키 락이 설정됨 JOIN UPDATE와 비슷함





### DDL 문장의 잠금

**CREATE TABLE tb_new ... SELECT ... FROM tb_old**

- tl_old 테이블은 읽기 잠금, tb_new 테이블에 insert되는 레코드는 배타적 레코드 락이 설정됨



**RENAME TABLE tb_test TO tb_backup, tb_swap TO tb_test, ...**

- RENAME TABLE 절에 명시된 모든 테이블에 대해 네임락을 검 네임락은 ㅔ이블수준의 잠금이고 DDL문장이라서 작업이 완료되면 트랜잭션을 자동으로 COMMIT하고 즉시 모든 잠금은 해제됨 이름을 변경하는 동안 해당 테이블의 레코드를 읽거나 쓰는 트랜잭션은 모두 대기하게됨



### InnoDB 에서 여러 쿼리 패턴 간의 잠금 대기

- 책 설명



## InnoDB에서 데드락 만들기

- 다른 dbms보다 innoDB에서는 레코드락, 갭락을 사용하기 떄문에 잠금 범위가 넓어서 데드락도 자주 발생하는 편임
- 상세한 내용은 책 참고
- innodb에서 데드락의 원인은 병렬로 여러 스레드에서 동시에 실행되면서 서로 간섭을 일으켜 발생하는경우가 대부분임
- 종류는 상호 거래 관련, 유니크인덱스 관련, 외래키 관련, 서로 다른 인덱스를 통한 잠금이 있음
- 데드락은 절대 애플리케이션이나 mysql 서버의 버그가 아님 데드락이 발생하면 해결할수 있는 처리 내용을 넣으면 됨 디버깅하는게 중요함



# #13 프로그램 연동



## 자바

- 자바로 mysql 에접속해서 sql을 실행하려면 jdbc를 사용해야함
- jdbc는 사실 인터페이스일 뿐이고 실제 구현체는 각 dbms 제조사에서 제공하는 jdbc드라이버임

### jdbc 버전

- jdbc 버전과  사용가능한 mysql 버전이 있으므로 확인할 것



**Statement와 PreparedStatement의 차이**

- mysql 서버가 쿼리를 실행하는 과정
  - 쿼리분석 -> 최적화 -> 권한 체크 -> 쿼리 실행
- 자바 프로그램에서 Statement로 실행되는 쿼리는 위의 모든 단계를 매번 거쳐서 쿼리가 실행됨 따라서 쿼리 분석이나 최적화 같은 작업은 상대적으로 시간이 걸림
- preparedStatment 를 사용하면 쿼리 분석이나 최적화의 일부 작업을 처음 한번만 수행해 별도로 저장해두고 다음부터 요청되는 쿼리는 저장된 분석 결과를 재사용함 이렇게 함으로 매번 쿼리를 실행할 때마다 거쳐야했던 쿼리 분석이나 최적화의 일부 작업을 건너뛰고 빠르게 처리 가능함 
- preparedStatement는 ? 를 사용한 바인딩 쿼리가 가능하고 이 형태로 사용하면 mysql 서버가 쿼리 분석, 최적화를 재사용할 수 있기 때문에 mysql 메모리 사용량을 줄일수 있음
- preparedStatement는 바이너리 프로토콜을 사용함. 즉 내부적으로 불필요한 타입 변환을 수행하지 않고 sql 인젝션 쿼리에도 안정적임





**프리페어 스테이트먼트의 종류**

- 클라이언트 프리페어 스테이트먼트
  - mysql connector/j를 이용하는 자바 애플리케이션에서 preparedstatement객체를 이용해 변수가 포함된 sql 문장을 실행할 때 connector/j가 자체적으로 sql 문장의 바인딩 변수에 값을 매핑해 하나의 완성된 sql 문장으로 만들어 서버에 전송하는 방식
  - 이 방식을 이용하면 애플리케이션 개발자는 preparedstatement를 사용한다고 느끼지만 실제 mysql 서버는 매번 쿼리 문장을 분석하고 실행 계획을 수립해서 쿼리를 실행함
- 서버 프리페어 스테이트먼트
  - mysql의 서버 프리페어 스테이트먼트를 다른 dbms에서는 일반적으로 프리페어 스테이트먼트라고 함. 이게 일반적인 프리페어 스테이트먼트
- jdbc 표준에 프리페어 스테이트먼트 기능이 도입되었을때 mysql에는 프리페어 스테이트먼트가 없었음 따라서 구분짓기위해 클라이언트, 서버로 나뉨
- 별도의 옵션이 없으면 클라이언트 프리페어 스테이트먼트로 작동하기때문에 반드시 설정할 것
- 애플리케이션에서 서버 프리페어 스테이트먼트를 사용하는지 확인하는 방법

```sql
SELECT * FROM information_schema.global_status
WHERE variable_name IN ('Com_stmt_prepare', 'Com_stmt_execute', 'Prepared_stmt_count');
```

- Com_stmt_parepare: 서버사이드 프리페어 스테이트먼트에서 Connection.prepareStatement()함수 호출에의해 프리페어 스테이트먼트 객체가 만들어진 횟수
- Com_stmt_execute: 서버사이드 프리페어 스테이트먼트에서 Connection.execute(), executepdate(), executeQuery() 함수 호출에 의해 프리페어 스테이트먼트 쿼리가 실행된 횟수
- Prepared_stmt_count: mysql 서버에 현재 만들어져 있는 프리페어 스테이트먼트 객체의 수

**스토어드 프로시저 실행 및 다중 결과 셋 조회**

- 자바에서 스토어드 프로시저를 실행하려면 CallableStatement를 사용해야함
- CallableStatement는 OUT이나 INOUT 타입의 파라미터를 추가로 등록하는 작업이 필요함 만약 없다면 preparedstatement와 동일
- 이후 생략



**배치 처리**



**트랜잭션**

- Connector/j는 기본적으로 AutoCommit
- 별도의 트랜잭션이 필요하면 직접 commit rollback 분기를 만들어서 할것
- 한번의 트랜잭션에서 끝낼 수 있는 작업을 여러개의 autocommit의 포함된 쿼리로 날리면 성능 저하가 있음



**Connector/J 설정 옵션**

- useCompression
  - 애플리케이션과 mysql 서버 사이에 전송되는 데이터를 압축할지 선택하는 옵션
  - 앱서버와 mysql 서버가 원격지로 떨어져있고 네트웍이 별로면 true로 설정해 압축하는게 좋음
  - 이 작업은 cpu 작업이 예상외로 크기 때문에 네트워크 좋으면 false 설정
- allowMultiQueries
  - 여러개의 sql 문장을 ; 구분자로 한번에 실행할수있도록 허용하는 기능 기본값 false
- allowLoadLocalInfile
  - mysql jdbc에서 LOAD DATA LOCAL INFILE 명령을 허용하는지. 기본값 TRUE
- allowUrlInLocalInfile
  - INFILE 옵션에 URL 사용 가능한지. 기본값 FALSE
- useCursorFetch
  - 5.0.2이상 사용 가능
  - 클라이언트 커서 대신 서버 커서를 사용하도록 설정 기본값 false
- defaultFetchSize
  - 서버 커서를 사용할 떄 mysql 서버로부터 한번에 몇개씩 레코드를 읽어올지를 설정함
- holdResultsOpenOverStatementClose
  - 가끔 Statement가 닫혔지만 그 Statement로부터 생성된 Result를 참조해야할 때 이 옵션을 활성화
  - 물론 이때 ResultSet이 불필요해지는 시점에 꼭 명시적으로 닫아 주어야함
  - 기본값 false
- rewriteBatchedStatements
  - 여러개의 insert 문장을 한꺼번에 실행할 때 preparedStatement의 addBatch() 함수로 누적된 레코드를 하나의 insert 문장으로 변환해서 실행하는 기능을 활성화하는 옵션 기본값 false
- useServerPRepStmts
  - 서버 preparedstatement를 사용할지 말지 설정하는 옵션 기본값 false
- traceProtocol
  - connector/j가 mysql 서버와 통신하기 위해 주고받는 패킷을 log4j를 이용해 로깅할 수 있음 기본값 false







# #14 데이터 모델링



## 논리 모델링

- 개념적으로 엔터티와 속성, 그리고 엔터티 간의 관계를 도출하고 통합하는 방법을 비롯해 그것들을 어떻게 erd에 표현하는지 등에 대한것

### 모델링 용어

| 논리 모델        | 물리모델      | 비고                                                         |
| ---------------- | ------------- | ------------------------------------------------------------ |
| 주제 영역        | 주제 영역     |                                                              |
| 엔터티           | 테이블        | 논리 모델과 물리 모델에서 하나의 오브젝트는 항상 1:1관계가 아닐수도있음 |
| 속성, 어트리뷰트 | 칼럼          | 일반적으로는 논리 모델인지 물리 모델인지 별로 구분 없이 사용하므로 둘 다 같은 의미로 인색해도 무방함 |
| 관계, 릴레이션   | 관계 릴레이션 | 논리 물리 구분 없이 사용                                     |
| 키 그룹          | 인덱스        | 논리 물리 모두 인덱스라고 표현                               |

- 주제 영역
  - 관리 용이성이나 가독성을 위해 엔터티 업무 분류별로 나눠서 그룹핑하는데 이를 주제 영역이라고함



### 용어집

- erd를 그리기 이전 또는 이후에 모든 주요 단어에 대해 명확히 그 범위를 제한하는 작업을 한번씩 진행하길 적극 권장함



### 엔터티

- 엔터티는 객체지향 개발 언어의 클래스와 동급의 의미임
- 2개 이상의 속성을 가지고 1개 이상의 레코드를 가지는 것이 일반적
- 테이블과 엔티티가 항상 1:1관계는 아님



**엔터티의 종류와 표현 방법**

- 엔터티이름, 엔티티의 식별자, 엔티티의 멤버 속성을 나열함
- 엔터티는 키엔티티와 메인 엔터티, 액센 엔터티로 구분함
  - 키엔터티
    - 관리 대상 데이터중 가장 최상위에 존재하는 엔터티 메인과 액션 엔터티를 만들어 내는 부모 역하을 함
    - 일반적으로 현실에 존재하는 객체를 표현하는 것들이 많음
  - 액션 엔터티
    - 키 엔터티 간의 작용으로 만들어지는 엔티티를 액션 엔터티라고함 회원(키 엔터티) -> 친구(액션 엔터티)
  - 메인 엔터티
    - 액션 엔터티이지만 서비스에서 상당히 중요한 역할을 하는 엔터티
    - 고객과 상품이라는 키엔터티에 발생할 수 있는 구매 또는 계약과 같은 엔터티는 메인 엔터티의 가장 대표적인 예
    - 키엔터티의 fk 이외에 조합한 식별자가 있으면 메인엔터티
- rdb 구성시 다음보다는

**구매 엔터티**

| 고객 아이디 fk<br />상품 코드 fk<br />구매 일련 번호 |
| ---------------------------------------------------- |
| 구매 일시                                            |

보다는 

**구매 엔터티**

| 구매 일련 번호                         |
| -------------------------------------- |
| 고객 아이디 fk<br />상품 코드 fk<br /> |

가 좋음

- 최종 엔터티를 선별해내는 작업을 엔터티 도출이라고함 

**엔터티의 작명**

- 엔터티 이름은 복수형 표현을 사용하지 않고 별도의 수식어가 없는 단순 또는 복합 명사 형태를 사용함



### 어트리뷰트

- 더는 분리될 수 없는 최소의 데이터 보관 단위
- 다른 어트리뷰트와 구별되는 뭔가를 가지고 있어야함
- 가공하지 않은 그대로의 값
- 추출칼럼은 하나의 엔터티나 다른 엔터티의 어트리뷸트로부터 계산된 값 ex 등록된 게시물의 개수 등 미리 계산해서 저장해둔것
- 반드시 의미가 명확한 명칭을 부여해야함
- 단수형 명명



**어트리뷰트의 원자성**

- 어트리뷰트는 반드시 독자적인 성질을 가지는 하나의 값만을 저장해야함
- 그러나 주소같이 너무 잘게 나눠서 관리의 어려움만 초래할필요는 없음
- 어트리뷰트의 최소 단위는 엔터티의 어트리뷰트 단위로 결정됨
- 하나의 어트리뷰트에 여러 개의 값을 동시에 저장하는 방법도 원자성에 위배됨 ex 취미



**어트리뷰트의 작명**

- 최대한 어트리뷰트의 이름만으로 그 의미를 이해할 수 있게 이름을 짓는 것이 좋음
- 어트리뷰트의 이름은 한정자 + 값을 표현하는 명사로구성하는 것이 가장 좋음



**엔터티와 어트리뷰트의 구분**

- 서비스에 따라 엔터티를 쪼개서 어트리뷰트를 분리해야할 수 있음



### 식별자

- pk 또는 식별자는 하나의 엔터티에서 개별 레코드를 식별할 수 있는 어트리뷰트의 조합을 의미함
- 일반적으로 키 엔터티는 식별자로 어트리뷰트 하나만 가질 때가 많고 메인엔터티, 액션 엔터티는 두 개 이상의 어트리뷰트가 조합되어 식별자 역할을 할 때가 많음
- 식별자는 본질식별자, 실질 식별자라는 말로 나눌 수 있음
  - 본질 식별자
    - 엔터티의 레코드가 생성되는 조건을 알려주는 식별자
    - ex 주문을 생성할때 고객아이디, 상품번호, 주문일자가 본질 식별자
  - 실질 식별자
    - 본질식별자로 구성하면 3개의 어트리뷰트를 사용하는데 그냥간단하게 주문번호로 사용하는 경우 실질식별자라함
  - 인조 식별자
    - 주문번호처럼 인위적으로 만든 식별자, surrogate key





### 관계

- 엔티티가 독립적인 데이터의 집합이라면 관계는 각 데이터 집합 간의 상호작용을 표현한것



**식별 관계와 비식별 관계**

- 식별관계
  - 부모의 식별자가 자식 엔터티의 레코드를 식별하는데 꼭 필요하다면 그 관계는 식별 관계임
  - 부모 엔터티의 식별자는 자식 엔터티의 식별자로 포함되어야함 
  - 부모 엔터티의 식별자가 자식 엔터티의 레코드의 생성 근원이 될 때 이를 식별 관계라함
  - 식별자 상속
  - 식별 관계는 실선으로 표시함
- 비식별 관계
  - 부모 엔티티의 식별자가 없어도 자식 엔터티의 레코드가 생성될 수 있을 때 비식별 관계를 사용함
  - 부모 엔티티의 식별잔ㄴ 일반 어트리뷰트로 참여하게됨
  - 점선으로 표시
- 부모 엔터티가 자식 엔터티를 만들어 내는데 필수라고 생각하면 식별 관계임
- 대체기 역할을 하는 어트리뷰트가 식별자가 될 수 있음 이를 식별자 상속이라고함



**관계 기수성**

- 관계의 기수성이란 부모 엔터티의 레코드 하나에 대해 자식엔터티의 레코드가 얼마나 만들어질 수 있느냐를 의미함
- 0, 1, N이 있음



**관계의 형태**

- 계층 관계
  - 부모와 자식 간의 직선적인 관계가 연속되는 형태
  - 자식 엔터티로 갈수록 식별자를 구성하는 어트리뷰트의 개수가 많아지는데 이럴땐 적절한 수준에서 자식 엔터티의 식별자를 인조 키로 식별자를 대체하는 것이 좋음
- 순환 관계
  - 하나의 엔터티가 부모임과 동시에 자식 엔터티가 되는 재귀적인형태의 관계를 순환 관계라고함

**M:M 관계**

- M:M을 물리모델에서 풀 방법이 없어서 풀어서 해결해야함 이걸 M:M 관계 해소라고함



**BOM 관계**





**배타 관계**

- 서로 다른 두 부모 엔터티로부터 관계를 갖고 있는데 각 관계까 서로 배타적으로만 존재할 때 하나의 엔터티에 두 개 이상의 관계까 동시에 존재할 수 없는 형태를 배타 관계라고 표현함





### 엔터티의 통합

- 처음 엔터티를 도출할 때는 수많은 엔터티가 나열됐다가 모델링이 진행될수록 엔터티의 개수가 줄어드는 것이 일반적임
- 서비스에 따라 적절하게 분리 통합을 선택하는것이 가장 좋음



### 관계의 통합

- 엔터티의 통합과 같이 관계도 통합하는 과정을 거치는 것이 좋음
- 관계의 통합은 성능적인 이슈보다는 업무 요건의 변화에 유연하게 대응하기 위한 것



### 모델 정규화

- 각 어트리뷰트가 적절한 엔터티에 배치되고 각 어트리뷰트가 중복된 데이터를 갖지 않게 하는것이 가장 큰 목적
- 논리 모델링에서 진행하는 정규화는 데이터의 저장 비용을 최소화하는 역할을 담당하고 물리 모델링에서 진행하는 반정규화는 데이터를 읽어오는 비용을 최소화하는 역할을 함





**제 1 정규화**

- 모든 속성은 반드시 하나의 값을 가져야한다.



**제 2 정규화 **

- 식별자 일부에 종속되는 어트리뷰트는 제거해야 한다.
- 어트리뷰트는 모든 식별자에 종속되어야함

**제 3 정규화**

- 식별자 이외의 속성간에 종속 관계가 존재하면 안된다.
- 식별자가 아닌 모든 어트리뷰트는 식별자에 종속성을 가져야함과 동시에 식별자가 아닌 모든 어트리뷰트 간에는 어떠한 종속 관계또 없이 모두 독립적이어야함





## 물리 모델링

- 대표적인 작업 내용
  - 논리 모델에서 신경쓰지 않았던 M:M 관계와 같이 RDBMS에 구현할 수 없는 구조를 해소하는 작업
  - 프라이머리 키의 칼럼 순서 선정
  - 칼럼의 이름 부여
  - 칼럼의 데이터 타입 선정
  - 조회 성능을 위한 반정규화



### 프라이머리 키 선택

- 테이블의 프라이머리키를 복합 칼럼으로 구성할 때는 너무 많은 칼럼이 프라이머리 키로 참여하지 않게 적절히 끊어줄 필요가 있음 EX 인조키 사용하는 방법
- INNODB는 PK의 크기에 따라 인덱스 크기가 결정됨
- 테이블을 대표하는 칼럼으로 PK를 구성하고 PK후보키가 여러개라면 조회 조건으로 가장 많이 사용되는 것을 PK로 선정하는 것이 좋음



### 데이터 타입 선정

- 물리모델링에서 칼럼의 데이터 타입은 가능한 한 최소 단위의 타입을 부여해야함 

**데이터 타입**

- 저장하려는 데이터 성격 별로 그대로 타입을 선정하는 것이 가장 좋음

**칼럼의 길이**

- 이건 서비스에따라 적절한 분석이 필요함

**문자 집합**

- MYSQL에서 정렬이나 그룹핑과 같은 임시테이블 또는 버퍼 작업을 위해 별도의 메모리 할당이 필요한데 MYSQL 서버는 데이터 타입에 명시된 길이를 기준으로 메모리 공간을 할당하고 사용함



**NULL과 NOT NULL**

- MYISAM 스토리지 엔진
  - NULL이든 NULL을 대체해서 저장하든 사용하는 디스크 공간의 차이는 없음
- INNODB 스토리지 엔진
  - 고정 가변 모두 NULL이 저장되는 칼럼은 전혀 디스크 공간을 사용하지 않음
- NULL과 NOT NULL의 선택은 디스크 공간 절약의 문제가 아니라 옵티마이저가 얼마나 쿼리를 더 최적화할 수 있게 환경을 만들어줄 것이냐는 관점에서 골해야함
- MYSQL 서버의 옵티마이저를 잘 알고 NULL의 철학적인 의미를 DBMS에 적용하고자 한다면 NULLABLE 칼럼을 사용해도 무방함
- 옵티마이저가 검색조건으로 자주 사용한다면 NOT NULL 추천



**도메인**

- 각 칼럼에 도메인을 매핑함으로써 하나의 프로그램뿐 아니라 한 회사의 모든 서비스나 애플리케이션에서 사용되는 칼럼 타입을 일관성있게 통일해서 사용할 수 있음



### 반정규화

- GROUP BY나 COUNT와 같이 많은 레코드를 대상으로 작업을 빠르게 조회하기 위해 미리 건수를 집계해서 별도의 테이블이나 칼럼으로 저장해두는 것을 반정규화라함
- 어떻게 반정규화된 칼럼이나 테이블을 유지할것인가가 관점
- 반정규화된 칼럼의 값을 유지하려면 최대한 모아서 배치 형태로 실행하거나 백그라운드 작업으로 처리하는게 좋음
- 대표적인 예
  - 칼럼 복사
    - 원본 칼럼의 값을 변경하지 않고 다른 테이블로 복사해두는 형태
    - 조인을 없애거나 GROUP BY나 ORDER BY 등을 인덱스로 처리할 수 있도록 유도
    - 조인이 목적이라면 비효율적, 이 칼럼이 자주 변경된다면 비효율적
    - 인덱스처리는 상당히 도움
  - 정렬을 위한 용도



**요약 칼럼**

- 어떠한 계산의 결과로 만들어진 값을 저장하기 위한 반정규화한 칼럼
- EX 게시판의 목록을 조회할 때 게시물 수를 함꼐 출력해야 할 때
- EX 특정 게시판의 상세 내용을 출력할 때 게시물 수를 함께 출력해야 할 때
- 배치 형태로 요약 칼럼의 값을 증가시키는 방법이 효율적임



**해시 인덱스**

- 해시 인덱스는 동등 비교를 가장 빠르게 처리할 수 있는 인덱싱 방식임
- 원래의 값을 인덱싱하는 것이 아니라 길이를 훨씬 줄인 해시값으로 인덱스를 구성함
- 특정 칼럼의 값을 MD5로 매핑한 컬럼을 추가해서 검색조건을 추가하는 형태로 사용가능



**반정규화된 테이블**

- EX 랭킹을 미리 집계해두는 형태의 테이블





# #15 데이터 타입

- 칼럼의 데이터 타입과 길이를 선정할 때 가장 주의해야할 사항
  - 저장되는 값의 성격에 맞는 최적의 타입 선정
  - 가변 길이 칼럼은 최적의 길이를 지정
  - 조인 조건으로 사용되는 칼럼은 똑같은 데이터 타입을 선정
- 실제로 저장되는 값의 성격을 정확히 분석하고 최적의 타입과 길이를 선정하는 것이 중요함



## 문자열(char와 varchar)

### 저장공간

- 공통점은 문자열을 저장할 수 있는 데이터 타입
- 차이점은 고정 길이인지 가변 길이인지의 여부
- char 타입은 고정 길이, varchar 타입은 가변길이
- varchar 타입은 문자열 길이를 관리하기 위한 1~2바이트의 공간을 추가적으로 더 사용함
- char 타입과 varchar 타입을 결정할 때 중요한 판단 기준
  - 저장되는 문자열의 길이가 대개 비슷한가?
  - 칼럼의 값이 자주 변경되는가?
- char 타입의 경우 이미 저장될 바이트를 확보했기 때문에 값의 변경이 있어도 레코드 이동이 일어나지 않지만 varchar의 경우 값이 길어질 경우 레코드 자체를 다른 공간으로 옮기거나 칼럼 값의 나머지 부분을 다른 공간에 저장해야함
- char(10)
  - 일반적으로 영어를 포함한 서구권 언어는 각 문자가 1 바이트를 사용하므로 10 바이트를 사용함
  - 한국어나 일본어와 같은 아시아권 언어는 각 문자가 최대 2바이트를 사용하므로 20바이트를 사용함
  - utf-8과 같은 유니코드는 최대 3바이트까지 사용하므로 30바이트까지 사용함
- utf-8의 4바이트 문자는 5.5이상에서만 지원됨





### 비교 방식

- char와 varchar가 거의 같음
- char타입이나 varchar타입 모두 비교할때 칼럼 값의 뒷쪽 공백문자는 모두 제거하고 비교를 수행함 like 제외



### 문자집합(캐릭터 셋 )

- char와 varchar, text 타입의 컬럼에만 설정 가능
- 테이블별로, db별로 기본 셋 설정 가능 
- SHOW CHARACTER SET 명령으로 확인 가능
- 기타 속성이나 자세한건 생략





### 콜레이션

- 문자열 칼럼의 값에 대한 비교나 정렬 순서를 위한 규칙 
- 각 문자열 칼럼의 값을 비교하거나 정렬할 때는 항상 문자집합뿐 아니라 콜레이션의 일치 여부에 따라 결과가 달라지며 쿼리 성능 또한 상당한 영향을 받음
- SHOW COLLATION;
- 콜레이션의 이름은 2개 또는 3개의 파티로 구분돼있고 다음과같은 의미를 가짐
  - 3개의 파트로 구성된 콜레이션 이름
    - 첫번째 파트는 문자집합의 이름
    - 두번째 파트는 해당 문자 집합의 하위 분류를 나타냄
    - 세번쨰 파트는 대문자나 소문자의 구분 여부를 나타냄 ci(구분x), cs(구분o)
  - 2개의 파트로 구성된 콜레이션 이름
    - 첫번째 파트는 문자집합의 이름
      - 두번째 파트는 항상 bin(이진데이터)이라는 키워드가 사용됨. 비교 및 정렬은 실제 문자 데이터의 바이트 값을 기준으로 수행됨
- 조인을 수행하는 양쪽 테이블 칼럼이 문자집합이나 콜레이션이 다르다면 콜레이션변환때문에 인덱스를 효율적으로 사용못함
- 때로 where 조건의 검색은 대소문자를 구분하지 않고 실행하되 정렬은 대소문자를 구분해서 해야 할 때도 있는데 이때는 검색과 정렬 작업 중에서 하나는 인덱스를 이용하는 것을 포기할 수 밖에 없음 주로 이때는 칼럼의 콜레이션을 _ci로 만들어 검색은 인덱스를 충분히 이용할 수 있게 해주고 정렬은 using filesort 형태로 처리하는것이 일반적임
- 만약 정렬 + 인덱스를 이용하려면 정렬을 위한 콜레이션을 사용하는 칼럼을 하나 더 추가하고 검색은 원본칼럼 정렬은 추출칼럼

```sql
SELECT table_name, column_name, cloum_type, character_set_name, collation_name
FROM information_schema.columns
WHERE table_schema='test' AND table_name='tb_collate';
```





문자열 이스케이프 처리

- `\`을 통해 이스케이프 처리할 수 있음



| 이스케이프 표기 | 의미            |
| --------------- | --------------- |
| \\0             | 아스키 null문자 |
| \'              | 홑따옴표        |
| \"              | 쌍따옴표        |
| \\b             | 백스페이스 문자 |
| \\n             | 개행            |
| \\r             | 캐리지 리턴     |
| \\t             | 탭              |
| \\\\            | 백슬래시        |
| \%              | 퍼센트          |
| \\_             | 언더스코어      |



## 숫자

- 참값과 근사값으로 나뉨
  - 참값
    - 소수점 이하 값의 유무에 관계 없이 정확히 그 값을 그대로 유지하는 것을 의미함
    - INTEGER, INT로 끝나는 타입과 DECIMAL
  - 근사값
    - 부동 소수점이라고 불리는 값. 처음 칼럼에 저장한 값과 조회된 값이 정확하게 일치하지 않고 최대한 비슷한 값을 관리하는것을 의미
    - FLOAT 과 DOUBLE
- 값이 저장되는 포맷에 따라 십진 표기법과 이진 표기법으로 나눠볼 수 있음
  - 이진 표기법
    - 정수나 실수 타입을 의미
    - 숫자 값을 적은 메모리나 디스크 공간에 저장할 수 있음
    - MYSQL의 INTEGER BIGINT등 대부분 숫자타임은 이진 표기법 사용
  - 십진 표기법
    - 우리가 흔히 이야기하는 십진수가 아니라 디스크나 메모리에 십진 표기법으로 저장된다는 것을 의미함
    - DECIMAL같은 경우 금액처럼 정확하게 소수점까지 관리돼야하는 값을 저장할 때 사용함
- 매우 큰 숫자나 고정 소수점을 저장해야하는 것이 아니라면 일반적으로 INTEGER나 BIGINT 타입을 사용



### 정수

- TINYINT, SMALLINT, MEDIUMINT, INTEGER, BIGINT가 있음
- USIGNED라는 칼럼 옵션을 사용하면 SINGED 타입보다 2배가 커짐

### 부동소수점

- 정확한 유효 소수점 값을 식별하기 어렵고 그 값을 비교하기가 쉽지 않음
- DOUBLE, FLOAT



### DECIMAL

- 돈과 관련된 매우 중요한 고정 소수점 타입을 위해 DECIMAL 타입을 제공함
- 소수가 아닌 정수값의 관리는 INTEGER, BIGINT를 사용하는 것이 좋음



### 정 타입의 칼럼을 생성할 때의 주의사항

- FLOAT이나 DOUBLE타입은 저장 공간의 크기가 고정형이므로 정밀도를 조절한다고해서 저장 공간의 크기가 바뀌는 것은 아님 하지만 DECIMAL 타입은 저장 공간의 크기가 가변적인 데이터 타입이여서 저장 공간의 크기까지 제한함
- BIGINT 같은애들은 이미 고정값
- BIGINT(10) ZEROFILL의 경우 10개를 맞춘 LPAD를 시도함
- ZEROFILL은 자동으로 UNSIGNED 타입이됨

### 자동 증가 옵션 사용

- 시스템 설정을 이용해 칼럼의 자동 증가 값을 변경할 수 있음
- auto_increment 옵션을 사용한 칼럼은 반드시 그 테이블에서 pk나 유니크 키의 일부로 정의되어야 함
- 다중 컬럼일 경우
  - myisam 
    - 자동 증가 옵션이 사용된 칼럼이 pk나 유니크키의 아무 위치에나 사용될 수 있음
  - innodb
    - pk또는 유니크 키 중 제일 앞에 위치해야함
- myisam과 innodb에서 다중 칼럼으로 작성된 pk가 있다면 다르게 동작함 참고
- auto_increment는 테이블당 단 하나만 사용 가능
- mysql 스키마 복사할때는 auto_increment의 초기값을 주의할 것



## 날짜와 시간

- mysql에서는 날짜 또는 시간만 따로 저장 가능 또 합쳐서 하나의 칼럼의로도 저장 가능
- 대표적으로 DATE와 DATETIME 타입이 많이사용됨
- MYSQL의 날짜 타입은 자체적으로 타임존을 관리하지 않으므로 DATETIME이나 DATE 타입은 현재 DBMS 커넥션의 타임존에 관계 없이 클라이언트로부터 입력된 값을 그대로 저장하고 조회할때도 변환 없이 그대로 출력함
- TIMESTAMP는 타임존이 변경됨에 따라 그에 맞게 시간이 보정됨
- 글로벌 한 상황에서의 시간 데이터는 항상 MYSQL 서버의 타임존으로 변환해서 저장하는게 좋음





### TIMESTAMP 타입의 옵션

- TIMESTAMP 값은 INSERT UPDATE시점에 그냥 자동으로 업데이트됨
- 기본적으로 테이블에서 먼저 명시된 TIMESTAMP값만 변경됨
- 4가지 특징을 지닌 TIMESTAMP
  - col_ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
    - INSERT, UPDATE시 자동으로 인서트 업데이트
    - 기본값
  - col_ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  - col_ts TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP
  - col_ts TIMESTAMP DEFAULT 0
    - 둘다 끔
- TIMESTAMP 두개가 있을때 맨먼저 오는 TIMESTAMP에 옵션을끄면 자동으로 2번째칼럼으로 넘겨짐



### 타임존 등록 및 사용



## ENUM과 SET

- ENUM과 SET은 모두 문자열 값을 MYSQL 내부적으로 숫자 값으로 매핑해서 관리하는 타입
- DB에는 이미 인코딩된 알파벳이나 숫자형태로 저장됨



### ENUM

- ENUM타입은 반드시 하나의 값만 저장 가능
- 코드화된 값을 관리
- MYSQL 서버가 실제로 값을 디스크에 저장할때는 숫자형으로 저장됨 따라서 1을 곱하거나 0을 더하는 형태로 셀렉트를 하면 실제 enum의 정수값을 알아낼 수 있음
- 빈 문자열은 0으로 맵핑 
- ENUM 타입은 저장해야 하는 문자열  값이 길면 길수록 저장 공간을 더 많이 절약 가능함
- 5.1 이후로 ENUM 타입이 기존 값은 변경되지 않고 새로운 문자열 값이 마지막에 추가되면 MYSQL 서버는 테이블의 데이터는 변경하지 않고 MYSQL 테이블의 메타 정보만 변경하므로 빠르게 처리됨 기존 값들 사이에 추가하는 것은 테이블 구조뿐아니라 테이블의 데이터까지 모두 변경해야하므로 상상한 시간이 걸릴 수 있음 기존 ENUM 타입에 정의된 문자열 중에서 하나를 제거하는 작업도 마찬가지임
- ENUM의 정렬은 눈에 보이는 문자열이아니라 실제 저장된 정수값으로 정렬됨 정렬하지 말것
- 정렬이 꼭 필요하다면 강제로 캐스팅해서 정렬해야함 이때 인덱스 사용 불가





### SET

- 문자열 값을 정수 값으로 맵핑해서 저장하는 방식은 ENUM과 같음
- SET은 하나의 칼럼에 2개 이상의 값을 저장할 수 있음
- 실제 내부에는 BIT-OR 연산으로 8개 이하면 1바이트 9개에서 16개는 2바이트 ... 2n의 값
- 여러 개의 값을 하나의 set 타입에 저장할땐 ,로 구분해서 문자열 값을 나열해서 입력하면 됨
- FIND_IN_SET() 함수로 검색
- SET타입의 칼럼에 인덱스가 있더라도 동등 비교 조건을 제외하고 FIND_IN_SET() 함수나 LIKE를 사용하는 쿼리는 인덱스 사용불가



### TEXT, BLOB

- MYSQL에서 대량의 데이터를 저장할때 TEXT나 BLOB타입을 사용함 둘이 거의 똑같은 방식으로 작동
- 유일한 차이점은 TEXT타입은 문자열을 저장하는 대용량 칼럼이라서 문자집합이나 콜레이션을 가지고 BLOB은 이진 데이터타입이라 문자집합이나 콜레이션이 없음
- TINYTEXT, TINYBLOB
- TEXT,BLOB
- MEDIUMTEXT, MEDIUMBLOB
- LONGTEXT, LONGBLOB이 있음

|             | 고정길이 | 가변길이  | 대용량 |
| ----------- | -------- | --------- | ------ |
| 문자 데이터 | CHAR     | VARCHAR   | TEXT   |
| 이진 데이터 | BINARY   | VARBINARY | BLOB   |

- TEXT와 BLOB칼럼은 똑같이 사용할때 주의하고 너무 남용하면안됨
- TEXT나 BLOB을 사용하기 좋은 상황
  - 칼럼 하나에 저장되는 문자열이나 이진 값의 길이가 예측할 수없이 클 때
  - 레코드의 전체 크기가 64KB를 넘긴다면 TEXT나 BLOB 아니라면 VARCHAR, VARBINARY로 커버됨
- 인덱스 생성에 몇 바이트까지 쓸껀지 명시하면 이컬럼도 인덱스 설정 가능함
- TEXT나 BLOB은 임시테이블을 생성할때 데이터가 크기 때문에 메모리가아니라 디스크를 사용함 성능 안좋음
- 가급적 SELECT * FROM 보단 실제 필요한 컬럼만 저회해야함
- 일부만조회해도 된다면 CAST나 SUBSTRING() 사용할 것 이경우 임시테이블을 메모리에 사용 가능
- BLOB이나 TEXT 타입 칼럼 값의 길이에 따라 디스크에 저장하는 방식도 달라질 수 있음
- 대용량 BLOB이나 TEXT 칼럼을 사용하는 쿼리가 있다면 MYSQL 서버의 max_allowed_packet 설정을 충분히 늘려 줄 것



## 공간 데이터 타입	

- 스킵















