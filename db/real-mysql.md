# #1 소개



# #2 설치와 설정





# #3 MySQL 아키텍처



## MySQL 아키텍처



![](https://t1.daumcdn.net/cfile/tistory/26219B435902D88522)

### mysql 전체구조

- mysql은 일반 상용 rdbms에서 제공하는 대부분의 접근법을 모두 지원함

- mysql 서버는 크게 mysql 엔진, 스토리지 엔진으로 구분해볼 수 있음

**mysql 엔진**

- mysql 엔진은 클라이언트로부터의 접속 및 쿼리요청을 처리하는 커넥션 핸들러와 sql 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심

**스토리지 엔진**

-  실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 스토리지 엔진이 전담, mysql 엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용 가능

**핸들러 api**

- mysql 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에게 쓰기 또는 읽기 요청을 하는데 이러한 요청을 핸들러 요청이라고하고 여기에 사용되는 api를 핸들러 api라함
  

### mysql 스레딩 구조

- mysql 서버는 프로세스기반이 아니라 스레드 기반으로 작동함 크게 포그라운드와 백그라운드 스레드로 구분

**포그라운드 스레드(클라이언트 스레드)**

- mysql 서버에 접속된 클라이어트의 수 만큼 존재
- 요청하는 쿼리 문장을 처리하는 것이 임무
- 요청 종료시 다시 스레드 캐시 (thread pool)로 돌아감
- 스레드의 개수를 일정하게 유지해주는 파라미터 thread_cache_size

**백그라운드 스레드**

- innoDB는 여러가지 작업이 백그라운드로 처리 여러가지 작업을 함
- 쓰기 스레드는 innodb_write_io_threads, 읽기 스레드는 innodb_read_io_treads로 지정 가능
- 읽기스레드는 클라이언트 스레드에서 처리되는데 쓰기의 경우 일반 내장 디스크에서는 2~4, ans,san과같은 스토리지를 사용할 경우 4개 이상으로 충분히 설정하는게 좋음

<br>

- 상용 dbms에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 있고 innodb도 그러함 but myisam은 그렇지 않고 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계되어 있음
- innodb에서는 cud 쿼리로 데이터가 변경되는 경우 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 됨 . 하지만 myisam에서 일반적인 쿼리는 쓰기 버퍼링을 사용할 수 없음



### 메모리 할당 및 사용 구조

- mysql에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분 가능
- 글로벌 메모리 영역의 모든 메모리 공간은 mysql 서버가 시작되면서 무조건 운영체제로부터 할당됨 
- 글로벌 메모리 영역과 로컬 메모리 영역의 차이는 mysql 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 아닌지에 따라 구분됨

**글로벌 메모리 영역**

- 일반적으로 클라이언트 스레드의 수와 무관하게 일반적으로는 하나의 메모리 공강만 할당, 필요에 따라 2개 이상의 메모리 공간을 할당받을 수 있지만 클라이언트 스레드의 수와 무관하고 생성된 글로벌영역은 모든 스레드의 의해 공유됨

**로컬 메모리 영역**

- 세션 메모리 영역이라도 불림
- mysql 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용되는 메모리 영역
- 로컬 메모리는 각 클라이언트 스레드 별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징

### 플러그인 스토리지 엔진 모델

- mysql 독특한 구조중 하나가 바로 플러그인 모델, 직접 제작도 가능함
- sql 파서 -> sql 옵티마이저 -> sql 실행기 -> 데이터 읽기/ 쓰기 -> DB
- 위 과정에서 마지막 데이터 읽기/쓰기 과정만 스토리지 엔진에 의해 처리됨 나머지는 mysql  엔진에서 처리
- 데이터 읽기/쓰기 작업은 대부분 1건의 레크도 단위로 처리됨
- mysql 서버에서는 mysql 엔진이 사람역하을 하고 각 스토리지 엔진은 자동차 역할을 하게 됨. mysql 엔진이 스토리지 엔진을 조정하기 위해 핸들러 라는것을 사용함
- mysql 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 핸들러를 사용한다는 점만 기억하면 됨
- 실질적인 group by oder by 등 많은 복잡한 처리는 스토리지 엔진 영역이 아니라 mysql 엔진의 처리 영역인 쿼리 실행기에서 실행됨

![](https://www.dbrnd.com/wp-content/uploads/2016/01/MySQLShowEngines.png)

- 이거말고 조금 더 있음
- 플러그인형식으로 스토리지 엔진을 쉽게 설치 가능함



### 쿼리 실행 구조



**파서**

- 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미
- 쿼리 문장의 기본 문접 오류는 이 과정에서 발견되고 사용자에게 오류 메시지를 전달하게 됨

**전처리기**

- 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인함
- 실제 존재하지 않거나 권한상 사용 불가한 토큰의 경우 이 단계에서 걸러짐

**옵티마이저**

- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 담당
- 매우 중요함

**실행 엔진**

- 옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발에 비유할 수 있음

- 옵티마이저가 group by를 처리하기위해 임시테이블을 사용하기로 결정했다면 다음과 같은 과정

  1. 실행 엔진은 핸들러에게 임시 테이블을 만들라고 요청

  2. 다시 실행 엔진은 where 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청

  3. 읽어온 레코드들을 1번에서 준비한 임시테이블로 저장하라고 다시 핸들러에게 요청

  4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어오라고 핸들러에게 다시 요청

  5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

     즉 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행

**핸들러 (스토리지 엔진)**

- mysql 서버 가장 밑단에서 mysql 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당
- 핸드럴 == 스토리지 엔진
- myisam 테이블을 조장하면 핸들러가 myisam 스토리지엔진 <- 이런식임



### Replication

- 복제는 2대 이상의 mysql 서버가 동일한 데이터를 담도록 실시간으로 동기화 하는 기술
- 쓰기는 마스터 읽기는 슬레이브
- mysql 서버의 복제에서는 마스터는 반드시 1개 슬레이브는 1개 이상으로 구성될 수 있음



**마스터**

- 기술적으로는 mysql의 바이너리 로그가 활성화되면 어떤 mysql 서버든 마스터가 될 수 있음
- 데이터가 생성 및 변경, 삭제되는 주체
- dml,ddl을 바이너리 로그에 기록
- 슬레이브는 변경 내역을 요청하면 바이너리 로그에서 읽어서 슬레이브로 넘김
- 마스터의 프로세스중 "Binlog dump"라는 스레드가 이 일을 전담함 슬레이브 수대로 스레드가 존재



**슬레이브**

- 데이터를 받아올 마스터 장비의 정보를 갖고 있는 경우 슬레이브가 됨
- 슬레이브 서버는 릴레이 로그를 갖고 있음
- 슬레이브는 읽기 전용
- 슬레이브 서버의 i/o 스레드는 마스터 서버에 접속해 변경 내역을 요청하고 받아 온 변경 내역을 릴레이 로그에 기록함
- 슬레이브 서버의 sql 스레드가 릴레이 로그에 기록된 변경 내역을 재실행 함으로 마스터와 동일한 상태로 유지함
- i/o 스레드는 슬레이브에만 있음



**복제시 주의사항**

- 슬레이브는 하나의 마스터만 설정 가능
- 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정
- 슬레이브 서버용 장비는 마스터와 동일한 사양이 적합
- 복제가 불필요한 경우에는 바이너리 로그 중지
- 바이너리 로그와 트랜잭션 격리 수준

> - 5.1에서는 Statement based replcation, Row based replication이 지원됨
> - sql 기반의 복제는 아무리 많은 데이터의 변경을 유발하더라도 sql 문장 하나만 슬레이브로 전달되기때문에 네트워크 트래픽을 많이 유발하지 않음 <- but repeatable-read 이상의 트랜잭션 격리 수준을 사용해야 하고 innodb 테이블에서는 레코드 간의 간격을 잠그는 갭 락이나 넥스트 키락이필요해짐
> - 레코드 기반으로 하면 트래픽이 많아지지만 read-commited 격리수준에도 동작하며 innodb테이블에서 잠금 경합이 줄어듬

### 쿼리 캐시

- mysql에만 있음
- sql 문장을 캐시하는게 아니라 쿼리 결과를 메모리에 캐시해두는 기능
- map과 같은 데이터 구조로 구현되어 있음 키는 sql 쿼리 문장, 값은 실행 결과
- 쿼리 캐시 결과 확인 절차를 가짐
  - 요청된 쿼리 문장이 쿼리 캐시에 존재하는가?
  - 해당 사용자가 그 결과를 볼 수 있는 권한을 갖고 있는가?
  - 트랜잭션 내에서 실행된 쿼리인 경우 가시 범위 내에 있는 결과인가?
  - 호출 시점에 달라 결과가 달라지는 요소가 있는가?
  - 프리페어 스테이트먼트의 경우 변수가 결과에 영향을 미치지 않는가?
  - 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가?
  - 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가?
  - 그 밖에 쿼리 캐시를 사용하지 못하게 만드는 요소가 있는가?
- `show global status` 명령을 이용해 쿼리 캐시의 사용량과 정보를 확인 가능
- Com_select (엔진이 처리)+ Qcache_hits (캐시 hit) = mysql 서버로 요청된 모든 select 문장
- 쿼리 캐시 히트율% = Qcache_hits  / (Qcache_hits + Com_select) * 100
- 쿼리 캐시율이 20% 이상이면 좋다고 이야기하는데 그냥 시기적절하게 잘 사용하는게 중요함
- 쿼리 캐시를 사용하지 않는 설정

```
query_cache_size = 0
query_cache_type = 0
```





## InnoDB 스토리지 엔진 아키텍처

- mysql에서 사용할 수 있는 스토리지 중 거의 유일하게 레코드 기반의 잠금을 제공
- 높은 동시성처리와 안정적, 성능 또한 뛰어남

![public](https://user-images.githubusercontent.com/30790184/98905454-c75d3680-24fe-11eb-8bc6-373681f016ae.jpeg)



### InnoDB 스토리지 엔진의 특성

**프라이머리 키에 의한 클러스터링**

- InnoDB의 모든 테이블은 기본적으로 키를 기준으로 클러스터링 되어 저장됨 이로 인해 pk에 의한 레인지 스캔은 상당히 빠르게 처리됨
- 결과적으로 쿼리의 실행 계획에서 pk는 다른 보조인덱스에 비해 비중이 높음 
- 오라클의 IOT(Index organized table)과 동일한 구조가 InnoDB에서는 일반적인 테이블 구조

**잠금이 필요없는 일관된 읽기 (None-locking consistent read)**

- InnoDB 스토리지엔진은 MVCC(Multi Version Concurrency Control) 이라는 기술을 이용해 락을 걸지 않고 읽기 작업을 수행함
- 락을 걸지 않기 때문에 읽기 작업은 다른 트랜잭션이 가지고 있는 락을 기다리지도 않음 SERIALIZABLE은 제외

**외래 키 지원**

- 외래키는 myisam에서 사용불가 innodb만 가능
- innodb에서 외래키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고 변경 시에 반드시 부모 테이블이나 자식 테이블에 데이터가 있는 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고 그로 인해 데드락이 발생할 때가 많음

**자동 데드락 감지**

- InnoDB는 그래프 기반의 데드락 체크 방식을 사용함. 데드락이 발생함과 동시에 바로 감지되고 감지된 데드락은 관련 트랜잭션 중에서 rollback이 가장 용이한 트랜잭션(복구 작업이 가장 적은 트랜잭션)을 자동적으로 강제 종료해버림
- 데드락 때문에 쿼리가 제한시간에 도달한다거나 슬로우 쿼리로 기록되는 경우가 많지 않음

**자동화된 장애 복구**

- 손실이나 장애로부터 데이터를 보호하기 위한 여러가지 메커니즘이 탑재되어 있음

**오라클 아키텍처 사용**

- innodb는 오라클과 상당히 비슷한 부분이 많음 ex mvcc 기능 등등



### InnoDB 버퍼 풀

- InnoDB에서 가장 핵심적인 부분
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
- 쓰기 작업을 지연시켜 일괄 작업을 처리할 수 있는 버퍼공간
- myisam은 키 캐시가 인덱스의 캐시만을 주로 처리하는데 비해 innodb의 버퍼 풀은 데이터와 인덱스 모두 캐시하고 쓰기 버퍼링의 역할까지 모두 처리함
- innodb의 버퍼 풀은 많은 백그라운드 작업의 기반이 되는 메모리 공간임 따라서 버퍼 풀 크기를 신중하게 설정하는 것이 좋음 (innodb_buffer_pool_size)
- 적절하게 설정해야하고 일반적으로 전체 장착된 물리 메모리의 50~80% 수준에서 버퍼 풀의 메모리 크기를 결정함
- innodb 버퍼 풀은 아직 디스크에 기록되지 않은 변경된 데이터를 갖고 있음 (더티 페이지라 함 )



### undo 로그

- update 문장이나 delete 문장으로 데이터를 변경했을때 변경되기 전의 데이터를 보관하는 곳
- 사용자가 커밋하면 적용된 그대로 유지되고 롤백하면 언두 영역의 백업 데이터를 다시 데이터 파일로 복구함
- 언두 용도
  - 트랜잭션 롤백 대비용
  - 트랜잭션 격리 수준을 유지하면서 높은 동시성을 제공하는데 사용됨



### 인서트 버퍼

- rdbms에서 insert나 update에 데이터 파일을 변경하는 작업 뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요함
- 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 인덱스가 많다면 자원소모가 많음
- innodb는 변경해야할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행함 그렇지 않으면 임시 공간에 저장해두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시킴 이 때 사용하는 임시 메모리 공간을 인서트 버퍼라고함
- 유니크 인덱스는 인서트 버퍼를 사용할 수 없음
- 5.5이전까지는 insert에만 가능했으나 5.5 이후부터는 insert delete인해 키를 추가하거나 삭제하는 작업에도 버퍼링이 될 수 있게 개선
- 5.5 이후부터는 innodb_change_buffering이라는 파라미터로 종류별로 인서트 버퍼를 활성화 가능



### redo 로그 및 로그 버퍼

- 쿼리 문장으로 데이터를 변경하고 커밋하면 dbms는 데이터의 acid 보장을 위해 변경된 내용을 데이터 파일로 기록해야함 <- 상당한부하 작업
- 따라서 대부분 dbms에는 버퍼링을 위한 버퍼풀과 같은 장치가 있지만 이 장치만으로 acid를 보장할수는 없음
- 따라서 이를 위해 변경된 내용을 순차적으로 디스크에 기록하는 로그 파일을 갖고 있는데 이게 리두 로그임
- 리두로그 덕분에 dbms 데이터는 버퍼링을 통해 한꺼번에 디스크에 변경된 내용을 처리할 수 있고 성능 향상을 기대할 수 있게 됨
- 변경작업이 매우 많은 dbms 서버의 경우 이 리두 로그의 기록 작업이 큰 문제가됨 <- 이런 부분을 보완하기 위해 최대한 acid 속성을 보장하는 수준에서 버퍼링함
- 리두 로그 버퍼링에 사용되는 공간이 로그 버퍼임
- 로그 버퍼의 크기는 1~8m수준이 좋고 blob이나 text같은 큰 데이터의 변경이 많으면 더 크게



### MVCC(Multi Version Concurrency Control)

- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 dbms가 제공하는 기능
- 잠금을 사용하지 않는 일관된 읽기를 제공함
- innodb는 언두 로그를 이용해 이기능을 구현함
- 멀티 버전은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미



### 잠금 없는 일관된 읽기(Non-locking consistent read)

- innodb에서 격리수준이 serializable이 아닌 read-uncommited나 read-commited 그리고 repeatable-read 수준인 경우 inserrt와 연결하지 않은 순수한 읽기 작업은 다른 트랜잭션의 변경과 관계 없이 항상 잠금을 대기하지 않고 바로 실행됨 <- 잠금 없는 일관된 읽기
- innodb의 언두로그를 사용함
- 오랜 시간동안 활동하는 트랜잭션이 있을 경우 일관된 읽기를 위해 언두 로그를 삭제하지 못해 성능저하가 있을 수 있음 트랜잭션은 최대한 빨리 끝낼것



### innodb와 myisam 스토리지 엔진 비교

- 5.5부터는 innodb가 기본 엔진
- innodb가 짱좋음



### innodb와 memory 스토리지 엔진 비교

- memory는 모두 메모리에 저장하기때문에 작업이 매우 빠름 but 테이블락



## MyISAM 스토리지 엔진

- 생..략

## MEMORY 스토리지 엔진 아키텍처

- 생략

## NDB 클러스터 스토리지 엔진

- 생략



## TokuDB

- 빠르게 증가하는 대용량 데이터를 관리하는 것이 주 특기
- 이외 생략 



## 전문 검색 엔진

- 생략



## MySQL 로그 파일

### 에러로그파일

- mysql config 파일에 log_error 라는 파라미터로 정의된 경로의 파일이거나  없는 경우 datadir에 .err 확장자가 붙은 파일
- 시작시점, 비정상종료일때 트랜잭션 복구 메시지, 쿼리 도중 에러 메시지 등등이 자주 발생함

### 제너럴 쿼리 로그 파일

- 쿼리 전체 목록 로그 파일
- general-log 라는 이름의 파라미터에 정의된 경로에 있는 파일 5.1.12이상에서는 general_log_file

### 슬로우 쿼리 로그 

- mysql 서버의 쿼리 튜닝은 서비스가 적용되기 전에 전체적으로 튜닝하는 경우와 서비스 운영 중에 mysql 서버의 전체적인 성능 저하를 검사하거나 정기점검을 위한 튜닝으로 나눌 수 있음
- 어떤 쿼리가 문제인지 판단하기가 상당히 어려움
- 슬로우 쿼리 로그 파일에는 long_query_time 파라미터 이상 소요된 쿼리가 모두 기록됨
- 반드시 완료되어야 슬로우쿼리로그에 기록됨

### 바이너리 로그와 릴레이 로그

- 바이너리로그 파일은 마스터에 릴레이로그는 슬레이브에 생성
- 바이너리로그에는 select 같이 데이터 구조나 내용을 변경하지 않는 쿼리는 기록되지 않음
- 바이너리로그는 이진 파일로 되어있어서 직접 확인 불가능 mysqlbinlog를 사용할 것





# #4 트랜잭션과 잠금



## 트랜잭션

### MySQL에서의 트랜잭션

- innodb는 쿼리중 일부라도 오류가 발생하면 전체를 원상태로 만들어둠
- myisam에는 부분업데이트가 일어남 부분업데이트는 데이터 정합성에 큰 문제임

### 주의사항

- 트랜잭션은 필요한 최소의 코드에만 적용하는 것이 좋음
- 원격작업이 묶인 트랜잭션은 치명적일 수 있음



## MySQL 엔진의 잠금

- 스토리지 엔진 레벨과 mysql 엔진 레벨로 나뉨
- mysql 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않음\
- mysql 엔진에서는 테이블락 말고 유저락, 테이블 명에 대한 잠금을 위한 네임락도 제공함



### 글로벌 락

- 글로벌락은 FLUSH TABLES WITH READ LOCK 명령으로만 획득 가능하고 mysql에서 제공하는 잠금 가운데 가장 범위가 큼
- 세션단위로 동작함 mysql 서버 전체의 테이블에 락을 검
- select를 제외한 모든 문장이 글로벌락이 해제될 때까지 대기상태로 남음
- 잘못사용하면 큰일남
- mysqldump라는 백업프로그램에서 사용할 수도 있음 잘 체크해볼것

### 테이블 락

- 개별 테이블 단위로 설정되는 잠금, 명시적 또는 묵시적으로 테이블의 락 획득 가능
- 테이블락은 myisam, innodb 모두 사용 가능
- LOCK TABLE table_name [READ | WRITE] 으로 명시적으로 획득 가능
- UNLOCK TABLES로 잠금 반납가능
- 특별한 상황이 아니면 사용할일이 없음 잘못사용하면 큰일남
- 묵시적인 테이블락은 myisam이나 memory 테이블에 데이터를 변경하는 쿼리를 실행하면 발생함 
- 묵시적 테이블 락은 쿼리가 실해오디는 동안 자동적으로 획득됐다가 쿼리가 완료된 후 자동 해제됨
- innodb는 레코드기반 락이기때문에 묵시적 테이블락이 설정되지 않음
- 정확히는 ddl의 경우에만 테이블락이 설정됨



### 유저 락

- GET_LOCK() 함수를 이용해 임의로 잠금 설정 가능
- 유저락은 테이블, 레코드 같은 대상이 아니라 사용자가 지정한 문자열에 대해 획득 및 반납하는 잠금임
- 자주 사용되지 않음
- 많은 레코드를 한번에 변경하는 트랜잭션의 경우 유용하게 사용 가능



### 네임 락

- 데이터베이스 객체의 이름을 변경하는 경우 획득하는 잠금
- READ TABLE tab_a TO tab_b 와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금, 원본과 대상 둘다 잠금



## MyISAM과 MEMORY 스토리지 엔진의 잠금

- 이 두 엔진은 자체적인 잠금을 가지지 않고 mysql에서 제공하는 테이블락을 그대로 사용함
- 쿼리단위로 필요한 잠금을 한꺼번에 모두 요청해서 획득하기 때문에 데드락이 발생할 수 없음
- momory, archive, merge 등과 같은 스토리지 엔진에도 아래 내용이 똑같이 작동함



### 잠금 획득

**읽기잠금**

- 테이블에 쓰기 잠금이 걸려있지 않으면 바로 읽기 잠금을 획득하고 읽기 작업 시작 가능

**쓰기 잠금**

- 테이블에 아무런 잠금이 걸려있지 않아야만 쓰기 잠금 가능
- 다른 잠금이 해제될 때까지 대기



### 잠금 튜닝

- SHOW STATUS LIKE 'Table%'

```
Table_locks_immediate	12428
Table_locks_waited	0
Table_open_cache_hits	1
Table_open_cache_misses	0
Table_open_cache_overflows	0
```

- Table_locks_immediate: 다른 잠금이 풀리기를 기다리지 않고 바로 잠금을 획득한 횟수
- Table_locks_waited: 다른 잠금이 이미 해당 테이블을 사용하고 있어서 기다려야 했던 횟수를 누적해서 저장함
- 잠금 대기 쿼리 비율 = Table_locks_waited / (Table_locks_waited + Table_locks_immediate) * 100
- 잠금 대기 쿼리 비율이 높다면 innodb로 변환 방법을 고려하는게 좋음
- innodb는 레코드 락

### 테이블 수준의 잠금 확인 및 해제

- SHOW OPEN TABLES [FROM table_name];
- in_use값은 해당 테이블을 잠그고 있는 클라이언트 수 + 대기하는 클라이언트 수
- name_locked는 alter table 또는 rename
- SHOW PROCESSLIST 명령으로 실시간 잠금 현황 확인 가능
- KILL QUERY 클라이언트_id 로 클라이언트 커넥션 종료 가능



## InnoDB 스토리지 엔진의 잠금

- mysql 엔진에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 락 기능을 탑재
- myisam보다 훨씬 뛰어난 동시성 처리 제공 가능
- 이원화된 잠금 처리탓에 innodb 스토리지 엔진에서 사용되는 잠금에 대한 정보는 mysql 명령을 이용해 접근하기가 상당히 까다로움
- 5.1 이후부터 innodb의 트랜잭션,잠금, 잠김 대기중인 트랜잭션 목록 조회하는 방법이 도입됨

### InnoDB의 잠금 방식

**비관적 잠금**

- 현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식을 비관적 잠금이라함
- 일반적으로 높은 동시성 처리에는 비관적 잠금이 유리하다고 알려져 있음 innodb는 비관적 잠금



**낙관적 잠금**

- 기본적으로 각 트랜잭션이 같은 레코드를 변경할 가능성이 상당히 희박할때 낙관적 잠금이라함
- 따라서 우선 변경 이후 마지막에 잠금 충돌이 있는지 확인 후 rollback함

### innodb 의 잠금 종류

- 잠금 정보가 상당히 작기때문에 레코드락이 페이지락 또는 테이블락으로 레벨업되는 경우가 없음
- 레코드와 레코드 사이의 간격을 잠그는 것을 갭락이라고 함

**레코드 락**

- 레코드 자체만 잠그는 것을 레코드락
- innodb 스토리지 엔진은 레코드 자체가 아니라 인덱스 레코드를 잠근다는 것
- 없더라도 클러스터 인덱스를 이용해 잠금



**갭 락**

- 갭락은 레코드와 바로 인접한 레코드 사이의 간격만 잠그는 것을 의미
- 갭락은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어함
- 개념일뿐이고 자체적으로 사용되지 않음 넥스트 키 락의 일부로 사용

**넥스트 키 락**

- 레코드 락과 갭 락을 합쳐놓은 형태의 잠금을 넥스트 키 락이라고함
- statement 포맷의 바이너리 로그를 사용하는 mysql 서버에는 repeatable read 격리수준을 사용해야함
- innodb의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어 난 결과와 동일한 결과를 만들어내보도록 보장하는 것이 주 목적임
- 으외로 넥스트 키락과 갭락으로 인한 데드락이 발생하거나 트랜잭션 대기가 자주 있으
- 가능하다면 바이너리 로그 포맷을 row형태로 바꿔서 넥스트 키락이나 갭락을 줄이는 것이 좋음 <- 아직 안정성을 확인하기 어려움



**자동 증가 락**

- auto_increment락이라고 하는 테이블 수준의 잠금을 사용함
- 이 락은 트랜잭션과 관계없이 값을 가져오는 순간만 락이 걸렸다가 즉시 해제됨
- 명시적으로 락 획득 불가
- 아주 짧게 적용되기때문에 문제될일 없음
- 5.1이후에 innodb_autoinc_lock_mode로 작동 방식을 제어 가능 함



### 인덱스와 잠금

- innodb의 잠금과 인덱스는 상당히 중요한 연관관계가 있음
- innodb는 레코드를 잠그는 것이 아니라 인덱스를 잠금
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 함
- 인덱스가 걸린 레코드는 모두 잠금
- 만약 인덱스가 없다면 모든 레코드를 잠금
- 따라서 innodb에서 인덱스 설계가 매우 중요함



### 트랜잭션 격리 수준과 잠금

- 불필요한 레코드의 잠금 현상은 innodb의 넥스트 키 락 때문에 발생함
- 이 넥스트 키 락을 필요하게 만드는 주 원인은 바로 복제를 위한 바이너리 로그 때문임
- row based 로그를 사용하거나 바이너리 로그를 사용하지 않으면 갭락이나 넥스트 키 락의 사용을 대폭 줄이므로 더 많은 요청을 처리할 수 있게 됨
- 다음 조합으로 mysql 서버가 기동하는 경우에 innodb에서 사용되는 대부분의 갭락이나 넥스트키락을 제거 가능

| 버전           | 설정의 조합                                                  |
| -------------- | ------------------------------------------------------------ |
| mysql 5.0      | innodb_locks_unsafe_for_binlog=1<br /> 트랜잭션 격리 수준을 read commited로 설정 |
| mysql 5.1 이상 | 바이너리 로그를 비활성화 트랜잭션 격리수준을 read-commited로 설정<br />레코드 기반의 바이너리 로그 사용<br />innodb_locks_unsafe_for_binlog=1<br />트랜잭션 격리 수준을 read-commited로 설정 |

- 이 조합이라도 유니크키나 외래키에 대한 갭 락은 없어지지 않음



### 레코드 수준의 잠금 확인 및 해제

- 테이블락보다 레코드락이 더 복잡함
- 5.0에서는 더힘들고 5.1부터는 확인이 좀 더 수월함
- 5.0에서는 공통적으로 특정 테이블의 레코드를 변경하거나 삭제하려고 하는 쿼리가 표시되는 것이 일반적, 구 중에서 활성화상태면서 아무런 sql도 실행하지 않는 트랜잭션이 있다면 이것이 문제일 가능성이 높음
- 근본적으로 찾기 어렵다면 오래기다리고 있는 트랜잭션의 커넥션을 모두 종료하는게 빠른 해결책
- 5.1 이상에서는 INFORMATION_SCHEMA라는 DB에 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAIT라는 테이블을 사용할 것
- INNODB_LOCKS는 어떤 잠금이 존재하는지 관리, INNODB_TRX는 어떤 트랜잭션이 어떤 클라이언트에 의해 기동되며 어떤 잠금을 기다리고 있는지, INNODB_LOCK_WAITS 테이블은 잠금에 의한 프로세스 간의 의존 관계를 관리하게됨



## mysql의 격리 수준

- read uncommited, read commited, repeatable read, rerializable 4가지로 나뉨
- read uncommited, serializable 은 잘 사용되지 않음
- innodb에서 repeatable read 격리수준에서는 phantom read가 발생하지 않음
- 오라클은 read commited, mysql에는 repeatable read를 주로 사용함

### READ UNCOMMITED

- DIRTY READ, 정말 위험할 수 있음 사용하지 말 것

### READ COMMITED

-  오라클의 기본 격리 수준, 온라인 서비스에서 가장 많이 선택되는 격리 수준
- 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있음
- NOT REPEATABLE READ가 발생함

### REPEATABLE READ

- mysql innodb 엔진에서 기본적으로 사용, 바이너리 로그를 가진 mysql 장비에서는 최소 repeatable read 수준 이상을 사용해야함
- mvcc를 사용함 rollback 가능성을 대비해 레코드를 언두 공간에 백업해두고 실제 레코드 변경
- 어떤 트랜잭션 A와 B가 있다고 가정했을때 A 또는 B 에서 시작된 트랜잭션은 항상 같은값만 반환함
- PHANTOM READ가 발생함

### SERIALIZABLE

- 이 레벨의 경우 읽기 작업도 공유잠금을 획득해야하는 매우 엄격한 격리 수준
- mysql innodb에서는 repeatable read에서 phantom read가 발생하지 않으므로 쓸일이 없음



- 사실 READ COMMITED와 REPEATABLE READ의 성능차이는 크지 않음



# #5 인덱스

## 디스크 읽기 방식

- 데이터베이스의 성능 튜닝은 어떻게 디스크 io를 줄이느냐가 관건인것이 많음

### 저장 매체

- 일반적인 서버에 사용되는 저장 매체
  - 내장디스크
  - DAS (Direct Attached Storage)
  - NAS (Network Attached Storage)
  - SAN (Storage Area Network)
- 내장디스크는 일반적인 pc의 디스크, 용량 문제가 있음
- DAS도 내장디스크와 비슷함 대용량 디스크가 필요할때 사용가능, 본체 한대와만 연결이 가능해서 디스크 정보를 다른 컴퓨터와 공유 불가능
- DAS의 단점을 NAS와 SAN으로 해결 가능
- NAS는 TCP/IP로 연결해서 공유 가능함, DAS보다 느림
- SAN은 DAS로는 구축할 수 없는 아주 대용량의 스토리지 공간을 제공함. 컴퓨터 본체들과 광케이블로 연결되고 빠르고 안정적, 비쌈

### 디스크 드라이브와 솔리드 스테이트 드라이브

- ssd의 장점은 랜덤 io가 훨씬 빠르다는 것

### 랜덤 io와 순차 io

- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하느냐에 의해 결정됨
- 순차 io가 랜덤 io보다 빠름
- 데이터베이스의 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 mysql 서버에서는 그룹 커밋이나 버이너리 로그 버퍼 또는 inndb 로그 버퍼 기능이 내장된 것

> - 인덱스 레인지 스캔은 랜덤 io
> - 풀 테이블 스캔은 순차 io



## 인덱스란?

- 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어둠
- 키를 기반으로 정렬시켜놓아서 빠르게 찾을 수 있게 해둠
- 인덱스는 항상 정렬된 상태로 유지함
- 인덱스가 많은 테이블은 insert, update delete 문장의 처리가 늦어짐 하지만 select는 매우 빠름
- 인덱스를 구분해본다면 primary key와 secondary key가 있음
- 프라이머리키는 대표적으로 그 테이블을 대표하는 컬럼의 값으로 만들어진 인덱스고 프라이머리 키를 제외한 모든 인덱스는 보조인덱스임
- 데이터 저장방식은 대표적으로 b-tree hash 인덱스로 구분할 수 있음
- hash 방식은 값의 일부만 검색할 수 없음, 메모리기 반 db에서 많이 사용함
- Fractal-tree 알고리즘도 있는데 b-tree랑 비슷하지만 데이터 저장 삭제시 처리 비용을 상당히줄일 수 있게 설계된 것이 특징임
- 데이터 중복 허용 여부로 분류하면 유니크 인덱스와 유니크하지 인덱스로 구분 할 수 있음
- dbms의 옵티마이저에게 중복 여부는 상당히 중요함 유니크인덱스에 대해 equal 으로 검색하면 1건의 레코드만 찾으면 더이상 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효고임
- 기능별로 분류하면 전문 검색이나 공간 검색용 인덱스 등이 있음



## B-Tree 인덱스

- Balanced Tree
- b-tree는 최상위에 하나의 루트노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태
- 루트, 브랜치, 리프노드 순서로 되어있음
- b-tree에서 바라보는 파일시스템들은 정렬된 상태가아님 but 클러스터 인덱스는 pk 순서대로 정렬된 상태
- 인덱스는 테이블의 키 칼럼만 갖고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야함



### B-tree 인덱스 키 추가 및 삭제

**인덱스 키 추가**

- b-tree에 저장될 때는 저장될 키 값을 이용해 b-tree 상의 적절한 위치를 검색해야함
- 리프노드가 꽉 찼을때는 상위 브랜치노드까지 영향을 주는데 이러한 작업이 b-tree에서 쓰는 비용이 많다고 알려짐
- 비용들 대부분은 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야하기때문에 오래걸리는것
- myisam이나 memory 스토리지엔진은 insert 즉시 b-tree 인덱스에 반영하고 작업완료까지 클라이언트는 기다림
- innodb는 상황에따라 적절하게 인덱스 키 추가 작업을 지연시켜 나중에 처리할지 아니면 바로 처리할지 결정함
  1. 사용자의 쿼리 실행
  2. innodb의 버퍼 풀에 새로운 키 값을 추가해야 할 페이지가 존재(b-tree의 리프노드)한다면 즉시 키 추가 작업 처리
  3. 버퍼 풀에 b-tree 리프 노드가 없다면 인서트 버퍼에 추가할 키 값과 레코드의 주소를 임시로 기록해두고 작업 완료
  4. 백그라운드 작업으로 인덱스 페이지를 읽을 때마다 인서트 버퍼에 머지해야 할 인덱스 키 값이 있는지 확인한 후 있다면 병합
  5. db 서버 자원의 여유가 생기면 mysql 서버의 인서트 버퍼 머지 스레드가 조금씩 인서트 버퍼에 임시 저장된 인덱스 키오 ㅏ주소 값을 머지
- 5.1 이하에서는 insert만 지연처리 5.5 이사엥서는 insert delete 둘다 됨
- 5.1 이하에서는 인서트 버퍼링, 5.5이상에서는 체인지 버퍼링



**인덱스 키 삭제**

- b-tree는 키 삭제가 상당히 간단함 리프노드를 찾아서 삭제만 마크하면 작업 완료

**인덱스 키 변경**

- b-tree에서는 키 값 변경 작업은 먼저 키값을 삭제한 후 다시 새로운 키값을 추가하는 형태



**인덱스 키 검색**

- b-tree인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용 가능, 부등호 비교나 값의 뒷부분이 일치하는 경우에는 b-tree인덱스를 이용한 검색이 불가능함
- 이미 변형된 값 (함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업)은 b-tree의 장점을 이용할 수 없음
- innodb테이블에서 지원하는 레코드 잠금이나 넥스트 키 락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 되어있음 따라서 update나 delete 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠금



### b-tree 인덱스 사용에 영향을 미치는 요소

**인덱스 키값의 크기**

- innodb에서 디스크의 모든 읽기 쓰기 작업의 최소단위는 페이지 또는 블록이라고 함 또한 페이지는 innodb 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위임
- 인덱스도 결국 페이지 단위로 관리됨
- 인덱스의 페이지 크기와 키 값의 크기에 따라 자식노드의 개수가 결정됨
- 결론적으로 키 값의 크기가 커질수록 효율이 떨어짐

**B-tree 깊이**

- 깊이는 상당히 중요하지만 직접적으로 제어할 방법이 없음
- 결론적으로 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 잇는 인덱스 키값의 개수가 작아지고 그 때문에 같은 레코드 건수라 하더라도 b-tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게된다는 것을 의미함
- 인덱스의 키값의 크기는 가능하면 작은게 좋고 아무리 대용량 데이터베이스라도 깊이가 4~5이상까지 깊어지는경우는 거의 발생하지 않음

**선택도(기수성)**

- 인덱스에서 선택도 = 기수성임 카디널리티
- 전체인덱스 키값은 100개인데 유니크한 값의 수는 10개라면 기수성은 10임 
- 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리함
- 인덱스의 선택도가 높을수록 미리 걸러지는 레코드의 수가 많아짐



**읽어야 하는 레코드의 건수**

- 인덱스를 통해 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이드는 작업임
- 인데스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는것보다 4~5배정도 비용이 많이든다고 예측함
- 전체테이블의 20~25를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는 방식으로 처리하는게 좋음



### B-tree 인덱스를 통한 데이터 읽기

- mysql이 인덱스를 이용하는 대표적인 방법

**인덱스 레인지 스캔**

- 가장 대표적인 접근 방식
- 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현함
- 루트 -> 브랜치 -> 리프로 한번 전체 스캔하고 range를 정하고 range에서의 데이터를 클라이언트에게 반환함
- 별도의 정렬과정 없이 인덱스 자체의 정렬 특성때문에 정순 또는 역순으로 레코드를 불러옴
- 검색결과가 많으면 풀스캔이 나음



**인덱스 풀 스캔**

- 인덱스의 처으부터 끝까지 모두 읽는 방식
- 대표적으로 쿼리의 조거넞ㄹ에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용됨
- 예를들어 인덱스는 a,b,c 순서로 만들어졌지만 쿼리 조건절은 b, c 로시작하는 경우
- 쿼리가 인덱스에 명시된 컬럼만 조건을 처리할 수 있는 경우 이방식으로 사용되고 다른 레코드를 읽어야 한다면 절대 이방식으로 처리되지 않음
- 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 뒤 처음부터 끝까지 스캔함
- 인덱스 레인지 스캔 > 인덱스 풀 스캔 > 테이블 풀 스캔으로 검색속도가 빠른정도

**루스 인덱스 스캔**

- 오라클에 인덱스 스킵 스캔이랑 비슷함
- 루스 인덱스 스캔은 느슨하게 또는 듬성듬성하게 인덱스를 읽음
- 인덱스 레인지 스캔과 비슷하지만 필요하지 않은 인덱스 키값은 무시하고 다음으로 넘어가는 형태로 처리
- 일반적으로 group by 또는 집합 함수 가운데 max() min()함수에 대해 최적화를 하는 경우에 사용



### 다중 칼럼 인덱스

- 실무에서는 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용됨
- 다중컬럼인덱스의 순서에 따라 정렬 순서도 바뀌기때문에 다중컬럼인덱스의 순서는 매우 중요하고 상당이 신중하게 결정해야함



### B-tree 인덱스의 정렬 및 스캔 방향

- 인덱스 키값은 항상 오름차순으로 정렬되지만 역순으로도 사용될 수 있음

**인덱스의 정렬**

- 일반적인 dbms는 asc, desc 설정이 가능하지만 mysql에서는 컬럼마다 asc, desc 별개로 적용은 안됨
- mysql에선 지정한다고 하더라도 전부 무시하고 오름차순으로만 정렬됨
- 아직까지는 방법이 없으므로 order by 에 따라 역순으로 정렬하게 해야할 수 있음
- 예를들면 order by user_name asc, user_score desc일때 user_score를 음수값으로?



**인덱스 스캔 방향**

- 인덱스를 역순으로 정렬할 순 없지만 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순정렬 효과를 얻을 수 있음



### B-Tree 인덱스의 가용성과 효율성

- 쿼리의 where, group by, order by 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 알아야함



**비교 조건의 종류와 효율성**

- = < 또는 > 에 따라 인덱스 컬럼의 활용 형태가 달라짐
- 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 필터링이라고함
- 작업 범위 결정 조건은 실제 값을 읽어오는 작업이고 작업의 범위를 줄이지 못하고 필터링하는 작업을 필터링 조건이라고함 작업 범위 결정 조건이 많을수록 쿼리 처리 능력을 높일 수 있음



**인덱스의 가용성**

- b-tree 인덱스의 특징은 왼쪽 값에 기분에서 오른쪽 값이 정렬되어 있다는 것
- like를 '%mer'로 걸면 인덱스 레인지 스캔 방식으로 인덱스를 이용할 수 없음
- 다중 컬럼 인덱스에서 (a, b) 가 있다고 가정할때 b로만 검색해도 인덱스를 효율적으로 사용할 수 없음



**가용성과 효율성 판단**

- 기본적으로 다음 조건들은 b-tree에서 사용할 수 없음 (작업 범위 결정 조건으로 사용 불가, 경우에 따라서는 체크조건으로 사용)
  - NOT-EQUAL로 비교된 경우
    - \<\>
    - NOT IN
    - IS NOT NULL
  - LIKE가 앞부분이 아닌 뒷부분의 형태로 비교된 경우
    - LIKE '%FOO'
  - 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변경된 후 비교된 경우
    - WHERE SUBSTRING ...
    - WHERE DAYOFMONTH ...
  - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
    - WHERE column = deterministic_function()
  - 데이터 타입이 서로 다른 비교 (인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
  - 문자열 데이터 타입의 콜레이션이 다른 경우
    - WHERE utf8_bin_char_column = euckr_bin_char_column



- 다른 일반적인 dbms에서 null 값은 인덱스에 저장되지 않지만 mysql에서는 null값도 인덱스로 관리됨
- WHERE cloumn IS NULL <- 인덱스를 사용함
- 다음은 다중컬럼에서 인덱스를 사용할 수 없는 경우
- INDEX ix_test (column_1, column_2, column_3, ... column_n)이 있다고 가정
  - 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
    - column_1 칼럼에 대한 조건이 없는 경우
    - column_1 칼럼의 비교 조건이 위의 인덱스 사용불가 조건 중 하나인 경우
  - 작업 범위 결정 조건으로 인덱스를 사용하는 경우 (i는 2보다 크고 n보다 작은 임의의 값을 의미)
    - column_1~ column_(i - 1) 칼럼까지 = 로 비교
    - column_i 칼럼에 대해 다음 연산자 중 하나로 비교
      -  = , <> , like 'foo%'
- 참고
  - 다음쿼리는 인덱스 사용 불가
    - where column_1 <> 2
  - 다음 쿼리는 column_1과 column_2까지 범위 결정 조건으로 사용됨
    - where column_1 = 1 and column_2 > 10
  - 다음 쿼리는 column_1, column_2, column_3 까지 범위 결정 조건으로 사용됨
    - where column_1 in (1,2) and column_2 = 2 and column_ <= 10
  - 다음 쿼리는 column_1, column_2, column_3 까지 범위 결정 조건으로, column_4는 체크 조건으로 사용됨
    - where column_1 = 1 and column_2 = 2 and column_3 in (10, 20, 30) and column_4 <> 100
  - 다음 쿼리는 column_1, column_2, column_3, column_4 까지 범위 결정 조건으로 사용됨 좌측 패턴 일치 like 비교는 크다 작다 비교 와 동급으로 생각하면 됨
    - where column_1 = 1 and column_2 in (2,4) and column_3 = 30 and column_4 like ('foo%')
  - 다음 쿼리는 column_1, column_2, column_3, column_4, column_5 칼럼까지 모두 범위 결정 조건으로 사용됨
    - where column_1 = 1 and column_2 = 2 and column_3 = 30 and column_4 = '김승환' and column_5 = '서울'
- 위 쿼리들은 b-tree인덱스의 특징이기때문에 다른 dbms에도 적용될 수 있음





## 해시 인덱스

- 해시 인덱스는 b-tree만큼 범용적이지는 않지만 고유의 특성과 용도를 지닌 인덱스임
- 해시 인덱스는 동등 비교 검색에만 최적화되어있고 범위, 정렬은 불가능
- 주로 메모리기반 테이블에 구현됨



### 구조 및 특성

- 해시 인덱스의 가장 큰 장점은 실제 키 값과는 관계 없이 인덱스 크기가 작고 검색이 빠르다는것
- 해시 장점 그대로 사용함 버킷에서 값을 꺼내옴
- 키 칼럼의 값이 아무리 길어도 4~8 바이트 수준으로 줄어들어듬
- 버킷의 수, 충돌 수에 따라 검색 성능 결정



### 해시 인덱스의 가용성 및 효율성

- 키값 자체가 변환되기때문에 원본데이터의 정렬을 할수 없음
- 다음의 경우 해시인덱스의 성능이 좋음
  - =
  - <>
  - in
  - is null
  - is not null
- 다음의 경우 해시인덱스 사용 불가
  - \>=
  - between
  - like
  - \<\>
- 다중 컬럼 인덱스를 해시인덱스로 만들면 컬럼의 개수만큼 조건을 걸어야됨 한개만걸면 안걸림



## R-Tree 인덱스

- 공간인덱스는 r-tree 인덱스 알고리즘을 사용해서 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스
- b-tree와 흡사 b-tree는 1차원 r-tree는 2차원
- 위치기반 서비스에 사용 가능



### 구조 및 특성

- mysql은 공간 정보의 저장 및 검색을 위해 여러가지 기하학적 도형(geometry) 정보를 관리할 수 있는 데이터 타입을 제공함
- point , line, polygon ?(3개의 수퍼타입 모두 저장 가능)
- mbr이라는 개념을 알고 있어야함 Minimum Bounding Rectagle의 약자고 해당 도형을 감싸는 최소 크기의 사각형을 의미함



## Fractal-Tree 인덱스

### Fractal-Tree의 특성

- b-tree의 가장 큰 문제는 디스크 랜덤 io가 상대적으로 많이 필요하다는 것
- fractal-tree는 이런 단점을 최소화하고 순차 io로 변환해서 처리할 수 있다는 것이 가장 큰 특징
- 인덱스 추가 삭제에 b-tree보다 더 많은 정렬과 리소스를 사용할지모르지만 인덱스의 단편화가 발생하지 않도록 구성할 수 있고 인덱스 키값을 클러스터링하기 때문에 b-tree 보다 대용량 테이블에서 높은 성능을 보장함 또한 b-tree는 일정 수준을 넘어서면 급격한 성능저하가 발생하는데 fractal-tree는 이런 급격한 성능 저하 현상이 없음



### fractal-tree의 가용성과 효율성

- 가장 큰 장점은 b-tree의 장점을 그대로 갖고 있다는것 b-tree의 인덱스 사용 방법 등등 ..



## 전문 검색 인덱스

- full text 검색에는 b-tree를 사용할 수 없음 키를 짤라서 저장하기 때문에
- 전문 검색 인덱스에서는 크게 구분자, n-그램으로 나눠서 생각할 수 있음



### 인덱스 알고리즘

**구분자 기법**

- 전문의 내용을 공백이나 탭 또는 마침표와 같은 문장기호로 분석하고 인덱스로 생성해둠
- 구분가 기법은 키워를 추출해 내는 작업이 추가로 필요할 뿐이고 b-tree를 그대로 사용함

**n-그램 기법**

- 무조건적으로 몇 글자씩 잘라서 인덱싱함
- 구분자 기법보다 복잡하고 인덱스 크기도 큰 편
- 2개씩 잘라서 하는 방법이 2-gram이고 많이 사용됨



## 비트맵 인덱스와 함수 기반 인덱스

- mysql 스토리지 엔진에서 비트맵 인덱스와 함수 기반 인덱스를 지원하는 스토리지 엔진은 없음
- 우회하는 방법은 있음

## 클러스터링 인덱스

- innodb와 tokudb에만 지원됨주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것

### 클러스터링 인덱스

- 클러스터링 인덱스는 프라이머리 키에만 적용되는 내용임
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라함
- 일반적으로 innodb와 같이 항상 클러스터링 인덱스로 저장되는 테이블의 프라이머리 키 값 기반 검색은 매우 빠르고 저장이나 변경이 상대적으로 느릴 수 밖에 없음
- 클러스터링 테이블의 구조 자체는 일반 b-tree와 많이 비슷한데 인덱스의 리프노드에는 레코드의 모든 컬럼이 저장되어 있는게 특징
- 즉 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되는것
- pk가 없는 innodb 테이블은 다음 우선순위대로 pk를 대체할 칼럼을 선택함
  1. pk가 있으면 기본적으로 pk 사용
  2. not null 옵션의 유니크 인덱스 중에서 첫번째 인덱스를 클러스터 키로 선택
  3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후 클러스터 키로 선택



**보조 인덱스에 미치는 영향**

- myisam이나 memory 테이블과 같이 넌 클러스터링 테이블은 한번 저정되면 공간이동이 절대 없음
- 그래서 myisam이나 memory 에선 pk나 보조인덱스나 별 차이가 없음
- innodb 테이블의 모든 보조 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어있음

```
CREATE TABLE employees (
	emp_no INT NOT NULL,
	first_name VARCHAR(20) NOT NULL,
	PRIMARY KEY(emp_no),
	INDEX ix_firstname (first_name)
);

SELECT * FROM employees WHERE first_name='Aamer';
```

- 다음의 경우에 엔진마다 검색이 조금 다름
  - myisam
    - ix_firstname 인덱스를 검색해서 실제 레코드를 검색, 레코드의 주소를 이용해서 최종 레코드를 가져옴
  - innodb
    - ix_firstname 인덱스를 검색해 레코드의 프라이머리 키 값 확인
    - pk값을 이용해 다시한번 테이블을 검색한 후 최종 레코드를 가져옴
- 위 경우 innodb가 조금 복잡하지만 pk로 레코드를 읽어오는게 상당히 빠르므로 걱정 x



### 클러스터 인덱스의 장점과 단점

- 장점

  - pk로 검색할때 처리 성능이 매우 빠름, 범위검색이 제일빠름
  - 테이블의 모든 보조 인덱스가 pk를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음

- 단점

  - 테이블의 모든 보조 인덱스가 클러스터 키를 갖기 때문에 클러스터 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
  - 보조 인덱스를 통해 검색할 때 프라이머리 키로 다시한번 검색해야 하므로 처리 성능이 조금 느림
  - insert 할때 pk 에 의해 레코드 저장 위치가 결정되기때문에 처리 성능이 느림
  - pk를 변경할때 delete , insert가 있기때문에 처리 성능이 느림

  

  

  

### 클러스터 테이블 사용시 주의사항

**클러스터 인덱스 키의 크기**

- 클러스터 테이블의 경우 모든 보조 인덱스가 프라이머리 키 값을 포함함 그래서 pk 값 크기가 커지면 보조 인덱스도 자동으로 커짐
- 레코드수가 기하급수적으로 증가하기때문에 innodb에서는 pk를 잘 정해야함

**pk는 auto-increment보다는 업무적인 컬럼으로 생성할 것 (가능한 경우)**

- innodb는 pk를 사용해 클러스터 테이블을 구성함
- 컬럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 크 컬럼을 pk로 설정하는 것이 좋음

**pk는 반드시 명시할 것**

- 가능하면 auto-increment 컬럼을 이용해서라도 지정하는게 좋음
- 아무것도 생성하지 않으면 innodb에서 사용자에게 보이지 않는 auto-increment를 생성하기때문에(but sql에서는 사용못함) 하나 안하나 똑같으니 하는게 나음

**auto-increment 컬럼을 인조 식별자로 사용할 경우**

- pk 를 여러개로 묶을때 pk 키가 커질 수 있음 but 보조인덱스를 사용하지 않으면 괜찮음
- 보조인덱스를 사용하면 auto-increment + 보조인덱스로 사용할 것
- 이런 auto-increment 컬럼을 인조 식별자 surrogate key라고함
- 조회보다는 insert 위주의 테이블들은 auto-increment를 이용한 인조 식별자를 pk로 설정하는 것이 좋음



## 유니크 인덱스

- 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미하는데 mysql에서는 인덱스 없이 유니크 제약만 설정할 방법이 없음



### 유니크 인덱스와 일반 보조 인덱스의 비교

- 유니크인덱스와 보조인덱스는 인덱스 구조상 아무런 차이가 없음

**인덱스 읽기**

- 읽는 속도에서 별 차이가 없음
- 하나의 값을 검색하는 경우 유니크 인덱스와 보조 인덱스는 사요되는 실행 계획이 다름
- 2개 이상의 레코드를 읽느냐의 차이만 있다는 것을 의미할 뿐 일겅야 할 레코드 건수가 같다면 성능상의 차이는 미미함

**인덱스 쓰기**

- 유니크 인덱스의 키값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한단계 더 필요함
- 일반 보조인덱스의 쓰기보다 느림
- mysql에서는 유니크 인덱스에서 중복값을 체크할때 읽기잠금, 쓰기잠금을 쓰는데 이 과정에서 데드락이 아주 빈번하게 발생함



### 유니크 인덱스 사용 시 주의사항

- 꼭 필요하면 사용하고 성능을 생각하면 생성하지 않는게 좋음
- 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하기 때문에 중복생성이 필요 없음



## 외래키

- mysql 왜래키는 innodb에서만 가능
- 외래키가 설정되면 연관되는 테이블 칼럼에 인덱스까지 생성됨
- innodb의 외래키 관리에는 중요한 두가지 특성
  - 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금대기)이 발생함
  - 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않음

### 자식 테이블의 변경이 대기하는 경우

- 자식 테이블의 외래키 칼럼의 변경은 부모 테이블의 확인이 필요한데 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다림
- 자식테이블의 외래키가 아닌 칼럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않음

### 부모 테이블의 변경 작업이 대기하는 경우

- 자식에서 먼저 로우락을 얻고 부모에서 cascade delete 제약의 자식 로우와 연관된 부모를 지우면 잠금됨
- 외래키를 물리적으로 생성하려면 이러한 현상으로 인한 잠금 경합까지 고려해 개발을 진행하는 것이 좋음



## 기타 주의사항

**스토리지 엔진별 지원 인덱스 목록**

- myisam: b-tree, r-tree, fulltext-index
- innodb: b-tree
- memory: b-tree, hash
- tokudb, factal-tree
- ndb: hash, b-tree

**analyze와 optimize의 필요성**

- myisam이나 innodb의 경우 인덱스에 대한 통계 정보를 관리하고 각 통계 정보를 기반으로 쿼리의 실행계획을 수립함
- innodb와 myisam 모두 칼럼의 cardinality에 의존해서 실행 계획을 수립함
- 쿼리의 실행계획이 의도했던 것과는 너무 다르게 만들어 질 때는 인덱스의 통계 정보가 실제와 너무 다르게 수집될 경우에 그럼 이 경우 analyze 명령으로 통계 정보를 다시 수집해보는 것이 좋음
  - 테이블의 데이터가 별로 없는 경우
  - 단시간에 대량의 데이터가 늘어나거나 줄어든 경우





# #6 실행 계획

## 개요

### 쿼리 실행 절차

- mysql 서버에서 쿼리가 실행되는 과정 3가지
  1. 사용자로부터 요청된 sql 문장을 잘게 쪼개서 mysql 서버가 이해할 수 있는 수준으로 분리함
  2. sql의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택
  3. 두번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴
- 첫번째 단계를 sql 파싱이라고하고 mysql 서버의 sql 파서라는 모듈로 처리함 만약 sql 문장이 문법적으로 잘못되었다면 여기서 걸러짐, 이 단계에서 sql 파스 트리가 만들어지고 sql 서버는 파스 트리를 이용해 쿼리를 실행
- 두번째 단계에서는 다음 내용 처리
  - 불필요한 조건의 제거 및 복잡한 연산의 단순화
  - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
  - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
  - 가져온 레코드들은 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
- 두번째 단계는 최적화 및 실행 계획 수립단계고 mysql 옵티마이저에서 처리함
- 세번째 단계는 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고 mysql 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행함
- 첫번째 두번째 단계는 거의 mysql 엔진에서 처리하며 세번째 단계는 mysql 엔진과 스토리지 엔진이 동시에 참여해서 처리함



### 옵티마이저의 종류

- 옵티마이저는 db에서 두뇌와 같은 역할을 담당
- 대부분의 dbms는 비용 기반 최적화 방법과 예전 오라클에서 많이 사용했던 기반 최적화 방법으로 크게 나눠볼 수 있음
- 규칙 기반 최적화
  - 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
  - 통계정보를 조사하지 않고 실행 계획이 수립되기 때문에 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어냄
  - 거의 안쓰고 업데이트도 안됨 지원도 잘 안됨
- 비용 기반 최적화
  - 쿼리를 처리하기 위해 여러 가지 가능한 방법을 만들고 각 단위 작업의 비용 정보와 테이블의 예측된 통계 정보를 이용해 각 실행 계획별 비용을 산출함 이렇게 산촐된 각 실행 방법별로 최소 비용이 소요되는 처리 방식을 선택해 최종 쿼리를 실행함
- mysql은 비용 기반 최적화



### 통계 정보

- 비용 기반 최적화에서 가장 중요한 것은 통계 정보임
- 기본적으로 mysql에서 관리되는 통계 정보는 대략 레코드 건수와 인덱스의 유니쿠한 값의 개수
- 통계정보가 부족하면 analyze 명령으로 강제 갱신
- 서비스 실행도중 analzye 실행은 안하는게 좋음 innodb의 경우 읽기 쓰기 모두 불가



## 실행 계획 분석

- mysql 쿼리 실행 계획 확인은 explain 명령을 사용하면 됨
- explain extended나 explain partitions 명령을 이용해 더 상세한 실행 계획을 확인할 수도 있음
- explain select ... 를 실행하면 나오는 로우 수는 쿼리에 사용된 테이블의 수만큼 나옴 (서브쿼리로 인한 테이블 포함)
- update, insert, delete의 경우 where절을 기반으로 대략적인 계획을 확인 가능함



### id 칼럼

- 실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 단위 select 쿼리별로 부여되는 식별자 값임
- 만약 하나의 같은 select 문장 안에서 여러 개의 테이블을 조인하면 조인되는 테이블의 개수만큼 실행 계획 레코드가 출력되지만 같은 id를 가짐, 서브쿼리는 다른 id select가 두번이여서



### select_type 컬럼

**SIMPLE**

- UNION이나 서브쿠리를 사용하지 않는 단순한 SELECT일 경우
- 쿼리 문장이 아무리 복잡해도 SIMPLE인 단위쿼리는 반드시 하나만 존재함
- 일반적으로 제일 바깥



**PRIMARY**

- UNION이나 서브쿼리가 포함된 SELECT 쿼리의 실행계획에서 가장 바깥에 있는 단위쿼리
- 한개만 있음



**UNION**

- 































































