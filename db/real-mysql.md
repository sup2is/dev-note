# #1 소개



# #2 설치와 설정





# #3 MySQL 아키텍처



## MySQL 아키텍처



![](https://t1.daumcdn.net/cfile/tistory/26219B435902D88522)

### mysql 전체구조

- mysql은 일반 상용 rdbms에서 제공하는 대부분의 접근법을 모두 지원함

- mysql 서버는 크게 mysql 엔진, 스토리지 엔진으로 구분해볼 수 있음

**mysql 엔진**

- mysql 엔진은 클라이언트로부터의 접속 및 쿼리요청을 처리하는 커넥션 핸들러와 sql 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심

**스토리지 엔진**

-  실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 스토리지 엔진이 전담, mysql 엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용 가능

**핸들러 api**

- mysql 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에게 쓰기 또는 읽기 요청을 하는데 이러한 요청을 핸들러 요청이라고하고 여기에 사용되는 api를 핸들러 api라함
  

### mysql 스레딩 구조

- mysql 서버는 프로세스기반이 아니라 스레드 기반으로 작동함 크게 포그라운드와 백그라운드 스레드로 구분

**포그라운드 스레드(클라이언트 스레드)**

- mysql 서버에 접속된 클라이어트의 수 만큼 존재
- 요청하는 쿼리 문장을 처리하는 것이 임무
- 요청 종료시 다시 스레드 캐시 (thread pool)로 돌아감
- 스레드의 개수를 일정하게 유지해주는 파라미터 thread_cache_size

**백그라운드 스레드**

- innoDB는 여러가지 작업이 백그라운드로 처리 여러가지 작업을 함
- 쓰기 스레드는 innodb_write_io_threads, 읽기 스레드는 innodb_read_io_treads로 지정 가능
- 읽기스레드는 클라이언트 스레드에서 처리되는데 쓰기의 경우 일반 내장 디스크에서는 2~4, ans,san과같은 스토리지를 사용할 경우 4개 이상으로 충분히 설정하는게 좋음

<br>

- 상용 dbms에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 있고 innodb도 그러함 but myisam은 그렇지 않고 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계되어 있음
- innodb에서는 cud 쿼리로 데이터가 변경되는 경우 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 됨 . 하지만 myisam에서 일반적인 쿼리는 쓰기 버퍼링을 사용할 수 없음



### 메모리 할당 및 사용 구조

- mysql에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분 가능
- 글로벌 메모리 영역의 모든 메모리 공간은 mysql 서버가 시작되면서 무조건 운영체제로부터 할당됨 
- 글로벌 메모리 영역과 로컬 메모리 영역의 차이는 mysql 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 아닌지에 따라 구분됨

**글로벌 메모리 영역**

- 일반적으로 클라이언트 스레드의 수와 무관하게 일반적으로는 하나의 메모리 공강만 할당, 필요에 따라 2개 이상의 메모리 공간을 할당받을 수 있지만 클라이언트 스레드의 수와 무관하고 생성된 글로벌영역은 모든 스레드의 의해 공유됨

**로컬 메모리 영역**

- 세션 메모리 영역이라도 불림
- mysql 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용되는 메모리 영역
- 로컬 메모리는 각 클라이언트 스레드 별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징

### 플러그인 스토리지 엔진 모델

- mysql 독특한 구조중 하나가 바로 플러그인 모델, 직접 제작도 가능함
- sql 파서 -> sql 옵티마이저 -> sql 실행기 -> 데이터 읽기/ 쓰기 -> DB
- 위 과정에서 마지막 데이터 읽기/쓰기 과정만 스토리지 엔진에 의해 처리됨 나머지는 mysql  엔진에서 처리
- 데이터 읽기/쓰기 작업은 대부분 1건의 레크도 단위로 처리됨
- mysql 서버에서는 mysql 엔진이 사람역하을 하고 각 스토리지 엔진은 자동차 역할을 하게 됨. mysql 엔진이 스토리지 엔진을 조정하기 위해 핸들러 라는것을 사용함
- mysql 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 핸들러를 사용한다는 점만 기억하면 됨
- 실질적인 group by oder by 등 많은 복잡한 처리는 스토리지 엔진 영역이 아니라 mysql 엔진의 처리 영역인 쿼리 실행기에서 실행됨

![](https://www.dbrnd.com/wp-content/uploads/2016/01/MySQLShowEngines.png)

- 이거말고 조금 더 있음
- 플러그인형식으로 스토리지 엔진을 쉽게 설치 가능함



### 쿼리 실행 구조



**파서**

- 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미
- 쿼리 문장의 기본 문접 오류는 이 과정에서 발견되고 사용자에게 오류 메시지를 전달하게 됨

**전처리기**

- 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인함
- 실제 존재하지 않거나 권한상 사용 불가한 토큰의 경우 이 단계에서 걸러짐

**옵티마이저**

- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 담당
- 매우 중요함

**실행 엔진**

- 옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발에 비유할 수 있음

- 옵티마이저가 group by를 처리하기위해 임시테이블을 사용하기로 결정했다면 다음과 같은 과정

  1. 실행 엔진은 핸들러에게 임시 테이블을 만들라고 요청

  2. 다시 실행 엔진은 where 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청

  3. 읽어온 레코드들을 1번에서 준비한 임시테이블로 저장하라고 다시 핸들러에게 요청

  4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어오라고 핸들러에게 다시 요청

  5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

     즉 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행

**핸들러 (스토리지 엔진)**

- mysql 서버 가장 밑단에서 mysql 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당
- 핸드럴 == 스토리지 엔진
- myisam 테이블을 조장하면 핸들러가 myisam 스토리지엔진 <- 이런식임



### Replication

- 복제는 2대 이상의 mysql 서버가 동일한 데이터를 담도록 실시간으로 동기화 하는 기술
- 쓰기는 마스터 읽기는 슬레이브
- mysql 서버의 복제에서는 마스터는 반드시 1개 슬레이브는 1개 이상으로 구성될 수 있음



**마스터**

- 기술적으로는 mysql의 바이너리 로그가 활성화되면 어떤 mysql 서버든 마스터가 될 수 있음
- 데이터가 생성 및 변경, 삭제되는 주체
- dml,ddl을 바이너리 로그에 기록
- 슬레이브는 변경 내역을 요청하면 바이너리 로그에서 읽어서 슬레이브로 넘김
- 마스터의 프로세스중 "Binlog dump"라는 스레드가 이 일을 전담함 슬레이브 수대로 스레드가 존재



**슬레이브**

- 데이터를 받아올 마스터 장비의 정보를 갖고 있는 경우 슬레이브가 됨
- 슬레이브 서버는 릴레이 로그를 갖고 있음
- 슬레이브는 읽기 전용
- 슬레이브 서버의 i/o 스레드는 마스터 서버에 접속해 변경 내역을 요청하고 받아 온 변경 내역을 릴레이 로그에 기록함
- 슬레이브 서버의 sql 스레드가 릴레이 로그에 기록된 변경 내역을 재실행 함으로 마스터와 동일한 상태로 유지함
- i/o 스레드는 슬레이브에만 있음



**복제시 주의사항**

- 슬레이브는 하나의 마스터만 설정 가능
- 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정
- 슬레이브 서버용 장비는 마스터와 동일한 사양이 적합
- 복제가 불필요한 경우에는 바이너리 로그 중지
- 바이너리 로그와 트랜잭션 격리 수준

> - 5.1에서는 Statement based replcation, Row based replication이 지원됨
> - sql 기반의 복제는 아무리 많은 데이터의 변경을 유발하더라도 sql 문장 하나만 슬레이브로 전달되기때문에 네트워크 트래픽을 많이 유발하지 않음 <- but repeatable-read 이상의 트랜잭션 격리 수준을 사용해야 하고 innodb 테이블에서는 레코드 간의 간격을 잠그는 갭 락이나 넥스트 키락이필요해짐
> - 레코드 기반으로 하면 트래픽이 많아지지만 read-commited 격리수준에도 동작하며 innodb테이블에서 잠금 경합이 줄어듬

### 쿼리 캐시

- mysql에만 있음
- sql 문장을 캐시하는게 아니라 쿼리 결과를 메모리에 캐시해두는 기능
- map과 같은 데이터 구조로 구현되어 있음 키는 sql 쿼리 문장, 값은 실행 결과
- 쿼리 캐시 결과 확인 절차를 가짐
  - 요청된 쿼리 문장이 쿼리 캐시에 존재하는가?
  - 해당 사용자가 그 결과를 볼 수 있는 권한을 갖고 있는가?
  - 트랜잭션 내에서 실행된 쿼리인 경우 가시 범위 내에 있는 결과인가?
  - 호출 시점에 달라 결과가 달라지는 요소가 있는가?
  - 프리페어 스테이트먼트의 경우 변수가 결과에 영향을 미치지 않는가?
  - 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가?
  - 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가?
  - 그 밖에 쿼리 캐시를 사용하지 못하게 만드는 요소가 있는가?
- `show global status` 명령을 이용해 쿼리 캐시의 사용량과 정보를 확인 가능
- Com_select (엔진이 처리)+ Qcache_hits (캐시 hit) = mysql 서버로 요청된 모든 select 문장
- 쿼리 캐시 히트율% = Qcache_hits  / (Qcache_hits + Com_select) * 100
- 쿼리 캐시율이 20% 이상이면 좋다고 이야기하는데 그냥 시기적절하게 잘 사용하는게 중요함
- 쿼리 캐시를 사용하지 않는 설정

```
query_cache_size = 0
query_cache_type = 0
```





## InnoDB 스토리지 엔진 아키텍처

- mysql에서 사용할 수 있는 스토리지 중 거의 유일하게 레코드 기반의 잠금을 제공
- 높은 동시성처리와 안정적, 성능 또한 뛰어남

![public](https://user-images.githubusercontent.com/30790184/98905454-c75d3680-24fe-11eb-8bc6-373681f016ae.jpeg)



### InnoDB 스토리지 엔진의 특성

**프라이머리 키에 의한 클러스터링**

- InnoDB의 모든 테이블은 기본적으로 키를 기준으로 클러스터링 되어 저장됨 이로 인해 pk에 의한 레인지 스캔은 상당히 빠르게 처리됨
- 결과적으로 쿼리의 실행 계획에서 pk는 다른 보조인덱스에 비해 비중이 높음 
- 오라클의 IOT(Index organized table)과 동일한 구조가 InnoDB에서는 일반적인 테이블 구조

**잠금이 필요없는 일관된 읽기 (None-locking consistent read)**

- InnoDB 스토리지엔진은 MVCC(Multi Version Concurrency Control) 이라는 기술을 이용해 락을 걸지 않고 읽기 작업을 수행함
- 락을 걸지 않기 때문에 읽기 작업은 다른 트랜잭션이 가지고 있는 락을 기다리지도 않음 SERIALIZABLE은 제외

**외래 키 지원**

- 외래키는 myisam에서 사용불가 innodb만 가능
- innodb에서 외래키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고 변경 시에 반드시 부모 테이블이나 자식 테이블에 데이터가 있는 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고 그로 인해 데드락이 발생할 때가 많음

**자동 데드락 감지**

- InnoDB는 그래프 기반의 데드락 체크 방식을 사용함. 데드락이 발생함과 동시에 바로 감지되고 감지된 데드락은 관련 트랜잭션 중에서 rollback이 가장 용이한 트랜잭션(복구 작업이 가장 적은 트랜잭션)을 자동적으로 강제 종료해버림
- 데드락 때문에 쿼리가 제한시간에 도달한다거나 슬로우 쿼리로 기록되는 경우가 많지 않음

**자동화된 장애 복구**

- 손실이나 장애로부터 데이터를 보호하기 위한 여러가지 메커니즘이 탑재되어 있음

**오라클 아키텍처 사용**

- innodb는 오라클과 상당히 비슷한 부분이 많음 ex mvcc 기능 등등



### InnoDB 버퍼 풀

- InnoDB에서 가장 핵심적인 부분
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
- 쓰기 작업을 지연시켜 일괄 작업을 처리할 수 있는 버퍼공간
- myisam은 키 캐시가 인덱스의 캐시만을 주로 처리하는데 비해 innodb의 버퍼 풀은 데이터와 인덱스 모두 캐시하고 쓰기 버퍼링의 역할까지 모두 처리함
- innodb의 버퍼 풀은 많은 백그라운드 작업의 기반이 되는 메모리 공간임 따라서 버퍼 풀 크기를 신중하게 설정하는 것이 좋음 (innodb_buffer_pool_size)
- 적절하게 설정해야하고 일반적으로 전체 장착된 물리 메모리의 50~80% 수준에서 버퍼 풀의 메모리 크기를 결정함
- innodb 버퍼 풀은 아직 디스크에 기록되지 않은 변경된 데이터를 갖고 있음 (더티 페이지라 함 )



### undo 로그

- update 문장이나 delete 문장으로 데이터를 변경했을때 변경되기 전의 데이터를 보관하는 곳
- 사용자가 커밋하면 적용된 그대로 유지되고 롤백하면 언두 영역의 백업 데이터를 다시 데이터 파일로 복구함
- 언두 용도
  - 트랜잭션 롤백 대비용
  - 트랜잭션 격리 수준을 유지하면서 높은 동시성을 제공하는데 사용됨



### 인서트 버퍼

- rdbms에서 insert나 update에 데이터 파일을 변경하는 작업 뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요함
- 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 인덱스가 많다면 자원소모가 많음
- innodb는 변경해야할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행함 그렇지 않으면 임시 공간에 저장해두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시킴 이 때 사용하는 임시 메모리 공간을 인서트 버퍼라고함
- 유니크 인덱스는 인서트 버퍼를 사용할 수 없음
- 5.5이전까지는 insert에만 가능했으나 5.5 이후부터는 insert delete인해 키를 추가하거나 삭제하는 작업에도 버퍼링이 될 수 있게 개선
- 5.5 이후부터는 innodb_change_buffering이라는 파라미터로 종류별로 인서트 버퍼를 활성화 가능



### redo 로그 및 로그 버퍼

- 쿼리 문장으로 데이터를 변경하고 커밋하면 dbms는 데이터의 acid 보장을 위해 변경된 내용을 데이터 파일로 기록해야함 <- 상당한부하 작업
- 따라서 대부분 dbms에는 버퍼링을 위한 버퍼풀과 같은 장치가 있지만 이 장치만으로 acid를 보장할수는 없음
- 따라서 이를 위해 변경된 내용을 순차적으로 디스크에 기록하는 로그 파일을 갖고 있는데 이게 리두 로그임
- 리두로그 덕분에 dbms 데이터는 버퍼링을 통해 한꺼번에 디스크에 변경된 내용을 처리할 수 있고 성능 향상을 기대할 수 있게 됨
- 변경작업이 매우 많은 dbms 서버의 경우 이 리두 로그의 기록 작업이 큰 문제가됨 <- 이런 부분을 보완하기 위해 최대한 acid 속성을 보장하는 수준에서 버퍼링함
- 리두 로그 버퍼링에 사용되는 공간이 로그 버퍼임
- 로그 버퍼의 크기는 1~8m수준이 좋고 blob이나 text같은 큰 데이터의 변경이 많으면 더 크게



### MVCC(Multi Version Concurrency Control)

- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 dbms가 제공하는 기능
- 잠금을 사용하지 않는 일관된 읽기를 제공함
- innodb는 언두 로그를 이용해 이기능을 구현함
- 멀티 버전은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미



### 잠금 없는 일관된 읽기(Non-locking consistent read)

- innodb에서 격리수준이 serializable이 아닌 read-uncommited나 read-commited 그리고 repeatable-read 수준인 경우 inserrt와 연결하지 않은 순수한 읽기 작업은 다른 트랜잭션의 변경과 관계 없이 항상 잠금을 대기하지 않고 바로 실행됨 <- 잠금 없는 일관된 읽기
- innodb의 언두로그를 사용함
- 오랜 시간동안 활동하는 트랜잭션이 있을 경우 일관된 읽기를 위해 언두 로그를 삭제하지 못해 성능저하가 있을 수 있음 트랜잭션은 최대한 빨리 끝낼것



### innodb와 myisam 스토리지 엔진 비교

- 5.5부터는 innodb가 기본 엔진
- innodb가 짱좋음



### innodb와 memory 스토리지 엔진 비교

- memory는 모두 메모리에 저장하기때문에 작업이 매우 빠름 but 테이블락



## MyISAM 스토리지 엔진

- 생..략

## MEMORY 스토리지 엔진 아키텍처

- 생략

## NDB 클러스터 스토리지 엔진

- 생략



## TokuDB

- 빠르게 증가하는 대용량 데이터를 관리하는 것이 주 특기
- 이외 생략 



## 전문 검색 엔진

- 생략



## MySQL 로그 파일

### 에러로그파일

- mysql config 파일에 log_error 라는 파라미터로 정의된 경로의 파일이거나  없는 경우 datadir에 .err 확장자가 붙은 파일
- 시작시점, 비정상종료일때 트랜잭션 복구 메시지, 쿼리 도중 에러 메시지 등등이 자주 발생함

### 제너럴 쿼리 로그 파일

- 쿼리 전체 목록 로그 파일
- general-log 라는 이름의 파라미터에 정의된 경로에 있는 파일 5.1.12이상에서는 general_log_file

### 슬로우 쿼리 로그 

- mysql 서버의 쿼리 튜닝은 서비스가 적용되기 전에 전체적으로 튜닝하는 경우와 서비스 운영 중에 mysql 서버의 전체적인 성능 저하를 검사하거나 정기점검을 위한 튜닝으로 나눌 수 있음
- 어떤 쿼리가 문제인지 판단하기가 상당히 어려움
- 슬로우 쿼리 로그 파일에는 long_query_time 파라미터 이상 소요된 쿼리가 모두 기록됨
- 반드시 완료되어야 슬로우쿼리로그에 기록됨

### 바이너리 로그와 릴레이 로그

- 바이너리로그 파일은 마스터에 릴레이로그는 슬레이브에 생성
- 바이너리로그에는 select 같이 데이터 구조나 내용을 변경하지 않는 쿼리는 기록되지 않음
- 바이너리로그는 이진 파일로 되어있어서 직접 확인 불가능 mysqlbinlog를 사용할 것

























