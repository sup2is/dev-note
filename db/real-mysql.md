# #1 소개



# #2 설치와 설정





# #3 MySQL 아키텍처



## MySQL 아키텍처



![](https://t1.daumcdn.net/cfile/tistory/26219B435902D88522)

### mysql 전체구조

- mysql은 일반 상용 rdbms에서 제공하는 대부분의 접근법을 모두 지원함

- mysql 서버는 크게 mysql 엔진, 스토리지 엔진으로 구분해볼 수 있음

**mysql 엔진**

- mysql 엔진은 클라이언트로부터의 접속 및 쿼리요청을 처리하는 커넥션 핸들러와 sql 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심

**스토리지 엔진**

-  실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 스토리지 엔진이 전담, mysql 엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용 가능

**핸들러 api**

- mysql 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에게 쓰기 또는 읽기 요청을 하는데 이러한 요청을 핸들러 요청이라고하고 여기에 사용되는 api를 핸들러 api라함
  

### mysql 스레딩 구조

- mysql 서버는 프로세스기반이 아니라 스레드 기반으로 작동함 크게 포그라운드와 백그라운드 스레드로 구분

**포그라운드 스레드(클라이언트 스레드)**

- mysql 서버에 접속된 클라이어트의 수 만큼 존재
- 요청하는 쿼리 문장을 처리하는 것이 임무
- 요청 종료시 다시 스레드 캐시 (thread pool)로 돌아감
- 스레드의 개수를 일정하게 유지해주는 파라미터 thread_cache_size

**백그라운드 스레드**

- innoDB는 여러가지 작업이 백그라운드로 처리 여러가지 작업을 함
- 쓰기 스레드는 innodb_write_io_threads, 읽기 스레드는 innodb_read_io_treads로 지정 가능
- 읽기스레드는 클라이언트 스레드에서 처리되는데 쓰기의 경우 일반 내장 디스크에서는 2~4, ans,san과같은 스토리지를 사용할 경우 4개 이상으로 충분히 설정하는게 좋음

<br>

- 상용 dbms에는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 있고 innodb도 그러함 but myisam은 그렇지 않고 사용자 스레드가 쓰기 작업까지 함께 처리하도록 설계되어 있음
- innodb에서는 cud 쿼리로 데이터가 변경되는 경우 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 됨 . 하지만 myisam에서 일반적인 쿼리는 쓰기 버퍼링을 사용할 수 없음



### 메모리 할당 및 사용 구조

- mysql에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분 가능
- 글로벌 메모리 영역의 모든 메모리 공간은 mysql 서버가 시작되면서 무조건 운영체제로부터 할당됨 
- 글로벌 메모리 영역과 로컬 메모리 영역의 차이는 mysql 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 아닌지에 따라 구분됨

**글로벌 메모리 영역**

- 일반적으로 클라이언트 스레드의 수와 무관하게 일반적으로는 하나의 메모리 공강만 할당, 필요에 따라 2개 이상의 메모리 공간을 할당받을 수 있지만 클라이언트 스레드의 수와 무관하고 생성된 글로벌영역은 모든 스레드의 의해 공유됨

**로컬 메모리 영역**

- 세션 메모리 영역이라도 불림
- mysql 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용되는 메모리 영역
- 로컬 메모리는 각 클라이언트 스레드 별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징

### 플러그인 스토리지 엔진 모델

- mysql 독특한 구조중 하나가 바로 플러그인 모델, 직접 제작도 가능함
- sql 파서 -> sql 옵티마이저 -> sql 실행기 -> 데이터 읽기/ 쓰기 -> DB
- 위 과정에서 마지막 데이터 읽기/쓰기 과정만 스토리지 엔진에 의해 처리됨 나머지는 mysql  엔진에서 처리
- 데이터 읽기/쓰기 작업은 대부분 1건의 레크도 단위로 처리됨
- mysql 서버에서는 mysql 엔진이 사람역하을 하고 각 스토리지 엔진은 자동차 역할을 하게 됨. mysql 엔진이 스토리지 엔진을 조정하기 위해 핸들러 라는것을 사용함
- mysql 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 핸들러를 사용한다는 점만 기억하면 됨
- 실질적인 group by oder by 등 많은 복잡한 처리는 스토리지 엔진 영역이 아니라 mysql 엔진의 처리 영역인 쿼리 실행기에서 실행됨

![](https://www.dbrnd.com/wp-content/uploads/2016/01/MySQLShowEngines.png)

- 이거말고 조금 더 있음
- 플러그인형식으로 스토리지 엔진을 쉽게 설치 가능함



### 쿼리 실행 구조



**파서**

- 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미
- 쿼리 문장의 기본 문접 오류는 이 과정에서 발견되고 사용자에게 오류 메시지를 전달하게 됨

**전처리기**

- 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인함
- 실제 존재하지 않거나 권한상 사용 불가한 토큰의 경우 이 단계에서 걸러짐

**옵티마이저**

- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 담당
- 매우 중요함

**실행 엔진**

- 옵티마이저가 두뇌라면 실행 엔진과 핸들러는 손과 발에 비유할 수 있음

- 옵티마이저가 group by를 처리하기위해 임시테이블을 사용하기로 결정했다면 다음과 같은 과정

  1. 실행 엔진은 핸들러에게 임시 테이블을 만들라고 요청

  2. 다시 실행 엔진은 where 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청

  3. 읽어온 레코드들을 1번에서 준비한 임시테이블로 저장하라고 다시 핸들러에게 요청

  4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어오라고 핸들러에게 다시 요청

  5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김

     즉 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행

**핸들러 (스토리지 엔진)**

- mysql 서버 가장 밑단에서 mysql 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당
- 핸드럴 == 스토리지 엔진
- myisam 테이블을 조장하면 핸들러가 myisam 스토리지엔진 <- 이런식임



### Replication

- 복제는 2대 이상의 mysql 서버가 동일한 데이터를 담도록 실시간으로 동기화 하는 기술
- 쓰기는 마스터 읽기는 슬레이브
- mysql 서버의 복제에서는 마스터는 반드시 1개 슬레이브는 1개 이상으로 구성될 수 있음



**마스터**

- 기술적으로는 mysql의 바이너리 로그가 활성화되면 어떤 mysql 서버든 마스터가 될 수 있음
- 데이터가 생성 및 변경, 삭제되는 주체
- dml,ddl을 바이너리 로그에 기록
- 슬레이브는 변경 내역을 요청하면 바이너리 로그에서 읽어서 슬레이브로 넘김
- 마스터의 프로세스중 "Binlog dump"라는 스레드가 이 일을 전담함 슬레이브 수대로 스레드가 존재



**슬레이브**

- 데이터를 받아올 마스터 장비의 정보를 갖고 있는 경우 슬레이브가 됨
- 슬레이브 서버는 릴레이 로그를 갖고 있음
- 슬레이브는 읽기 전용
- 슬레이브 서버의 i/o 스레드는 마스터 서버에 접속해 변경 내역을 요청하고 받아 온 변경 내역을 릴레이 로그에 기록함
- 슬레이브 서버의 sql 스레드가 릴레이 로그에 기록된 변경 내역을 재실행 함으로 마스터와 동일한 상태로 유지함
- i/o 스레드는 슬레이브에만 있음



**복제시 주의사항**

- 슬레이브는 하나의 마스터만 설정 가능
- 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정
- 슬레이브 서버용 장비는 마스터와 동일한 사양이 적합
- 복제가 불필요한 경우에는 바이너리 로그 중지
- 바이너리 로그와 트랜잭션 격리 수준

> - 5.1에서는 Statement based replcation, Row based replication이 지원됨
> - sql 기반의 복제는 아무리 많은 데이터의 변경을 유발하더라도 sql 문장 하나만 슬레이브로 전달되기때문에 네트워크 트래픽을 많이 유발하지 않음 <- but repeatable-read 이상의 트랜잭션 격리 수준을 사용해야 하고 innodb 테이블에서는 레코드 간의 간격을 잠그는 갭 락이나 넥스트 키락이필요해짐
> - 레코드 기반으로 하면 트래픽이 많아지지만 read-commited 격리수준에도 동작하며 innodb테이블에서 잠금 경합이 줄어듬

### 쿼리 캐시

- mysql에만 있음
- sql 문장을 캐시하는게 아니라 쿼리 결과를 메모리에 캐시해두는 기능
- map과 같은 데이터 구조로 구현되어 있음 키는 sql 쿼리 문장, 값은 실행 결과
- 쿼리 캐시 결과 확인 절차를 가짐
  - 요청된 쿼리 문장이 쿼리 캐시에 존재하는가?
  - 해당 사용자가 그 결과를 볼 수 있는 권한을 갖고 있는가?
  - 트랜잭션 내에서 실행된 쿼리인 경우 가시 범위 내에 있는 결과인가?
  - 호출 시점에 달라 결과가 달라지는 요소가 있는가?
  - 프리페어 스테이트먼트의 경우 변수가 결과에 영향을 미치지 않는가?
  - 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가?
  - 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가?
  - 그 밖에 쿼리 캐시를 사용하지 못하게 만드는 요소가 있는가?
- `show global status` 명령을 이용해 쿼리 캐시의 사용량과 정보를 확인 가능
- Com_select (엔진이 처리)+ Qcache_hits (캐시 hit) = mysql 서버로 요청된 모든 select 문장
- 쿼리 캐시 히트율% = Qcache_hits  / (Qcache_hits + Com_select) * 100
- 쿼리 캐시율이 20% 이상이면 좋다고 이야기하는데 그냥 시기적절하게 잘 사용하는게 중요함
- 쿼리 캐시를 사용하지 않는 설정

```
query_cache_size = 0
query_cache_type = 0
```





## InnoDB 스토리지 엔진 아키텍처

- mysql에서 사용할 수 있는 스토리지 중 거의 유일하게 레코드 기반의 잠금을 제공
- 높은 동시성처리와 안정적, 성능 또한 뛰어남

![public](https://user-images.githubusercontent.com/30790184/98905454-c75d3680-24fe-11eb-8bc6-373681f016ae.jpeg)



### InnoDB 스토리지 엔진의 특성

**프라이머리 키에 의한 클러스터링**

- InnoDB의 모든 테이블은 기본적으로 키를 기준으로 클러스터링 되어 저장됨 이로 인해 pk에 의한 레인지 스캔은 상당히 빠르게 처리됨
- 결과적으로 쿼리의 실행 계획에서 pk는 다른 보조인덱스에 비해 비중이 높음 
- 오라클의 IOT(Index organized table)과 동일한 구조가 InnoDB에서는 일반적인 테이블 구조

**잠금이 필요없는 일관된 읽기 (None-locking consistent read)**

- InnoDB 스토리지엔진은 MVCC(Multi Version Concurrency Control) 이라는 기술을 이용해 락을 걸지 않고 읽기 작업을 수행함
- 락을 걸지 않기 때문에 읽기 작업은 다른 트랜잭션이 가지고 있는 락을 기다리지도 않음 SERIALIZABLE은 제외

**외래 키 지원**

- 외래키는 myisam에서 사용불가 innodb만 가능
- innodb에서 외래키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고 변경 시에 반드시 부모 테이블이나 자식 테이블에 데이터가 있는 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고 그로 인해 데드락이 발생할 때가 많음

**자동 데드락 감지**

- InnoDB는 그래프 기반의 데드락 체크 방식을 사용함. 데드락이 발생함과 동시에 바로 감지되고 감지된 데드락은 관련 트랜잭션 중에서 rollback이 가장 용이한 트랜잭션(복구 작업이 가장 적은 트랜잭션)을 자동적으로 강제 종료해버림
- 데드락 때문에 쿼리가 제한시간에 도달한다거나 슬로우 쿼리로 기록되는 경우가 많지 않음

**자동화된 장애 복구**

- 손실이나 장애로부터 데이터를 보호하기 위한 여러가지 메커니즘이 탑재되어 있음

**오라클 아키텍처 사용**

- innodb는 오라클과 상당히 비슷한 부분이 많음 ex mvcc 기능 등등



### InnoDB 버퍼 풀

- InnoDB에서 가장 핵심적인 부분
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간
- 쓰기 작업을 지연시켜 일괄 작업을 처리할 수 있는 버퍼공간
- myisam은 키 캐시가 인덱스의 캐시만을 주로 처리하는데 비해 innodb의 버퍼 풀은 데이터와 인덱스 모두 캐시하고 쓰기 버퍼링의 역할까지 모두 처리함
- innodb의 버퍼 풀은 많은 백그라운드 작업의 기반이 되는 메모리 공간임 따라서 버퍼 풀 크기를 신중하게 설정하는 것이 좋음 (innodb_buffer_pool_size)
- 적절하게 설정해야하고 일반적으로 전체 장착된 물리 메모리의 50~80% 수준에서 버퍼 풀의 메모리 크기를 결정함
- innodb 버퍼 풀은 아직 디스크에 기록되지 않은 변경된 데이터를 갖고 있음 (더티 페이지라 함 )



### undo 로그

- update 문장이나 delete 문장으로 데이터를 변경했을때 변경되기 전의 데이터를 보관하는 곳
- 사용자가 커밋하면 적용된 그대로 유지되고 롤백하면 언두 영역의 백업 데이터를 다시 데이터 파일로 복구함
- 언두 용도
  - 트랜잭션 롤백 대비용
  - 트랜잭션 격리 수준을 유지하면서 높은 동시성을 제공하는데 사용됨



### 인서트 버퍼

- rdbms에서 insert나 update에 데이터 파일을 변경하는 작업 뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요함
- 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 인덱스가 많다면 자원소모가 많음
- innodb는 변경해야할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행함 그렇지 않으면 임시 공간에 저장해두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시킴 이 때 사용하는 임시 메모리 공간을 인서트 버퍼라고함
- 유니크 인덱스는 인서트 버퍼를 사용할 수 없음
- 5.5이전까지는 insert에만 가능했으나 5.5 이후부터는 insert delete인해 키를 추가하거나 삭제하는 작업에도 버퍼링이 될 수 있게 개선
- 5.5 이후부터는 innodb_change_buffering이라는 파라미터로 종류별로 인서트 버퍼를 활성화 가능



### redo 로그 및 로그 버퍼

- 쿼리 문장으로 데이터를 변경하고 커밋하면 dbms는 데이터의 acid 보장을 위해 변경된 내용을 데이터 파일로 기록해야함 <- 상당한부하 작업
- 따라서 대부분 dbms에는 버퍼링을 위한 버퍼풀과 같은 장치가 있지만 이 장치만으로 acid를 보장할수는 없음
- 따라서 이를 위해 변경된 내용을 순차적으로 디스크에 기록하는 로그 파일을 갖고 있는데 이게 리두 로그임
- 리두로그 덕분에 dbms 데이터는 버퍼링을 통해 한꺼번에 디스크에 변경된 내용을 처리할 수 있고 성능 향상을 기대할 수 있게 됨
- 변경작업이 매우 많은 dbms 서버의 경우 이 리두 로그의 기록 작업이 큰 문제가됨 <- 이런 부분을 보완하기 위해 최대한 acid 속성을 보장하는 수준에서 버퍼링함
- 리두 로그 버퍼링에 사용되는 공간이 로그 버퍼임
- 로그 버퍼의 크기는 1~8m수준이 좋고 blob이나 text같은 큰 데이터의 변경이 많으면 더 크게



### MVCC(Multi Version Concurrency Control)

- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 dbms가 제공하는 기능
- 잠금을 사용하지 않는 일관된 읽기를 제공함
- innodb는 언두 로그를 이용해 이기능을 구현함
- 멀티 버전은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미



### 잠금 없는 일관된 읽기(Non-locking consistent read)

- innodb에서 격리수준이 serializable이 아닌 read-uncommited나 read-commited 그리고 repeatable-read 수준인 경우 inserrt와 연결하지 않은 순수한 읽기 작업은 다른 트랜잭션의 변경과 관계 없이 항상 잠금을 대기하지 않고 바로 실행됨 <- 잠금 없는 일관된 읽기
- innodb의 언두로그를 사용함
- 오랜 시간동안 활동하는 트랜잭션이 있을 경우 일관된 읽기를 위해 언두 로그를 삭제하지 못해 성능저하가 있을 수 있음 트랜잭션은 최대한 빨리 끝낼것



### innodb와 myisam 스토리지 엔진 비교

- 5.5부터는 innodb가 기본 엔진
- innodb가 짱좋음



### innodb와 memory 스토리지 엔진 비교

- memory는 모두 메모리에 저장하기때문에 작업이 매우 빠름 but 테이블락



## MyISAM 스토리지 엔진

- 생..략

## MEMORY 스토리지 엔진 아키텍처

- 생략

## NDB 클러스터 스토리지 엔진

- 생략



## TokuDB

- 빠르게 증가하는 대용량 데이터를 관리하는 것이 주 특기
- 이외 생략 



## 전문 검색 엔진

- 생략



## MySQL 로그 파일

### 에러로그파일

- mysql config 파일에 log_error 라는 파라미터로 정의된 경로의 파일이거나  없는 경우 datadir에 .err 확장자가 붙은 파일
- 시작시점, 비정상종료일때 트랜잭션 복구 메시지, 쿼리 도중 에러 메시지 등등이 자주 발생함

### 제너럴 쿼리 로그 파일

- 쿼리 전체 목록 로그 파일
- general-log 라는 이름의 파라미터에 정의된 경로에 있는 파일 5.1.12이상에서는 general_log_file

### 슬로우 쿼리 로그 

- mysql 서버의 쿼리 튜닝은 서비스가 적용되기 전에 전체적으로 튜닝하는 경우와 서비스 운영 중에 mysql 서버의 전체적인 성능 저하를 검사하거나 정기점검을 위한 튜닝으로 나눌 수 있음
- 어떤 쿼리가 문제인지 판단하기가 상당히 어려움
- 슬로우 쿼리 로그 파일에는 long_query_time 파라미터 이상 소요된 쿼리가 모두 기록됨
- 반드시 완료되어야 슬로우쿼리로그에 기록됨

### 바이너리 로그와 릴레이 로그

- 바이너리로그 파일은 마스터에 릴레이로그는 슬레이브에 생성
- 바이너리로그에는 select 같이 데이터 구조나 내용을 변경하지 않는 쿼리는 기록되지 않음
- 바이너리로그는 이진 파일로 되어있어서 직접 확인 불가능 mysqlbinlog를 사용할 것





# #4 트랜잭션과 잠금



## 트랜잭션

### MySQL에서의 트랜잭션

- innodb는 쿼리중 일부라도 오류가 발생하면 전체를 원상태로 만들어둠
- myisam에는 부분업데이트가 일어남 부분업데이트는 데이터 정합성에 큰 문제임

### 주의사항

- 트랜잭션은 필요한 최소의 코드에만 적용하는 것이 좋음
- 원격작업이 묶인 트랜잭션은 치명적일 수 있음



## MySQL 엔진의 잠금

- 스토리지 엔진 레벨과 mysql 엔진 레벨로 나뉨
- mysql 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 미치지 않음\
- mysql 엔진에서는 테이블락 말고 유저락, 테이블 명에 대한 잠금을 위한 네임락도 제공함



### 글로벌 락

- 글로벌락은 FLUSH TABLES WITH READ LOCK 명령으로만 획득 가능하고 mysql에서 제공하는 잠금 가운데 가장 범위가 큼
- 세션단위로 동작함 mysql 서버 전체의 테이블에 락을 검
- select를 제외한 모든 문장이 글로벌락이 해제될 때까지 대기상태로 남음
- 잘못사용하면 큰일남
- mysqldump라는 백업프로그램에서 사용할 수도 있음 잘 체크해볼것

### 테이블 락

- 개별 테이블 단위로 설정되는 잠금, 명시적 또는 묵시적으로 테이블의 락 획득 가능
- 테이블락은 myisam, innodb 모두 사용 가능
- LOCK TABLE table_name [READ | WRITE] 으로 명시적으로 획득 가능
- UNLOCK TABLES로 잠금 반납가능
- 특별한 상황이 아니면 사용할일이 없음 잘못사용하면 큰일남
- 묵시적인 테이블락은 myisam이나 memory 테이블에 데이터를 변경하는 쿼리를 실행하면 발생함 
- 묵시적 테이블 락은 쿼리가 실해오디는 동안 자동적으로 획득됐다가 쿼리가 완료된 후 자동 해제됨
- innodb는 레코드기반 락이기때문에 묵시적 테이블락이 설정되지 않음
- 정확히는 ddl의 경우에만 테이블락이 설정됨



### 유저 락

- GET_LOCK() 함수를 이용해 임의로 잠금 설정 가능
- 유저락은 테이블, 레코드 같은 대상이 아니라 사용자가 지정한 문자열에 대해 획득 및 반납하는 잠금임
- 자주 사용되지 않음
- 많은 레코드를 한번에 변경하는 트랜잭션의 경우 유용하게 사용 가능



### 네임 락

- 데이터베이스 객체의 이름을 변경하는 경우 획득하는 잠금
- READ TABLE tab_a TO tab_b 와 같이 테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금, 원본과 대상 둘다 잠금



## MyISAM과 MEMORY 스토리지 엔진의 잠금

- 이 두 엔진은 자체적인 잠금을 가지지 않고 mysql에서 제공하는 테이블락을 그대로 사용함
- 쿼리단위로 필요한 잠금을 한꺼번에 모두 요청해서 획득하기 때문에 데드락이 발생할 수 없음
- momory, archive, merge 등과 같은 스토리지 엔진에도 아래 내용이 똑같이 작동함



### 잠금 획득

**읽기잠금**

- 테이블에 쓰기 잠금이 걸려있지 않으면 바로 읽기 잠금을 획득하고 읽기 작업 시작 가능

**쓰기 잠금**

- 테이블에 아무런 잠금이 걸려있지 않아야만 쓰기 잠금 가능
- 다른 잠금이 해제될 때까지 대기



### 잠금 튜닝

- SHOW STATUS LIKE 'Table%'

```
Table_locks_immediate	12428
Table_locks_waited	0
Table_open_cache_hits	1
Table_open_cache_misses	0
Table_open_cache_overflows	0
```

- Table_locks_immediate: 다른 잠금이 풀리기를 기다리지 않고 바로 잠금을 획득한 횟수
- Table_locks_waited: 다른 잠금이 이미 해당 테이블을 사용하고 있어서 기다려야 했던 횟수를 누적해서 저장함
- 잠금 대기 쿼리 비율 = Table_locks_waited / (Table_locks_waited + Table_locks_immediate) * 100
- 잠금 대기 쿼리 비율이 높다면 innodb로 변환 방법을 고려하는게 좋음
- innodb는 레코드 락

### 테이블 수준의 잠금 확인 및 해제

- SHOW OPEN TABLES [FROM table_name];
- in_use값은 해당 테이블을 잠그고 있는 클라이언트 수 + 대기하는 클라이언트 수
- name_locked는 alter table 또는 rename
- SHOW PROCESSLIST 명령으로 실시간 잠금 현황 확인 가능
- KILL QUERY 클라이언트_id 로 클라이언트 커넥션 종료 가능



## InnoDB 스토리지 엔진의 잠금

- mysql 엔진에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 레코드 락 기능을 탑재
- myisam보다 훨씬 뛰어난 동시성 처리 제공 가능
- 이원화된 잠금 처리탓에 innodb 스토리지 엔진에서 사용되는 잠금에 대한 정보는 mysql 명령을 이용해 접근하기가 상당히 까다로움
- 5.1 이후부터 innodb의 트랜잭션,잠금, 잠김 대기중인 트랜잭션 목록 조회하는 방법이 도입됨

### InnoDB의 잠금 방식

**비관적 잠금**

- 현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식을 비관적 잠금이라함
- 일반적으로 높은 동시성 처리에는 비관적 잠금이 유리하다고 알려져 있음 innodb는 비관적 잠금



**낙관적 잠금**

- 기본적으로 각 트랜잭션이 같은 레코드를 변경할 가능성이 상당히 희박할때 낙관적 잠금이라함
- 따라서 우선 변경 이후 마지막에 잠금 충돌이 있는지 확인 후 rollback함

### innodb 의 잠금 종류

- 잠금 정보가 상당히 작기때문에 레코드락이 페이지락 또는 테이블락으로 레벨업되는 경우가 없음
- 레코드와 레코드 사이의 간격을 잠그는 것을 갭락이라고 함

**레코드 락**

- 레코드 자체만 잠그는 것을 레코드락
- innodb 스토리지 엔진은 레코드 자체가 아니라 인덱스 레코드를 잠근다는 것
- 없더라도 클러스터 인덱스를 이용해 잠금



**갭 락**

- 갭락은 레코드와 바로 인접한 레코드 사이의 간격만 잠그는 것을 의미
- 갭락은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어함
- 개념일뿐이고 자체적으로 사용되지 않음 넥스트 키 락의 일부로 사용

**넥스트 키 락**

- 레코드 락과 갭 락을 합쳐놓은 형태의 잠금을 넥스트 키 락이라고함
- statement 포맷의 바이너리 로그를 사용하는 mysql 서버에는 repeatable read 격리수준을 사용해야함
- innodb의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어 난 결과와 동일한 결과를 만들어내보도록 보장하는 것이 주 목적임
- 으외로 넥스트 키락과 갭락으로 인한 데드락이 발생하거나 트랜잭션 대기가 자주 있으
- 가능하다면 바이너리 로그 포맷을 row형태로 바꿔서 넥스트 키락이나 갭락을 줄이는 것이 좋음 <- 아직 안정성을 확인하기 어려움



**자동 증가 락**

- auto_increment락이라고 하는 테이블 수준의 잠금을 사용함
- 이 락은 트랜잭션과 관계없이 값을 가져오는 순간만 락이 걸렸다가 즉시 해제됨
- 명시적으로 락 획득 불가
- 아주 짧게 적용되기때문에 문제될일 없음
- 5.1이후에 innodb_autoinc_lock_mode로 작동 방식을 제어 가능 함



### 인덱스와 잠금

- innodb의 잠금과 인덱스는 상당히 중요한 연관관계가 있음
- innodb는 레코드를 잠그는 것이 아니라 인덱스를 잠금
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 함
- 인덱스가 걸린 레코드는 모두 잠금
- 만약 인덱스가 없다면 모든 레코드를 잠금
- 따라서 innodb에서 인덱스 설계가 매우 중요함



### 트랜잭션 격리 수준과 잠금

- 불필요한 레코드의 잠금 현상은 innodb의 넥스트 키 락 때문에 발생함
- 이 넥스트 키 락을 필요하게 만드는 주 원인은 바로 복제를 위한 바이너리 로그 때문임
- row based 로그를 사용하거나 바이너리 로그를 사용하지 않으면 갭락이나 넥스트 키 락의 사용을 대폭 줄이므로 더 많은 요청을 처리할 수 있게 됨
- 다음 조합으로 mysql 서버가 기동하는 경우에 innodb에서 사용되는 대부분의 갭락이나 넥스트키락을 제거 가능

| 버전           | 설정의 조합                                                  |
| -------------- | ------------------------------------------------------------ |
| mysql 5.0      | innodb_locks_unsafe_for_binlog=1<br /> 트랜잭션 격리 수준을 read commited로 설정 |
| mysql 5.1 이상 | 바이너리 로그를 비활성화 트랜잭션 격리수준을 read-commited로 설정<br />레코드 기반의 바이너리 로그 사용<br />innodb_locks_unsafe_for_binlog=1<br />트랜잭션 격리 수준을 read-commited로 설정 |

- 이 조합이라도 유니크키나 외래키에 대한 갭 락은 없어지지 않음



### 레코드 수준의 잠금 확인 및 해제

- 테이블락보다 레코드락이 더 복잡함
- 5.0에서는 더힘들고 5.1부터는 확인이 좀 더 수월함
- 5.0에서는 공통적으로 특정 테이블의 레코드를 변경하거나 삭제하려고 하는 쿼리가 표시되는 것이 일반적, 구 중에서 활성화상태면서 아무런 sql도 실행하지 않는 트랜잭션이 있다면 이것이 문제일 가능성이 높음
- 근본적으로 찾기 어렵다면 오래기다리고 있는 트랜잭션의 커넥션을 모두 종료하는게 빠른 해결책
- 5.1 이상에서는 INFORMATION_SCHEMA라는 DB에 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAIT라는 테이블을 사용할 것
- INNODB_LOCKS는 어떤 잠금이 존재하는지 관리, INNODB_TRX는 어떤 트랜잭션이 어떤 클라이언트에 의해 기동되며 어떤 잠금을 기다리고 있는지, INNODB_LOCK_WAITS 테이블은 잠금에 의한 프로세스 간의 의존 관계를 관리하게됨



## mysql의 격리 수준

- read uncommited, read commited, repeatable read, rerializable 4가지로 나뉨
- read uncommited, serializable 은 잘 사용되지 않음
- innodb에서 repeatable read 격리수준에서는 phantom read가 발생하지 않음
- 오라클은 read commited, mysql에는 repeatable read를 주로 사용함

### READ UNCOMMITED

- DIRTY READ, 정말 위험할 수 있음 사용하지 말 것

### READ COMMITED

-  오라클의 기본 격리 수준, 온라인 서비스에서 가장 많이 선택되는 격리 수준
- 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있음
- NOT REPEATABLE READ가 발생함

### REPEATABLE READ

- mysql innodb 엔진에서 기본적으로 사용, 바이너리 로그를 가진 mysql 장비에서는 최소 repeatable read 수준 이상을 사용해야함
- mvcc를 사용함 rollback 가능성을 대비해 레코드를 언두 공간에 백업해두고 실제 레코드 변경
- 어떤 트랜잭션 A와 B가 있다고 가정했을때 A 또는 B 에서 시작된 트랜잭션은 항상 같은값만 반환함
- PHANTOM READ가 발생함

### SERIALIZABLE

- 이 레벨의 경우 읽기 작업도 공유잠금을 획득해야하는 매우 엄격한 격리 수준
- mysql innodb에서는 repeatable read에서 phantom read가 발생하지 않으므로 쓸일이 없음



- 사실 READ COMMITED와 REPEATABLE READ의 성능차이는 크지 않음



# #5 인덱스

## 디스크 읽기 방식

- 데이터베이스의 성능 튜닝은 어떻게 디스크 io를 줄이느냐가 관건인것이 많음

### 저장 매체

- 일반적인 서버에 사용되는 저장 매체
  - 내장디스크
  - DAS (Direct Attached Storage)
  - NAS (Network Attached Storage)
  - SAN (Storage Area Network)
- 내장디스크는 일반적인 pc의 디스크, 용량 문제가 있음
- DAS도 내장디스크와 비슷함 대용량 디스크가 필요할때 사용가능, 본체 한대와만 연결이 가능해서 디스크 정보를 다른 컴퓨터와 공유 불가능
- DAS의 단점을 NAS와 SAN으로 해결 가능
- NAS는 TCP/IP로 연결해서 공유 가능함, DAS보다 느림
- SAN은 DAS로는 구축할 수 없는 아주 대용량의 스토리지 공간을 제공함. 컴퓨터 본체들과 광케이블로 연결되고 빠르고 안정적, 비쌈

### 디스크 드라이브와 솔리드 스테이트 드라이브

- ssd의 장점은 랜덤 io가 훨씬 빠르다는 것

### 랜덤 io와 순차 io

- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하느냐에 의해 결정됨
- 순차 io가 랜덤 io보다 빠름
- 데이터베이스의 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 mysql 서버에서는 그룹 커밋이나 버이너리 로그 버퍼 또는 inndb 로그 버퍼 기능이 내장된 것

> - 인덱스 레인지 스캔은 랜덤 io
> - 풀 테이블 스캔은 순차 io



## 인덱스란?

- 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어둠
- 키를 기반으로 정렬시켜놓아서 빠르게 찾을 수 있게 해둠
- 인덱스는 항상 정렬된 상태로 유지함
- 인덱스가 많은 테이블은 insert, update delete 문장의 처리가 늦어짐 하지만 select는 매우 빠름
- 인덱스를 구분해본다면 primary key와 secondary key가 있음
- 프라이머리키는 대표적으로 그 테이블을 대표하는 컬럼의 값으로 만들어진 인덱스고 프라이머리 키를 제외한 모든 인덱스는 보조인덱스임
- 데이터 저장방식은 대표적으로 b-tree hash 인덱스로 구분할 수 있음
- hash 방식은 값의 일부만 검색할 수 없음, 메모리기 반 db에서 많이 사용함
- Fractal-tree 알고리즘도 있는데 b-tree랑 비슷하지만 데이터 저장 삭제시 처리 비용을 상당히줄일 수 있게 설계된 것이 특징임
- 데이터 중복 허용 여부로 분류하면 유니크 인덱스와 유니크하지 인덱스로 구분 할 수 있음
- dbms의 옵티마이저에게 중복 여부는 상당히 중요함 유니크인덱스에 대해 equal 으로 검색하면 1건의 레코드만 찾으면 더이상 찾지 않아도 된다는 것을 옵티마이저에게 알려주는 효고임
- 기능별로 분류하면 전문 검색이나 공간 검색용 인덱스 등이 있음



## B-Tree 인덱스

- Balanced Tree
- b-tree는 최상위에 하나의 루트노드가 존재하고 그 하위에 자식 노드가 붙어있는 형태
- 루트, 브랜치, 리프노드 순서로 되어있음
- b-tree에서 바라보는 파일시스템들은 정렬된 상태가아님 but 클러스터 인덱스는 pk 순서대로 정렬된 상태
- 인덱스는 테이블의 키 칼럼만 갖고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야함



### B-tree 인덱스 키 추가 및 삭제

**인덱스 키 추가**

- b-tree에 저장될 때는 저장될 키 값을 이용해 b-tree 상의 적절한 위치를 검색해야함
- 리프노드가 꽉 찼을때는 상위 브랜치노드까지 영향을 주는데 이러한 작업이 b-tree에서 쓰는 비용이 많다고 알려짐
- 비용들 대부분은 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야하기때문에 오래걸리는것
- myisam이나 memory 스토리지엔진은 insert 즉시 b-tree 인덱스에 반영하고 작업완료까지 클라이언트는 기다림
- innodb는 상황에따라 적절하게 인덱스 키 추가 작업을 지연시켜 나중에 처리할지 아니면 바로 처리할지 결정함
  1. 사용자의 쿼리 실행
  2. innodb의 버퍼 풀에 새로운 키 값을 추가해야 할 페이지가 존재(b-tree의 리프노드)한다면 즉시 키 추가 작업 처리
  3. 버퍼 풀에 b-tree 리프 노드가 없다면 인서트 버퍼에 추가할 키 값과 레코드의 주소를 임시로 기록해두고 작업 완료
  4. 백그라운드 작업으로 인덱스 페이지를 읽을 때마다 인서트 버퍼에 머지해야 할 인덱스 키 값이 있는지 확인한 후 있다면 병합
  5. db 서버 자원의 여유가 생기면 mysql 서버의 인서트 버퍼 머지 스레드가 조금씩 인서트 버퍼에 임시 저장된 인덱스 키오 ㅏ주소 값을 머지
- 5.1 이하에서는 insert만 지연처리 5.5 이사엥서는 insert delete 둘다 됨
- 5.1 이하에서는 인서트 버퍼링, 5.5이상에서는 체인지 버퍼링



**인덱스 키 삭제**

- b-tree는 키 삭제가 상당히 간단함 리프노드를 찾아서 삭제만 마크하면 작업 완료

**인덱스 키 변경**

- b-tree에서는 키 값 변경 작업은 먼저 키값을 삭제한 후 다시 새로운 키값을 추가하는 형태



**인덱스 키 검색**

- b-tree인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용 가능, 부등호 비교나 값의 뒷부분이 일치하는 경우에는 b-tree인덱스를 이용한 검색이 불가능함
- 이미 변형된 값 (함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업)은 b-tree의 장점을 이용할 수 없음
- innodb테이블에서 지원하는 레코드 잠금이나 넥스트 키 락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 되어있음 따라서 update나 delete 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠금



### b-tree 인덱스 사용에 영향을 미치는 요소

**인덱스 키값의 크기**

- innodb에서 디스크의 모든 읽기 쓰기 작업의 최소단위는 페이지 또는 블록이라고 함 또한 페이지는 innodb 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위임
- 인덱스도 결국 페이지 단위로 관리됨
- 인덱스의 페이지 크기와 키 값의 크기에 따라 자식노드의 개수가 결정됨
- 결론적으로 키 값의 크기가 커질수록 효율이 떨어짐

**B-tree 깊이**

- 깊이는 상당히 중요하지만 직접적으로 제어할 방법이 없음
- 결론적으로 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 잇는 인덱스 키값의 개수가 작아지고 그 때문에 같은 레코드 건수라 하더라도 b-tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게된다는 것을 의미함
- 인덱스의 키값의 크기는 가능하면 작은게 좋고 아무리 대용량 데이터베이스라도 깊이가 4~5이상까지 깊어지는경우는 거의 발생하지 않음

**선택도(기수성)**

- 인덱스에서 선택도 = 기수성임 카디널리티
- 전체인덱스 키값은 100개인데 유니크한 값의 수는 10개라면 기수성은 10임 
- 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리함
- 인덱스의 선택도가 높을수록 미리 걸러지는 레코드의 수가 많아짐



**읽어야 하는 레코드의 건수**

- 인덱스를 통해 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이드는 작업임
- 인데스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는것보다 4~5배정도 비용이 많이든다고 예측함
- 전체테이블의 20~25를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는 방식으로 처리하는게 좋음



### B-tree 인덱스를 통한 데이터 읽기

- mysql이 인덱스를 이용하는 대표적인 방법

**인덱스 레인지 스캔**

- 가장 대표적인 접근 방식
- 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현함
- 루트 -> 브랜치 -> 리프로 한번 전체 스캔하고 range를 정하고 range에서의 데이터를 클라이언트에게 반환함
- 별도의 정렬과정 없이 인덱스 자체의 정렬 특성때문에 정순 또는 역순으로 레코드를 불러옴
- 검색결과가 많으면 풀스캔이 나음



**인덱스 풀 스캔**

- 인덱스의 처으부터 끝까지 모두 읽는 방식
- 대표적으로 쿼리의 조거넞ㄹ에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용됨
- 예를들어 인덱스는 a,b,c 순서로 만들어졌지만 쿼리 조건절은 b, c 로시작하는 경우
- 쿼리가 인덱스에 명시된 컬럼만 조건을 처리할 수 있는 경우 이방식으로 사용되고 다른 레코드를 읽어야 한다면 절대 이방식으로 처리되지 않음
- 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동한 뒤 처음부터 끝까지 스캔함
- 인덱스 레인지 스캔 > 인덱스 풀 스캔 > 테이블 풀 스캔으로 검색속도가 빠른정도

**루스 인덱스 스캔**

- 오라클에 인덱스 스킵 스캔이랑 비슷함
- 루스 인덱스 스캔은 느슨하게 또는 듬성듬성하게 인덱스를 읽음
- 인덱스 레인지 스캔과 비슷하지만 필요하지 않은 인덱스 키값은 무시하고 다음으로 넘어가는 형태로 처리
- 일반적으로 group by 또는 집합 함수 가운데 max() min()함수에 대해 최적화를 하는 경우에 사용



### 다중 칼럼 인덱스

- 실무에서는 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용됨
- 다중컬럼인덱스의 순서에 따라 정렬 순서도 바뀌기때문에 다중컬럼인덱스의 순서는 매우 중요하고 상당이 신중하게 결정해야함



### B-tree 인덱스의 정렬 및 스캔 방향

- 인덱스 키값은 항상 오름차순으로 정렬되지만 역순으로도 사용될 수 있음

**인덱스의 정렬**

- 일반적인 dbms는 asc, desc 설정이 가능하지만 mysql에서는 컬럼마다 asc, desc 별개로 적용은 안됨
- mysql에선 지정한다고 하더라도 전부 무시하고 오름차순으로만 정렬됨
- 아직까지는 방법이 없으므로 order by 에 따라 역순으로 정렬하게 해야할 수 있음
- 예를들면 order by user_name asc, user_score desc일때 user_score를 음수값으로?



**인덱스 스캔 방향**



































































