



# Database Internals









데이터베이스 관리 시스템의 주 목적은 데이터를 안정적으로 저장하고 사용자에게 제공하는 것이다.



# #1 소개 및 개요

## DBMS 구조

- 표준화된 DBMS 구조란 존재하지 않는다. 모든 데이터베이스 구조는 다르고 내부 컴포넌트의 경계를 명확히 나누고 정의하기 어렵다.
- DBMS는 클라이언트/서버 모델을 기반으로 한다.
- 클라이언트의 요청은 트랜스포트 서브시스템을 통해 전달된다. 요청은 쿼리 형태이고 트랜스포트 서브시스템은 데이터 클러스터 노드 사이의 통신에도 사용된다.
- 트랜스포트 서브시스템은 쿼리를 쿼리 프로세서에게 전달한다. 쿼리 프로세서는 쿼리를 해석 분석 및 검증한다. 쿼리의 의미를 파악한 뒤에 액세스 제어를 진행할 수 있다.
- 분석된 쿼리는 쿼리 옵티마이저에게 전달된다. 쿼리에서 논리적으로 불가능한 부분과 중복을 제거한 뒤에 내부 데이터 통계 등을 기반으로 가장 효율적인 쿼리 실행 계획을 생성한다. 그외에도 인덱스 순서 선택, 카디널리티 예측, 액세스 메서드 선택등의 최적화 단계를 처리한다.
- 쿼리는 일반적으로 실행 계획 형태로 표현되고 다양한 쿼리 실행계획이 있을 수 있으며 옵티마이저는 이 가운데 가장 효율적인 실행 계획을 선택한다.
- 선택된 실행 계획은 로컬 및 원격 실행의 결과를 결합하는 실행 엔진이 수행한다.
- 로컬 쿼리는 스토리지 엔진이 수행한다. 스토리지 엔진은 다음과 같이 명확한 역할을 담당하는 컴포넌트로 구성되어 있다.
  - 트랜잭션 매니저: 트랜잭션을 스케줄링하고 데이터베이스 상태의 논리적 일관성을 보장한다.
  - 잠금 매니저: 트랜잭션에서 접근하는 데이터베이스 객체에 대한 잠금을 제어한다. 동시 수행 작업이 물리적 데이터 무결성을 침해하지 않도록 제어한다.
  - 액세스 메서드: 디스크에 저장된 데이터에 대한 접근 및 저장 방식을 정의한다. 힙 파일과 B-트리 또는 LSM트리 등의 자료구조를 사용한다.
  - 버퍼 매니저: 데이터 페이지를 메모리에 캐시한다.
  - 복구 매니저: 로그를 유지 관리하고 장애 발생시 시스템을 복구한다.
- 트랜잭션과 잠금 매너지는 동시성을 제어한다. 

## 인메모리 DBMS 대 디스크 기반 DBMS

- 인메모리 DBMS는 메모리에 데이터를 저장하고 디스크는 복구와 로그 저장 용도로 사용한다.
- 디스크 기반 DBMS는 데이터를 디스크에 저장하고 메모리는 캐시 용도로 사용한다.
- 메모리는 디스크보다 훨씬 더 빠르게 데이터에 접근하지만 RAM은 디스크보다 가격이 비싸다.
- 인메모리 DBMS는 디스크 기반 데이터베이스와 비교해 기본 저장 매체뿐만 아니라 내부 자료 구조와 설계 및 최적화 방식도 모두 다르다.
- 메모리를 주 저장 매체로 사용하는 이유는 성능과 상대적으로 낮은 데이터 접근 비용, 세밀한 접근 단위 때문이다.
- 인메모리 DBMS의 가장 큰 단점은 RAM의 휘발성과 높은 가격이다.
- 디스크는 메모리보다 유지관리 측면에서 더 간단하고 비용이 낮다.
- 비휘발성 램 기술이 더 대중화되면 이런 상황은 뒤바뀔 수 있다.

### 인메모리 데이터베이스의 지속성

- 인메모리 DBMS는 데이터의 지속성을 보장하고 데이터 손실을 방지하기 위해 데이터를 디스크에 백업한다.
- 모든 작업은 로그 파일에 작업 내용을 순차적으로 기록해야 완료된다.
- 인메모리 시스템에서는 시스템 시작과 복구 시 모든 로그를 재수행하지 않기 위해 백업본을 유지하고 백업본은 디스크 기반 자료구조에 순서대로 저장하는데 일반적으로 수정 내용은 비동기적으로 갱신하며 I/O 작업을 최소화하기 위해 배치 단위로 백업한다.
- 로그 레코드는 일반적으로 배치 단위로 백업한다. 배치 작업이 완료되면 백업본은 특정 시점의 데이터베이스 스냅숏이기 때문에 이 시점 이전의 로그는 삭제해도 된다. 이러한 작업을 가리켜 체크포인트를 남긴다고 표현한다.
- 클라이언트의 요청을 블로킹하지 않고 디스크에 저장된 백업본을 최신 로그 데이터와 동기화하면 복구 시간을 단축할 수 있다.
- 메모리는 포인터를 사용해 비교적으로 빠르게 참조할 수 있고 랜덤 메모리 접근 속도는 랜덤 디스크 접근 보다 월등히 빠르다.

## 칼럼형 DBMS 대 로우형 DBMS

- 대부분의 데이터베이스는 열과 행으로 구성된 테이블에 데이터 레코드를 저장한다.
- 사용자 정보 테이블의 모든 사용자 이름은 같은 형식으로 같은 칼럼에 저장하고 논리적으로 같은 레코드에 속하는 값의 집합을 로우라고 부른다.
- 칼럼 저장 방식은 테이블을 수직 분할하고 로우 저장 방식은 수평 분할한다.
- MySQL과 PostgreSQL 등 대부분의 전통적인 관계형 데이터베이스는 로우형 DBMS다.
- MonetDB C-Store는 선구적인 칼럼형 오픈소스 데이터베이스다.

### 로우형 데이터 레이아웃

- 로우형 DBMS는 데이터 레코드를 로우 형식으로 저장한다.
- 이 방식은 여러 필드의 값일 고유 식별 키로 구분할 수 있는 레코드 형식에 적합하다.
- 특정 사용자의 모든 필드는 일반적으로 함께 요청되는 경우가 많다.
- 레코드를 생성할 때에도 레코드의 모든 필드를 함께 쓴다.
- 로우형 DBMS는 한 개의 로우씩 접근하는 경우 적합하다. 로우 단위로 저장하면 공간 지역성을 극대화할 수 있다.
- 특정 사용자의 모든 정보를 읽을 때는 효율적이지만 여러 사용자의 특정 필드를 읽을 때는 비효율적이다.



### 칼럼형 데이터 레이아웃

- 칼럼형 DBMS는 데이터를 로우 단위가 아니라 수직 분할해 칼럼 단위로 저장한다.
- 칼럼형 DBMS는 데이터의 추세와 평균 등을 계산하는 집계 분석 작업에 적합하다.
- 칼럼형 DBMS에서 조인과 필터링, 다중 로우 집계 등을 위해 튜플을 재구성하려면 칼럼 사이의 관계를 정의하는 메타데이터가 필요하다.
- 아파치 Parquet, 아파치 ORC, RCFile과 같은 칼럼 기반 파일 포맷과 아파치 Kudu, ClickHouse 등이 있다.

### 차이점과 최적화 기법

- 로우형 DBMS와 칼럼형 DBMS의 차이점을 데이터를 저장하는 방식만으로 설명하기에는 부족함이 많다.
- 데이터 레이아웃은 칼럼형 DBMS에서 목표하고 있는 여러 최적화 단계 중 하나일 뿐이다.
- 같은 칼럼의 여러 값을 한 번에 읽으면 캐시 활용도와 처리 효율성이 높아진다.
- 자료형별로 저장하면 압축률도 증가한다.
- 칼럼형과 로우형 DBMS중 어떤 것을 사용할지 선택하려면 먼저 액세스 패턴을 파악해야 한다.
- 데이터를 레코드 단위로 접근하고 일반 쿼리와 범위 스캔 요청이 많다면 로우형 DBMS가 적합하다. 반면 많은 로우를 스캔하거나 일부 칼럼에 대한 집계 작업이 많다면 칼럼형 DBMS가 더 적합할 수 있다.



### 와이드 칼럼 스토어

- 빅테이블과 HBase와 같은 와이드 칼럼 스토어는 일반적인 칼럼형 DBMS와는 구분해야 한다.
- 와이드 칼럼 스토어는 데이터를 다차원 맵으로 표현하고 여러 칼럼을 칼럼 패밀리 단위로 저장한다.
- 칼럼 패밀리의 데이터는 로우 형식으로 저장한다. 이 방식은 키 단위 액세스 패턴에 적합하다.
- 이 방식의 가장 대표적인 구현은 웹테이블이다.

```
{
	"com.cnn.www" : {
		contents: {
			t6: html: "<html> ..."
			t5: html: "<html> ..."
			t3: html: "<html> ..."
		}
		anchor: {
			t9: cnnsi.com: "CNN"
			t8: my.look.ca: "CNN.com"
		}
	}
}
```

- 웹테이블은 다차원 맵에 데이터를 정렬해서 저장하고 계층 인덱스를 생성한다.

- 각 로우는 로우 키와 매핑하고 관련 있는 칼럼끼리 칼럼 패킬리(contents와 anchor 필드) 단위로 저장한다.

- 칼럼 패밀리의 칼럼은 칼럼 패밀리 이름과 수식자(html, cnnsi.com. my.look.ca)로 구성된 칼럼 키로 식별할 수 있다.

- 칼럼 패밀리는 시간별로 여러 버전의 데이터를 유지한다 이 자료구조를 사용해 상위 레벨 요소와 관련된 변수를 검색할 수 있다.

- 와이드 칼럼 스토어의 논리적 구조는 이해하기 쉽지만 실제 저장 방식은 복잡하다.

  

## 데이터 파일과 인덱스 파일

- 데이터베이스 시스템의 주 목적은 데이터를 저장하고 빠르게 데이터를 검색하는 것이다.
- 데이터베이스가 일반 파일을 사용하지 않는 이유
  - 저장 효율성: 데이터 레코드의 저장 오버헤드를 최소화하는 방식으로 파일을 구성할 수 있다.
  - 접근 효율성: 최소한의 단계로 원하는 레코드를 찾을 수 있다.
  - 갱신 효율성: 디스크 쓰기를 최소화하는 방식으로 레코드를 갱신할 수 있다.
- 데이터베이스 시스템은 여러 필드로 구성된 데이터 레코드를 테이블 형식으로 저장하며 일반적으로 각 테이블을 별도의 파일에 저장한다.
- 테이블의 레코드는 인덱스를 사용해서 찾고 인덱스는 요청마다 테이블 전체를 읽지 않고 데이터를 효율적으로 검색할 수 있는 자료구조다. (인덱스를 사용하는 쿼리를 사용하면?)
- 데이터베이스 시스템은 데이터 파일(실제 레코드)과 인덱스 파일(레코드에 대한 메타데이터)을 분리한다.
- 새로운 레코드와 업데이트된 레코드는 키-값 쌍의 형식으로 저장한다
- 대부분의 데이터베이스 시스템은 데이터를 즉시 페이지에서 삭제하지 않고 삭제 마커를 사용해서 남겨두고 가비지컬렉션에 의해 최신 레코드로 생신되며 기존 값은 삭제된다.



### 데이터 파일

- 데이터 파일은 인덱스 구조형 테이블, 힙 구조형 테이블 또는 해시 구조형 테이블을 기반으로 한다.
- 힙 파일은 레코드를 특정 순서를 따르지 않고 대체로 삽입 순서대로 저장하지 않아 새로운 페이지가 추가돼도 파일을 재구성하지 않아도 된다. 하지만 데이터 검색 시 데이터의 실제 위치를 가리키는 인덱스가 필요하다.
- 해시 파일은 레코드를 각 키의 해시 값에 해당하는 버킷에 저장한다. 버킷 내 레코드는 삽입 순서대로 저장하거나 키 순서로 정렬하면 조회 속도를 향상시킬 수 있다.
- 인덱스 구조형 테이블은 인덱스에 실제 데이터 레코드를 저장한다.
- 인덱스에 데이터 레코드를 저장하면 디스크 탐색 횟수를 최소 1회 줄일 수 있다. (인덱스로만 필요한 데이터를 찾으면?)

### 인덱스 파일

- 인덱스는 디스크에 저장된 데이터 레코드를 효율적으로 검색할 수 있는 자료구조다.
- 인덱스 파일은 데이터 레코드를 식별할 수 있는 키 또는 기본키를 데이터 파일에서 해당 레코드의 위치에 매핑한다.
- 일반적으로 기본 인덱스는 기본 키 또는 기본키 역할을 할 수 있는 여러 키의 조합에 대한 인덱스고 나머지는 모두 보조 인덱스라고 한다.
- 보조 인덱스는 데이터 레코드를 직접 가리키거나 해당 레코드의 기본 키를 저장한다.
- 여러 보조 인덱스가 같은 레코드를 가리킬 수 있고 하나의 레코드는 여러 다른 필드로 식별될 수 있고 다양한 인덱스를 사용해 검색할 수 있다.
- 기본 인덱스 파일은 키별로 하나의 레코드만 가리키는 반면, 보조 인덱스는 키별로 여러 레코드를 가리킬 수도 있다.
- 실제 데이터 레코드의 정렬 순서와 검색 키의 정렬 순서가 같은 인덱스를 클러스터형 인덱스라고 한다. (기본 인덱스)
- 데이터가 다른 파일에 저장돼 있고 인덱스 키를 기준으로 정렬되지 않은 인덱스는 비클러스터형 인덱스라고 한다.
- 대부분의 데이터베이스 시스템은 데이터 레코드를 식별할 수 있는 칼럼의 집합을 내부 키로 사용한다. 기본키를 설정하지 않은 경우 내부적으로 기본 키를 자동 생성한다.

### 기본 인덱스를 통한 간접 참조

- 데이터를 직접 참조하면 디스크 탐색 오버헤드가 줄어든다. 하지만 레코드를 갱신하거나 위치를 변경할 때마다 포인터를 수정해야하는 오버헤드가 있다.
- 기본 인덱스를 통해 간접 참조하면 포인터 갱신 비용이 줄어들지만 레코드 위치를 찾는 과정이 추가된다.
- 읽기 작업이 많은 워크로드에서는 인덱스 개수가 여러 개여도 괜찮지만 쓰기 작업이 많은 워크로드에서는 인덱스 개수가 많으면 포인터 갱신이 문제가 될 수 있다. 따라서 일부 시스템은 오프셋 대신 기본 키를 사용해 데이터를 간접 참조한다.

## 버퍼링과 불변성, 순서화

- 데이터베이스 자료 구조에는 세 가지 공통점이 있다. 
  1. 버퍼링을 사용한다는점
  2. 불변파일을 사용한다는점
  3. 저장할 때 값의 순서를 유지한다는 점



`버퍼링`

- 데이터를 디스크에 쓰기 전에 일부를 메모리에 저장하는 것
- 디스크와 데이터를 주고받는 가장 작은 전송단위는 블록이므로 블록을 채워서 쓰는 것이 바람직하기 때문이다.

`가변성 (또는 불변성)`

- 파일 일부를 읽고 갱신한 뒤에 똑같은 자리에 다시 쓸지에 대한 여부를 나타내는 속성
- 불변 구조에서는 한 번 쓴 파일 내용은 고칠 수 없다.

`순서화`

- 디스크 페이지에 데이터 레코드를 키 순서로 저장하는 것을 의미한다.
- 정렬 순서상 인접한 키는 디스크의 연속된 세그먼트에 저장된다.
- 순서화는 특정 데이터 레코드 검색뿐만 아니라 효율적인 범위 스캔에 매우 중요한 속성이다.



## 요약 







# #2 B-트리 개요

- 불변성은 저장 구조의 설계와 구현 방식을 결정하는 중요한 속성이다.
- 대부분의 가변 자료 구조는 데이터 삽입 및 삭제, 업데이트 시 데이터 저장 위치에 새로운 데이터를 바로 쓰는 인플레이스 업데이트 방식을 사용한다.
- 스토리지 엔진은 동시성 제어, 슬롯 페이지 구조 같은 방식으로 여러 버전의 레코드를 데이터베이스에 저장하지만 쉽게 이해할 수 있게 책에서 모든 키는 고유한 위치에 저장된 한 개의 데이터 레코드를 가리킨다고 가정한다. 
- B-트리는 가장 많이 사용되는 자료 구조 중 하나다.



## 이진 탐색 트리

- 이진 탐색 트리는 정렬된 인메모리 자료 구조로 키-값 쌍 검색에 사용된다.
- BST는 키와 두 개의 자식 포인터(left, right)가 저장된 여러 노드로 구성된다.
- 각 노드의 키는 왼쪽 서브트리의 모든 노드보다 크고 오른쪽 서브트리의 모든 키보다 작다.
- 루트에서부터 왼쪽 포인터를 따라 리프 레벨까지 내려가면 트리에서 가장 작은 키와 해당 값이 저장된 노드가 있다. 마찬가지로 오른쪽 포인터의 가장 밑은 가장 큰 키가 저장된 노드가 있다.



### 트리 밸런싱

- 노드 삽입 작업에는 특정 패턴이 없어 삽입하는 값에 따라 트리가 불균형해질 수 있다. 이 경우 선형 복잡도(On)을 가질 수 있다.
- 균형 트리란 노드 개수가 N일때 높이가 log2N이고 두 서브트리의 높이 차이가 최대 1인 트리다.
- 균형 트리는 왼쪽 오른쪽 2개의 노드 포인터가 있기 때문에 탐색 공간이 평균적으로 절반이 줄어든다. 따라서 탐색 시간 복잡도는 O(log2N)이다.
- 새로운 노드 추가로 인해 트리가 치우치지 않도록 노드 삽입 후 트리의 균형을 유지해야 한다.



### 디스크 기반 스토리지용 트리

- 트리의 팬아웃(노드가 가질 수 있는 최대 자식 노드의 개수)이 낮기 때문에 트리 밸런싱, 노드 재배치, 포인터 갱신이 자주 발생한다. 따라서 BST는 높은 트리 유지 비용 때문에 디스크 기반 자료구조로는 적합하지 않다.
- BST를 디스크에서 제어하면 몇 가지 문제에 직면한다.
  - 지역성: 노드는 키 순서에 따라 삽입되지 않기 때문에 새로운 노드와 부모 노드가 가까운 위치에 저장되지 않을 수 있다.
  - 트리의 높이: 팬아웃이 2이기 때문에 높이는 전체 노드 수의 로그 값이다.
- 디스크 기반 BST의 구현은 지역성을 고려하지 않기 때문에 최악의 경우 비교 횟수만큼 디스크 탐색이 필요하다.
- 디스크 저장에 적합한 트리의 두가지 특성
  - 인접한 키의 지역성을 높이기 위한 높은 팬아웃
  - 트리 순회 중 디스크 탐색을 줄이기 위한 낮은 트리 높이



## 디스크 기반 자료 구조

- 자료구조도 일부는 디스크에 알맞고 일부는 메모리 저장에 적합하다.
- 데이터베이스 자료구조는 디스크와 같은 영속적 저장 매체의 한계를 반드시 고려해야 한다.
- 디스크 기반 자료구조는 메모리에 데이터 전부를 저장할 수 없을 때 주로 사용한다.
- 데이터 일부를 메모리에 캐시하고 나머지는 효율적으로 접근할 수 있는 형태로 디스크에 저장한다.

### 하드 디스크 드라이브

- 디스크에서는 탐색 작업이 랜덤 읽기 비용의 많은 부분을 차지한다. 디스크를 회전하고 읽기/쓰기용 헤드를 원하는 위치까지 물리적으로 옮겨야 하기 때문이다.
- 디스크 탐색 작업 이후의 연속된 바이트 읽기/쓰기는 상대적으로 비용이 낮다.
- 디스크의 최소 전송 단위는 섹터이고 모든 작업은 최소 한 개의 섹터를 읽거나 쓴다. 섹터의 크기는 보통 512바이트에서 4kb 사이다.
- 물리적 헤드 이동은 HDD 작업 중 가장 비용이 높은 작업이다. 따라서 디스크에서 연속된 메모리 섹터를 읽거나 쓰는 순차적 I/O를 극대화해야 한다.

### 솔리드 스테이트 드라이브

- 디스크와 달리 SSD는 물리적으로 움직이는 부품이 없다.(no 회전 디스크, no 헤드)
- SSD는 메모리 셀로 구성된다.
- 셀을 연결하면 스트링이 되고 스트링의 배열이 페이지를 이룬다. 페이지가 모이면 블록이 된다.
- 내부 구현 방식에 따라 셀은 한 개 또는 여러 개의 비트를 저장한다.
- 페이지는 보통 2~16kb, 블록은 64~512개의 페이지로 구성된다.
- 블록의 집합은 플레인, 플레인의 집합은 다이라고 부르며 SSD는 한 개 이상의 다이로 구성된다.
- 페이지는 읽고 쓸 수 있는 가장 작은 단위이고 비어 있는 메모리 셀에서만 쓸 수 있다.
- 반면 삭제할 수 있는 가장 작은 단위는 페이지가 아니라 블록이다. 이 때문에 삭제 블록이라고 불기도 한다.
- 페이지 ID를 실제 위치와 매핑하고 비어 있거나 쓰여진 혹은 삭제된 페이지를 관리하는 플래시 메모리 컨트롤러를 플래시 변환 레이어(FTL)라고 부른다.
- HDD와 SSD는 개별 바이트 단위가 아닌 메모리 청크 단위로 데이터를 참조해서 대부분의 운영체제에는 블록 디바이스 추상화 계층이 있다.
- 이 계층은 하드 디스크의 내부 구조를 추상화하고 I/O 작업을 내부적으로 버퍼링 한다. 블록 디바이스에서 하나의 워드를 읽으면 해당 워드를 포함하는 블록 전체를 읽게 된다. 이는 디스크 기반 자료 구조에서 항상 염두에 둬야 할 중요한 제약사항이다.
- SSD는 HDD와 다르게 랜덤과 순차I/O의 구분이 중요하지 않다. 둘 사이의 레이턴시가 매우 작기 때문이다.
- 전체 블록 단위로 쓰거나 같은 블록에 대한 쓰기 작업을 모아 한 번에 처리할 수 있다면 I/O 작업 수를 줄일 수 있다.



## 디스크 기반 자료

- 효율적인 디스크 기반 자료 구조 설계가 어려운 이유는 디스크 접근 비용 탓도 있지만 가장 작은 작업 단위가 블록이라는 제약 때문이다.
- 블록의 특정 위치를 참조하려면 블록 전체를 읽어야 한다. 이와 같은 특성을 고려해 자료구조를 설계해야 한다.
- 대부분의 경우 디스크 기반 자료 구조에서는 포인터를 직접 관리해야한다.
- 디스크 기반 자료구조에 긴 종속 관계 사슬이 만들어지면 유지관리가 어렵고 구조가 매우 복잡해진다. 따라서 전체 포인터수를 제안하고 저장 범위를 최소화하는 편이 좋다.
- 정리하자면 디스크 기반 자료구조는 저장 매체의 구조를 고려해서 설계해야 하며 디스크 접근 횟수를 최소화해야 한다. 내부 구조를 최적화하고 지역성을 높여 페이지를 넘나드는 포인터를 최소화해야 한다 
- 디스크 기반 자료 구조는 팬아웃이 높고 높이가 낮을 때 가장 이상적이다.
- B-트리는 팬아웃을 크게하고 높이와 노드 포인터 개수, 밸런싱 빈도를 줄인 트리이다.



### 유비쿼터스 B-트리

- B-트리는 검색 항목을 빠르게 찾을 수 있는 계층형 자료 구조다.
- B-트리는 키의 순서가 보장되는 자료구조다. 노드 키를 기준으로 정렬해서 저장하기 때문에 이진 탐색과 같은 알고리즘을 사용해 특정 키를 찾을 수 있다.
- B-트리의 탐색 시간 복잡도는 로그 시간이다. (40억개의 키에서 특정 키를 찾는데 32번의 비교가 필요하다)
- B-트리를 사용해 포인트 쿼리와 범위 쿼리를 효율적으로 수행할 수 있다.



### B-트리 계층

- B-트리는 여러 노드로 구성된다.
- 각 노드는 최대 N개의 키와 N+1개의 자식 노드 포인터를 저장한다.
- 노드는 논리적으로 다음 세 개의 계층으로 나눌 수 있다.
  - 루트 노드
    - 트리의 최상위 노드로 부모 노드가 없다.
  - 내부 노드
    - 루트와 리프 노드를 연결하는 모든 노드. 트리에는 일반적으로 한 레벨 이상의 내부 노드가 있다.
  - 리프 노드
    - 자식 노드가 없는 트리의 최하위 계층 노드



사진

- B-트리는 페이지 기반 자료구조이기 때문에 노드와 페이지가 같은 의미로 쓰이기도 한다.
- 보유 가능한 노드 용량과 실제로 보유하고 있는 키의 개수의 비율을 점유율이라고 한다.
- B-트리에서 각 노드에 저장할 수 있는 최대 키 수를 의미하는 팬아웃은 중요한 속성이다.
- 팬아웃이 높으면 트리의 균형을 유지하는 데 필요한 트리 구조 변경 비용을 낮출 수 있고 키와 포인터 같은 블록 또는 연속된 블록에 저장해 불필요한 탐색을 줄일 수 있다.
- B-트리는 루프와 내부, 리프노드가 포함된 모든 레벨에 값을 저장할 수 있는 반면에 B+트리는 리프 노드에만 값을 저장할 수 있다. (참고)





### 구분 키

- B-트리 노드에 저장된 키를 인덱스 엔트리, 구분 키, 또는 디바이더 셀이라고 부른다.
- 각 키는 트리를 해당 키 범위의 서브트리로 분할한다.
- 키는 정렬되어 있어서 이진 검색에 사용할 수 있다.
- 노드의 첫번째 포인터는 해당 키보다 작은 키가 저장된 서브트리를 가리키고 마지막 키는 해당 키보다 같거나 큰 키가 저장된 서브트리를 갖는다. 나머지 포인터들은 두 키 사이의 서브트리를 가리킨다.
- 이중 연결리스트 형식의 포인터를 사용해 양방향으로 탐색할 수 있도록 B-트리를 구현하기도 한다.
- 하향식으로 만들어지는 이진트리와 반대로 B-트리는 상향식으로 트리를 구성한다. 리프노드가 많아질수록 내부 노드와 높이가 증가한다.
- B-트리는 나중에 삽입 및 업데이트될 노드의 공간을 미리 확보해둬서 공간 활용률이 최대 50%까지 낮아질 수 있지만 높은 점유율은 B-트리 성능에 부정적인 영향을 미치지 않는다.



### B-트리 탐색의 시간 복잡도

- B-트리 탐색의 시간 복잡도는 블록 전송 횟수와 비교 횟수라는 두 가지 관점에서 계산할 수 있다.
- 전송횟수 관점에서 복잡도는 최대 logk M개의 페이지에 접근해야 한다.
- 비교횟수 관점에서는 이진탐색을 사용해 키를 찾기 때문에 log2 M이다.



### B-트리 탐색 알고리즘

- B-트리에서 특정 값을 찾으려면 루트에서 리프 레벨까지 순회해야한다.
- 포인트 쿼리와 업데이트, 삭제 작업에는 정확히 일치하는 키를 찾아야하고 범위 스캔과 노드 삽입시에는 대상 키의 바로 앞의 키를 찾아야 한다.
- 탐색 알고리즘은 루트 노드에서부터 이진 검색을 수행한다. 낮은 레벨로 내려갈 수록 검색 범위가 줄어든다.
- 포인트 쿼리는 특정 키를 찾거나 찾는 데 실패하면 완료되고 범위 스캔은 첫번째 키 값 쌍에서 시작해 범위 끝에 도달하거나 조건을 충족하지 않는 노드를 찾을때까지 형제 노드 포인터를 따라간다.



### 키 개수

- 키와 자식 오프셋 수를 계산하는 다양한 방식이 있지만 결과는 동일하고 설명하는 방식이 다를뿐이다.
- 이 책에서는 N을 키의 개수로 정의한다.



### B-트리 노드 분할

- B-트리에 새로운 노드를 삽입하려면 우선 대상 리프를 찾고 삽입할 위치를 결정해야 한다.

- 리프노드에 남은 공간이 없는 노드를 오버플로우 상태라고 한다. 오버플로우 상태의 노드에 새로운 키를 삽입하려면 노드를 분할해야 한다. 

- 노드 분할 조건

  - 리프노드: 노드에 최대 N개의 키-값 쌍을 저장할 수 있고 새로운 키-값 쌍을 삽입 시 용량이 초과되는 경우
  - 리프가 아닌 노드: 노드에 최대 N+1 개의 포인터를 저장할 수 있고 포인터 추가시 용량이 초과되는 경우

- 노드 분할은 새로운 노드를 할당해 키의 절반을 새로운 노드로 옮기고 첫 번째 키와 포인터를 부모 노드에 추가하는 방식으로 이뤄진다. 이때 이러한 키는 승급했다고 표현하고 분할이 발생한 키를 분할 지점이라고 부른다.

- 부모 노드에 승급 키와 포인터를 추가할 공간이 없을 경우 부모 노드로 분할하고 이는 루트 노드까지 재귀적으로 전파될 수 있다.

- 트리에 용량이 부족하면 기존의 루트와 생성된 형제 노드는 다음 레벨로 강등되고 트리의 높이가 한 레벨 증가한다.

- 루트 노드 분할로 인해 새로운 루트 노드를 할당하거나 노드 병합으로 인해 새로운 루트 노드가 형성되면 트리의 높이가 변한다. 반면 리프와 내부 노드 레벨에서는 트리가 수평으로만 확장한다.

  

  

사진

- 키 11삽입으로 인해 남은 공간이 없는 비 리프노드를 분할하는 과정
- 새로운 노드를 생성하고 N/2 + 1번 인덱스로부터 옮긴다. 분할 저짐의 키는 부모 노드로 승급된다.



사진



- 리프가 아닌 노드의 분할은 항상 하위 레벨 노드의 분할로 인해 발생하기 때문에 새로운 포인터가 추가된다.
- 리프 노드가 분할되는지 리프가 아닌 노드가 분할되는지는 상관 없다. 리프 노드를 분할할 경우 키와 값을 모두 옮긴다.
- 분할이 완료되면 두 노드 중에 새로운 키를 상비할 노드를 선택한다. 구분 키의 속성에 따라 삽입할 키가 승급된 키보다 작자면 분할 노드에 삽입하고 더 크다면 새로운 노드에 삽입한다.
- 노드 분할 요약
  1. 새로운 노드를 할당한다.
  2. 분할 노드 키의 절반을 새로운 노드로 복사한다.
  3. 새로운 키를 알맞은 노드에 삽입한다.
  4. 분할 노드의 부모 노드에 분할 키와 새로운 노드를 가리키는 포인터를 추가한다.





### B-트리 노드 병합

- 키를 삭제하는 경우에는 우선 대상 키가 포함된 리프 노드를 찾는다.
- 키를 삭제하다보면 노드에 저장된 값이 너무 적은 경우가 생기는데 이때는 형제 노드들을 병합해야한다. 이런 상황을 언더플로우라고 한다.
- 언더플로우가 발생하는 시나리오
  - 형제 노드의 부모가 같고 한 개의 노드로 합칠 수 있다면 두 노드를 병합한다.
  - 한 개의 노드로 합칠 수 없다면 키를 두 노드 사이에 재분배하고 균형을 맞춘다.
- 노드 병합 조건 정리
  - 리프 노드: 노드에 최대 N개의 키-값 쌍을 저장할 수 있고 두 노드의 총 키-값 쌍의 수가 N보다 작은 경우
  - 리프가 아닌 노드: 노드에 최대 N+1개의 포인터를 저장할 수 있고 두 노드의 포인터 수의 합이 N+1 보다 작은 경우



사진



- 노드 병합은 이미 키가 이미 삭제되었다고 가정할 때 다음 세 단계로 이뤄진다.
  1. 모든 키를 오른쪽 노드에서 왼쪽 노드로 복사한다.
  2. 부모 노드에서 오른쪽 노드를 가리키는 포인터를 제거한다.
  3. 오른쪽 노드를 제거한다



## 요약

- 이진 탐색 트리는 복잡도 관점에서 보면 디스크에 더 적합하지만 팬아웃이 낮고 균형을 맞추기 위한 재배치와 포인터 업데이트가 자주 발생하기 때문에 디스크에 적합하지 않다.
- B-트리는 각 노드에 더 많은 키를 저장할 수 있고 리밸런싱 작업 빈도가 더 낮은 자료구조이다.
- B-트리는 노드 삽입 또는 삭제 시 노드 분할과 병합을 통해 트리의 균형을 유지한다.
- 트리의 높이는 최소한으로 유지해야 하고 키 추가시 사용 가능한 공간이 남아 있는 노드를 적극 활용해야 한다.
- 디스크 기반 B-트리의 특성은 인메모리 B-트리 설계 시에도 똑같이 적용할 수 있다. 디스크 기반 B-트리 구현 시 디스크에 노드를 저장하는 방식과 데이터 인코딩 포맷을 신중하게 결정해야 한다.



# #3 파일 포맷

- 가상 메모리를 사용하면 오프셋을 직접 관리하지 않아도 되지만 디스크는 대상 파일 내의 오프셋을 직접 지정해야 하며, 디스크상의 표현을 메인 메모리에서 읽을 수 있는 형태로 변환해야 한다.
- 효율적인 디스크 기반 자료구조를 설계하려면 위와 같은 차이점을 알아야한다. 따라서 생성, 수정, 해석이 쉬운 파일 포맷이 무엇인지 알아야 한다.



## 파일 포맷의 중요성

- 파일 포맷 설계는 메모리 모델이 unmanaged인 프로그래밍 언어로 자료구조럴 설계하는 것과 여러모로 유사하다.
- 자료구조를 효율적으로 디스크에 저장하려면 영속적 저장 장치의 특성을 이해하고 빠르게 접근할 수 있는 형태로 저장해야 한다. 더 나아가 바이너리 포맷 구조를 설계하고 효율적으로 데이터를 직렬화하고 역직렬화하는 수단이 있어야 한다.
- 운영처제와 파일시스템에서 일부 문제를 해결해주기도하지만 디스크 기반 자료구조를 구현할 때는 신경써야할 부분이 많다.



## 바이너리 인코딩

- 데이터를 효율적으로 디스크에 저장하려면 컴팩트하고 직렬화와 역직렬화가 쉬운 포맷으로 인코딩해야 한다.
- 효율적인 페이지 레이아웃을 설계하는 데 중요한 몇가지 원칙

### 기본형

- 키와 값은 integer, date, string 등의 지정된 자료형이 있고 바이너리 형식으로 표현할 수 있다.
- 대부분의 숫자형은 고정 길이 자료형이다. 멀티바이트 숫장형을 사용할 때 인코딩과 디코딩은 모두 같은 바이트순서를 사용해야 한다.
- 엔디언은 바이트 배열 순서를 정의한다.
  - 빅 엔디언: 최상위 바이트 MSB 부터 시작해서 내림차순으로 저장한다. MSB를 가장 낮은 주소에 저장한다.
  - 리틀 엔디언: 최하위 바이트부터 높은 자리 바이트까지 오름차순으로 저장한다.
- 레코드는 숫자, 문자열, 불리언과 같은 기본형과 이들의 조합으로 구성된다.
- 레코드는 바이트 시퀀스 형태로 네트워크를 통해 전송되고 디스크에 저장한다. 따라서 전송 및 쓰기 전에 우선 직렬화하고 수신 및 읽기 전에 역직렬화해야한다.
- 기본 형 데이터리를 바이너리 형식으로 표현하는 방법
  - byte형: 8비트
  - short: 16비트 (2바이트)
  - int: 32비트 (4바이트)
  - long 64비트 (8바이트)



### 문자열과 가변 길이 데이터

- 복잡한 자료형은 여러 기본형 값을 조합해 하나의 자료구조로 만들고 고정 길이 배열 또는 포인터를 사용해 다른 메모리 영역을 참조한다.
- 문자열과 가변 길이 자료형은 배열의 크기 또는 문자열의 길이를 나타내는 숫자와 size 바이트 크기의 실제 데이터로 구성된다.
- 이런 형식을 UCSD문자열 또는 파스칼 문자열이라고 부른다.



### 비트 묶음형 데이터: 불리언, 열거형, 플래그

**불리언**

- 불리언 자료형은 단일 바이트 또는 true와 false를 1과 0으로 인코딩한 값을 표현한다.
- 불리언은 바이트 전체를 사용하는것이 낭비이기 때문에 8개의 불리언 값을 묶어서 쓰기도 한다.(packed 불리언)
- 비트의 값이 1이면 설정 상태, 0이라면 미설정 또는 빈 상태라고 표현한다.

**열거형**

- Enum은 열거형의 줄임말이며 숫자를 표현한다.
- 바이너리 포맷과 통신 프로토콜에서 주로 사용된다.
- 가짓수가 적고 자주 반속해서 나오는 값을 표현할 때 사용한다.

**플래그**

- packed 불리언과 열거형의 조합인 플래그
- 플래그는 상호배타적이지 않은 불리언 값들을 표현할 수 있다.



...



# #4 B-트리 구현

## 페이지 헤더

- 페이지 헤더에는 탐색과 유지보수, 최적화에 필요한 페이지에 대한 정보를 저장한다.
- 일반적으로 플래그와 레이아웃, 셀 개수, 오프셋과 같은 몇가지 유용한 메타데이터를 저장한다.



### 매직 넘버

- 파일 헤더 또는 페이지 헤더에 주로 저장하는 또 다른 값으로 매직 넘버가 있다.
- 일반적으로 매직 넘버는 상수 값을 포함하는 멀티바이트 블록이며 페이지의 종류와 버전과 같은 정보를 포함한다.
- 매직넘버는 검증과 상태체크에도 사용된다.

### 형제 링크

- 좌우에 있는 형제 페이지를 가리키도록 순방향 링크와 역방향 링크를 저장하는 방식으로 트리를 구현하기도 한다.
- 약간의 복잡도가 증가하긴 하지만 이렇게 하면 부모 노드로 거슬러 올라가지 않고 이웃 노드를 바로 참조할 수 있다.
- 하지만 형제링크가 없는 트리에서 형제 노드를 찾으려면 반드시 부모 노드를 거쳐야 하는 오버헤드가 있다.

![4-1](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-1.jpeg)

- 이 방법의 단점은 노드 분할과 병합 시 링크를 업데이트해야 한다는 점이다. 분할과 병합의 대상 노드 뿐만 아니라 형제 노드까지 업데이트하기 위해 추가적으로 잠금이 필요할 수 있다.





### 가장 오른쪽 포인터

- B-트리의 구분 키의 주 역할은 트리를 서브트리로 분할하고 탐색할 수 있도록 하는 것이다. 따라서 자식 페이지를 가리키는 포인터가 키보다 반드시 하나 더 있다.
- 각 구분 키에는 자식 포인터가 있고 마지막 포인터는 어떤 키와도 연관되지 않기 때문에 따로 저장한다.

![4-2](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-2.jpeg)

- 가장 오른쪽 자식 노드가 분할되고 부모에 새로운 셀이 추가되면 부모의 마지막 포인터도 다시 설정해야 한다.
- 노드 분할 시 마지막 포인터는 새로운 노드를 가리키도록 업데이트 된다.

![4-3](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-3.jpeg)



### 하이 키

- 각 트리의 노드의 가장 오른쪽포인터와 노드의 하이 키를 함께 저장하는 방법도 있다.
- 하이 키는 현재 노드의 서브트리에 저장된 가장 큰 키를 나타낸다. 이런 형식을 Blink-트리라고 부르며 PostgreSQL에서 사용된다.
- Blink-트리는 각 노드에 Kn+1 키를 하나씩 더 추가로 저장한다. 이 키는 포인터 Pn이 가리키는 서브트리에서 가장 큰 키를 나타낸다. 따라서 이 키 값이 해당 서브트리에 저장할 수 있는 최댓값이 된다.

![4-4](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-4.jpeg)

- 하이 키를 저장하는 트리는 각 노드에 저장된 키와 포인터 개수가 같으며 모든 셀에는 키-포인터 쌍이 존재한다. 이에 따라 엣지 케이스가 줄어들고 가장 오른쪽 포인터의 처리가 단순해진다.
- 첫번째 방식에서 최댓값은 +⚯ 이지만 두번째 방식은 K3으로 줄어든다.

![4-5](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-5.jpeg)



### 오버플로우 페이지

- 노드의 크기와 트리 팬아웃은 고정 값이며 동적으로 변하지 않는다.
- B-트리 알고리즘에서 모든 노드는 일정 개수의 키를 유지해야하지만 노드에 저장된 값의 크기가 크다면 개수가 가득차지 않더라도 고정 크기의 페이지에는 남은 공간이 없을 수 있다. 페이지 변경을 하는건 비효율적이지만 페이지 크기 증가 및 확장은 불가피하다.
- 여러 페이지를 연결하면 데이터를 다른 연속된 공간으로 복사하지 않고 가변 크기 노드를 구현할 수 있다. 예를 들어 기본 크기가 4K인 페이지에 삽입된 값의 합이 4K 이상이면 임의의 크기를 추가 할당하지 않고 4K 단위로 노드를 확장하고 할당된 새로운 페이지를 원본 페이지에 연결하면 된다. 이렇게 새로 할당된 페이지를 오버플로우 페이지라고 한다.
- 대부분의 B-트리는 고정 크기의 바이트만 노드에 저장하고 나머지는 오버플로우 페이지에 저장한다.
- 고정 크기는 노드 크기를 팬아웃으로 나눈 값이다. 따라서 페이지에 최소 max_payload_byte 바이트 만큼의 공간이 항상 남아 있기 때문에 페이지에 공간이 부족한 상황은 발생하지 않는다.
- 삽입된 데이터가 max_payload_size보다 크다면 해당 노드에 연결된오버플로우 페이지가 있는지 확인해야 한다.

![4-6](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-6.jpeg)

- 오버 플로우 페이지는 기본 페이지와 마찬가지로 단편화가 발생할 수 있고 새로운 데이터를 쓰기 위해 공간을 회수하거나 필요없는 페이지를 삭제해야 한다. 
- 첫 오버플로우 페이지를 할당할 때에는 해당 페이지의 ID를 기본 페이지의 헤더에 저장한다. 오버플로우 페이지가 하나로는 충분하지 않아 여러 개가 되는 경우에는 각 헤더에 다음 페이지 ID를 저장하고 연결한다. 따라서 특정 데이터를 찾기 위해 여러 오버플로우 페이지를 확인해야 할 수 있다.



## 이진 검색

- 트리의 노드에서 특정 키는 이진 검색 알고리즘을 사용해 찾을 수 있다.
- 이진 검색 알고리즘은 정렬된 배열과 검색 키를 인자로 받고 숫자를 반환한다. 양수라면 이 값은 배열에서의 위치를 의미하고 음수라면 해당 키는 배열에 없고 반환 값은 삽입 위치를 의미한다.
- 삽입 위치는 검색 키보다 첫 번째로 큰 값의 위치다. 삽입시에는 삽입 위치 이후 모든 원소를 한 자리씩 이동시켜 새로운 값을 위한 공간을 만들고 삽입한다.
- 검색 키보다 큰 첫번째 값을 찾고 해당 서브트리를 가리키는 포인터를 따라가는 탐색 경로가 중요하다.



### 간접 포인터를 사용한 이진 검색

- B-트리 페이지의 셀은 삽입 순서대로 저장되며 셀 오프셋만 논리적 순서를 유지한다.
- 페이지 셀의 이진 검색은 먼저 중간 셀 오프셋을 선택하고 해당 위치의 키와 검색 키를 비교해 왼쪽과 오른쪽 중 진행 방향을 결정한다.

 ![4-6](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-7.jpeg)





## 분할과 병합

- 노드의 분할과 병합은 상위 레벨까지 전파될 수 있다 따라서 분할하는 리프 노드나 병합하는 두 리프 노드로부터 루트 노드까지 순회할 수 있어야 한다. 
- 하위 레벨의 페이지는 항상 바로 위 레벨을 통해서 참조되기 때문에 부모 노드에 대한 정보는 디스크에 저장하지 않아도 된다.
- 형제 포인터와 마찬가지로 부모 포인터도 부모가 변경되면 알맞게 갱신해야 한다.
- 일부 트리 구현에서는 형제 포인터 사용으로 인해 발생할 수 있는 데드락을 제거하기 위해 리프 노드 탐색에 부모 포인터를 사용하기도 한다.
- 부모 노드에서부터 재귀적으로 포인터를 따라 내려가면 형제 노드를 찾을 수 있다. 같은 부모를 공유하는 모든 형제 노드를 순회하고 난 후에는 재귀적으로 상위 레벨로 올라가 검색을 계속한다. 그러다보면 결국 루트 노드에 도달하고 또 다시 리프 레벨까지 내려가게 된다.



### 탐색 경로

- 부모 포인터를 저장 및 유지하는 대신 리프 노드까지의 경로를 저장해두고 노드 삽입과 삭제로 인해 분할 및 병합이 발생했을 때 저장된 경로를 역순으로 순회하는 방법도 있다.
- B-트리의 구조를 변경하기 위해서는 루트에서 리프 노드 또는 삽입 지점까지 트리를 순회해야 한다. 리프 노드에 도달하기 전에 분할 또는 병합의 발생 여부를 미리 알 수 없기 때문에 탐색 경로를 저장해야 한다.
- 탐색 경로는 루트부터 방문한 모든 노드에 대한 정보를 포함한다. 이러한 정보는 분할 또는 병합이 상위 레벨로 전파될 때 노드를 거슬러  올라가는데 쓴다.
- 노드가 분할되거나 병합되는 경우 저장된 탐색 경로를 이용해 부모 노드로 승급된 키의 삽입 지점을 찾고 필요하다면 더 상위 레벨 노드까지 차례대로 방문하면서 구조를 변경한다. 경로를 저장한 스택은 메모리에 유지한다.

![4-6](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-8.jpeg)

- 루트에서 리프 노드까지 방문한 노드를 가리키는 포인터와 해당 셀의 인덱스가 포함된 탐색 경로를 수집하는 과정
- 리프 노드를 분할해야 한다면 스택의 최상위 요소를 참조해 부모 노드를 찾을 수 있다. 부모 노드에 공간이 남아 있다면 탐색 경로에 저장된 셀 인덱스 위치에 새로운 셀을 추가한다. 만약 공간이 부족하다면 부모 노드도 분할해야 한다. 루트 노드에 도달해 스택에 더 이상 요소가 없거나 분할하지 않아도 될 때까지 이 과정을 반복한다.



## 리밸런싱

- 일부 B-트리 구현에서는 분할과 병합 비용을 줄이기 위해 레벨 내에서 노드를 리밸런싱하거나 분할 및 병합 작업을 수행하기 전에 상대적으로 빈 공간이 많은 노드로 원소를 이동한다. 이 경우 리밸런싱 비용이 높아질 수도 있지만 노드의 점유율을 높이고 트리의 높이는 낮출 수 있다.
- 노드 삽입과 삭제 시 로드 밸런싱을 수행하는 방법도 있다.
- 효율적인 공간 활용을 위해 노드를 분할하는 대신 형제 노드로 일부 원소를 옮기고 삽입할 공간을 확보한다. 삭제 작업도 마찬가지로 형제 노드와 병합하는 대신 노드가 절반 이상 찬 상태를 유지하도록 형제노드에서 일부 원소를 가져올 수 있다.
- B*-트리는 형제 노드가 모두 가득 찰 때까지 이웃 간에 원소를 분산한다.
- B*-트리 알고리즘은 노드를 절반이 비어 있는 두 개의 노드로 분할하는 것이 아니라 두 노드를 2/3가 채워진 3개의 노드로 분할한다. SQLite에서 사용하는 알고리즘이다. 이 방식은 분할을 지연시켜 평균 점유율을 높일 수 있지만 상태를 관리하는 로직이 추가로 필요하다. 높은 점유율로 인해 트리 높이가 낮아지고 순회 시 참조하는 페이지 수가 줄어들면 검색의 효율성도 높아진다.

![4-9](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-9.jpeg)

- 리밸런싱은 많은 데이터베이스 구현에서 사용되는 유용한 기술이다.



## 오른쪽 추가 기법

- 많은 데이터베이스 시스템에서 자동 증가 값을 기본 인덱스로 사용하는데 이 방식을 사용하면 모든 삽입이 인덱스 끝에서만 발생하기 때문에 대부분의 노드 분할 작업이 각 레벨의 가장 오른쪽 노드에서 일어나게 된다. 
- 삽입하는 키가 가장 오른쪽 페이지의 첫 번째 키보다 크고 가장 오른쪽 페이지에 새로운 키를 삽입할 공간이 충분하면 탐색 과정을 건너 뛰고 캐시된 페이지의 알맞은 위치에 키를 바로 삽입한다. PostgreSQL은 이와 같은 방식을 패스트패스라고 부른다.
- SQLite도 퀵밸런스라는 비슷한 개념을 사용한다.

### 벌크 로딩

- 정렬된 데이터를 벌크 로딩하거나 트리를 재구성할 때에는 우측 추가 알고리즘을 사용할 수 있다.
- 데이터가 이미 정렬돼 있기 때문에 벌크 로딩 시 트리의 가장 오른쪽에만 데이터를 추가하면 된다.
- 이 경우에는 트리를 하위 레벨부터 상향식으로 한 레벨씩 구성하거나 상위 레벨 노드에 충분한 수의 포인터를 넣을 수 있을 만큼 하위 레벨의 노드가 추가됐을 때 상위 노드를 쓰는 방식으로 트리를 구성하면 노드의 분할과 병합을 피할 수 있다.
- 미리 정렬된 데이터를 리프 레벨에 페이지 단위로 저장하는 방식으로 벌크 로딩을 구현할 수도 있다.
- B-트리는 항상 최하위 레벨부터 상향식으로 구성하기 때문에 상위 레벨을 만들기 전에 리프 레벨 전체를 먼저 구성할 수 있다. 그렇기 때문에 상위 레벨을 구성하는 시점에는 이미 모든 자식 포인터가 준비돼 있다. 이 방식은 디스크에서 분할이나 병합을 할 필요가 없고 트리를 구성할 때 트리의 최소한의 부분만 메모리에 저장하면 된다는 장점이 있다.
- 불변 B-트리도 같은 방식으로 만들 수 있는데 수정이 불가능하기 때문에 추가적인 공간 오버헤드가 발생하지 않아 점유율과 성능이 향상된다.



## 압축

- 원시 데이터를 압축하지 않고 저장하면 상당한 저장 오버헤드가 발생하기 때문에 대부분의 데이터베이스는 공간을 절약할 수 있는 압축 알고리즘을 제공한다.
- 압축 알고리즘에서 접근 속도와 압축률은 반비례 관계다. 압축률이 높을수록 데이터 크기는 감소하지만 더 많은 자원을 소모해야한다.
- 파일 전체를 압축하면 비효율적이기 때문에 파일 전체가 아닌 페이지 단위로 압축하는게 알맞다.
- 페이지는 다른 페이지와 독립적으로 압축 및 압축 해제할 수 있기 때문에 페이지 로딩 및 플러시와 같이 수행할 수 있다. (파일 전체는 파일 단위로 압축, 해제를 해야함)
- 일반적으로 데이터 전송이 블록 단위로 이뤄지기 때문에 압축된 페이지가 블록의 극히 일부분을 차지하는 경우에는 실제 데이터보다 더 많은 바이트를 읽는 비효율적인 상황이 발생한다.

![4-10](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-10.jpeg)

- (a)를 가져올 때는 다른 페이지의 일부분도 포함이되고 (b)를 요청할 때는 여러 페이지를 요청해야 한다.
- 압축 라이브러리를 선택할 때는 메모리 오버헤드, 압축 성능, 압축 해제 성능, 압축률을 중점적으로 비교해야 한다.



## 정리와 유지

- 지금까지 본 B-트리를 정리하면 B-트리는 데이터 무결성 유지와 공간 회수, 오버헤드 최소화, 페이지 정렬 등의 다양한 작업이 쿼리 수행과 더불어 수행된다.
- 추가로 내부 노드의 분할과 병합, 리프 레벨 노드에 대한 삽입 및 업데이트, 삭제 등이 계속 일어나면 단편화가 발생해 논리적 공간은 충분하지만 연속된 물리적 공간이 부족한 페이지가 생긴다 (단편화)

![4-10](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-11.jpeg)



### 업데이트와 삭제로 인한 단편화

- 삭제된 리프 레벨의 셀은 헤더에서 오프셋만 제거하고 실제 셀은 남겨둔다. 해당 셀은 더이상 참조할 수 없으며 관련 데이터는 쿼리 대상에서 제외된다.
- 페이지가 분할되면 페이지의 일부는 더 이상 참조할 수 없기 때문에 해당 오프셋은 삭제된다. 삭제된 오프셋의 셀은 새로운 데이터로 덮어쓰거나 정리 단계에서 가비지 컬렉터가 처리한다.
- 일부 데이터베이스는 MVCC를 위해 바로 삭제하지 않고 가비지 컬렉션을 수행한다. 해당 셀을 아무런 스레드도 사용하고 있지 않을 때 셀을 정리한다.
- 삭제된 셀의 오프셋만 삭제하고 다른 셀을 재배치하거나 공간 확보를 위해 물리적으로 셀을 삭제하지 않기 때문에 사용 가능한 바이트가 페이지에 흩어져 있을 수 있다. 이와 같은 현상을 단편화라고 하며 이는 제거해야 하는 현상이다.
- 일반적으로 데이터를 삽입하려면 셀 크기에 맞는 연속된 바이트 블록이 필요하다. 단편화된 여러 조각을 모아 연속된 공간을 확보하려면 페이지를 재구성해야 한다.

### 페이지 단편화

- 공간 회수 및 페이지를 재구성하는 과정을 컴팩션, 정리 또는 유지보수라고 한다. 페이지에 사용 가능한 물리적 공간이 부족한 경우 컴팩션과 쓰기를 동시에 수행할 수 있다.
- 컴팩션은 데드셀이 차지하는 공간을 회수하고 셀을 논리적 순서로 재정렬한다. 재구성된 페이지는 파일에서의 위치가 변경될 수 있다.



## 요약

- B-트리 구현과 관련된 몇 가지 주제
  - 페이지 헤더: 헤더에 저장되는 정보
  - 가장 오른쪽 포인터: 구분 키와 쌍이 아닌 포인터를 처리하는 방법
  - 하이 키: 노드에 저장할 수 있는 최대 키
  - 오버플로우 페이지: 사이즈가 큰 가변 길이 레코드를 고정 사이즈 페이지에 저장하는 방법
- 루트 노드에서 리프 노트까지 트리 순회와 군련된 주제
  - 간접 포인터를 사용한 이진 검색
  - 부모 포인터와 탐색 경로를 사용해 탐색 경로를 저장하는 방법
- 트리 최적화 기법, 유지보수 방법
  - 리밸런싱: 분할과 병합 횟수를 줄이기 위해 이웃 노드로 일부 요소를 이동
  - 오른쪽 추가 기법: 새로운 데이터가 빠르게 삽입될 때 셀을 분할하는 대신 데이터를 트리의 가장 오른쪽 셀에 추가하는 방법
  - 벌크 로딩: 정렬된 데이터를 사용해 B-트리 효율적으로 구성하는 방법
  - 가비지 컬렉션: 페이지를 재구성하고 키 순으로 셀 정렬 및 사용하지 않는 셀의 공간을 회수하는 작업



























