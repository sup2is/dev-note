



# Database Internals









데이터베이스 관리 시스템의 주 목적은 데이터를 안정적으로 저장하고 사용자에게 제공하는 것이다.



# #1 소개 및 개요

## DBMS 구조

- 표준화된 DBMS 구조란 존재하지 않는다. 모든 데이터베이스 구조는 다르고 내부 컴포넌트의 경계를 명확히 나누고 정의하기 어렵다.
- DBMS는 클라이언트/서버 모델을 기반으로 한다.
- 클라이언트의 요청은 트랜스포트 서브시스템을 통해 전달된다. 요청은 쿼리 형태이고 트랜스포트 서브시스템은 데이터 클러스터 노드 사이의 통신에도 사용된다.
- 트랜스포트 서브시스템은 쿼리를 쿼리 프로세서에게 전달한다. 쿼리 프로세서는 쿼리를 해석 분석 및 검증한다. 쿼리의 의미를 파악한 뒤에 액세스 제어를 진행할 수 있다.
- 분석된 쿼리는 쿼리 옵티마이저에게 전달된다. 쿼리에서 논리적으로 불가능한 부분과 중복을 제거한 뒤에 내부 데이터 통계 등을 기반으로 가장 효율적인 쿼리 실행 계획을 생성한다. 그외에도 인덱스 순서 선택, 카디널리티 예측, 액세스 메서드 선택등의 최적화 단계를 처리한다.
- 쿼리는 일반적으로 실행 계획 형태로 표현되고 다양한 쿼리 실행계획이 있을 수 있으며 옵티마이저는 이 가운데 가장 효율적인 실행 계획을 선택한다.
- 선택된 실행 계획은 로컬 및 원격 실행의 결과를 결합하는 실행 엔진이 수행한다.
- 로컬 쿼리는 스토리지 엔진이 수행한다. 스토리지 엔진은 다음과 같이 명확한 역할을 담당하는 컴포넌트로 구성되어 있다.
  - 트랜잭션 매니저: 트랜잭션을 스케줄링하고 데이터베이스 상태의 논리적 일관성을 보장한다.
  - 잠금 매니저: 트랜잭션에서 접근하는 데이터베이스 객체에 대한 잠금을 제어한다. 동시 수행 작업이 물리적 데이터 무결성을 침해하지 않도록 제어한다.
  - 액세스 메서드: 디스크에 저장된 데이터에 대한 접근 및 저장 방식을 정의한다. 힙 파일과 B-트리 또는 LSM트리 등의 자료구조를 사용한다.
  - 버퍼 매니저: 데이터 페이지를 메모리에 캐시한다.
  - 복구 매니저: 로그를 유지 관리하고 장애 발생시 시스템을 복구한다.
- 트랜잭션과 잠금 매너지는 동시성을 제어한다. 

## 인메모리 DBMS 대 디스크 기반 DBMS

- 인메모리 DBMS는 메모리에 데이터를 저장하고 디스크는 복구와 로그 저장 용도로 사용한다.
- 디스크 기반 DBMS는 데이터를 디스크에 저장하고 메모리는 캐시 용도로 사용한다.
- 메모리는 디스크보다 훨씬 더 빠르게 데이터에 접근하지만 RAM은 디스크보다 가격이 비싸다.
- 인메모리 DBMS는 디스크 기반 데이터베이스와 비교해 기본 저장 매체뿐만 아니라 내부 자료 구조와 설계 및 최적화 방식도 모두 다르다.
- 메모리를 주 저장 매체로 사용하는 이유는 성능과 상대적으로 낮은 데이터 접근 비용, 세밀한 접근 단위 때문이다.
- 인메모리 DBMS의 가장 큰 단점은 RAM의 휘발성과 높은 가격이다.
- 디스크는 메모리보다 유지관리 측면에서 더 간단하고 비용이 낮다.
- 비휘발성 램 기술이 더 대중화되면 이런 상황은 뒤바뀔 수 있다.

### 인메모리 데이터베이스의 지속성

- 인메모리 DBMS는 데이터의 지속성을 보장하고 데이터 손실을 방지하기 위해 데이터를 디스크에 백업한다.
- 모든 작업은 로그 파일에 작업 내용을 순차적으로 기록해야 완료된다.
- 인메모리 시스템에서는 시스템 시작과 복구 시 모든 로그를 재수행하지 않기 위해 백업본을 유지하고 백업본은 디스크 기반 자료구조에 순서대로 저장하는데 일반적으로 수정 내용은 비동기적으로 갱신하며 I/O 작업을 최소화하기 위해 배치 단위로 백업한다.
- 로그 레코드는 일반적으로 배치 단위로 백업한다. 배치 작업이 완료되면 백업본은 특정 시점의 데이터베이스 스냅숏이기 때문에 이 시점 이전의 로그는 삭제해도 된다. 이러한 작업을 가리켜 체크포인트를 남긴다고 표현한다.
- 클라이언트의 요청을 블로킹하지 않고 디스크에 저장된 백업본을 최신 로그 데이터와 동기화하면 복구 시간을 단축할 수 있다.
- 메모리는 포인터를 사용해 비교적으로 빠르게 참조할 수 있고 랜덤 메모리 접근 속도는 랜덤 디스크 접근 보다 월등히 빠르다.

## 칼럼형 DBMS 대 로우형 DBMS

- 대부분의 데이터베이스는 열과 행으로 구성된 테이블에 데이터 레코드를 저장한다.
- 사용자 정보 테이블의 모든 사용자 이름은 같은 형식으로 같은 칼럼에 저장하고 논리적으로 같은 레코드에 속하는 값의 집합을 로우라고 부른다.
- 칼럼 저장 방식은 테이블을 수직 분할하고 로우 저장 방식은 수평 분할한다.
- MySQL과 PostgreSQL 등 대부분의 전통적인 관계형 데이터베이스는 로우형 DBMS다.
- MonetDB C-Store는 선구적인 칼럼형 오픈소스 데이터베이스다.

### 로우형 데이터 레이아웃

- 로우형 DBMS는 데이터 레코드를 로우 형식으로 저장한다.
- 이 방식은 여러 필드의 값일 고유 식별 키로 구분할 수 있는 레코드 형식에 적합하다.
- 특정 사용자의 모든 필드는 일반적으로 함께 요청되는 경우가 많다.
- 레코드를 생성할 때에도 레코드의 모든 필드를 함께 쓴다.
- 로우형 DBMS는 한 개의 로우씩 접근하는 경우 적합하다. 로우 단위로 저장하면 공간 지역성을 극대화할 수 있다.
- 특정 사용자의 모든 정보를 읽을 때는 효율적이지만 여러 사용자의 특정 필드를 읽을 때는 비효율적이다.



### 칼럼형 데이터 레이아웃

- 칼럼형 DBMS는 데이터를 로우 단위가 아니라 수직 분할해 칼럼 단위로 저장한다.
- 칼럼형 DBMS는 데이터의 추세와 평균 등을 계산하는 집계 분석 작업에 적합하다.
- 칼럼형 DBMS에서 조인과 필터링, 다중 로우 집계 등을 위해 튜플을 재구성하려면 칼럼 사이의 관계를 정의하는 메타데이터가 필요하다.
- 아파치 Parquet, 아파치 ORC, RCFile과 같은 칼럼 기반 파일 포맷과 아파치 Kudu, ClickHouse 등이 있다.

### 차이점과 최적화 기법

- 로우형 DBMS와 칼럼형 DBMS의 차이점을 데이터를 저장하는 방식만으로 설명하기에는 부족함이 많다.
- 데이터 레이아웃은 칼럼형 DBMS에서 목표하고 있는 여러 최적화 단계 중 하나일 뿐이다.
- 같은 칼럼의 여러 값을 한 번에 읽으면 캐시 활용도와 처리 효율성이 높아진다.
- 자료형별로 저장하면 압축률도 증가한다.
- 칼럼형과 로우형 DBMS중 어떤 것을 사용할지 선택하려면 먼저 액세스 패턴을 파악해야 한다.
- 데이터를 레코드 단위로 접근하고 일반 쿼리와 범위 스캔 요청이 많다면 로우형 DBMS가 적합하다. 반면 많은 로우를 스캔하거나 일부 칼럼에 대한 집계 작업이 많다면 칼럼형 DBMS가 더 적합할 수 있다.



### 와이드 칼럼 스토어

- 빅테이블과 HBase와 같은 와이드 칼럼 스토어는 일반적인 칼럼형 DBMS와는 구분해야 한다.
- 와이드 칼럼 스토어는 데이터를 다차원 맵으로 표현하고 여러 칼럼을 칼럼 패밀리 단위로 저장한다.
- 칼럼 패밀리의 데이터는 로우 형식으로 저장한다. 이 방식은 키 단위 액세스 패턴에 적합하다.
- 이 방식의 가장 대표적인 구현은 웹테이블이다.

```
{
	"com.cnn.www" : {
		contents: {
			t6: html: "<html> ..."
			t5: html: "<html> ..."
			t3: html: "<html> ..."
		}
		anchor: {
			t9: cnnsi.com: "CNN"
			t8: my.look.ca: "CNN.com"
		}
	}
}
```

- 웹테이블은 다차원 맵에 데이터를 정렬해서 저장하고 계층 인덱스를 생성한다.

- 각 로우는 로우 키와 매핑하고 관련 있는 칼럼끼리 칼럼 패킬리(contents와 anchor 필드) 단위로 저장한다.

- 칼럼 패밀리의 칼럼은 칼럼 패밀리 이름과 수식자(html, cnnsi.com. my.look.ca)로 구성된 칼럼 키로 식별할 수 있다.

- 칼럼 패밀리는 시간별로 여러 버전의 데이터를 유지한다 이 자료구조를 사용해 상위 레벨 요소와 관련된 변수를 검색할 수 있다.

- 와이드 칼럼 스토어의 논리적 구조는 이해하기 쉽지만 실제 저장 방식은 복잡하다.

  

## 데이터 파일과 인덱스 파일

- 데이터베이스 시스템의 주 목적은 데이터를 저장하고 빠르게 데이터를 검색하는 것이다.
- 데이터베이스가 일반 파일을 사용하지 않는 이유
  - 저장 효율성: 데이터 레코드의 저장 오버헤드를 최소화하는 방식으로 파일을 구성할 수 있다.
  - 접근 효율성: 최소한의 단계로 원하는 레코드를 찾을 수 있다.
  - 갱신 효율성: 디스크 쓰기를 최소화하는 방식으로 레코드를 갱신할 수 있다.
- 데이터베이스 시스템은 여러 필드로 구성된 데이터 레코드를 테이블 형식으로 저장하며 일반적으로 각 테이블을 별도의 파일에 저장한다.
- 테이블의 레코드는 인덱스를 사용해서 찾고 인덱스는 요청마다 테이블 전체를 읽지 않고 데이터를 효율적으로 검색할 수 있는 자료구조다. (인덱스를 사용하는 쿼리를 사용하면?)
- 데이터베이스 시스템은 데이터 파일(실제 레코드)과 인덱스 파일(레코드에 대한 메타데이터)을 분리한다.
- 새로운 레코드와 업데이트된 레코드는 키-값 쌍의 형식으로 저장한다
- 대부분의 데이터베이스 시스템은 데이터를 즉시 페이지에서 삭제하지 않고 삭제 마커를 사용해서 남겨두고 가비지컬렉션에 의해 최신 레코드로 생신되며 기존 값은 삭제된다.



### 데이터 파일

- 데이터 파일은 인덱스 구조형 테이블, 힙 구조형 테이블 또는 해시 구조형 테이블을 기반으로 한다.
- 힙 파일은 레코드를 특정 순서를 따르지 않고 대체로 삽입 순서대로 저장하지 않아 새로운 페이지가 추가돼도 파일을 재구성하지 않아도 된다. 하지만 데이터 검색 시 데이터의 실제 위치를 가리키는 인덱스가 필요하다.
- 해시 파일은 레코드를 각 키의 해시 값에 해당하는 버킷에 저장한다. 버킷 내 레코드는 삽입 순서대로 저장하거나 키 순서로 정렬하면 조회 속도를 향상시킬 수 있다.
- 인덱스 구조형 테이블은 인덱스에 실제 데이터 레코드를 저장한다.
- 인덱스에 데이터 레코드를 저장하면 디스크 탐색 횟수를 최소 1회 줄일 수 있다. (인덱스로만 필요한 데이터를 찾으면?)

### 인덱스 파일

- 인덱스는 디스크에 저장된 데이터 레코드를 효율적으로 검색할 수 있는 자료구조다.
- 인덱스 파일은 데이터 레코드를 식별할 수 있는 키 또는 기본키를 데이터 파일에서 해당 레코드의 위치에 매핑한다.
- 일반적으로 기본 인덱스는 기본 키 또는 기본키 역할을 할 수 있는 여러 키의 조합에 대한 인덱스고 나머지는 모두 보조 인덱스라고 한다.
- 보조 인덱스는 데이터 레코드를 직접 가리키거나 해당 레코드의 기본 키를 저장한다.
- 여러 보조 인덱스가 같은 레코드를 가리킬 수 있고 하나의 레코드는 여러 다른 필드로 식별될 수 있고 다양한 인덱스를 사용해 검색할 수 있다.
- 기본 인덱스 파일은 키별로 하나의 레코드만 가리키는 반면, 보조 인덱스는 키별로 여러 레코드를 가리킬 수도 있다.
- 실제 데이터 레코드의 정렬 순서와 검색 키의 정렬 순서가 같은 인덱스를 클러스터형 인덱스라고 한다. (기본 인덱스)
- 데이터가 다른 파일에 저장돼 있고 인덱스 키를 기준으로 정렬되지 않은 인덱스는 비클러스터형 인덱스라고 한다.
- 대부분의 데이터베이스 시스템은 데이터 레코드를 식별할 수 있는 칼럼의 집합을 내부 키로 사용한다. 기본키를 설정하지 않은 경우 내부적으로 기본 키를 자동 생성한다.

### 기본 인덱스를 통한 간접 참조

- 데이터를 직접 참조하면 디스크 탐색 오버헤드가 줄어든다. 하지만 레코드를 갱신하거나 위치를 변경할 때마다 포인터를 수정해야하는 오버헤드가 있다.
- 기본 인덱스를 통해 간접 참조하면 포인터 갱신 비용이 줄어들지만 레코드 위치를 찾는 과정이 추가된다.
- 읽기 작업이 많은 워크로드에서는 인덱스 개수가 여러 개여도 괜찮지만 쓰기 작업이 많은 워크로드에서는 인덱스 개수가 많으면 포인터 갱신이 문제가 될 수 있다. 따라서 일부 시스템은 오프셋 대신 기본 키를 사용해 데이터를 간접 참조한다.

## 버퍼링과 불변성, 순서화

- 데이터베이스 자료 구조에는 세 가지 공통점이 있다. 
  1. 버퍼링을 사용한다는점
  2. 불변파일을 사용한다는점
  3. 저장할 때 값의 순서를 유지한다는 점



`버퍼링`

- 데이터를 디스크에 쓰기 전에 일부를 메모리에 저장하는 것
- 디스크와 데이터를 주고받는 가장 작은 전송단위는 블록이므로 블록을 채워서 쓰는 것이 바람직하기 때문이다.

`가변성 (또는 불변성)`

- 파일 일부를 읽고 갱신한 뒤에 똑같은 자리에 다시 쓸지에 대한 여부를 나타내는 속성
- 불변 구조에서는 한 번 쓴 파일 내용은 고칠 수 없다.

`순서화`

- 디스크 페이지에 데이터 레코드를 키 순서로 저장하는 것을 의미한다.
- 정렬 순서상 인접한 키는 디스크의 연속된 세그먼트에 저장된다.
- 순서화는 특정 데이터 레코드 검색뿐만 아니라 효율적인 범위 스캔에 매우 중요한 속성이다.



## 요약 







# #2 B-트리 개요

- 불변성은 저장 구조의 설계와 구현 방식을 결정하는 중요한 속성이다.
- 대부분의 가변 자료 구조는 데이터 삽입 및 삭제, 업데이트 시 데이터 저장 위치에 새로운 데이터를 바로 쓰는 인플레이스 업데이트 방식을 사용한다.
- 스토리지 엔진은 동시성 제어, 슬롯 페이지 구조 같은 방식으로 여러 버전의 레코드를 데이터베이스에 저장하지만 쉽게 이해할 수 있게 책에서 모든 키는 고유한 위치에 저장된 한 개의 데이터 레코드를 가리킨다고 가정한다. 
- B-트리는 가장 많이 사용되는 자료 구조 중 하나다.



## 이진 탐색 트리

- 이진 탐색 트리는 정렬된 인메모리 자료 구조로 키-값 쌍 검색에 사용된다.
- BST는 키와 두 개의 자식 포인터(left, right)가 저장된 여러 노드로 구성된다.
- 각 노드의 키는 왼쪽 서브트리의 모든 노드보다 크고 오른쪽 서브트리의 모든 키보다 작다.
- 루트에서부터 왼쪽 포인터를 따라 리프 레벨까지 내려가면 트리에서 가장 작은 키와 해당 값이 저장된 노드가 있다. 마찬가지로 오른쪽 포인터의 가장 밑은 가장 큰 키가 저장된 노드가 있다.



### 트리 밸런싱

- 노드 삽입 작업에는 특정 패턴이 없어 삽입하는 값에 따라 트리가 불균형해질 수 있다. 이 경우 선형 복잡도(On)을 가질 수 있다.
- 균형 트리란 노드 개수가 N일때 높이가 log2N이고 두 서브트리의 높이 차이가 최대 1인 트리다.
- 균형 트리는 왼쪽 오른쪽 2개의 노드 포인터가 있기 때문에 탐색 공간이 평균적으로 절반이 줄어든다. 따라서 탐색 시간 복잡도는 O(log2N)이다.
- 새로운 노드 추가로 인해 트리가 치우치지 않도록 노드 삽입 후 트리의 균형을 유지해야 한다.



### 디스크 기반 스토리지용 트리

- 트리의 팬아웃(노드가 가질 수 있는 최대 자식 노드의 개수)이 낮기 때문에 트리 밸런싱, 노드 재배치, 포인터 갱신이 자주 발생한다. 따라서 BST는 높은 트리 유지 비용 때문에 디스크 기반 자료구조로는 적합하지 않다.
- BST를 디스크에서 제어하면 몇 가지 문제에 직면한다.
  - 지역성: 노드는 키 순서에 따라 삽입되지 않기 때문에 새로운 노드와 부모 노드가 가까운 위치에 저장되지 않을 수 있다.
  - 트리의 높이: 팬아웃이 2이기 때문에 높이는 전체 노드 수의 로그 값이다.
- 디스크 기반 BST의 구현은 지역성을 고려하지 않기 때문에 최악의 경우 비교 횟수만큼 디스크 탐색이 필요하다.
- 디스크 저장에 적합한 트리의 두가지 특성
  - 인접한 키의 지역성을 높이기 위한 높은 팬아웃
  - 트리 순회 중 디스크 탐색을 줄이기 위한 낮은 트리 높이



## 디스크 기반 자료 구조

- 자료구조도 일부는 디스크에 알맞고 일부는 메모리 저장에 적합하다.
- 데이터베이스 자료구조는 디스크와 같은 영속적 저장 매체의 한계를 반드시 고려해야 한다.
- 디스크 기반 자료구조는 메모리에 데이터 전부를 저장할 수 없을 때 주로 사용한다.
- 데이터 일부를 메모리에 캐시하고 나머지는 효율적으로 접근할 수 있는 형태로 디스크에 저장한다.

### 하드 디스크 드라이브

- 디스크에서는 탐색 작업이 랜덤 읽기 비용의 많은 부분을 차지한다. 디스크를 회전하고 읽기/쓰기용 헤드를 원하는 위치까지 물리적으로 옮겨야 하기 때문이다.
- 디스크 탐색 작업 이후의 연속된 바이트 읽기/쓰기는 상대적으로 비용이 낮다.
- 디스크의 최소 전송 단위는 섹터이고 모든 작업은 최소 한 개의 섹터를 읽거나 쓴다. 섹터의 크기는 보통 512바이트에서 4kb 사이다.
- 물리적 헤드 이동은 HDD 작업 중 가장 비용이 높은 작업이다. 따라서 디스크에서 연속된 메모리 섹터를 읽거나 쓰는 순차적 I/O를 극대화해야 한다.

### 솔리드 스테이트 드라이브

- 디스크와 달리 SSD는 물리적으로 움직이는 부품이 없다.(no 회전 디스크, no 헤드)
- SSD는 메모리 셀로 구성된다.
- 셀을 연결하면 스트링이 되고 스트링의 배열이 페이지를 이룬다. 페이지가 모이면 블록이 된다.
- 내부 구현 방식에 따라 셀은 한 개 또는 여러 개의 비트를 저장한다.
- 페이지는 보통 2~16kb, 블록은 64~512개의 페이지로 구성된다.
- 블록의 집합은 플레인, 플레인의 집합은 다이라고 부르며 SSD는 한 개 이상의 다이로 구성된다.
- 페이지는 읽고 쓸 수 있는 가장 작은 단위이고 비어 있는 메모리 셀에서만 쓸 수 있다.
- 반면 삭제할 수 있는 가장 작은 단위는 페이지가 아니라 블록이다. 이 때문에 삭제 블록이라고 불기도 한다.
- 페이지 ID를 실제 위치와 매핑하고 비어 있거나 쓰여진 혹은 삭제된 페이지를 관리하는 플래시 메모리 컨트롤러를 플래시 변환 레이어(FTL)라고 부른다.
- HDD와 SSD는 개별 바이트 단위가 아닌 메모리 청크 단위로 데이터를 참조해서 대부분의 운영체제에는 블록 디바이스 추상화 계층이 있다.
- 이 계층은 하드 디스크의 내부 구조를 추상화하고 I/O 작업을 내부적으로 버퍼링 한다. 블록 디바이스에서 하나의 워드를 읽으면 해당 워드를 포함하는 블록 전체를 읽게 된다. 이는 디스크 기반 자료 구조에서 항상 염두에 둬야 할 중요한 제약사항이다.
- SSD는 HDD와 다르게 랜덤과 순차I/O의 구분이 중요하지 않다. 둘 사이의 레이턴시가 매우 작기 때문이다.
- 전체 블록 단위로 쓰거나 같은 블록에 대한 쓰기 작업을 모아 한 번에 처리할 수 있다면 I/O 작업 수를 줄일 수 있다.



## 디스크 기반 자료

- 효율적인 디스크 기반 자료 구조 설계가 어려운 이유는 디스크 접근 비용 탓도 있지만 가장 작은 작업 단위가 블록이라는 제약 때문이다.
- 블록의 특정 위치를 참조하려면 블록 전체를 읽어야 한다. 이와 같은 특성을 고려해 자료구조를 설계해야 한다.
- 대부분의 경우 디스크 기반 자료 구조에서는 포인터를 직접 관리해야한다.
- 디스크 기반 자료구조에 긴 종속 관계 사슬이 만들어지면 유지관리가 어렵고 구조가 매우 복잡해진다. 따라서 전체 포인터수를 제안하고 저장 범위를 최소화하는 편이 좋다.
- 정리하자면 디스크 기반 자료구조는 저장 매체의 구조를 고려해서 설계해야 하며 디스크 접근 횟수를 최소화해야 한다. 내부 구조를 최적화하고 지역성을 높여 페이지를 넘나드는 포인터를 최소화해야 한다 
- 디스크 기반 자료 구조는 팬아웃이 높고 높이가 낮을 때 가장 이상적이다.
- B-트리는 팬아웃을 크게하고 높이와 노드 포인터 개수, 밸런싱 빈도를 줄인 트리이다.



### 유비쿼터스 B-트리

- B-트리는 검색 항목을 빠르게 찾을 수 있는 계층형 자료 구조다.
- B-트리는 키의 순서가 보장되는 자료구조다. 노드 키를 기준으로 정렬해서 저장하기 때문에 이진 탐색과 같은 알고리즘을 사용해 특정 키를 찾을 수 있다.
- B-트리의 탐색 시간 복잡도는 로그 시간이다. (40억개의 키에서 특정 키를 찾는데 32번의 비교가 필요하다)
- B-트리를 사용해 포인트 쿼리와 범위 쿼리를 효율적으로 수행할 수 있다.



### B-트리 계층

- B-트리는 여러 노드로 구성된다.
- 각 노드는 최대 N개의 키와 N+1개의 자식 노드 포인터를 저장한다.
- 노드는 논리적으로 다음 세 개의 계층으로 나눌 수 있다.
  - 루트 노드
    - 트리의 최상위 노드로 부모 노드가 없다.
  - 내부 노드
    - 루트와 리프 노드를 연결하는 모든 노드. 트리에는 일반적으로 한 레벨 이상의 내부 노드가 있다.
  - 리프 노드
    - 자식 노드가 없는 트리의 최하위 계층 노드



사진

- B-트리는 페이지 기반 자료구조이기 때문에 노드와 페이지가 같은 의미로 쓰이기도 한다.
- 보유 가능한 노드 용량과 실제로 보유하고 있는 키의 개수의 비율을 점유율이라고 한다.
- B-트리에서 각 노드에 저장할 수 있는 최대 키 수를 의미하는 팬아웃은 중요한 속성이다.
- 팬아웃이 높으면 트리의 균형을 유지하는 데 필요한 트리 구조 변경 비용을 낮출 수 있고 키와 포인터 같은 블록 또는 연속된 블록에 저장해 불필요한 탐색을 줄일 수 있다.
- B-트리는 루프와 내부, 리프노드가 포함된 모든 레벨에 값을 저장할 수 있는 반면에 B+트리는 리프 노드에만 값을 저장할 수 있다. (참고)





### 구분 키

- B-트리 노드에 저장된 키를 인덱스 엔트리, 구분 키, 또는 디바이더 셀이라고 부른다.
- 각 키는 트리를 해당 키 범위의 서브트리로 분할한다.
- 키는 정렬되어 있어서 이진 검색에 사용할 수 있다.
- 노드의 첫번째 포인터는 해당 키보다 작은 키가 저장된 서브트리를 가리키고 마지막 키는 해당 키보다 같거나 큰 키가 저장된 서브트리를 갖는다. 나머지 포인터들은 두 키 사이의 서브트리를 가리킨다.
- 이중 연결리스트 형식의 포인터를 사용해 양방향으로 탐색할 수 있도록 B-트리를 구현하기도 한다.
- 하향식으로 만들어지는 이진트리와 반대로 B-트리는 상향식으로 트리를 구성한다. 리프노드가 많아질수록 내부 노드와 높이가 증가한다.
- B-트리는 나중에 삽입 및 업데이트될 노드의 공간을 미리 확보해둬서 공간 활용률이 최대 50%까지 낮아질 수 있지만 높은 점유율은 B-트리 성능에 부정적인 영향을 미치지 않는다.



### B-트리 탐색의 시간 복잡도

- B-트리 탐색의 시간 복잡도는 블록 전송 횟수와 비교 횟수라는 두 가지 관점에서 계산할 수 있다.
- 전송횟수 관점에서 복잡도는 최대 logk M개의 페이지에 접근해야 한다.
- 비교횟수 관점에서는 이진탐색을 사용해 키를 찾기 때문에 log2 M이다.



### B-트리 탐색 알고리즘

- B-트리에서 특정 값을 찾으려면 루트에서 리프 레벨까지 순회해야한다.
- 포인트 쿼리와 업데이트, 삭제 작업에는 정확히 일치하는 키를 찾아야하고 범위 스캔과 노드 삽입시에는 대상 키의 바로 앞의 키를 찾아야 한다.
- 탐색 알고리즘은 루트 노드에서부터 이진 검색을 수행한다. 낮은 레벨로 내려갈 수록 검색 범위가 줄어든다.
- 포인트 쿼리는 특정 키를 찾거나 찾는 데 실패하면 완료되고 범위 스캔은 첫번째 키 값 쌍에서 시작해 범위 끝에 도달하거나 조건을 충족하지 않는 노드를 찾을때까지 형제 노드 포인터를 따라간다.



### 키 개수

- 키와 자식 오프셋 수를 계산하는 다양한 방식이 있지만 결과는 동일하고 설명하는 방식이 다를뿐이다.
- 이 책에서는 N을 키의 개수로 정의한다.



### B-트리 노드 분할

- B-트리에 새로운 노드를 삽입하려면 우선 대상 리프를 찾고 삽입할 위치를 결정해야 한다.

- 리프노드에 남은 공간이 없는 노드를 오버플로우 상태라고 한다. 오버플로우 상태의 노드에 새로운 키를 삽입하려면 노드를 분할해야 한다. 

- 노드 분할 조건

  - 리프노드: 노드에 최대 N개의 키-값 쌍을 저장할 수 있고 새로운 키-값 쌍을 삽입 시 용량이 초과되는 경우
  - 리프가 아닌 노드: 노드에 최대 N+1 개의 포인터를 저장할 수 있고 포인터 추가시 용량이 초과되는 경우

- 노드 분할은 새로운 노드를 할당해 키의 절반을 새로운 노드로 옮기고 첫 번째 키와 포인터를 부모 노드에 추가하는 방식으로 이뤄진다. 이때 이러한 키는 승급했다고 표현하고 분할이 발생한 키를 분할 지점이라고 부른다.

- 부모 노드에 승급 키와 포인터를 추가할 공간이 없을 경우 부모 노드로 분할하고 이는 루트 노드까지 재귀적으로 전파될 수 있다.

- 트리에 용량이 부족하면 기존의 루트와 생성된 형제 노드는 다음 레벨로 강등되고 트리의 높이가 한 레벨 증가한다.

- 루트 노드 분할로 인해 새로운 루트 노드를 할당하거나 노드 병합으로 인해 새로운 루트 노드가 형성되면 트리의 높이가 변한다. 반면 리프와 내부 노드 레벨에서는 트리가 수평으로만 확장한다.

  

  

사진

- 키 11삽입으로 인해 남은 공간이 없는 비 리프노드를 분할하는 과정
- 새로운 노드를 생성하고 N/2 + 1번 인덱스로부터 옮긴다. 분할 저짐의 키는 부모 노드로 승급된다.



사진



- 리프가 아닌 노드의 분할은 항상 하위 레벨 노드의 분할로 인해 발생하기 때문에 새로운 포인터가 추가된다.
- 리프 노드가 분할되는지 리프가 아닌 노드가 분할되는지는 상관 없다. 리프 노드를 분할할 경우 키와 값을 모두 옮긴다.
- 분할이 완료되면 두 노드 중에 새로운 키를 상비할 노드를 선택한다. 구분 키의 속성에 따라 삽입할 키가 승급된 키보다 작자면 분할 노드에 삽입하고 더 크다면 새로운 노드에 삽입한다.
- 노드 분할 요약
  1. 새로운 노드를 할당한다.
  2. 분할 노드 키의 절반을 새로운 노드로 복사한다.
  3. 새로운 키를 알맞은 노드에 삽입한다.
  4. 분할 노드의 부모 노드에 분할 키와 새로운 노드를 가리키는 포인터를 추가한다.





### B-트리 노드 병합

- 키를 삭제하는 경우에는 우선 대상 키가 포함된 리프 노드를 찾는다.
- 키를 삭제하다보면 노드에 저장된 값이 너무 적은 경우가 생기는데 이때는 형제 노드들을 병합해야한다. 이런 상황을 언더플로우라고 한다.
- 언더플로우가 발생하는 시나리오
  - 형제 노드의 부모가 같고 한 개의 노드로 합칠 수 있다면 두 노드를 병합한다.
  - 한 개의 노드로 합칠 수 없다면 키를 두 노드 사이에 재분배하고 균형을 맞춘다.
- 노드 병합 조건 정리
  - 리프 노드: 노드에 최대 N개의 키-값 쌍을 저장할 수 있고 두 노드의 총 키-값 쌍의 수가 N보다 작은 경우
  - 리프가 아닌 노드: 노드에 최대 N+1개의 포인터를 저장할 수 있고 두 노드의 포인터 수의 합이 N+1 보다 작은 경우



사진



- 노드 병합은 이미 키가 이미 삭제되었다고 가정할 때 다음 세 단계로 이뤄진다.
  1. 모든 키를 오른쪽 노드에서 왼쪽 노드로 복사한다.
  2. 부모 노드에서 오른쪽 노드를 가리키는 포인터를 제거한다.
  3. 오른쪽 노드를 제거한다



## 요약

- 이진 탐색 트리는 복잡도 관점에서 보면 디스크에 더 적합하지만 팬아웃이 낮고 균형을 맞추기 위한 재배치와 포인터 업데이트가 자주 발생하기 때문에 디스크에 적합하지 않다.
- B-트리는 각 노드에 더 많은 키를 저장할 수 있고 리밸런싱 작업 빈도가 더 낮은 자료구조이다.
- B-트리는 노드 삽입 또는 삭제 시 노드 분할과 병합을 통해 트리의 균형을 유지한다.
- 트리의 높이는 최소한으로 유지해야 하고 키 추가시 사용 가능한 공간이 남아 있는 노드를 적극 활용해야 한다.
- 디스크 기반 B-트리의 특성은 인메모리 B-트리 설계 시에도 똑같이 적용할 수 있다. 디스크 기반 B-트리 구현 시 디스크에 노드를 저장하는 방식과 데이터 인코딩 포맷을 신중하게 결정해야 한다.



# #3 파일 포맷

- 가상 메모리를 사용하면 오프셋을 직접 관리하지 않아도 되지만 디스크는 대상 파일 내의 오프셋을 직접 지정해야 하며, 디스크상의 표현을 메인 메모리에서 읽을 수 있는 형태로 변환해야 한다.
- 효율적인 디스크 기반 자료구조를 설계하려면 위와 같은 차이점을 알아야한다. 따라서 생성, 수정, 해석이 쉬운 파일 포맷이 무엇인지 알아야 한다.



## 파일 포맷의 중요성

- 파일 포맷 설계는 메모리 모델이 unmanaged인 프로그래밍 언어로 자료구조럴 설계하는 것과 여러모로 유사하다.
- 자료구조를 효율적으로 디스크에 저장하려면 영속적 저장 장치의 특성을 이해하고 빠르게 접근할 수 있는 형태로 저장해야 한다. 더 나아가 바이너리 포맷 구조를 설계하고 효율적으로 데이터를 직렬화하고 역직렬화하는 수단이 있어야 한다.
- 운영처제와 파일시스템에서 일부 문제를 해결해주기도하지만 디스크 기반 자료구조를 구현할 때는 신경써야할 부분이 많다.



## 바이너리 인코딩

- 데이터를 효율적으로 디스크에 저장하려면 컴팩트하고 직렬화와 역직렬화가 쉬운 포맷으로 인코딩해야 한다.
- 효율적인 페이지 레이아웃을 설계하는 데 중요한 몇가지 원칙

### 기본형

- 키와 값은 integer, date, string 등의 지정된 자료형이 있고 바이너리 형식으로 표현할 수 있다.
- 대부분의 숫자형은 고정 길이 자료형이다. 멀티바이트 숫장형을 사용할 때 인코딩과 디코딩은 모두 같은 바이트순서를 사용해야 한다.
- 엔디언은 바이트 배열 순서를 정의한다.
  - 빅 엔디언: 최상위 바이트 MSB 부터 시작해서 내림차순으로 저장한다. MSB를 가장 낮은 주소에 저장한다.
  - 리틀 엔디언: 최하위 바이트부터 높은 자리 바이트까지 오름차순으로 저장한다.
- 레코드는 숫자, 문자열, 불리언과 같은 기본형과 이들의 조합으로 구성된다.
- 레코드는 바이트 시퀀스 형태로 네트워크를 통해 전송되고 디스크에 저장한다. 따라서 전송 및 쓰기 전에 우선 직렬화하고 수신 및 읽기 전에 역직렬화해야한다.
- 기본 형 데이터리를 바이너리 형식으로 표현하는 방법
  - byte형: 8비트
  - short: 16비트 (2바이트)
  - int: 32비트 (4바이트)
  - long 64비트 (8바이트)



### 문자열과 가변 길이 데이터

- 복잡한 자료형은 여러 기본형 값을 조합해 하나의 자료구조로 만들고 고정 길이 배열 또는 포인터를 사용해 다른 메모리 영역을 참조한다.
- 문자열과 가변 길이 자료형은 배열의 크기 또는 문자열의 길이를 나타내는 숫자와 size 바이트 크기의 실제 데이터로 구성된다.
- 이런 형식을 UCSD문자열 또는 파스칼 문자열이라고 부른다.



### 비트 묶음형 데이터: 불리언, 열거형, 플래그

**불리언**

- 불리언 자료형은 단일 바이트 또는 true와 false를 1과 0으로 인코딩한 값을 표현한다.
- 불리언은 바이트 전체를 사용하는것이 낭비이기 때문에 8개의 불리언 값을 묶어서 쓰기도 한다.(packed 불리언)
- 비트의 값이 1이면 설정 상태, 0이라면 미설정 또는 빈 상태라고 표현한다.

**열거형**

- Enum은 열거형의 줄임말이며 숫자를 표현한다.
- 바이너리 포맷과 통신 프로토콜에서 주로 사용된다.
- 가짓수가 적고 자주 반속해서 나오는 값을 표현할 때 사용한다.

**플래그**

- packed 불리언과 열거형의 조합인 플래그
- 플래그는 상호배타적이지 않은 불리언 값들을 표현할 수 있다.
  - 페이지의 값 보유 여부
  - 특정 값 크기의 고정 또는 가변 여부
  - 특정 노드의 페이지에 오버플로우 발생 여부
- packed 불리언처럼 플래그도 비트마스크와 비트 연산자를 사용해 값을 묶어서 표현할 수 있다.



## 파일 포맷 설계 원칙

- 일반적으로 파일 포맷을 설계할 때 파일을 단일 블록 또는 연속된 여러 블록으로 저장할지. 주소 지정 방식부터 결정해야 한다.
- 대부분의 인플레이스 업데이트 방식을 지원하는 자료 구조는 고정된 페이지 크기를 사용한다. 읽기와 쓰기가 비교적 쉽기 때문이다.
- 추가 전용 자료 구조도 페이지 단위로 쓰는 경우가 많다. 레코드를 순차적으로 추가하고 페이지가 가득 차면 디스크로 플러시한다.
- 일반적으로 파일은 고정 크기의 헤더로 시작하며 끝부분에 고정 크기의 트레일러가 있을 수도 있다. 
- 대부분의 데이터 스토어에는 테이블의 필드 수와 순서, 형식이 고정된 스키마가 있다. 고정된 스키마를 사용하면 필드명을 반복적으로 저장하지 않고 각 위치를 활용해 디스크에 저장되는 데이터를 줄일 수 있다.
- 파일 포맷을 설계하는 데 반드시 따라야하는 규칙은 없고 어떤 형식의 데이터의 포맷을 설계하느냐가 중요하다.
- 데이터베이스 파일은 탐색에 유용한 룩업 테이블을 유지하고 각 레코드의 시작점을 가리키는 오프셋은 헤더와 트레일러 또는 개별 파일에 저장한다.



## 페이지 구조

- 데이터베이스 시스템은 데이터 레코드를 데이터 파일과 인덱스 파일에 저장한다.
- 파일은 여러 파일시스템 블록을 합친 고정 크기의 페이지로 구성되고 블록 크기는 4Kb에서 16Kb까지 다양하다.
- 구조적 관점에서 B-트리 노드는 키와 데이터 레코드 쌍을 저장하는 리프 노드 그리고 키와 다른 노드를 가리키는 포인터를 저장하는 비 리프 노드로 나뉜다.
- B-트리 노드는 단일 페이지 또는 연결된 여러 페이지로 구성된다. 따라서 B-트리 맥락에서 노드와 페이지의 의미는 같다.

사진

- 위 구조의 단점
  - 오른쪽 빈 공간이 아닌 곳에 키 추가 시 여러 원소를 재배치해야 한다.
  - 고정 길이 레코드 저장에 적합하지만 가변 길이 레코드를 효율적으로 관리 및 저장할 수 없다.



## 슬롯 페이지

- 가변 길이 레코드 저장 시 발생하는 가장 큰 문제는 삭제된 레코드의 공간을 회수하는 공간관리다.
- 페이지를 여러 개의 고정 길이 세그먼트로 분할하면 가변 길이 레코드를 저장할 수 있지만 공간 낭비는 피할 수 없다.
- 정리하면 페이지 포맷은 다음 조건을 충족해야 한다.
  - 최소한의 오버헤드로 가변 길이 레코드 저장
  - 삭제된 레코드의 메모리 회수
  - 페이지의 레코드를 정확한 위치와 상관없이 참조
- 슬롯 페이지 또는 슬롯 디렉터리를 사용하면 문자열, 블랍과 같은 가변 길이 자료형을 효율적으로 저장할 수 있다. (PostgreSQL)
- 페이지는 슬롯 또는 셀의 집합이다. 페이지 내 독립적인 영역에 포인터와 셀을 분리해서 저장한다. 따라서 레코드의 논리적 순서는 셀을 가리키는 포인터의 순서로 제어할 수 있다. 레코드 삭제 시 해당 포인터를 삭제하거나 null로 설정하면 된다.
- 슬롯 페이지에는 페이지와 셀에 대한 중요한 정보를 저장하는 고정 길이의 헤더가 있다.



사진



- 슬롯 페이지는 앞서 설명한 조건을 모두 충족한다.
  - 오버헤드 최소화: 실제 레코드 위치를 가리키는 포인터 배열 사용이 유일한 오버헤드다.
  - 공간 회수: 단편화 제거 및 페이지 재구성을 통해 공간을 회수할 수 있다.
  - 동적 레이아웃: 슬롯은 ID를 통해 페이지 외부에서 접근하기 때문에 정확한 위치는 페이지 내부에서만 필요하다.



## 셀 구조

- 플래그와 열거형, 기본형을 사용해 셀 레이아웃을 설계할 수 있다.
- 셀을 병합하면 페이지가 되고 페이지를 병합하면 트리가 된다. 셀은 키 셀과 키-값 셀로 나눌 수 있다.
- 키 셀에는 구분 키와 인접한 두 키 사이의 페이지를 가리키는 포인터가 들어가고 키-값 셀에는 키와 헤당 데이터 레코드가 들어간다.
- 키 셀의 구성 요소
  - 셀 종류
  - 키 길이
  - 셀이 가리키는 자식 페이지의 ID
  - 키 바이트 수
- 키-값 셀의 구성 요소
  - 셀 종류
  - 키 길이
  - 값 길이
  - 키 바이트
  - 데이터 레코드 바이트



## 셀 병합으로 슬롯 페이지 구성

- 슬롯 페이지 방식을 사용하면 셀을 병합해 페이지를 구성할 수 있다.



사진

- 키는 삽입 순서대로 추가하고 셀 오프셋 포인터는 키 순서대로 저장하면 논리적 순서를 유지할 수 있다. 이 방식은 셀을 삽입 또는 업데이트, 삭제해도 다른 셀을 재배치하지 않아도 된다.
- 셀은 삽입 순서대로 배치되고 오프셋은 이진 탐색이 가능하도록 정렬한다.



## 가변 길이 데이터 관리

## 버전 관리

## 체크섬

## 요약



# #4 B-트리 구현

## 페이지 헤더

- 페이지 헤더에는 탐색과 유지보수, 최적화에 필요한 페이지에 대한 정보를 저장한다.
- 일반적으로 플래그와 레이아웃, 셀 개수, 오프셋과 같은 몇가지 유용한 메타데이터를 저장한다.



### 매직 넘버

- 파일 헤더 또는 페이지 헤더에 주로 저장하는 또 다른 값으로 매직 넘버가 있다.
- 일반적으로 매직 넘버는 상수 값을 포함하는 멀티바이트 블록이며 페이지의 종류와 버전과 같은 정보를 포함한다.
- 매직넘버는 검증과 상태체크에도 사용된다.

### 형제 링크

- 좌우에 있는 형제 페이지를 가리키도록 순방향 링크와 역방향 링크를 저장하는 방식으로 트리를 구현하기도 한다.
- 약간의 복잡도가 증가하긴 하지만 이렇게 하면 부모 노드로 거슬러 올라가지 않고 이웃 노드를 바로 참조할 수 있다.
- 하지만 형제링크가 없는 트리에서 형제 노드를 찾으려면 반드시 부모 노드를 거쳐야 하는 오버헤드가 있다.

![4-1](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-1.jpeg)

- 이 방법의 단점은 노드 분할과 병합 시 링크를 업데이트해야 한다는 점이다. 분할과 병합의 대상 노드 뿐만 아니라 형제 노드까지 업데이트하기 위해 추가적으로 잠금이 필요할 수 있다.





### 가장 오른쪽 포인터

- B-트리의 구분 키의 주 역할은 트리를 서브트리로 분할하고 탐색할 수 있도록 하는 것이다. 따라서 자식 페이지를 가리키는 포인터가 키보다 반드시 하나 더 있다.
- 각 구분 키에는 자식 포인터가 있고 마지막 포인터는 어떤 키와도 연관되지 않기 때문에 따로 저장한다.

![4-2](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-2.jpeg)

- 가장 오른쪽 자식 노드가 분할되고 부모에 새로운 셀이 추가되면 부모의 마지막 포인터도 다시 설정해야 한다.
- 노드 분할 시 마지막 포인터는 새로운 노드를 가리키도록 업데이트 된다.

![4-3](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-3.jpeg)



### 하이 키

- 각 트리의 노드의 가장 오른쪽포인터와 노드의 하이 키를 함께 저장하는 방법도 있다.
- 하이 키는 현재 노드의 서브트리에 저장된 가장 큰 키를 나타낸다. 이런 형식을 Blink-트리라고 부르며 PostgreSQL에서 사용된다.
- Blink-트리는 각 노드에 Kn+1 키를 하나씩 더 추가로 저장한다. 이 키는 포인터 Pn이 가리키는 서브트리에서 가장 큰 키를 나타낸다. 따라서 이 키 값이 해당 서브트리에 저장할 수 있는 최댓값이 된다.

![4-4](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-4.jpeg)

- 하이 키를 저장하는 트리는 각 노드에 저장된 키와 포인터 개수가 같으며 모든 셀에는 키-포인터 쌍이 존재한다. 이에 따라 엣지 케이스가 줄어들고 가장 오른쪽 포인터의 처리가 단순해진다.
- 첫번째 방식에서 최댓값은 +⚯ 이지만 두번째 방식은 K3으로 줄어든다.

![4-5](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-5.jpeg)



### 오버플로우 페이지

- 노드의 크기와 트리 팬아웃은 고정 값이며 동적으로 변하지 않는다.
- B-트리 알고리즘에서 모든 노드는 일정 개수의 키를 유지해야하지만 노드에 저장된 값의 크기가 크다면 개수가 가득차지 않더라도 고정 크기의 페이지에는 남은 공간이 없을 수 있다. 페이지 변경을 하는건 비효율적이지만 페이지 크기 증가 및 확장은 불가피하다.
- 여러 페이지를 연결하면 데이터를 다른 연속된 공간으로 복사하지 않고 가변 크기 노드를 구현할 수 있다. 예를 들어 기본 크기가 4K인 페이지에 삽입된 값의 합이 4K 이상이면 임의의 크기를 추가 할당하지 않고 4K 단위로 노드를 확장하고 할당된 새로운 페이지를 원본 페이지에 연결하면 된다. 이렇게 새로 할당된 페이지를 오버플로우 페이지라고 한다.
- 대부분의 B-트리는 고정 크기의 바이트만 노드에 저장하고 나머지는 오버플로우 페이지에 저장한다.
- 고정 크기는 노드 크기를 팬아웃으로 나눈 값이다. 따라서 페이지에 최소 max_payload_byte 바이트 만큼의 공간이 항상 남아 있기 때문에 페이지에 공간이 부족한 상황은 발생하지 않는다.
- 삽입된 데이터가 max_payload_size보다 크다면 해당 노드에 연결된오버플로우 페이지가 있는지 확인해야 한다.

![4-6](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-6.jpeg)

- 오버 플로우 페이지는 기본 페이지와 마찬가지로 단편화가 발생할 수 있고 새로운 데이터를 쓰기 위해 공간을 회수하거나 필요없는 페이지를 삭제해야 한다. 
- 첫 오버플로우 페이지를 할당할 때에는 해당 페이지의 ID를 기본 페이지의 헤더에 저장한다. 오버플로우 페이지가 하나로는 충분하지 않아 여러 개가 되는 경우에는 각 헤더에 다음 페이지 ID를 저장하고 연결한다. 따라서 특정 데이터를 찾기 위해 여러 오버플로우 페이지를 확인해야 할 수 있다.



## 이진 검색

- 트리의 노드에서 특정 키는 이진 검색 알고리즘을 사용해 찾을 수 있다.
- 이진 검색 알고리즘은 정렬된 배열과 검색 키를 인자로 받고 숫자를 반환한다. 양수라면 이 값은 배열에서의 위치를 의미하고 음수라면 해당 키는 배열에 없고 반환 값은 삽입 위치를 의미한다.
- 삽입 위치는 검색 키보다 첫 번째로 큰 값의 위치다. 삽입시에는 삽입 위치 이후 모든 원소를 한 자리씩 이동시켜 새로운 값을 위한 공간을 만들고 삽입한다.
- 검색 키보다 큰 첫번째 값을 찾고 해당 서브트리를 가리키는 포인터를 따라가는 탐색 경로가 중요하다.



### 간접 포인터를 사용한 이진 검색

- B-트리 페이지의 셀은 삽입 순서대로 저장되며 셀 오프셋만 논리적 순서를 유지한다.
- 페이지 셀의 이진 검색은 먼저 중간 셀 오프셋을 선택하고 해당 위치의 키와 검색 키를 비교해 왼쪽과 오른쪽 중 진행 방향을 결정한다.

 ![4-6](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-7.jpeg)





## 분할과 병합

- 노드의 분할과 병합은 상위 레벨까지 전파될 수 있다 따라서 분할하는 리프 노드나 병합하는 두 리프 노드로부터 루트 노드까지 순회할 수 있어야 한다. 
- 하위 레벨의 페이지는 항상 바로 위 레벨을 통해서 참조되기 때문에 부모 노드에 대한 정보는 디스크에 저장하지 않아도 된다.
- 형제 포인터와 마찬가지로 부모 포인터도 부모가 변경되면 알맞게 갱신해야 한다.
- 일부 트리 구현에서는 형제 포인터 사용으로 인해 발생할 수 있는 데드락을 제거하기 위해 리프 노드 탐색에 부모 포인터를 사용하기도 한다.
- 부모 노드에서부터 재귀적으로 포인터를 따라 내려가면 형제 노드를 찾을 수 있다. 같은 부모를 공유하는 모든 형제 노드를 순회하고 난 후에는 재귀적으로 상위 레벨로 올라가 검색을 계속한다. 그러다보면 결국 루트 노드에 도달하고 또 다시 리프 레벨까지 내려가게 된다.



### 탐색 경로

- 부모 포인터를 저장 및 유지하는 대신 리프 노드까지의 경로를 저장해두고 노드 삽입과 삭제로 인해 분할 및 병합이 발생했을 때 저장된 경로를 역순으로 순회하는 방법도 있다.
- B-트리의 구조를 변경하기 위해서는 루트에서 리프 노드 또는 삽입 지점까지 트리를 순회해야 한다. 리프 노드에 도달하기 전에 분할 또는 병합의 발생 여부를 미리 알 수 없기 때문에 탐색 경로를 저장해야 한다.
- 탐색 경로는 루트부터 방문한 모든 노드에 대한 정보를 포함한다. 이러한 정보는 분할 또는 병합이 상위 레벨로 전파될 때 노드를 거슬러 올라가는데 쓴다.
- 노드가 분할되거나 병합되는 경우 저장된 탐색 경로를 이용해 부모 노드로 승급된 키의 삽입 지점을 찾고 필요하다면 더 상위 레벨 노드까지 차례대로 방문하면서 구조를 변경한다. 경로를 저장한 스택은 메모리에 유지한다.

![4-6](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-8.jpeg)

- 루트에서 리프 노드까지 방문한 노드를 가리키는 포인터와 해당 셀의 인덱스가 포함된 탐색 경로를 수집하는 과정
- 리프 노드를 분할해야 한다면 스택의 최상위 요소를 참조해 부모 노드를 찾을 수 있다. 부모 노드에 공간이 남아 있다면 탐색 경로에 저장된 셀 인덱스 위치에 새로운 셀을 추가한다. 만약 공간이 부족하다면 부모 노드도 분할해야 한다. 루트 노드에 도달해 스택에 더 이상 요소가 없거나 분할하지 않아도 될 때까지 이 과정을 반복한다.



## 리밸런싱

- 일부 B-트리 구현에서는 분할과 병합 비용을 줄이기 위해 레벨 내에서 노드를 리밸런싱하거나 분할 및 병합 작업을 수행하기 전에 상대적으로 빈 공간이 많은 노드로 원소를 이동한다. 이 경우 리밸런싱 비용이 높아질 수도 있지만 노드의 점유율을 높이고 트리의 높이는 낮출 수 있다.
- 노드 삽입과 삭제 시 로드 밸런싱을 수행하는 방법도 있다.
- 효율적인 공간 활용을 위해 노드를 분할하는 대신 형제 노드로 일부 원소를 옮기고 삽입할 공간을 확보한다. 삭제 작업도 마찬가지로 형제 노드와 병합하는 대신 노드가 절반 이상 찬 상태를 유지하도록 형제노드에서 일부 원소를 가져올 수 있다.
- B*-트리는 형제 노드가 모두 가득 찰 때까지 이웃 간에 원소를 분산한다.
- B*-트리 알고리즘은 노드를 절반이 비어 있는 두 개의 노드로 분할하는 것이 아니라 두 노드를 2/3가 채워진 3개의 노드로 분할한다. SQLite에서 사용하는 알고리즘이다. 이 방식은 분할을 지연시켜 평균 점유율을 높일 수 있지만 상태를 관리하는 로직이 추가로 필요하다. 높은 점유율로 인해 트리 높이가 낮아지고 순회 시 참조하는 페이지 수가 줄어들면 검색의 효율성도 높아진다.

![4-9](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-9.jpeg)

- 리밸런싱은 많은 데이터베이스 구현에서 사용되는 유용한 기술이다.



## 오른쪽 추가 기법

- 많은 데이터베이스 시스템에서 자동 증가 값을 기본 인덱스로 사용하는데 이 방식을 사용하면 모든 삽입이 인덱스 끝에서만 발생하기 때문에 대부분의 노드 분할 작업이 각 레벨의 가장 오른쪽 노드에서 일어나게 된다. 
- 삽입하는 키가 가장 오른쪽 페이지의 첫 번째 키보다 크고 가장 오른쪽 페이지에 새로운 키를 삽입할 공간이 충분하면 탐색 과정을 건너 뛰고 캐시된 페이지의 알맞은 위치에 키를 바로 삽입한다. PostgreSQL은 이와 같은 방식을 패스트패스라고 부른다.
- SQLite도 퀵밸런스라는 비슷한 개념을 사용한다.

### 벌크 로딩

- 정렬된 데이터를 벌크 로딩하거나 트리를 재구성할 때에는 우측 추가 알고리즘을 사용할 수 있다.
- 데이터가 이미 정렬돼 있기 때문에 벌크 로딩 시 트리의 가장 오른쪽에만 데이터를 추가하면 된다.
- 이 경우에는 트리를 하위 레벨부터 상향식으로 한 레벨씩 구성하거나 상위 레벨 노드에 충분한 수의 포인터를 넣을 수 있을 만큼 하위 레벨의 노드가 추가됐을 때 상위 노드를 쓰는 방식으로 트리를 구성하면 노드의 분할과 병합을 피할 수 있다.
- 미리 정렬된 데이터를 리프 레벨에 페이지 단위로 저장하는 방식으로 벌크 로딩을 구현할 수도 있다.
- B-트리는 항상 최하위 레벨부터 상향식으로 구성하기 때문에 상위 레벨을 만들기 전에 리프 레벨 전체를 먼저 구성할 수 있다. 그렇기 때문에 상위 레벨을 구성하는 시점에는 이미 모든 자식 포인터가 준비돼 있다. 이 방식은 디스크에서 분할이나 병합을 할 필요가 없고 트리를 구성할 때 트리의 최소한의 부분만 메모리에 저장하면 된다는 장점이 있다.
- 불변 B-트리도 같은 방식으로 만들 수 있는데 수정이 불가능하기 때문에 추가적인 공간 오버헤드가 발생하지 않아 점유율과 성능이 향상된다.



## 압축

- 원시 데이터를 압축하지 않고 저장하면 상당한 저장 오버헤드가 발생하기 때문에 대부분의 데이터베이스는 공간을 절약할 수 있는 압축 알고리즘을 제공한다.
- 압축 알고리즘에서 접근 속도와 압축률은 반비례 관계다. 압축률이 높을수록 데이터 크기는 감소하지만 더 많은 자원을 소모해야한다.
- 파일 전체를 압축하면 비효율적이기 때문에 파일 전체가 아닌 페이지 단위로 압축하는게 알맞다.
- 페이지는 다른 페이지와 독립적으로 압축 및 압축 해제할 수 있기 때문에 페이지 로딩 및 플러시와 같이 수행할 수 있다. (파일 전체는 파일 단위로 압축, 해제를 해야함)
- 일반적으로 데이터 전송이 블록 단위로 이뤄지기 때문에 압축된 페이지가 블록의 극히 일부분을 차지하는 경우에는 실제 데이터보다 더 많은 바이트를 읽는 비효율적인 상황이 발생한다.

![4-10](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-10.jpeg)

- (a)를 가져올 때는 다른 페이지의 일부분도 포함이되고 (b)를 요청할 때는 여러 페이지를 요청해야 한다.
- 압축 라이브러리를 선택할 때는 메모리 오버헤드, 압축 성능, 압축 해제 성능, 압축률을 중점적으로 비교해야 한다.



## 정리와 유지

- 지금까지 본 B-트리를 정리하면 B-트리는 데이터 무결성 유지와 공간 회수, 오버헤드 최소화, 페이지 정렬 등의 다양한 작업이 쿼리 수행과 더불어 수행된다.
- 추가로 내부 노드의 분할과 병합, 리프 레벨 노드에 대한 삽입 및 업데이트, 삭제 등이 계속 일어나면 단편화가 발생해 논리적 공간은 충분하지만 연속된 물리적 공간이 부족한 페이지가 생긴다 (단편화)

![4-10](/Users/a10300/Choi/Git/dev-note/db/images/database-internals/4-11.jpeg)



### 업데이트와 삭제로 인한 단편화

- 삭제된 리프 레벨의 셀은 헤더에서 오프셋만 제거하고 실제 셀은 남겨둔다. 해당 셀은 더이상 참조할 수 없으며 관련 데이터는 쿼리 대상에서 제외된다.
- 페이지가 분할되면 페이지의 일부는 더 이상 참조할 수 없기 때문에 해당 오프셋은 삭제된다. 삭제된 오프셋의 셀은 새로운 데이터로 덮어쓰거나 정리 단계에서 가비지 컬렉터가 처리한다.
- 일부 데이터베이스는 MVCC를 위해 바로 삭제하지 않고 가비지 컬렉션을 수행한다. 해당 셀을 아무런 스레드도 사용하고 있지 않을 때 셀을 정리한다.
- 삭제된 셀의 오프셋만 삭제하고 다른 셀을 재배치하거나 공간 확보를 위해 물리적으로 셀을 삭제하지 않기 때문에 사용 가능한 바이트가 페이지에 흩어져 있을 수 있다. 이와 같은 현상을 단편화라고 하며 이는 제거해야 하는 현상이다.
- 일반적으로 데이터를 삽입하려면 셀 크기에 맞는 연속된 바이트 블록이 필요하다. 단편화된 여러 조각을 모아 연속된 공간을 확보하려면 페이지를 재구성해야 한다.

### 페이지 단편화

- 공간 회수 및 페이지를 재구성하는 과정을 컴팩션, 정리 또는 유지보수라고 한다. 페이지에 사용 가능한 물리적 공간이 부족한 경우 컴팩션과 쓰기를 동시에 수행할 수 있다.
- 컴팩션은 데드셀이 차지하는 공간을 회수하고 셀을 논리적 순서로 재정렬한다. 재구성된 페이지는 파일에서의 위치가 변경될 수 있다.



## 요약

- B-트리 구현과 관련된 몇 가지 주제
  - 페이지 헤더: 헤더에 저장되는 정보
  - 가장 오른쪽 포인터: 구분 키와 쌍이 아닌 포인터를 처리하는 방법
  - 하이 키: 노드에 저장할 수 있는 최대 키
  - 오버플로우 페이지: 사이즈가 큰 가변 길이 레코드를 고정 사이즈 페이지에 저장하는 방법
- 루트 노드에서 리프 노트까지 트리 순회와 군련된 주제
  - 간접 포인터를 사용한 이진 검색
  - 부모 포인터와 탐색 경로를 사용해 탐색 경로를 저장하는 방법
- 트리 최적화 기법, 유지보수 방법
  - 리밸런싱: 분할과 병합 횟수를 줄이기 위해 이웃 노드로 일부 요소를 이동
  - 오른쪽 추가 기법: 새로운 데이터가 빠르게 삽입될 때 셀을 분할하는 대신 데이터를 트리의 가장 오른쪽 셀에 추가하는 방법
  - 벌크 로딩: 정렬된 데이터를 사용해 B-트리 효율적으로 구성하는 방법
  - 가비지 컬렉션: 페이지를 재구성하고 키 순으로 셀 정렬 및 사용하지 않는 셀의 공간을 회수하는 작업





# #5 트랜잭션 처리와 복구

- DBMS에서 트랜잭션이란 하나의 논리적 작업 단위를 의미하며 여러 작업을 한 단계로 표현하는 방법이다.
- 모든 데이터베이스 트랜잭션은 원자성과 일관성, 격리성, 지속성을 보장한다 (ACID)
- 원자성
  - 트랜잭션과 관련된 작업은 모두 실행되거나 모두 실패해야 한다.
- 일관성
  - 애플리케이션이 제어하는 속성
  - 데이터베이스를 하나의 유효한 상태에서 또 다른 유효한 상태로 변경한다.
- 격리성
  - 동시에 수행되는 여러 트랜잭션은 다른 트랜잭션이 존재하지 안흔 것처럼 서로 간섭없이 수행돼야 한다.
- 지속성
  - 트랜잭션 커밋 후 디스크에 저장된 데이터베이스는 시스템 장애가 발생해도 그대로 유지돼야 한다.
- 트랜잭션을 수행하기 위해서는 데이터를 디스크에 저장하고 유지하는 자료 구조 외에도 여러 컴포넌트가 필요하다.



## 버퍼 관리

- 대부분의 데이터베이스는 상대적으로 속도가 느린 영구 저장소와 빠른 메인 메모리로 구성된 메모리 계층 구조로 되어 있다.
- 다른 프로세스가 디스크에 저장된 같은 페이지를 변경하지 않았다면 메모리에 캐시된 페이지를 재사용할 수 있다. 이를 가상 디스크라고 부르기도 한다. 가상 디스크 작업은 페이지가 메모리에 없을 경우에만 물리적으로 접근한다. 이 개념의 더 일반적인 명칭은 페이지 캐시 또는 버퍼 풀이다.
- 아직 캐시되지 않은 페이지를 디스크에서 메모리로 복사하는 작업을 페이징이라고 한다. 
- 아직 디스크로 플러시 되지 않은 변경된 페이지는 더티 페이지라고 표현한다.
- 데이터셋보다 메모리가 작기 때문에 새로운 페이지를위해 기존 페이지들을 만료시켜야한다.
- 페이지 캐시는 순서를 고려하지 않기 때문에 디스크와 메모리에서 페이지가 정렬되는 방식 사이에는 연관성이 없다.
- 페이지 캐시의 주요 기능
  - 페이지 내용을 메모리에 캐시한다.
  - 디스크에 저장된 페이지에 대한 변경 사항을 함께 버퍼링하고 캐시된 페이지에 반영한다.
  - 캐시되지 않은 데이터가 요청된 경우 메모리에 공간이 충분하다면 페이징하고 캐시된 버전을 반환한다.
  - 캐시된 페이지가 요청된 경우 메모리에서 반환한다.
  - 메모리에 새로운 페이지를 추가할 공간이 없을 경우 일부 페이지를 만료시키고 페이지로 플러시한다.



### 캐싱

- 데이터베이스는 페이지 캐시를 사용해 메모리를 관리하고 디스크 접근을 제어한다.
- 스토리지 엔진이 특정 페이지를 요청하면 우선 캐시된 버전이 있는지 확인하고 있을 경우 반환, 없으면 논리적 페이지 주소 또는 페이지 번호를 물리적 주소로 변환해 해당 페이지를 메모리로 복사하고 반환한다. 이때 해당 페이지가 저장된 버퍼는 참조 상태라고 표현한다.
- 작업이 끝나면 참조상태의 페이지를 참조 해제상태로 만들어야한다. 페이지를 고정시키면 페이지 캐시에서 제거되지 않는다.
- 페이지가 변경된 경우 페이지에 더티 플래그를 설정한다. 더티 플래그는 해당 페이지가 디스크와 동기화되지 않았다는 것을 의미한다.



### 캐시 만료

- 페이지 크기는 한정적이기 때문에 새로운 페이즈를 위해 오래된 페이지는 제거해야 한다.
- 페이지가 동기화됐고(더티 상태가 아님) 고정 또는 참조 상태가 아니라면 바로 제거될 수 있다. 더티 페이지는 제거되기 전에 먼저 플러시 해야한다.
- 페이지를 제거할 때마다 디스크로 플러시한다면 성능을 저하시킬 수 있어서 일부 데이터베이스는 별도의 백그라운드 프로세스가 제거될 가능성이 높은 더티 페이지를 주기적으로 디스크로 플러시한다. (PostgreSQL의 Background flush writer)
- 캐싱의 여러 트레이드 오프
  - 디스크 접근 횟수를줄이기 위해 플러시 시점을 늦춘다.
  - 페이지를 우선적으로 플러시해 빠르게 캐시를 제거한다.
  - 제거할 페이지를 선택하고 최적의 순서로 플러시한다.
  - 캐시 크기를 메모리 범위 내로 유지한다.
  - 기본 저장소에 저장되지 않은 데이터는 손실되지 않아야 한다.

### 페이지 고정

- 모든 읽기와 쓰기 작업에 디스크 I/O가 발생하는 시스템은 사실상 사용이 불가능하다.
- 가까운 시간 내에 요청될 확률이 높은 페이지는 고정시킬 수 있다. 고정된 페이지는 메모리에 더 오랜 시간 유지되기 때문에 디스크 접근 횟수가 줄어들고 성능에 도움이 된다.
- 트리의 하위 레벨에는 상위 레벨보다 노드 수가 월등히 많기 때문에 상위 레벨 노드는 트리의 전체에서 극히 일부분에 해당한다. 상위 레벨 노드를 메모리에 고정시키고 나머지 노드는 요청 시 페이징해도된다.

### 페이지 교체 알고리즘

- 저장 공간이 부족한 캐시에 새로운 페이지를 추가하려면 일부 페이지를 만료시켜야 한다. 이때 자주 요청되는 페이지를 만료시키면 같은 페이지를 여러 차례 페이징할 수 있기 때문에 캐시된 페이지가 요청될 확률을 계산할 수 있어야 한다.
- 페이지 교체 알고리즘은 패이지 캐시 성능을 결정하는 중요한 요인이다.
- 벨레이디의 모순
  - 적합하지 않은 페이지 교체 알고리즘을 사용했을 때 페이지 수가 증가하면 제거되는 페이지 수도 같이 증가하는 현상

**FIFO와 LRU**

- FIFO는 페이지 ID를 삽입 순서대로 큐의 끝에 추가한다. 
- 페이지 캐시에 공간이 부족할 경우 큐의 헤드에 저장된 페이지 ID가 가리키는 가장 오래된 페이지를 만료시킨다.
- 이 방식은 페이지 접근 순서를 전혀 고려하지 않기 떄문에 실용적이지 않다.
- LRU 알고리즘은 FIFO를 확장한 방식이다. FIFO와 마찬가지로 삽입 순서대로 큐에 추가하지만 페이지가 재요청되면 마치 처음 페이징된 것처럼 다시 큐의 끝에 추가한다. 페이지를 요청할 때마다 페이지에 대한 참조와 노드를 갱신해야 하기 때문에 동시 접근 환경에서는 매우 비효율적일 수 있다.
- LRU기반의 다른 여러 페이지 교체 알고리즘도 있다. (2Q-LRU, LRU-K)

**CLOCK 알고리즘**

- 어떤 상황에서는 정확성보다 효율성이 더 중요할 수 있다.
- LRU의 대안으로 사용되는 CLOCK알고리즘은 더 단순하고 캐시 친화적이며 동시성을 지원한다.
- CLOCK-sweep 알고리즘은 페이지에 대한 참조와 접근 여부를 나타내는 비트를 원형 버퍼에 저장한다. 페이지가 요청될 때마다 해당 페이지의 접근 비트를 1로 설정한다.
  - 접근 비트가 1이지만 페이지가 참조 중이 아니라면 접근 비트를 0으로 설정하고 다음 페이지를 확인한다.
  - 접근 비트가 0이면 해당 페이지를 제거 대상으로 선정하고 만료 작업을 스케줄링한다.
  - 현재 참조중인 페이지의 접근 비트는 그대로 유지한다. (참조중이라면 반드시 1)
- 원형 버퍼의 장점은 클럭 포인터와 CAS 방식으로 쉽게 수정할 수 있고 추가적인 잠금 메커니즘이 필요하지 않다는 것이다.
- LRU가 항상 데이터베이스 시스템에서 사용할 수 있는 최적의 페이지 교체 알고리즘은 아니다.



**LFU**

- 페이징 횟수 대신 페이지가 참조된 횟수를 기반으로 제거할 페이지를 선택하는 방법도 있다.
- LFU 알고리즘은 요청 빈도가 가장 낮은 페이지를 제거한다.
- TinyLFU는 페이징 시점이 아닌 요청 빈도를 고려해 페이지의 만료 여부를 결정하는 요청 빈도 기반 페이지 교체 알고리즘이다.
- TinyLFU는 페이지를 다음 중 하나의 큐에 저장한다.
  - 등록큐: LRU 알고리즘을 기반으로 새로 추가된 페이지를 저장한다.
  - 관찰큐: 제거될 확률이 높은 페이지를 저장한다.
  - 보호큐: 큐에 오랫동안 남아 있을 페이지를 저장한다.
- TinyLFU는 제거할 페이지 대신 큐에 유지할 페이지를 선택한다. 요청 빈도가 높은 페이지를 관찰 큐로 옮기고 다시 요청되면 보호 큐로 옮긴다. 보호 큐가 가득 차면 일부 페이지를 다시 관찰 큐로 옮긴다. 



## 복구

- 데이터베이스 개발자는 여러 장애 시나리오를 고려하고 약속된 데이터가 실제로 저장되게 해야 한다.
- 선행 기록 로그(WAL 또는 커밋 로그)는 장애 및 트랜잭션 복구를 위해 디스크에 저장하는 추가 전용 보조 자료구조다.
- 페이지 캐시는 페이지에 대한 변경사항을 메모리에 버퍼하고 디스크에 플러시하는데 플러시 되기 이전에 유일한 디스크 복사본은 WAL이다.
- WAL의 주요 기능
  - 디스크에 저장된 페이지에 대한 변경 사항을 페이지 캐시에 버퍼링하는 동시에 데이터베이스 시스템 맥락에서의 지속성을 보장한다.
  - 캐시된 페이지가 디스크와 동기화될 때까지 작업 이력을 디스크에 저장한다. 데이터베이스의 상태를 변경하는 모든 작업을 실제 페이지에 적용하기 전에 먼저 디스크에 로깅한다.
  - 장애 발생 시 로그를 기반으로 마지막 메모리 상태를 재구성한다.
- WAL은 데이터가 영구히 저장소에 저장되로록 보장하고 로그를 재수행해서 커밋되지 않은 트랜잭션을 완료하거나 장애가 발생하기 전의 상태로 되돌릴 수 있기 때문에 매우 중요하다.

### 로그의 시맨틱

- WAL은 불변이기 때문에 모든 쓰기 작업은 순차적이다. 따라서 동시성 이슈가 없다.
- WAL은 여러 로그 레코드로 구성된다 모든 레코드에는 단조 증가하는 고유 로그 시퀀스 번호(LSN)가 있다. LSN은 내부 카운터 값 또는 타임스탬프 값이다.

### 작업 로그 대 데이터 로그

- 모든 상태 변화는 이전 상태와 이후 상태의 조합으로 나타낼 수 있다. 또는 그에 대응되는 리두 작업과 언두 작업으로 나타낼 수 있다. 이전 상태에 리두 작업을 수행하면 이후 상태가 되고 이후 상태에 언두 작업을 수행하면 이전 상태가 된다. 
- 물리적 로그 또는 논리적 로그를 사용해 레코드와 페이지의 상태를 한 상태에서 다른 상태로 되돌리거나 재구성할 수 있다.
- 대부분의 데이터베이스는 물리적 로그와 논리적 로그를 모두 사용한다 언두 작업에는 논리적 로그(동시성과 성능을 위해), 리두 작업에는 물리적 로그(복구 시간을 단축하기 위해)를 사용한다.

### 스틸과 포스 정책

- DBMS는 스틸/노스틸 정책과 포스/노포스 정책을 기반으로 메모리에 캐시된 변경사항을 디스크로 플러시하는 시점을 결정한다.
- 스틸 정책은 트랜잭션이 수정한 페이지를 커밋하기도 전에 플러시하는 것을 허용한다.
- 노스틸 정책은 커밋되지 않은 트랜잭션이 디스크로 플러시되는 것을 허용하지 않는다.
- 포스 정책은 트랜잭션이 수정한 모든 페이지를 커밋 전에 플러시한다.
- 노포스 정책은 일부 페이지가 디스크로 플러시되지 않았더라도 트랜잭션 커밋을 허용한다.
- 스틸과 포스 정책은 트랜잭션 언두와 리두 작업에 관련되기 때문에 매우 중요하다.
- 노스틸 정책을 사용하면 디스크에는 이전 상태의 페이지가 저장돼 있고 로그에는 최신 변경 사항이 저장돼 있기 때문에 리두 로그만 사용해 상태를 복구할 수 있다.
- 노포스 정책을 사용 시 플러시 시점을 늦추면 더 많은 변경사항을 버퍼링할 수 있다.
- 포스 정책 사용 시 트랜잭션에서 수정한 페이지는 커밋 전에 플러시되기 때문에 장애 복구시 트랜잭션의 커밋 결과를 재구성하지 않아도 된다.



### ARIES

- ARIES는 스틸/노포스 정책 기반의 복구 알고리즘이다.
- ARIES는 빠른 복구를 위해 물리적 리두 로그를 사용하고 일반 작업의 동시성을 높이기 위해 논리적 언두를 사용한다.
- 장애 발생 후 데이터베이스 시스템을 재시작하면 복구는 다음 3단계로 진행된다.
  1. 분석 단계: 페이지 캐시에 저장된 더티 페이지와 장애 발생 당시 수행 중이던 트랜잭션을 파악한다. 더티 페이지에 대한 정보를 기반으로 리두 단계의 시작 지점을 결정한다. 트랜잭션 목록은 언두 단계에서 미완료된 트랜잭션을 롤백하는 데 사용한다.
  2. 리두 단계: 장애가 발생하기 전까지의 작업을 재수행하고 데이터베이스를 이전 상태로 복원한다. 불완전한 트랜잭션뿐만 아니라 커밋됐지만 결과가 디스크로 플러시 되지 않은 트랜잭션을 롤백하기 위한 준비 단계다.
  3. 언두 단계: 불완전한 트랜잭션을 롤백하고 데이터베이스를 마지막 일관된 상태로 복원한다. 모든 작업은 실제 수행 순서의 역순으로 롤백된다. 복구 중에도 장애가 발생할 수 있기 때문에 언두 작업도 로그에 기록해야 한다.

## 동시성 제어

- 동시성 제어는 동시에 수행되는 여러 트랜잭션 사이의 상호작용을 제어하는 기법이다. 동시성 제어는 대략 다음과 같이 분류할 수 있다.

`낙관적 동시성 제어 OCC, Optimistic Concurrency Control`

- 여러 트랜잭션이 동시에 읽고 쓰는 것을 허용하고 결합된 여러 작업이 직렬화가 가능한지 여부를 결정한다.
- 트랜잭션이 서로 간섭하지 않고 각자의 작업내역을 유지할 수 있게 하고 커밋 전에 충돌이 발생할 수 있는지 확인한다. 충돌이 발생할 경우 트랜잭션 중 하나를 중단한다.

`다중 버전 동시성 제어 MVCC, Multiversion Concurrency Control`

- 여러 버전의 레코드를 저장해 과거의 특정 타임스탬프의 데이터베이스의 일관성을 보장한다.
- MVCC는 하나의 트랜잭션만을 채택하는 검증 기법을 사용해 구현하거나 타임스탬프 순서화 기법과 같은 무잠금 방식 또는 2단계 잠금과 같은 잠금 기반의 방식으로도 구현할 수 있다.

`낙관적 동시성 제어 PCC, Pessimistic Concurrency Control`

- PCC는 잠금 기반 방식과 무잠금 방식이 있으며 두 방식은 공유 자원에 대한 관리 및 접근 방식이 다르다.
- 잠금 기반 방식에서 각 트랜잭션은 다른 트랜잭션이 같은 레코드를 동시에 수정 및 접근할 수 없도록 레코드에 대한 자금을 획득한다.
- 무잠금 방식은 읽기와 쓰기 작업에 대한 목록을 유지하고 완료되지 않은 트랜잭션의 스케줄에 따라 다른 트랜잭션의 수행을 제한한다.
- 여러 트랜잭션이 잠금을 해제하기를 기다리는 교착상태가 발생할 수 있다.



### 직렬화 가능성

- 데이터베이스의 관점에서 스케줄이란 트랜잭션을 수행하는 데 필요한 작업의 목록이다.
- 완전한 스케줄은 관련 트랜잭션의 모든 작업을 포함한다. 올바른 스케줄은 논리적으로 전체 작업 목록과 동일하지만 ACID 속성과 트랜잭션 결과의 정확성이 보장될 경우 일부 작업이 병렬 수행되거나 성능을 위해 수행 순서가 바뀔 수 있다.
- 포함된 모든 트랜잭션이 교차하지 않고 완전히 독립적으로 수행될 수 있는 스케줄을 직렬 스케줄이라고 한다. 하지만 트랜잭션을 하나씩 실행하면 시스템 처리량이 크게 제한되고 성능이 저하된다.
- 트랜잭션을 동시에 수행하면서 직렬 스케줄의 정확성과 단순성을 유지하는 방법은 직렬화 가능한 스케줄이다.



### 트랜잭션 격리

- 격리수준은 트랜잭션이 변경한 내용 중 어떤 부분이 언제 다른 트랜잭션에서 접근할 수 있는지를 정의한다.
- 격리수준은 동시에 수행되는 트랜잭션이 고립된 정도와 수행 중에 발생할 수 있는 이상현상이 발생할 수 있는지를 나타낸다.
- 트랜잭션을 격리하려면 불완전하거나 일시적인 데이터가 트랜잭션 경계를 넘어 전파되는 것을 방지해야하기 때문에 추가적인 코디네이션과 동기화가 필요하다. 이로 인해 추가 비용이 발생하며 성능저하의 요인이 될 수 있다.

### 읽기와 쓰기 이상 현상

- SQL 표준은 여러 트랜잭션이 동시 수행될 때 발생할 수 있는 읽기 이상 현상을 dirty read, non-repeatable read, phantom read로 분류한다.
- dirty read는 아직 커밋되지 않은 다른 트랜잭션의 결과를 읽는 현상을 나타낸다.
- non-repeatable read는 트랜잭션이 동일한 로우를 두 번 쿼리했을 때 둘의 결과가 다른 현상을 나타낸다.
- pahntom read는 여러 로우를 두 번 쿼리했을 때 결과가 다른 현상을 나타낸다. non-repeatable read와 다른점은 대상이 범위 쿼리라는 점이다.
- 쓰기 이상 현상은 lost update와 dirty write, write skew으로 분류할 수 있다.
- lost update은 트랜잭션 T1과 T2가 같은 값 V를 수정할 때 발생한다. 트랜잭션은 서로의 존재를 모릑 때문에 T1의 결과를 T2가 덮어쓰고 T1이 갱신한 값은 사라진다.
- dirty write는 트랜잭션이 커밋되지 않은 값을 읽고 수정 및 커밋하는 현상을 나타낸다. 
- 개별 트랜잭션은 불변 조건(일관성)을 충족하지만 동시 수행 시 조건이 위반되는 현상을 write skew라고 한다.



### 격리 수준

- 가장 낮은 격리수준은 read uncommitted 수준이다. 이 수준에서 트랜잭션은 동시 수행중인 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 있다. (dirty read)
- 다음 격리수준은 read cimmitted 수준이다. 이 수준에서 트랜잭션은 오직 커밋된 데이터만을 읽도록 하지만 같은 레코드를 다시 요청했을 때 값이 다를 수 있다. (non-repeatable read)
- 다음 격리수준은 repeatable read 수준이다. 이 수준에서 dirty read와 non-repeatable read는 방지할 수 있지만 phantom read가 발생할 수 있다.
- 가장 높은 격리수준은 serializable 격리수준이다. 이 수준에서 모든 이상현상을 방지할 수 있지만 데이터베이스의 성능이 매우떨어진다.
- 일부 데이터베이스는 스냅숏 격리 수준을 지원한다. 스냅숏 격리 수준에서 각 트랜잭션은 시작 당시의 다른 트랜잭션이 커밋한 내용을 확인할 수 있다. 트랜잭션은 데이터의 스냅숏을 생성하고 이에 대해 쿼리하며 트랜잭션 수행중에는 스냅숏을 변경할 수 없다. 트랜잭션에서 수정한 값이 수행 중에 변경되지 않은경우에만 커밋될 수 있다. 변경됐다면 중단 후 롤백된다.
- 스냅숏 격리 수준을 사용하면 load update는 발생하지 않는다. 하지만 write skew는 발생할 수 있다.

### 낙관적 동시성 제어

- 낙관적 동시성 제어는 트랜잭션 충돌이 거의 발생하지 않는다고 가정한다.
- 결과를 커밋하기 전에 트랜잭션을 검증해 동시 수행 트랜잭션의 읽기/쓰기 충돌을 방지하고 직렬화 가능성을 확인한다.
- 일반적으로 트랜잭션 수행은 다음 세 단계로 구성된다.
  - 읽기 단계
    - 트랜잭션은 자신이 변경한 내용을 다른 트랜잭션에서 볼 수 없도록 개별 컨텍스트에서 트랜잭션 단계를 수행한다. 이 단계 후에는 모든 트랜잭션 존속성과 트랜잭션의 효과를 알 수 있다.
  - 검증 단계
    - 동시 수행 트랜잭션의 읽기와 쓰기 대상에서 직렬화 가능성을 보장하지 않는 충돌이 발생할 수 있는지 확인한다.
    - 트랜잭션이 쿼리한 데이터가 최신이 아니거나 읽기 단계 중에 수정 및 커밋한 값을 다른 트랜잭션이 덮어쓴 경우 컨텍스트를 초기화하고 읽기 단계부터 다시 수행한다.
    - 트랜잭션을 커밋해도 ACID 속성이 유지되는지 검증하는 단계다.
  - 쓰기 단계
    - 검증 단계에서 충돌이 발견되지 않았다면 결과를 개별 컨텍스트에서 데이터베이스 상태로 커밋한다.
- 검증은 이미 커밋된 트랜잭션(역방향) 또는 현재 검증 중인 트랜잭션(순방향)과의 충돌 여부를 확인하는 작업이다. 
- 트랜잭션의 검증과 쓰기 단계는 원자적으로 수행되어야 한다.
- 역방향 동시성 제어는 모든 T1, T2 트랜잭션 쌍에 대해 다음 속성을 보장한다.
  - T2의 읽기 단계가 시작되기 전에 T1이 커밋하면 T2도 커밋할 수 있다.
  - T2의 쓰기 단계가 시작되기 전에  T1이 커밋하고 T1의 쓰기 대상과  T2의 읽기 대상이 겹치지 않는다면 T1이 쓴 값은 T2에서 참조하지 않는다는 뜻이다.
  - T1의 읽기 단계가 T2의 읽기 단계뽀다 먼저 완료되고  T2의 쓰기 대상과 T1의 읽기 또는 쓰기 대상과 겹치지 않는다면 두 트랜잭션은 서로 독립적인 데이터 레코드를 사용하기 때문에 모두 커밋이 허용된다.
- 낙관적 동시성 제어는 일반적으로 검증이 성공적이고 트랜잭션을 재시도할 필요가 없는 경우 효율적이다.



### 다중 버전 동시성 제어

- 다중 버전 동시성 제어는 여러 버전의 레코드를 저장하고 단조 증가하는 트랜잭션 ID 또는 타임스탬프로 식별해 데이터베이스 트랜잭션의 일관성을 보장하는 동시성 제어 방식이다.
- 새로운 버전이 커밋될 때까지 이전 버전을 읽을 수 있기 때문에 비교적 간단한 조정 단계를 통해 동시 읽기 및 쓰기 작업을 수행할 수 있다.
- MVCC로 구현된 대표적인 격리수준은 스냅숏 격리다.



### 비관적 동시성 제어

- 비관적 동시성 제어는 낙관적 동시성 제어보다 더 보수적이다.
- 트랜잭션 수행 중에 충돌 발생 가능성을 확인하고 계속 수행하거나 중단 또는 취소한다.
- 가장 단순한 비관적 동시성 제어 방식은 각 트랜잭션에 타임스탬프를 설정하는 타임스탬프 순서화 알고리즘이다.



### 잠금 기반 동시성 제어

- 잠금 기반 동시성 제어는 데이터베이스 객체에 명시적으로 잠금을 설정하는 비관적 동시성 제어의 한 종류다.
- 잠금 기반 방식은 경합 현상 및 확장성 문제가 발생할 수 있다는 단점이 있다.
- 가장 보편적인 자금 기법은 2단계 잠금이다.
  - 확장 단계: 필요한 잠금을 획득하고 유지한다.
  - 축소 단계: 획득한 잠금을 해제한다.

**교착 상태**

**잠금**

**래치**

**리더-라이터 잠금**

**래치 크래빙**

**Blink-트리**



## 요약

- 트랜잭션 처리를 구현할 때 다음 두 가지 사항을 고려해야 한다.
  - 효율성을 높이기 위해서는 트랜잭션의 동시 수행을 지원해야 한다.
  - 정확성을 보장하기 위해서는 모든 동시 수행 트랜잭션이 ACID 속성을 보장해야 한다.
- 동시에 여러 트랜잭션을 수행하면 다양한 유형의 읽기 및 쓰기 이상현상이 발생할 수 있다.
- 어떤 격리수준을 구현하는지에 따라 이상 현상이 생기는 이유를 설명하거나 이상 현상을 제한할 수 있다. 
- 동시성 제어 방식은 트랜잭션의 스케줄링이나 수행 방식을 결정한다.
- 페이지 캐시는 페이지를 메모리에 캐시하고 읽기와 쓰기를 허용하기 때문에 효과적으로 디스크 접근 횟수를 줄일 수 있다. 캐시가 가득 차면 일부 페이지를 제거하고 디스크로 플러시해야 한다.
- 장애 발생시 플러시되지 않은 데이터를 복구하고 트랜잭션을 롤백하기 위해 선행 기록 로그를 사용한다.
- 모든 트랜잭션을 효율적으로 수행하고 지속성을 유지하면서 롤백하기 위해 포스와 스틸 정책을 기반으로 페이지 캐시와 선행 기록 로그를 제어한다.






