



# Database Internals









데이터베이스 관리 시스템의 주 목적은 데이터를 안정적으로 저장하고 사용자에게 제공하는 것이다.



# #1 소개 및 개요

## DBMS 구조

- 표준화된 DBMS 구조란 존재하지 않는다. 모든 데이터베이스 구조는 다르고 내부 컴포넌트의 경계를 명확히 나누고 정의하기 어렵다.
- DBMS는 클라이언트/서버 모델을 기반으로 한다.
- 클라이언트의 요청은 트랜스포트 서브시스템을 통해 전달된다. 요청은 쿼리 형태이고 트랜스포트 서브시스템은 데이터 클러스터 노드 사이의 통신에도 사용된다.
- 트랜스포트 서브시스템은 쿼리를 쿼리 프로세서에게 전달한다. 쿼리 프로세서는 쿼리를 해석 분석 및 검증한다. 쿼리의 의미를 파악한 뒤에 액세스 제어를 진행할 수 있다.
- 분석된 쿼리는 쿼리 옵티마이저에게 전달된다. 쿼리에서 논리적으로 불가능한 부분과 중복을 제거한 뒤에 내부 데이터 통계 등을 기반으로 가장 효율적인 쿼리 실행 계획을 생성한다. 그외에도 인덱스 순서 선택, 카디널리티 예측, 액세스 메서드 선택등의 최적화 단계를 처리한다.
- 쿼리는 일반적으로 실행 계획 형태로 표현되고 다양한 쿼리 실행계획이 있을 수 있으며 옵티마이저는 이 가운데 가장 효율적인 실행 계획을 선택한다.
- 선택된 실행 계획은 로컬 및 원격 실행의 결과를 결합하는 실행 엔진이 수행한다.
- 로컬 쿼리는 스토리지 엔진이 수행한다. 스토리지 엔진은 다음과 같이 명확한 역할을 담당하는 컴포넌트로 구성되어 있다.
  - 트랜잭션 매니저: 트랜잭션을 스케줄링하고 데이터베이스 상태의 논리적 일관성을 보장한다.
  - 잠금 매니저: 트랜잭션에서 접근하는 데이터베이스 객체에 대한 잠금을 제어한다. 동시 수행 작업이 물리적 데이터 무결성을 침해하지 않도록 제어한다.
  - 액세스 메서드: 디스크에 저장된 데이터에 대한 접근 및 저장 방식을 정의한다. 힙 파일과 B-트리 또는 LSM트리 등의 자료구조를 사용한다.
  - 버퍼 매니저: 데이터 페이지를 메모리에 캐시한다.
  - 복구 매니저: 로그를 유지 관리하고 장애 발생시 시스템을 복구한다.
- 트랜잭션과 잠금 매너지는 동시성을 제어한다. 

## 인메모리 DBMS 대 디스크 기반 DBMS

- 인메모리 DBMS는 메모리에 데이터를 저장하고 디스크는 복구와 로그 저장 용도로 사용한다.
- 디스크 기반 DBMS는 데이터를 디스크에 저장하고 메모리는 캐시 용도로 사용한다.
- 메모리는 디스크보다 훨씬 더 빠르게 데이터에 접근하지만 RAM은 디스크보다 가격이 비싸다.
- 인메모리 DBMS는 디스크 기반 데이터베이스와 비교해 기본 저장 매체뿐만 아니라 내부 자료 구조와 설계 및 최적화 방식도 모두 다르다.
- 메모리를 주 저장 매체로 사용하는 이유는 성능과 상대적으로 낮은 데이터 접근 비용, 세밀한 접근 단위 때문이다.
- 인메모리 DBMS의 가장 큰 단점은 RAM의 휘발성과 높은 가격이다.
- 디스크는 메모리보다 유지관리 측면에서 더 간단하고 비용이 낮다.
- 비휘발성 램 기술이 더 대중화되면 이런 상황은 뒤바뀔 수 있다.

### 인메모리 데이터베이스의 지속성

- 인메모리 DBMS는 데이터의 지속성을 보장하고 데이터 손실을 방지하기 위해 데이터를 디스크에 백업한다.
- 모든 작업은 로그 파일에 작업 내용을 순차적으로 기록해야 완료된다.
- 인메모리 시스템에서는 시스템 시작과 복구 시 모든 로그를 재수행하지 않기 위해 백업본을 유지하고 백업본은 디스크 기반 자료구조에 순서대로 저장하는데 일반적으로 수정 내용은 비동기적으로 갱신하며 I/O 작업을 최소화하기 위해 배치 단위로 백업한다.
- 로그 레코드는 일반적으로 배치 단위로 백업한다. 배치 작업이 완료되면 백업본은 특정 시점의 데이터베이스 스냅숏이기 때문에 이 시점 이전의 로그는 삭제해도 된다. 이러한 작업을 가리켜 체크포인트를 남긴다고 표현한다.
- 클라이언트의 요청을 블로킹하지 않고 디스크에 저장된 백업본을 최신 로그 데이터와 동기화하면 복구 시간을 단축할 수 있다.
- 메모리는 포인터를 사용해 비교적으로 빠르게 참조할 수 있고 랜덤 메모리 접근 속도는 랜덤 디스크 접근 보다 월등히 빠르다.

## 칼럼형 DBMS 대 로우형 DBMS

- 대부분의 데이터베이스는 열과 행으로 구성된 테이블에 데이터 레코드를 저장한다.
- 사용자 정보 테이블의 모든 사용자 이름은 같은 형식으로 같은 칼럼에 저장하고 논리적으로 같은 레코드에 속하는 값의 집합을 로우라고 부른다.
- 칼럼 저장 방식은 테이블을 수직 분할하고 로우 저장 방식은 수평 분할한다.
- MySQL과 PostgreSQL 등 대부분의 전통적인 관계형 데이터베이스는 로우형 DBMS다.
- MonetDB C-Store는 선구적인 칼럼형 오픈소스 데이터베이스다.

### 로우형 데이터 레이아웃

- 로우형 DBMS는 데이터 레코드를 로우 형식으로 저장한다.
- 이 방식은 여러 필드의 값일 고유 식별 키로 구분할 수 있는 레코드 형식에 적합하다.
- 특정 사용자의 모든 필드는 일반적으로 함께 요청되는 경우가 많다.
- 레코드를 생성할 때에도 레코드의 모든 필드를 함께 쓴다.
- 로우형 DBMS는 한 개의 로우씩 접근하는 경우 적합하다. 로우 단위로 저장하면 공간 지역성을 극대화할 수 있다.
- 특정 사용자의 모든 정보를 읽을 때는 효율적이지만 여러 사용자의 특정 필드를 읽을 때는 비효율적이다.



### 칼럼형 데이터 레이아웃

- 칼럼형 DBMS는 데이터를 로우 단위가 아니라 수직 분할해 칼럼 단위로 저장한다.
- 칼럼형 DBMS는 데이터의 추세와 평균 등을 계산하는 집계 분석 작업에 적합하다.
- 칼럼형 DBMS에서 조인과 필터링, 다중 로우 집계 등을 위해 튜플을 재구성하려면 칼럼 사이의 관계를 정의하는 메타데이터가 필요하다.
- 아파치 Parquet, 아파치 ORC, RCFile과 같은 칼럼 기반 파일 포맷과 아파치 Kudu, ClickHouse 등이 있다.

### 차이점과 최적화 기법

- 로우형 DBMS와 칼럼형 DBMS의 차이점을 데이터를 저장하는 방식만으로 설명하기에는 부족함이 많다.
- 데이터 레이아웃은 칼럼형 DBMS에서 목표하고 있는 여러 최적화 단계 중 하나일 뿐이다.
- 같은 칼럼의 여러 값을 한 번에 읽으면 캐시 활용도와 처리 효율성이 높아진다.
- 자료형별로 저장하면 압축률도 증가한다.
- 칼럼형과 로우형 DBMS중 어떤 것을 사용할지 선택하려면 먼저 액세스 패턴을 파악해야 한다.
- 데이터를 레코드 단위로 접근하고 일반 쿼리와 범위 스캔 요청이 많다면 로우형 DBMS가 적합하다. 반면 많은 로우를 스캔하거나 일부 칼럼에 대한 집계 작업이 많다면 칼럼형 DBMS가 더 적합할 수 있다.



### 와이드 칼럼 스토어

- 빅테이블과 HBase와 같은 와이드 칼럼 스토어는 일반적인 칼럼형 DBMS와는 구분해야 한다.
- 와이드 칼럼 스토어는 데이터를 다차원 맵으로 표현하고 여러 칼럼을 칼럼 패밀리 단위로 저장한다.
- 칼럼 패밀리의 데이터는 로우 형식으로 저장한다. 이 방식은 키 단위 액세스 패턴에 적합하다.
- 이 방식의 가장 대표적인 구현은 웹테이블이다.

```
{
	"com.cnn.www" : {
		contents: {
			t6: html: "<html> ..."
			t5: html: "<html> ..."
			t3: html: "<html> ..."
		}
		anchor: {
			t9: cnnsi.com: "CNN"
			t8: my.look.ca: "CNN.com"
		}
	}
}
```

- 웹테이블은 다차원 맵에 데이터를 정렬해서 저장하고 계층 인덱스를 생성한다.

- 각 로우는 로우 키와 매핑하고 관련 있는 칼럼끼리 칼럼 패킬리(contents와 anchor 필드) 단위로 저장한다.

- 칼럼 패밀리의 칼럼은 칼럼 패밀리 이름과 수식자(html, cnnsi.com. my.look.ca)로 구성된 칼럼 키로 식별할 수 있다.

- 칼럼 패밀리는 시간별로 여러 버전의 데이터를 유지한다 이 자료구조를 사용해 상위 레벨 요소와 관련된 변수를 검색할 수 있다.

- 와이드 칼럼 스토어의 논리적 구조는 이해하기 쉽지만 실제 저장 방식은 복잡하다.

  

## 데이터 파일과 인덱스 파일

- 데이터베이스 시스템의 주 목적은 데이터를 저장하고 빠르게 데이터를 검색하는 것이다.
- 데이터베이스가 일반 파일을 사용하지 않는 이유
  - 저장 효율성: 데이터 레코드의 저장 오버헤드를 최소화하는 방식으로 파일을 구성할 수 있다.
  - 접근 효율성: 최소한의 단계로 원하는 레코드를 찾을 수 있다.
  - 갱신 효율성: 디스크 쓰기를 최소화하는 방식으로 레코드를 갱신할 수 있다.
- 데이터베이스 시스템은 여러 필드로 구성된 데이터 레코드를 테이블 형식으로 저장하며 일반적으로 각 테이블을 별도의 파일에 저장한다.
- 테이블의 레코드는 인덱스를 사용해서 찾고 인덱스는 요청마다 테이블 전체를 읽지 않고 데이터를 효율적으로 검색할 수 있는 자료구조다. (인덱스를 사용하는 쿼리를 사용하면?)
- 데이터베이스 시스템은 데이터 파일(실제 레코드)과 인덱스 파일(레코드에 대한 메타데이터)을 분리한다.
- 새로운 레코드와 업데이트된 레코드는 키-값 쌍의 형식으로 저장한다
- 대부분의 데이터베이스 시스템은 데이터를 즉시 페이지에서 삭제하지 않고 삭제 마커를 사용해서 남겨두고 가비지컬렉션에 의해 최신 레코드로 생신되며 기존 값은 삭제된다.



### 데이터 파일

- 데이터 파일은 인덱스 구조형 테이블, 힙 구조형 테이블 또는 해시 구조형 테이블을 기반으로 한다.
- 힙 파일은 레코드를 특정 순서를 따르지 않고 대체로 삽입 순서대로 저장하지 않아 새로운 페이지가 추가돼도 파일을 재구성하지 않아도 된다. 하지만 데이터 검색 시 데이터의 실제 위치를 가리키는 인덱스가 필요하다.
- 해시 파일은 레코드를 각 키의 해시 값에 해당하는 버킷에 저장한다. 버킷 내 레코드는 삽입 순서대로 저장하거나 키 순서로 정렬하면 조회 속도를 향상시킬 수 있다.
- 인덱스 구조형 테이블은 인덱스에 실제 데이터 레코드를 저장한다.
- 인덱스에 데이터 레코드를 저장하면 디스크 탐색 횟수를 최소 1회 줄일 수 있다. (인덱스로만 필요한 데이터를 찾으면?)

### 인덱스 파일

- 인덱스는 디스크에 저장된 데이터 레코드를 효율적으로 검색할 수 있는 자료구조다.
- 인덱스 파일은 데이터 레코드를 식별할 수 있는 키 또는 기본키를 데이터 파일에서 해당 레코드의 위치에 매핑한다.
- 일반적으로 기본 인덱스는 기본 키 또는 기본키 역할을 할 수 있는 여러 키의 조합에 대한 인덱스고 나머지는 모두 보조 인덱스라고 한다.
- 보조 인덱스는 데이터 레코드를 직접 가리키거나 해당 레코드의 기본 키를 저장한다.
- 여러 보조 인덱스가 같은 레코드를 가리킬 수 있고 하나의 레코드는 여러 다른 필드로 식별될 수 있고 다양한 인덱스를 사용해 검색할 수 있다.
- 기본 인덱스 파일은 키별로 하나의 레코드만 가리키는 반면, 보조 인덱스는 키별로 여러 레코드를 가리킬 수도 있다.
- 실제 데이터 레코드의 정렬 순서와 검색 키의 정렬 순서가 같은 인덱스를 클러스터형 인덱스라고 한다. (기본 인덱스)
- 데이터가 다른 파일에 저장돼 있고 인덱스 키를 기준으로 정렬되지 않은 인덱스는 비클러스터형 인덱스라고 한다.
- 대부분의 데이터베이스 시스템은 데이터 레코드를 식별할 수 있는 칼럼의 집합을 내부 키로 사용한다. 기본키를 설정하지 않은 경우 내부적으로 기본 키를 자동 생성한다.

### 기본 인덱스를 통한 간접 참조

- 데이터를 직접 참조하면 디스크 탐색 오버헤드가 줄어든다. 하지만 레코드를 갱신하거나 위치를 변경할 때마다 포인터를 수정해야하는 오버헤드가 있다.
- 기본 인덱스를 통해 간접 참조하면 포인터 갱신 비용이 줄어들지만 레코드 위치를 찾는 과정이 추가된다.
- 읽기 작업이 많은 워크로드에서는 인덱스 개수가 여러 개여도 괜찮지만 쓰기 작업이 많은 워크로드에서는 인덱스 개수가 많으면 포인터 갱신이 문제가 될 수 있다. 따라서 일부 시스템은 오프셋 대신 기본 키를 사용해 데이터를 간접 참조한다.

## 버퍼링과 불변성, 순서화

- 데이터베이스 자료 구조에는 세 가지 공통점이 있다. 
  1. 버퍼링을 사용한다는점
  2. 불변파일을 사용한다는점
  3. 저장할 때 값의 순서를 유지한다는 점



`버퍼링`

- 데이터를 디스크에 쓰기 전에 일부를 메모리에 저장하는 것
- 디스크와 데이터를 주고받는 가장 작은 전송단위는 블록이므로 블록을 채워서 쓰는 것이 바람직하기 때문이다.

`가변성 (또는 불변성)`

- 파일 일부를 읽고 갱신한 뒤에 똑같은 자리에 다시 쓸지에 대한 여부를 나타내는 속성
- 불변 구조에서는 한 번 쓴 파일 내용은 고칠 수 없다.

`순서화`

- 디스크 페이지에 데이터 레코드를 키 순서로 저장하는 것을 의미한다.
- 정렬 순서상 인접한 키는 디스크의 연속된 세그먼트에 저장된다.
- 순서화는 특정 데이터 레코드 검색뿐만 아니라 효율적인 범위 스캔에 매우 중요한 속성이다.



## 요약 







# #2 B-트리 개요

- 불변성은 저장 구조의 설계와 구현 방식을 결정하는 중요한 속성이다.
- 대부분의 가변 자료 구조는 데이터 삽입 및 삭제, 업데이트 시 데이터 저장 위치에 새로운 데이터를 바로 쓰는 인플레이스 업데이트 방식을 사용한다.
- 스토리지 엔진은 동시성 제어, 슬롯 페이지 구조 같은 방식으로 여러 버전의 레코드를 데이터베이스에 저장하지만 쉽게 이해할 수 있게 책에서 모든 키는 고유한 위치에 저장된 한 개의 데이터 레코드를 가리킨다고 가정한다. 
- B-트리는 가장 많이 사용되는 자료 구조 중 하나다.



## 이진 탐색 트리

- 이진 탐색 트리는 정렬된 인메모리 자료 구조로 키-값 쌍 검색에 사용된다.
- BST는 키와 두 개의 자식 포인터(left, right)가 저장된 여러 노드로 구성된다.
- 각 노드의 키는 왼쪽 서브트리의 모든 노드보다 크고 오른쪽 서브트리의 모든 키보다 작다.
- 루트에서부터 왼쪽 포인터를 따라 리프 레벨까지 내려가면 트리에서 가장 작은 키와 해당 값이 저장된 노드가 있다. 마찬가지로 오른쪽 포인터의 가장 밑은 가장 큰 키가 저장된 노드가 있다.



### 트리 밸런싱

- 노드 삽입 작업에는 특정 패턴이 없어 삽입하는 값에 따라 트리가 불균형해질 수 있다. 이 경우 선형 복잡도(On)을 가질 수 있다.
- 균형 트리란 노드 개수가 N일때 높이가 log2N이고 두 서브트리의 높이 차이가 최대 1인 트리다.
- 균형 트리는 왼쪽 오른쪽 2개의 노드 포인터가 있기 때문에 탐색 공간이 평균적으로 절반이 줄어든다. 따라서 탐색 시간 복잡도는 O(log2N)이다.
- 새로운 노드 추가로 인해 트리가 치우치지 않도록 노드 삽입 후 트리의 균형을 유지해야 한다.



### 디스크 기반 스토리지용 트리

- 트리의 팬아웃(노드가 가질 수 있는 최대 자식 노드의 개수)이 낮기 때문에 트리 밸런싱, 노드 재배치, 포인터 갱신이 자주 발생한다. 따라서 BST는 높은 트리 유지 비용 때문에 디스크 기반 자료구조로는 적합하지 않다.
- BST를 디스크에서 제어하면 몇 가지 문제에 직면한다.
  - 지역성: 노드는 키 순서에 따라 삽입되지 않기 때문에 새로운 노드와 부모 노드가 가까운 위치에 저장되지 않을 수 있다.
  - 트리의 높이: 팬아웃이 2이기 때문에 높이는 전체 노드 수의 로그 값이다.
- 디스크 기반 BST의 구현은 지역성을 고려하지 않기 떄문에 최악의 경우 비교 횟수만큼 디스크 탐색이 필요하다.
- 디스크 저장에 적합한 트리의 두가지 특성
  - 인접한 키의 지역성을 높이기 위한 높은 팬아웃
  - 트리 순회 중 디스크 탐색을 줄이기 위한 낮은 트리 높이



## 디스크 기반 자료 구조

- 자료구조도 일부는 디스크에 알맞고 일부는 메모리 저장에 적합하다.
- 데이터베이스 자료구조는 디스크와 같은 영속적 저장 매체의 한계를 반드시 고려해야 한다.
- 디스크 기반 자료구조는 메모리에 데이터 전부를 저장할 수 없을 때 주로 사용한다.
- 데이터 일부를 메모리에 캐시하고 나머지는 효율적으로 접근할 수 있는 형태로 디스크에 저장한다.

### 하드 디스크 드라이브

- 디스크에서는 탐색 작업이 랜덤 읽기 비용의 많은 부분을 차지한다. 디스크를 회전하고 읽기/쓰기용 헤드를 원하는 위치까지 물리적으로 옮겨야 하기 때문이다.
- 디스크 탐색 작업 이후의 연속된 바이트 읽기/쓰기는 상대적으로 비용이 낮다.
- 디스크의 최소 전송 단위는 섹터이고 모든 작업은 최소 한 개의 섹터를 읽거나 쓴다. 섹터의 크기는 보통 512바이트에서 4kb 사이다.
- 물리적 헤드 이동은 HDD 작업 중 가장 비용이 높은 작업이다. 따라서 디스크에서 연속된 메모리 섹터를 읽거나 쓰는 순차적 I/O를 극대화해야 한다.

### 솔리드 스테이트 드라이브

- 디스크와 달리 SSD는 물리적으로 움직이는 부품이 없다.(no 회전 디스크, no 헤드)
- SSD는 메모리 셀로 구성된다.
- 셀을 연결하면 스트링이 되고 스트링의 배열이 페이지를 이룬다. 페이지가 모이면 블록이 된다.
- 내부 구현 방식에 따라 셀은 한 개 또는 여러 개의 비트를 저장한다.
- 페이지는 보통 2~16kb, 블록은 64~512개의 페이지로 구성된다.
- 블록의 집합은 플레인, 플레인의 집합은 다이라고 부르며 SSD는 한 개 이상의 다이로 구성된다.
- 페이지는 읽고 쓸 수 있는 가장 작은 단위이고 비어 있는 메모리 셀에서만 쓸 수 있다.
- 반면 삭제할 수 있는 가장 작은 단위는 페이지가 아니라 블록이다. 이 때문에 삭제 블록이라고 불기도 한다.
- 페이지 ID를 실제 위치와 매핑하고 비어 있거나 쓰여진 혹은 삭제된 페이지를 관리하는 플래시 메모리 컨트롤러를 플래시 변환 레이어(FTL)라고 부른다.
- HDD와 SSD는 개별 바이트 단위가 아닌 메모리 청크 단위로 데이터를 참조해서 대부분의 운영체제에는 블록 디바이스 추상화 계층이 있다.
- 이 계층은 하드 디스크의 내부 구조를 추상화하고 I/O 작업을 내부적으로 버퍼링 한다. 블록 디바이스에서 하나의 워드를 읽으면 해당 워드를 포함하는 블록 전체를 읽게 된다. 이는 디스크 기반 자료 구조에서 항상 염두에 둬야 할 중요한 제약사항이다.
- SSD는 HDD와 다르게 랜덤과 순차I/O의 구분이 중요하지 않다. 둘 사이의 레이턴시가 매우 작기 때문이다.
- 전체 블록 단위로 쓰거나 같은 블록에 대한 쓰기 작업을 모아 한 번에 처리할 수 있다면 I/O 작업 수를 줄일 수 있다.



## 디스크 기반 자료

- 효율적인 디스크 기반 자료 구조 설계가 어려운 이유는 디스크 접근 비용 탓도 있지만 가장 작은 작업 단위가 블록이라는 제약 때문이다.
- 블록의 특정 위치를 참조하려면 블록 전체를 읽어야 한다. 이와 같은 특성을 고려해 자료구조를 설계해야 한다.
- 대부분의 경우 디스크 기반 자료 구조에서는 포인터를 직접 관리해야한다.
- 디스크 기반 자료구조에 긴 종속 관계 사슬이 만들어지면 유지관리가 어렵고 구조가 매우 복잡해진다. 따라서 전체 포인터수를 제안하고 저장 범위를 최소화하는 편이 좋다.
- 정리하자면 디스크 기반 자료구조는 저장 매체의 구조를 고려해서 설계해야 하며 디스크 접근 횟수를 최소화해야 한다. 내부 구조를 최적화하고 지역성을 높여 페이지를 넘나드는 포인터를 최소화해야 한다 
- 디스크 기반 자료 구조는 팬아웃이 높고 높이가 낮을 때 가장 이상적이다.
- B-트리는 팬아웃을 크게하고 높이와 노드 포인터 개수, 밸런싱 빈도를 줄인 트리이다.



### 유비쿼터스 B-트리

- B-트리는 검색 항목을 빠르게 찾을 수 있는 계층형 자료 구조다.
- B-트리는 키의 순서가 보장되는 자료구조다. 노드 키를 기준으로 정렬해서 저장하기 때문에 이진 탐색과 같은 알고리즘을 사용해 특정 키를 찾을 수 있다.
- B-트리의 탐색 시간 복잡도는 로그 시간이다. (40억개의 키에서 특정 키를 찾는데 32번의 비교가 필요하다)
- B-트리를 사용해 포인트 쿼리와 범위 쿼리를 효율적으로 수행할 수 있다.



### B-트리 계층

- B-트리는 여러 노드로 구성된다.
- 각 노드는 최대 N개의 키와 N+1개의 자식 노드 포인터를 저장한다.
- 노드는 논리적으로 다음 세 개의 계층으로 나눌 수 있다.
  - 루트 노드
    - 트리의 최상위 노드로 부모 노드가 없다.
  - 내부 노드
    - 루트와 리프 노드를 연결하는 모든 노드. 트리에는 일반적으로 한 레벨 이상의 내부 노드가 있다.
  - 리프 노드
    - 자식 노드가 없는 트리의 최하위 계층 노드



사진

- B-트리는 페이지 기반 자료구조이기 때문에 노드와 페이지가 같은 의미로 쓰이기도 한다.
- 보유 가능한 노드 용량과 실제로 보유하고 있는 키의 개수의 비율을 점유율이라고 한다.
- B-트리에서 각 노드에 저장할 수 있는 최대 키 수를 의미하는 팬아웃은 중요한 속성이다.
- 팬아웃이 높으면 트리의 균형을 유지하는 데 필요한 트리 구조 변경 비용을 낮출 수 있고 키와 포인터 같은 블록 또는 연속된 블록에 저장해 불필요한 탐색을 줄일 수 있다.
- B-트리는 루프와 내부, 리프노드가 포함된 모든 레벨에 값을 저장할 수 있는 반면에 B+트리는 리프 노드에만 값을 저장할 수 있다. (참고)





### 구분 키

- B-트리 노드에 저장된 키를 인덱스 엔트리, 구분 키, 또는 디바이더 셀이라고 부른다.
- 각 키는 트리를 해당 키 범위의 서브트리로 분할한다.
- 키는 정렬되어 있어서 이진 검색에 사용할 수 있다.
- 노드의 첫번째 포인터는 해당 키보다 작은 키가 저장된 서브트리를 가리키고 마지막 키는 해당 키보다 같거나 큰 키가 저장된 서브트리를 갖는다. 나머지 포인터들은 두 키 사이의 서브트리를 가리킨다.
- 이중 연결리스트 형식의 포인터를 사용해 양방향으로 탐색할 수 있도록 B-트리를 구현하기도 한다.
- 하향식으로 만들어지는 이진트리와 반대로 B-트리는 상향식으로 트리를 구성한다. 리프노드가 많아질수록 내부 노드와 높이가 증가한다.
- B-트리는 나중에 삽입 및 업데이트될 노드의 공간을 미리 확보해둬서 공간 활용률이 최대 50%까지 낮아질 수 있지만 높은 점유율은 B-트리 성능에 부정적인 영향을 미치지 않는다.



### B-트리 탐색의 시간 복잡도

- B-트리 탐색의 시간 복잡도는 블록 전송 횟수와 비교 횟수라는 두 가지 관점에서 계산할 수 있다.
- 전송횟수 관점에서 복잡도는 최대 logk M개의 페이지에 접근해야 한다.
- 비교횟수 관점에서는 이진탐색을 사용해 키를 찾기 때문에 log2 M이다.



### B-트리 탐색 알고리즘

- B-트리에서 특정 값을 찾으려면 루트에서 리프 레벨까지 순회해야한다.
- 포인트 쿼리와 업데이트, 삭제 작업에는 정확히 일치하는 키를 찾아야하고 범위 스캔과 노드 삽입시에는 대상 키의 바로 앞의 키를 찾아야 한다.
- 탐색 알고리즘은 루트 노드에서부터 이진 검색을 수행한다. 낮은 레벨로 내려갈 수록 검색 범위가 줄어든다.
- 포인트 쿼리는 특정 키를 찾거나 찾는 데 실패하면 완료되고 범위 스캔은 첫번째 키 값 쌍에서 시작해 범위 끝에 도달하거나 조건을 충족하지 않는 노드를 찾을때까지 형제 노드 포인터를 따라간다.



### 키 개수

- 키와 자식 오프셋 수를 계산하는 다양한 방식이 있지만 결과는 동일하고 설명하는 방식이 다를뿐이다.
- 이 책에서는 N을 키의 개수로 정의한다.



### B-트리 노드 분할

- B-트리에 새로운 노드를 삽입하려면 우선 대상 리프를 찾고 삽입할 위치를 결정해야 한다.

- 리프노드에 남은 공간이 없는 노드를 오버플로우 상태라고 한다. 오버플로우 상태의 노드에 새로운 키를 삽입하려면 노드를 분할해야 한다. 

- 노드 분할 조건

  - 리프노드: 노드에 최대 N개의 키-값 쌍을 저장할 수 있고 새로운 키-값 쌍을 삽입 시 용량이 초과되는 경우
  - 리프가 아닌 노드: 노드에 최대 N+1 개의 포인터를 저장할 수 있고 포인터 추가시 용량이 초과되는 경우

- 노드 분할은 새로운 노드를 할당해 키의 절반을 새로운 노드로 옮기고 첫 번째 키와 포인터를 부모 노드에 추가하는 방식으로 이뤄진다. 이때 이러한 키는 승급했다고 표현하고 분할이 발생한 키를 분할 지점이라고 부른다.

- 부모 노드에 승급 키와 포인터를 추가할 공간이 없을 경우 부모 노드로 분할하고 이는 루트 노드까지 재귀적으로 전파될 수 있다.

- 트리에 용량이 부족하면 기존의 루트와 생성된 형제 노드는 다음 레벨로 강등되고 트리의 높이가 한 레벨 증가한다.

- 루트 노드 분할로 인해 새로운 루트 노드를 할당하거나 노드 병합으로 인해 새로운 루트 노드가 형성되면 트리의 높이가 변한다. 반면 리프와 내부 노드 레벨에서는 트리가 수평으로만 확장한다.

  

  

사진

- 키 11삽입으로 인해 남은 공간이 없는 비 리프노드를 분할하는 과정
- 새로운 노드를 생성하고 N/2 + 1번 인덱스로부터 옮긴다. 분할 저짐의 키는 부모 노드로 승급된다.



사진



- 리프가 아닌 노드의 분할은 항상 하위 레벨 노드의 분할로 인해 발생하기 때문에 새로운 포인터가 추가된다.
- 리프 노드가 분할되는지 리프가 아닌 노드가 분할되는지는 상관 없다. 리프 노드를 분할할 경우 키와 값을 모두 옮긴다.
- 분할이 완료되면 두 노드 중에 새로운 키를 상비할 노드를 선택한다. 구분 키의 속성에 따라 삽입할 키가 승급된 키보다 작자면 분할 노드에 삽입하고 더 크다면 새로운 노드에 삽입한다.
- 노드 분할 요약
  1. 새로운 노드를 할당한다.
  2. 분할 노드 키의 절반을 새로운 노드로 복사한다.
  3. 새로운 키를 알맞은 노드에 삽입한다.
  4. 분할 노드의 부모 노드에 분할 키와 새로운 노드를 가리키는 포인터를 추가한다.





### B-트리 노드 병합

- 키를 삭제하는 경우에는 우선 대상 키가 포함된 리프 노드를 찾는다.
- 키를 삭제하다보면 노드에 저장된 값이 너무 적은 경우가 생기는데 이때는 형제 노드들을 병합해야한다. 이런 상황을 언더플로우라고 한다.
- 언더플로우가 발생하는 시나리오
  - 형제 노드의 부모가 같고 한 개의 노드로 합칠 수 있다면 두 노드를 병합한다.
  - 한 개의 노드로 합칠 수 없다면 키를 두 노드 사이에 재분배하고 균형을 맞춘다.
- 노드 병합 조건 정리
  - 리프 노드: 노드에 최대 N개의 키-값 쌍을 저장할 수 있고 두 노드의 총 키-값 쌍의 수가 N보다 작은 경우
  - 리프가 아닌 노드: 노드에 최대 N+1개의 포인터를 저장할 수 있고 두 노드의 포인터 수의 합이 N+1 보다 작은 경우



사진



- 노드 병합은 이미 키가 이미 삭제되었다고 가정할 때 다음 세 단계로 이뤄진다.
  1. 모든 키를 오른쪽 노드에서 왼쪽 노드로 복사한다.
  2. 부모 노드에서 오른쪽 노드를 가리키는 포인터를 제거한다.
  3. 오른쪽 노드를 제거한다



## 요약

- 이진 탐색 트리는 복잡도 관점에서 보면 디스크에 더 적합하지만 팬아웃이 낮고 균형을 맞추기 위한 재배치와 포인터 업데이트가 자주 발생하기 때문에 디스크에 적합하지 않다.
- B-트리는 각 노드에 더 많은 키를 저장할 수 있고 리밸런싱 작업 빈도가 더 낮은 자료구조이다.
- B-트리는 노드 삽입 또는 삭제 시 노드 분할과 병합을 통해 트리의 균형을 유지한다.
- 트리의 높이는 최소한으로 유지해야 하고 키 추가시 사용 가능한 공간이 남아 있는 노드를 적극 활용해야 한다.
- 디스크 기반 B-트리의 특성은 인메모리 B-트리 설계 시에도 똑같이 적용할 수 있다. 디스크 기반 B-트리 구현 시 디스크에 노드를 저장하는 방식과 데이터 인코딩 포맷을 신중하게 결정해야 한다.





