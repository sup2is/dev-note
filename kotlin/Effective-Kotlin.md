



# Effective Kotlin

코드 참고: [https://github.com/f-lab-edu/kts-effective-kotlin/](https://github.com/f-lab-edu/kts-effective-kotlin/)

# #1 안정성

- 코틀린의 가장 큰 장점은 안전하다는 것!!!

## 아이템 1: 가변성을 제한하라

- 프로그램이 상태를 가지면 어려운 점들 ..
  - 프로그램을 이해하고 디버깅하기 힘들어진다. 추적 & 사이드이펙트 등등 ..
  - 가변성이 있으면 코드의 실행을 추론하기 어려워진다.
  - 멀티스레드 프로그램일 때 적절한 동기화가 필요하다.
  - 모든 상태를 테스트하기 어렵다.
  - 상태변경이 일어날 때 다른 부분에 알려줘야 하는 경우가 있다.
- **변할 수 있는 지점은 줄일 수록 좋다.**
- 순수 함수형 언어
  - 하스켈같은 순수 함수형언어는 가변성을 완전히 차단한다.
  - 실제로 프로그램을 작성하기 매우 어렵기 때문에 주류로 사용하는 언어가 되지 못한다.
- 가변성
  - 시스템의 상태를 나타내기 위한 중요한 방법
  - 하지만 변경이 일어나는 부분을 신중하고 확실하게 결정해야 한다.



### 코틀린에서 가변성 제어하기

- 코틀린에서 가변성 제어하기
  - 읽기 전용 프로퍼티 (val)
  - 가변 컬렉션과 읽기 전용 컬렉션 구분하기
  - 데이터 클래스의 copy



**읽기 전용 프로퍼티 (val)**

- val로 선언한 프로퍼티는 마치 값처럼 동작하고 일반적인 방법으로 값이 변하지 않는다.

```kotlin
val a = 10
a = 20 // 오류
```

- 읽기 전용 프로퍼티가 mutable 객체를 담고 있다면 내부적으로는 변할 수 있다.

```kotlin
val list = mutableListOf(1,2,3)
list.add(4)
print(list) // [1, 2, 3, 4]
```

- 사용자 정의 게터로 정의된 val 프로퍼티도 변할 수 있다.

```kotlin
var name: String = "GilDong"
var surname: String = "Hong"
val fullName
	get() = "$name $surname"

fun main() {
	println(fullName) // Hong GilDong
	name = "Kim"
	println(fullName) // Kim GilDong
```







## 아이템 2: 변수의 스코프를 최소화하라

## 아이템 3: 최대한 플랫폼 타입을 사용하지 말라

## 아이템 4: inffered 타입으로 리턴하지 말라

## 아이템 5: 예외를 활용해 코드에 제한을 걸어라

## 아이템 6: 사용자 정의 오류보다는 표준 오류를 사용하라

## 아이템 7: 결과 부족이 발생할 경우 null과 Failure를 사용하라

## 아이템 9: use를 사용하여 리소스를 닫아라

## 아이템 10: 단위 테스트를 만들어라



