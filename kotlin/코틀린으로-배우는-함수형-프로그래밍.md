



# 코틀린으로 배우는 함수형 프로그래밍

예제 참고

- https://github.com/funfunStory/fp-kotlin-example





# #1 함수형 프로그래밍이란?

## 함수형 프로그래밍의 특징

- 함수형 프로그래밍은 함수를 사용해서 데이터 처리의 참조 투명성을 보장하고 상태와 가변 데이터 생성을 피하는 프로글밍 패러다임이다.
- 함수형 프로그래밍의 특징
  - 불변성
  - 참조 투명성
  - 일급 함수
  - 게으른 실행
- 함수형 프로그래밍의 장점
  - 부수효과가 없는 프로그램을 만들 수 있어 동시성 프로그래밍에 적합하다.
  - 코드의 복잡도가 낮아 간결한 코드를 만들 수 있고, 모듈성이 높아져 유지보수하기 쉽다.
  - 프로그램의 예측성을 높여 컴파일러가 효율적으로 실행되는 코드를 만들어 준다.



## 순수한 함수란 무엇인가?

- 순수한 함수의 예

```kotlin
fun pureFunction(x: Int, y: Int): Int = x + y
```

- 순수 함수의 특징
  - 동일한 입력으로 실행하면 항상 동일한 결과가 나온다.
  - 부수효과가 없다.

### 동일 입력 동일 출력

- 동일한 입력으로 실행하면 항상 동일한 결과가 나온다.
- 순수하지 않은 함수의 특징
  - 전역 변수, 파일 네트워크 등으로부터 데이터를 가져오면서 같은 값을 입력해도 다른 결괏값을 낸다.

```kotlin
// 순수하지 않은 함수
fun impureFunction(x: Int, y: Int): Int = x + y + z

println(impureFunction(1, 2))   // 13
z = 20
println(impureFunction(1, 2))   // 23
```



### 부수효과 없는 코드

- 부수효과
  - 함수가 실행되는 과정에서 외부의 상태를 사용 또는 수정하는 것을 말한다.
  - 전역변수, 정적 변수, 파일, 네트워크를 출력하는 작업

```kotlin
fun withSideEffect(x: Int, y: Int): Int {
    z = y
    return x + y
}
```



### 순수한 함수의 효과와 그 외 고려사항

- 함수형 프로그래밍의 장점
  - 동일한 입력에 대해 동일한 결과를 반환하고 부수효과가 없기 때문에 결과에 대한 추론이 가능하고 테스트도 쉽다.
  - 컴파일 타임에 코드를 최적화하거나 오류 코드를 예측하고 경고하는 등 많은 것을 할 수 있다.
- 정말 부수효과가 없으면 안돼?
  - 순수한 함수형이 아닌 하이브리드 언어들은 파일 입출력이나 네트워크 통신 등등을 허용한다.



## 부수효과 없는 프로그램 작성하기

### 공유 변수 수정으로 인한 부수효과

- 함수 내에서 전역 변수와 같은 공유 변수를 수정하면 부수효과가 발생하고, 이 변수를 참조하는 변수는 결과가 외부 요인에 의해 달라진다.

```kotlin
// 순수하지 않은 함수
fun impureFunction(x: Int, y: Int): Int = x + y + z

// 부수 효과가 있는 함수
fun withSideEffect(x: Int, y: Int): Int {
    z = y
    return x + y
}

z = 10
println(impureFunction(1, 2))   // 13
println(withSideEffect(10, 20))   // 30
println(impureFunction(1, 2))   // 23
```

- 이러한 불확실성은 많은 노이즈코드를 생성하고 프로그램을 복잡하게 만든다.



### 객체의 상태 변경으로 인한 부수효과

```kotlin
data class MutablePerson(var name: String, var age: Int)

// 인자로 들어온 객체의 상태를 변경
fun addAge(person: MutablePerson, num: Int) {
    person.age += num
}
```

- 함수형 프로그래밍에서는 가변객체를 사용하지 않고 불변 객체를 사용한다.

```kotlin
// 객체의 속성을 val로 선언하면 수정이 불가능함
data class ImmutablePerson(val name: String, val age: Int)

// Person 객체를 수정하지않고, 새로운 객체로 생성하여 반환
fun addAge(person: ImmutablePerson, num: Int): ImmutablePerson {
    return ImmutablePerson(person.name, person.age + num)
}
```

- 불필요한 부수효과를 최소화하는 것이 함수적 해법이다.



## 참조 투명성으로 프로그램을 더 안전하게 만들기

- 참조 투명성
  - 프로그램의 변경 없이 어떤 표현식을 값으로 대체할 수 있다는 뜻
- 참조 투명성의 장점
  - 프로그래머나 컴파일러가 평과 결과를 추론할 수 있다.
  - 코드에 예외가 사라져서 간결해지고 버그가 발생할 가능성은 낮아진다.
  - 멀티스레드 코드에서도 스레드 안정성에 대한 고민을 덜 수 있다.

### 참조 투명하지 않은 함수

```kotlin
var someName: String = "Joe"

fun hello1() {
    println("Hello $someName")
}

```

- 전역변수에 의존하기때문에 참조에 투명하지 않다.



### 참조 투명한 함수

```kotlin
fun main() {
    val result = transparent("Joe")
    print(result)
}

fun transparent(name: String): String {
    return "Hello $name"
}

fun print(helloStr: String) {
    println(helloStr)
}

```

- transparent 함수는 참조에 투명하다. 언제 어디서 호출해도 문제가 없기때문에 재사용성이 높고 테스트하기 쉽다.
- print는 부수효과이기때문에 함수의 본문에서 순수함수 본문에서 분리했다.
- 이렇게까지 해야돼?
  - 함수형 프로그래밍 관점에서 올바른 설계 방향이다.
  - 부수효과를 일으키는 영역과 순수한영역을 되도록 분리하고 참조에 투명한 함수들로 구성하는 것이 좋다.
  - 이렇게하면 코드에 버그가 생길 확률이 줄어들고 더 안전한 프로그램을 작성할 수 있다.



## 일급 함수란?

### 일급 객체

- 일급 객체의 세가지 조건
  - 객체를 함수의 매개변수로 넘길 수 있다.
  - 객체를 함수의 반환값으로 돌려줄 수 있다.
  - 객체를 변수나 자료구조에 담을 수 있다.

```kotlin
// Any를 함수의 매개변수로 넘길수 있다
fun doSomethingWithAny(any: Any) {
    // do something
}

// Any를 함수의 리턴값으로 돌려줄 수 있다
fun doSomethingWithAny(): Any {
    return Any()
}

// Any를 List 자료구조에 담을 수 있다
var anyList: List<Any> = listOf(Any())

```



### 일급 함수

- 일급 함수의 세가지 조건
  - 함수를 함수의 매개변수로 넘길 수 있다.
  - 함수를 함수의 반환값으로 돌려줄 수 있다.
  - 함수를 변수나 자료구조에 담을 수 있다.

```kotlin
// 함수를 함수의 매개변수로 넘길수 있다
fun doSomething(func: (Int) -> String) {
    // do something
}

// 함수를 함수의 리턴값으로 돌려줄 수 있다
fun doSomething(): (Int) -> String {
    return { value -> value.toString() }
}

// 함수를 List 자료구조에 담을 수 있다
var funcList: List<(Int) -> String> = listOf { value -> value.toString() }
```



## 일급 함수를 이용한 추상화와 재사용성 높이기

### 간단한 계산기 예제

```kotlin
fun main() {
    val calculator = SimpleCalculator()

    println(calculator.calculate('+', 3, 1))    // 4
    println(calculator.calculate('-', 3, 1))    // 2
}

class SimpleCalculator {
    fun calculate(operator: Char, num1: Int, num2: Int): Int = when (operator) {
        '+' -> num1 + num2
        '-' -> num1 - num2
        else -> throw IllegalArgumentException()
    }
}
```

- 좋은 프로그램은 아니다. 연산자가 추가될 때마다 프로그램이 변경되어야 한다.



### 객체지향적으로 개선한 계산기 예제

```kotlin

fun main() {
    val plusCalculator = OopCalculator(Plus())
    println(plusCalculator.calculate(3, 1))  // 4

    val minusCalculator = OopCalculator(Minus())
    println(minusCalculator.calculate(3, 1))  // 2
}

interface Calculator {
    fun calculate(num1: Int, num2: Int): Int
}

class Plus : Calculator {
    override fun calculate(num1: Int, num2: Int): Int {
        return num1 + num2
    }
}

class Minus : Calculator {
    override fun calculate(num1: Int, num2: Int): Int {
        return num1 - num2
    }
}

class OopCalculator(private val calculator: Calculator) {
    fun calculate(num1: Int, num2: Int): Int = calculator.calculate(num1, num2)
}
```

- 객체지향의 장점
  - 기능 추가 및 변경 시, 관련없는 모듈을 수정할 필요가 없고 내부에 대해서 알 필요도 없다.
  - 인터페이스를 이용해 기능을 쉽게 확장할 수 있다.
  - 클래스나 함수들이 한 가지 일만 하기 때문에 코드 재사용성이 높다.
  - 의존성 주입 덕분에 테스트하기가 쉽다.



### 함수형 프로그래밍 방식으로 개선한 계산기 예제

```kotlin
package fp.kotlin.example.chapter01

fun main() {
    val fpCalculator = FpCalculator()

    println(fpCalculator.calculate({ n1, n2 -> n1 + n2 }, 3, 1))    // 4
    println(fpCalculator.calculate({ n1, n2 -> n1 - n2 }, 3, 1))    // 2
}

class FpCalculator {
    fun calculate(calculator: (Int, Int) -> Int, num1: Int, num2: Int): Int = calculator(num1, num2)
}
```





## 게으른 평가로 무한 자료구조 만들기

- 일반적으로 명령형 언어는 코드가 실행되는 즉시 값이 평가된다.
- 함수형 언어는 기본적으로 값이 필요한 시점에 평가되므로 프로그래머가 평가 시점을 지정할 수도 있다.

```kotlin
fun main() {
    println(lazyValue)  // hello
}

val lazyValue: String by lazy {
    // 매우 오래걸리는 작업
    "hello"
}
```

- 중요한것은 lazyValue를 선언하는 시점에는 프로그램이 실행되지 않고 lazyValue가 실제 호출되는 시점에 실행된다는 점.
- by lazy는 여러번 호출되더라도 최초에 한 번만 평가를 실행한다.
  - 값이 한 번만 평가되기 떄문에 값을 바꿀 수 없다.
  - 따라서 var타입은 사용이 불가능하다.



### 무한대 값을 자료구조에 담다

- 함수형 언어에서는 lazy evaluation으로 무한대 값을 자료구조에 저장할 수 있다.

```kotlin
fun main() {
    val infiniteValue = generateSequence(0) { it + 5 }
    infiniteValue.take(5).forEach { print("$it ") }   // 0 5 10 15 20
}
```



## 마치며

# #2 코틀린으로 함수형 프로그래밍 시작하기

## 프로퍼티 선언과 안전한 널 처리

### 프로퍼티 선언

- 코틀린에서는 읽기 전용 프로퍼티와 가변 프로퍼티를 구별해서 선언할 수 있다.

```kotlin
// 읽기 전용
val value: Int = 10

// 가변
var variable: Int = 10

// 읽기 전용 타입 추론
val value = 10

// 가변 타입 추론
var variable = 10
```

- 타입이 명확한 경우에는 타입을 생략해도 괜찮지만 코드가 복잡하다면 가독성을 위해 타입을 의도적으로 명시하는게 좋다.



### 안전한 널 처리

```kotlin
val nonNull: Int = null // 컴파일 오류 발생
val nullable: Int? = null
```

- 코틀린에서 타입 뒤에 ?를 붙이면 해당 프로퍼티는 값으로 널을 할당할 수 있다.
- ?가 없이 선언된 프로퍼티에 널을 할당하면 컴파일 오류가 발생한다.



## 함수와 람다

### 함수를 선언하는 다양한 방법

```kotlin
fun twice1(value: Int): Int {
  return value * 2
}

fun twice2(value: Int): Int = value * 2
fun twice3(value: Int) = value * 2
```

- 코틀린에서 함수는 블록을 생략하거나 리턴 타입을 생략할 수 있다.

```kotlin
fun add(x: Int, y: Int): Int {
  return x + y
} 

fun add(x: Int, y: Int): Int = x + y
fun add(x: Int, y: Int) = x + y
```



### 매개변수에 기본값 설정하기

- 코틀린은 함수의 매개변수에 기본값을 할당할 수 있다.

```kotlin
fun add(x: Int, y: Int = 3): Int = x + y

println(add(9, 1)) // 10
println(add(10)) // 13
```

- 매개변수의 순서에 따라서 값이 할당되기 때문에 주의해야 한다.

```kotlin
fun add(x: Int = 10, y: Int = 3): Int = x + y

println(add()) // 13
println(add(7)) // 10
```

- 호출자가 값을 할당하고자 하는 매개변수명을 지정할 수 있다.

```kotlin
fun add(x: Int = 10, y: Int = 3): Int = x + y

println(add(y = 7)) // 17
println(add(x = 10, y = 20)) // 30
```



### 익명 함수와 람다 표현식

- 익명 함수
  - 함수 이름을 선언하지 않고 구현부만 작성하는 함수를 표현하는 방식의 일종

```kotlin
fun sum(x: Int, y: Int, calculate: (Int, Int) -> Int): Int {
  return calculate(x, y)
}

val value = sum(5, 10, { x, y -> x + y})
```



### 확장 함수

- 코틀린에서는 상속을 하거나 내부를 수정하지 않고도 이미 작성된 클래스에 함수나 프로퍼티를 추가할 수 있다.

```kotlin
fun Int.product(value: Int): Int {
  return this * value
}

println(10.product(2)) // 20
```



`연습문제 2 - 1`

```kotlin
/**
 * 연습문제 2-1
 *
 * ``String`` 값을 입력받아 "Hello, 입력받은 값"이 출력하는 확장함수를 구현하라. 예를 들어 "World"를 입력받으면 "Hello, World", "Kotlin"을
 * 입력받으면 "Hello, Kotlin"을 출력한다.
 */
fun main() {
    require("kotlin".addHelloPrefix() == "Hello, kotlin")
    require("FP".addHelloPrefix() == "Hello, FP")
}

private fun String.addHelloPrefix(): String = "Hello, $this"
```



## 제어 구문

### if문

```kotlin
val max: Int

if (x > y) {
  max = x
} else {
  max = y
}
```

- 코틀린의 if문은 기본적으로 표현식이다. 표현식은 결과로서 어떤 값을 반환한다.

```kotlin
val max: Int = if (x > y) x else y
```

- 이런 경우 else 문을 반드시 작성해야 한다. (삼항연산자 같음)

### when문

```kotlin
when (x) {
  1 -> print("x == 1")
  2, 3 -> print("x == 2 or 3")
  parseInt("4") -> print("x == 4")
  else -> print("else number")
}
```

- when 문도 표현식이기 때문에 아래와 같이 사용할 수 있다.

```kotlin
val numType = when {
  x == 0 -> "zero"
  x > 0 -> "positive"
  else -> "negative"
}
```



### for문

```kotlin
val collection = listOf(1, 2, 3)

for (item in collection) {
  print(item) // 123
}

for ((index, item) in collection.withIndex()) {
  println("the element at $index is $item")
}
```

- 값의 범위와 증감 규칙을 사용할 수도 있다.

```kotlin
for (i in 1..3) {
  print(i) // 123
}

for (i until 3) {
  print(i) // 12
}

for (i in 6 downTo 0 step 2) {
  print(i) // 6420
}
```



## 인터페이스

### 인터페이스의 특징

- 코틀린에서 제공하는 인터페이스의 특징
  - 다중 상속이 가능하다.
  - 추상 함수를 가질 수 있다.
  - 함수의 본문을 구현할 수 있다.
  - 여러 인터페이스에서 같은 이름의 함수를 가질 수 있다.
  - 추상 프로퍼티를 가질 수 있다.

### 인터페이스 선언하고 상속하기

```kotlin
interface Foo {

}

interface Bar {

}

class Kotlin: Foo, Bar {

}
```



### 인터페이스에 추상 함수 선언하기

```kotlin
interface Foo {
  fun printFoo()
}

interface Bar {
  fun printBar()
}

class Kotlin: Foo, Bar {
  override fun printFoo() {
    //..
  }
  override fun printFoo() {
    //..
  }
}
```



### 추상 함수 구현하기

### 추상 프로퍼티의 선언과 사용

- 추상 프로퍼티
  - 해당 인터페이스를 상속한 클래스가 가질 프로퍼티를 말한다.

```kotlin
interface Foo {
  val bar: Int
}

class Kotlin : Foo {
  override val bar: Int = 3
}
```

- 추상 프로퍼티도 override 키워드로 재정의할 수 있다.

## 클래스

### 클래스와 프로퍼티

```kotlin
class User(var name: String, val age: Int)

val user = User("FP", 32)
println(user.name) // "FP"

user.name = "kotlin"
println(user.name) // "kotlin"
```

- 자동 getter setter
  - 프로퍼티는 자바의 멤버변수와 달리 게터와 세터를 내부에서 자동으로 생성해준다.
  - var로 선언된 프로퍼티는 게터와 세터를, val로 선언된 프로퍼티는 게터만 사용할 수 있다.
- 함수와 동일하게 클래스 셍성자에서도 프로퍼티의 기본값을 할당할 수 있다.

```kotlin
class User(var name: String, val age: Int = 17)
```



### data 클래스

- data class의 기능
  - 게터와 세터 생성
  - hashCode, eqauls, toString 메서드 override
  - copy, componentN 함수 제공

### enum 클래스

```kotlin
enum class Error(val num: Int) {
  WARN(2) {
    override fun getErrorName(): String {
      return "WARN"
    }
  },
  ERROR(3) {
    override fun getErrorName(): String {
      return "ERROR"
    }
  };
  
  abstract fun getErrorName(): String
}
```

### sealed 클래스

- sealed class
  - enum class의 확장 형태로 클래스를 묶은 클래스다.

```kotlin
sealed class Expr
data class Const(val number: Double): Expr()
data class Sum(val e1: Expr, val e2: Expr): Expr()
object NotANumber: Expr()
```

- enum 클래스와 달리 각 하위 클래스는 모두 다른 프로퍼티와 함수를 가질 수 있다.
- 단 sealed class는 동일한 파일에서만 선언이 가능하다.



## 패턴 매칭

### 다양한 패턴 정의 방법

```kotlin
fun main() {
    println(checkValue("kotlin"))   // kotlin
    println(checkValue(5))      // 1..10
    println(checkValue(15))     // 11 or 15
    println(checkValue(User("Joe", 76)))    // User
    println(checkValue("unknown"))  // SomeValue
}

data class User(val name: String, val age: Int)

fun checkValue(value: Any) = when (value) {
    "kotlin" -> "kotlin"
    in 1..10 -> "1..10"
    11, 15 -> "11 or 15"
    is User -> "User"
    else -> "SomeValue"
}
```



### 조건에 따른 패턴 매칭

```kotlin
fun main() {
    println(checkCondition("kotlin"))   // kotlin
    println(checkCondition(5))   // 1..10
    println(checkCondition(User("Joe", 76)))   // == User(Joe, 76)
    println(checkCondition(User("Sandy", 65)))   // is User
    println(checkCondition("unknown"))   // SomeValue
}

data class User(val name: String, val age: Int)

fun checkCondition(value: Any) = when {
    value == "kotlin" -> "kotlin"
    value in 1..10 -> "1..10"
    value === User("Joe", 76) -> "=== User"
    value == User("Joe", 76) -> "== User(Joe, 76)"
    value is User -> "is User"
    else -> "SomeValue"
}
```



### 코틀린 패턴 매칭의 제약

- 코틀린은 리스트와 같은 매개변수를 포함하는 타입이나 함수의 타입에 대핸 패턴매칭을 지원하지 않는다.

## 객체 분해

```kotlin
data class User(val name: String, val age: Int)

fun main(args: Array<String>) {
  val user: User = User("kotlin", 28)
  
  val (name, age) = user
}

```

- 이런 객체 분해는 for문에서 사용할 수 있다.

```kotlin
for ((name, age) in users) {
  ...
}
```

- 일부만 할당하고싶다면 _를 사용하면 된다.

```kotlin
for ((name, _) in users) {
  ...
}
```

- 객체분해가 가능한이유
  - 코틀린에서 객체 분해가 가능한 이유는 내부적으로 선언된 componentN 함수가 객체 분해시 사용된다.
- 객체분해는 람다식에서도 사용된다.

```kotlin
{ p1, p2 -> "$p1 $p2"} // 매개변수가 두개인 람다식
{ (p1, p2) -> "$p1 $p2"} // 튜플 한개를 받아서 객체 분해한 람다식
```

- 객체분해의 장점
  - 부필요한 코드를 없앤다.
  - 함수에서 여러 개의 값을 반환하거나 간결한 루프를 작성할 수 있다.



## 컬렉션

- 일반적으로 함수형 프로그래밍에서는 불변 자료구조를 사용한다.
- 불변 자료구조의 장점
  - 객체의 상태 변화를 미연에 방지해서 부수효과를 근본적으로 방지한다.
  - 상태 변화에 대한 예외를 고려할 필요가 없어서 코드를 간결하게 작성할 수 있게 한다.
- 코틀린은 불변과 가변 자료구조를 분리해서 제공한다
  - 불변
    - List, Set, Map
  - 가변
    - MutableList, MutableSet, MutableMap

### 리스트와 세트

### 맵

## 제네릭

### 제네릭 함수 선언

## 코틀린 표준 라이브러리

### let 함수

```kotlin
public inline fun <T, R> T.let(block: (T) -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block(this)
}
```

- let은 T의 확장함수다.
- 자기 자신은 T를 받고 R을 반환하는 block 함수를 입력으로 받고 block 함수의 반환값 R을 반환한다.
- let 함수를 사용하면 어떤 객체의 상태를 변경할 수 있다.

```kotlin
    val person = Person("FP", 30)
    val result = person.let {
        it.name = "Kotlin"
        it.age = 10
        it
    }
    println(result) // Person(name=Kotlin, age=10)
```

- person 객체의 확장함수로 선언되었기 때문에 Person 객체에서 let 함수를 제공하는 것처럼 연결되었다.
- 입력받은 block 함수에서는 it를 사용해서 person 객체에 접근했다. 그리고 block 함수의 반환값 it가 result에 할당되어 출력되었다.
- let 함수는 널처리에도 유용하게 사용된다.

```kotlin
fun printUserName(user: User?) {
  user?.let { println(it.firstName) }
}

val name = user?.let { it.lastName + it.firstName } ?: "lazysoul"
```



### with 함수

```kotlin
public inline fun <T, R> with(receiver: T, block: T.() -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return receiver.block()
}
```

- with는 일반적인 함수로 선언되어 있다.
- 객체(receiver)를 직접 입력받고 객체를 사용하기 위한 block 함수를 두 번째 매개변수로 받는다.
- T.()
  - 람다리시버
  - 람다 리시버는 첫 번째 매개변수로 받은 receiver의 타입 T를 block 함수의 입력인 T.()로 전달한다.
  - 이렇게 전달받으면 block 함수에서  receiver로 받은 객체에 this를 사용하지 않고 접근할 수 있다.
- with 함수는 block 함수의 반환값을 그대로 반환한다.
- with 함수도 let 함수와 동일하게 어떤 객체의 상태를 변경하는 데 활용될 수 있다.

```kotlin
fun with() {
    val person = Person("FP", 30)
    val result = with(person) {
        name = "Kotlin"
        age = 10
        this
    }
    println(result) // Person(name=Kotlin, age=10)
}
```

- with 함수는 person 객체를 함수의 입력으로 받았고, 블록 내에서 객체의 프로퍼티에 직접 접근한다.
- let 함수와 같이 it를 사용하거나 this를 사용하지 않고 객체의 프로퍼티에 바로 접근할 수 있는 것은 block의 첫 번째 매개변수가 람다 리시버이기 때문이다.



### run 함수

- run 함수는 두가지 형태로 선언되어 있다.

```kotlin
public inline fun <T, R> T.run(block: T.() -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block()
}

```

- 타입 T의 확장함수로 선언되었고 block 함수에 this가 람다 리시버로 전달된다. 그리고 block 함수의 반환값을 그대로 반환한다.

```kotlin
    val person = Person("FP", 30)
    val result = person.run {
        name = "Kotlin"
        age = 10
        this
    }
    println(result) // Person(name=Kotlin, age=10)
```

- let처럼 객체에 바로 호출하면서 it를 사용하지 않고 객체의 프로퍼티에 접근할 수 있다.
- run 함수는 let과 with 함수의 각 특징을 섞은 형태로 작성되었다.

```
public inline fun <R> run(block: () -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block()
}


```

- 두번째  run 함수는 확장 함수가 아니고 block 함수에 입력값이 없다.

```kotlin
    val person = run {
        val name = "Kotlin"
        val age = 10
        Person(name, age)
    }
    println(person) // Person(name=Kotlin, age=10)
```



### apply 함수

```kotlin
public inline fun <T> T.apply(block: T.() -> Unit): T {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    block()
    return this
}
```

- T의 확장 함수이므로  apply 함수는 객체를 통해서 호출된다. 또한  block 함수의 입력을 람다 리시버로 받았으므로 block 내에서  this 없이 객체에 접근할 수 있다.
- run과 유사하지만 block함수의 반환값이 없고 객체 자신 T를 리턴한다.

```kotlin
    val person = Person("FP", 30)
    val result = person.apply {
        name = "Kotlin"
        age = 10
    }
    println(result) // Person(name=Kotlin, age=10)
```

- 객체를 변경할때 주로 사용한다.

### also 함수

```kotlin
public inline fun <T> T.also(block: (T) -> Unit): T {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    block(this)
    return this
}

```

- block 함수의 반환값이 없고, 객체 자신인  T를 반환하는 점에서 let과 다르다.
- block 함수의 입력을 람다 리시버로 받지 않고 자기 자신을 입력받았다는 점에서 apply와 다르다.
- apply 함수와 동일하게 객체 자체를 변경할 때만 사용된다.



### let, with, run, apply, also 함수 비교

|           | let           | run           | with          | apply       | also      |
| --------- | ------------- | ------------- | ------------- | ----------- | --------- |
| 코드 블록 | 람다식        | 람다 리시버   | 람다 리시버   | 람다 리시버 | 람다식    |
| 접근      | it            | this          | this          | this        | it        |
| 반환값    | 람다식 반환값 | 람다식 반환값 | 람다식 반환값 | 자기 자신   | 자기 자신 |



### use 함수

- 클로저블 객체는 자원을 사용한 후 클로주 해주어야 한다.
- use는 이 클로저 작업을 자동으로 해주는 함수다 자바의 try-with-resource와 기능이 동일하다.

```
val property = Properties()
FileInputStream("config.properties").use {
  property.load(it)
}

```

- use 함수의 블록 내 동작이 완료되면 property는 자동으로 클로즈되어 자원이 정리된다.

## 변성

- 변성
  - 제네릭을 포함한 타입의 계층 관계에서 타입의 가변성을 처리하는 방식
  - "타입 S가 T의 하위 타입일때 Box[S]가 Box[T]의 하위 타입인가?" 라는 질문에서 부터 시작하는게 좋다.
    - Box[S]와 Box[T]는 상속 관계가 없다 -> 무공변
    - Box[S]는 Box[T]의 하위 타입이다 -> 공변
    - Box[T]는 Box[S]의 하위 타입이다. -> 반공변

### 무공변의 의미와 예

- 무공변은 타입 S가 T의 하위타입일 때, Box[S]와 Box[T] 사이에 상속 관계가 없는 것을 말한다.

```kotlin
interface Box<T>

open class Language
open class JVM : Language()
class Kotlin : JVM()
```

- 상속관계 Kotlin -> JVM -> Language

```kotlin
val languageBox = object : Box<Language> {}
val jvmBox = object : Box<JVM> {}
val kotlinBox = object : Box<Kotlin> {}

```

- 런타임에 타입이 소거되기 때문에 Box 안의 타입들이 상속관계임에도 불구하고 Box[T] 타입에 대한 상속 관계는 사라진다.

```kotlin
fun invariant(value: Box<JVM>) {}

//    invariant(languageBox)    // compile error
    invariant(jvmBox)
//    invariant(kotlinBox)      // compile error
```

- `Box<JVM>` 타입만 받기때문에 나머지 languageBox, kotlinBox는 컴파일에러가 발생한다.
- 여기서 `Box<JVM>`의 변성은 무공변이 된다.



### 공변의 의미와 예

- 공변은 타입 S가 T의 하위 타입일 때, Box[S]가 Box[T]의 하위 타입인 것을 말한다.
- 코틀린에서는 공변을  `<out T>` 로 선언한다.

```kotlin
fun covariant(value: Box<out JVM>) {}

//    covariant(languageBox)    // compile error
    covariant(jvmBox)
    covariant(kotlinBox)
```

- covariant 함수의 매개변수는  value 타입이 `Box<out JVM>`로 선언되었기 때문에 공변이다.
- 따라서 `Box<Kotlin>`, `Box<JVM>` 까지는 허용하지만  `Box<Language>`는 허용하지 않는다.



### 반공변의 의미와 예

- 반공변은 타입 S가 T의 하위 타입일 때, Box[S]가 Box[T]의 상위타입 인 것을 말한다.
- 코틀린에서는 반공변을 선언할 때, `<in T>` 를 사용한다.

```kotlin
fun contravariant(value: Box<in JVM>) {}

    contravariant(languageBox)
    contravariant(jvmBox)
//    contravariant(kotlinBox)  // compile error
```

- contravariant 함수의 매개변수는 반공변이기 때문에 Kotlin -> JVM -> Language와 반대방향으로 `Box<Language>` ->  `Box<JVM>` ->  `Box<Kotlin>` 으로 상속 관계가 성립된다.
- 따라서 `Box<JVM>`, `Box<Language>` 타입은 허용하지만  `Box<Kotlin>` 은 허용하지 않는다.



### in, out으로 변성 선언하기

- 코틀린에서는 변성으로  in, out 키워드를 사용해서 선언한다.
- 타입 매개변수를 이렇게 선언하면 기본적으로 변성을 가지게 될 뿐만 아니라 타입 매개변수에 대한 몇가지 정보를 컴파일러에게 알려준다.
- 무공변 타입 T를 가진  Box2 인터페이스

```kotlin
interface Box2<T> {
    fun read(): T
    fun write(value: T)
}
```

- 여기서 T는 무공변이다.
- 이때는 Box2에서 T를 읽어서 반환하거나, Box2에 T 타입의 값을 쓰는것이 모두 안전하다.

- 공변 타입T를 가진  Box2 인터페이스

```kotlin
interface Box2<out T> {
    fun read(): T
    fun write(value: T)    // compile error
}
```

- 타입 매개변수를 공변으로 선언하면 write 함수에 컴파일 오류가 발생한다.
- Box2에서 T를 읽어서 반환(produce)할 때는 어떤 상위 타입에 하위 타입을 할당하는 것이 가능하기에 문제가 발생할 여지가 없다.
- 하지만 write 함수에서는 value 값을 받아서 처리(consume)할 때 어떤 하위 타입이 들어올지 알 수 없기 때문에 런타임 오류가 발생할 가능성이 있다.

- 반공변 타입 T를 가진 Box2 인터페이스

```kotlin
interface Box2<in T> {
    fun read(): T         // compile error
    fun write(value: T)
}
```

- 반공변으로 선언했을 때는 반대로 read 함수에서 컴파일 오류가 발생한다.
- 호출자가 선언한 T 타입의 변수에 T 보다 상위 타입의 값을 할당하면 런타임 오류가 발생하기 떄문이다.



- in, out 키워드 이해하기
  - in으로 선언된 타입은 입력 값에만 활용할 수 있다.
  - out으로 선언된 타입은 반환 값의 타입으로만 사용할 수 있다. 
  - 타입을 선언할 때 타입 제한을 명시하면 프로그래머의 의도치 않은 실수를 컴파일 타임에 막을 수 있다.



## 마치며

# #3 재귀

## 함수형 프로그래밍에서 재귀가 가지는 의미

- 재귀
  - 어떤 함수의 구현 내부에서 자기 자신을 호출하는 함수를 정의하는 방법

### 피보나치 수열을 명령형 프로그래밍으로 구현한 예제

- 다이나믹 프로그래밍을 활용해서 피보나치 수열을 명령형 프로그래밍으로 구현하기

```kotlin
private fun fiboDynamic(n: Int, fibo: IntArray): Int {
    fibo[0] = 0
    fibo[1] = 1

    for (i in 2..n) {
        fibo[i] = fibo[i - 1] + fibo[i - 2]
    }

    return fibo[n]
}
```

- 이런 재귀는 미리 fibo[]의 메모리를 할당시켜야하는 문제가 있다.

### 피보나치 수열을 재귀로 구현한 예제

```kotlin
private fun fiboRecursion(n: Int): Int = when (n) {
    0 -> 0
    1 -> 1
    else -> fiboRecursion(n - 2) + fiboRecursion(n - 1)
}
```

- 이런 재귀는 스택을 사용하기 때문에 n의 값이 커지면 stackoverflow가 발생할 확률이 매우 높아진다.

### 함수형 프로그래밍에서 재귀

- 함수형 프로그래밍에서는 어떻게 값을 계산할 수 있을지 선언하는 대신 무엇을 선언할지를 고민해야 한다.
- 반복문에 대비한 재귀의 단점
  - 동적 계획법 방식에 비해서 성능이 느리다.
  - 스택 오버플로가 발생할 수 있다.

## 재귀를 설계하는 방법

- n번씩 Hello를 호출하는 helloFunc

```kotlin
private fun helloFunc(n: Int) {
    when {
        n < 0 -> return
        else -> {
            println("Hello")
            helloFunc(n - 1)
        }
    }
}
```

### 재귀 함수 설계 방법

- 종료조건
  - 재귀가 무한루프에 빠지지 않으려면 재귀에서 빠져나오는 종료조건이 적어도 한 개 이상존재해야한다.
  - 재귀가 반복할수록 종료조건으로 수렴해야 한다.
- 재귀 함수 접근 방식
  - 종로조건 정의
  - 함수의 입력을 분할하여 어떤 부분에서 재귀 호출을 할지 결정
  - 함수의 입력값이 종료조건으로 수렴하도록 재귀 호출의 입력값을 결정

### 재귀가 수행되는 흐름 관찰해 보기

- 1부터 5까지 더하는 프로그램

```kotlin
fun func(n: Int): Int = when {
    n < 0 -> 0
    else -> n + func(n - 1)
}
```



`연습문제 3- 1`

`연습문제 3- 2`

```kotlin
fun main() {
    require(25.0 == power(5.0, 2))
    require(1024.0 == power(2.0, 10))
}

private fun power(x: Double, n: Int): Double = when (n) {
    0 -> 1.0
    else -> x * power(x, n - 1)
}
```

`연습문제 3- 3`

```kotlin
fun main() {
    require(1 == factorial(1))
    require(24 == factorial(4))
    require(5040 == factorial(7))
    require(3628800 == factorial(10))
}

private fun factorial(n: Int): Int = when (n) {
    0 -> 1
    else -> factorial(n - 1) * n
}
```



### 재귀 함수 설계 방법을 사용하여 코드를 구현하기

## 재귀에 익숙해지기

### reverse 함수 예제

`연습문제 3-4`

```kotlin
/**
 * 연습문제 3-4
 *
 * 10진수 숫자를 입력받아서 2진수로 문자열로 변환하여 반환하는 함수를 작성하라.
 *
 * 힌트: 함수의 선언 타입은 아래와 같다.
 * fun toBinary(n: Int): String
 */

fun main() {
    require("1010" == toBinary(10))
    require("11011" == toBinary(27))
    require("11111111" == toBinary(255))
}

private fun toBinary(n: Int): String = when (n) {
    0 -> ""
    else -> "${toBinary(n / 2)}" + "${n % 2}"
}
```

`연습문제 3-5`

```kotlin
/**
 * 연습문제 3-5
 *
 * 숫자를 두 개 입력받은 후 두 번째 숫자를 첫 번째 숫자만큼 가지고 있는 리스트를 반환하는 함수를 만들어 보자. 예를 들어 ``replicate(3, 5)``를 입력하면
 * 5가 3개 있는 리스트 [5, 5, 5]를 반환한다.
 *
 * 힌트: 함수의 선언 타입은 아래와 같다.
 * fun replicate(n: Int, element: Int): List<Int>
 */

fun main() {
    require(listOf(5, 5, 5) == replicate(3, 5))
    require(listOf(1, 1, 1, 1, 1) == replicate(5, 1))
}

private fun replicate(n: Int, element: Int): List<Int> = when (n) {
    0 -> listOf()
    else -> listOf(element) + replicate(n - 1, element)
}
```

### take 함수 예제

`연습문제 3-6`

```kotlin
fun main() {
    require(elem(5, listOf(1, 3, 5)))
    require(!elem(5, listOf(1, 3, 7)))
}

private fun elem(num: Int, list: List<Int>): Boolean = when {
    list.isEmpty() -> false
    list.head() == num -> true
    else -> elem(num, list.tail())
}
```



### repeat 함수 예제

`연습문제 3-7`

```kotlin
/**
 * 연습문제 3-7
 *
 * 코드 3-9에서 다루었던 take 함수를 참고하여 repeat 함수를 테스트하기 위해서 사용한 takeSequence 함수를 작성해보자.
 * 그리고 repeat 함수가 잘 동작하는지 직접 테스트 해보라.
 *
 * 힌트: 함수의 선언 타입은 아래와 같다. 빈 시퀀스는 sequence.none() 으로 표현한다.
 * fun takeSequence(n: Int, sequence: Sequence<Int>): List<Int>
 */

fun main() {
    require(listOf(3, 3, 3, 3, 3) == takeSequence(5, repeat(3)))
}

private fun takeSequence(n: Int, sequence: Sequence<Int>): List<Int> = when {
    n <= 0 -> listOf()
    sequence.none() -> listOf()
    else -> listOf(sequence.head()) + takeSequence(n - 1, sequence.tail())
}

private fun repeat(n: Int): Sequence<Int> = sequenceOf(n) + { repeat(n) }
```



### zip 함수 예제

`연습문제 3-8`

```kotlin
/**
 * 연습문제 3-8
 *
 * 퀵정렬 알고리즘의 ``quicksort`` 함수를 작성해 보자.
 *
 * 힌트1: 퀵정렬 알고리즘의 동작 방식은 아래 위키를 참고하자.
 * https://en.wikipedia.org/wiki/Quicksort
 * 힌트2: 리스트를 분할하기 위해 함수 ``partition``을 활용하자.
 */

fun main() {
    require(listOf(1, 2, 3, 4, 5, 6, 7) == quicksort(listOf(5, 3, 7, 6, 2, 1, 4)))
}

private fun quicksort(list: List<Int>): List<Int> = when {
    list.isEmpty() -> list
    else -> {
        val pivot = list.head()
        val (small, bigger) = list.tail().partition { it < pivot }
        quicksort(small) + listOf(pivot) + quicksort(bigger)
    }
}
```



`연습문제 3-9`

```kotlin
/**
 * 연습문제 3-9
 *
 * 최대공약수를 구하는 gcd 함수를 작성해보자.
 *
 * 힌트: 함수의 선언 타입은 아래와 같다.
 * fun gcd(m: Int, n: Int): Int
 */

fun main() {
    println(gcd(12, 18))    // 6
    println(gcd(60, 48))    // 12
    println(gcd(366, 60))   // 6
}

private fun gcd(m: Int, n: Int): Int = when (n) {
    0 -> m
    else -> gcd(n, m % n)
}
```



## 메모이제이션으로 성능 개선하기

- 메모이제이션
  - 어떤 반복된 연산을 수행할 떄 이전에 계산했던 값을 캐싱해서 중복된 연산을 제거하는 방법

### 재귀적인 방식의 피보나치 수열 예제

### 메모이제이션을 사용한 피보나치 수열 예제

### 재귀의 문제점을 함수로 해결하기

## 꼬리 재귀로 최적화하기

### 꼬리 재귀 최적화란? 

### maximum 함수를 꼬리 재귀로 다시 작성하기

### reverse 함수를 꼬리 재귀로 다시 작성하기

### take 함수를 꼬리 재귀로 다시 작성하기

### zip 함수를 꼬리 재귀로 다시 작성하기

## 상호 재귀를 꼬리 재귀로 최적화하기

### 상호 재귀

### 트램펄린

## 실전 응용

### 멱직합을 구하는 함수

## 마치며

