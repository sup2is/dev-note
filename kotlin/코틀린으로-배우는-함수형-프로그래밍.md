



# 코틀린으로 배우는 함수형 프로그래밍

예제 참고

- https://github.com/funfunStory/fp-kotlin-example





# #1 함수형 프로그래밍이란?

## 함수형 프로그래밍의 특징

- 함수형 프로그래밍은 함수를 사용해서 데이터 처리의 참조 투명성을 보장하고 상태와 가변 데이터 생성을 피하는 프로글밍 패러다임이다.
- 함수형 프로그래밍의 특징
  - 불변성
  - 참조 투명성
  - 일급 함수
  - 게으른 실행
- 함수형 프로그래밍의 장점
  - 부수효과가 없는 프로그램을 만들 수 있어 동시성 프로그래밍에 적합하다.
  - 코드의 복잡도가 낮아 간결한 코드를 만들 수 있고, 모듈성이 높아져 유지보수하기 쉽다.
  - 프로그램의 예측성을 높여 컴파일러가 효율적으로 실행되는 코드를 만들어 준다.



## 순수한 함수란 무엇인가?

- 순수한 함수의 예

```kotlin
fun pureFunction(x: Int, y: Int): Int = x + y
```

- 순수 함수의 특징
  - 동일한 입력으로 실행하면 항상 동일한 결과가 나온다.
  - 부수효과가 없다.

### 동일 입력 동일 출력

- 동일한 입력으로 실행하면 항상 동일한 결과가 나온다.
- 순수하지 않은 함수의 특징
  - 전역 변수, 파일 네트워크 등으로부터 데이터를 가져오면서 같은 값을 입력해도 다른 결괏값을 낸다.

```kotlin
// 순수하지 않은 함수
fun impureFunction(x: Int, y: Int): Int = x + y + z

println(impureFunction(1, 2))   // 13
z = 20
println(impureFunction(1, 2))   // 23
```



### 부수효과 없는 코드

- 부수효과
  - 함수가 실행되는 과정에서 외부의 상태를 사용 또는 수정하는 것을 말한다.
  - 전역변수, 정적 변수, 파일, 네트워크를 출력하는 작업

```kotlin
fun withSideEffect(x: Int, y: Int): Int {
    z = y
    return x + y
}
```



### 순수한 함수의 효과와 그 외 고려사항

- 함수형 프로그래밍의 장점
  - 동일한 입력에 대해 동일한 결과를 반환하고 부수효과가 없기 때문에 결과에 대한 추론이 가능하고 테스트도 쉽다.
  - 컴파일 타임에 코드를 최적화하거나 오류 코드를 예측하고 경고하는 등 많은 것을 할 수 있다.
- 정말 부수효과가 없으면 안돼?
  - 순수한 함수형이 아닌 하이브리드 언어들은 파일 입출력이나 네트워크 통신 등등을 허용한다.



## 부수효과 없는 프로그램 작성하기

### 공유 변수 수정으로 인한 부수효과

- 함수 내에서 전역 변수와 같은 공유 변수를 수정하면 부수효과가 발생하고, 이 변수를 참조하는 변수는 결과가 외부 요인에 의해 달라진다.

```kotlin
// 순수하지 않은 함수
fun impureFunction(x: Int, y: Int): Int = x + y + z

// 부수 효과가 있는 함수
fun withSideEffect(x: Int, y: Int): Int {
    z = y
    return x + y
}

z = 10
println(impureFunction(1, 2))   // 13
println(withSideEffect(10, 20))   // 30
println(impureFunction(1, 2))   // 23
```

- 이러한 불확실성은 많은 노이즈코드를 생성하고 프로그램을 복잡하게 만든다.



### 객체의 상태 변경으로 인한 부수효과

```kotlin
data class MutablePerson(var name: String, var age: Int)

// 인자로 들어온 객체의 상태를 변경
fun addAge(person: MutablePerson, num: Int) {
    person.age += num
}
```

- 함수형 프로그래밍에서는 가변객체를 사용하지 않고 불변 객체를 사용한다.

```kotlin
// 객체의 속성을 val로 선언하면 수정이 불가능함
data class ImmutablePerson(val name: String, val age: Int)

// Person 객체를 수정하지않고, 새로운 객체로 생성하여 반환
fun addAge(person: ImmutablePerson, num: Int): ImmutablePerson {
    return ImmutablePerson(person.name, person.age + num)
}
```

- 불필요한 부수효과를 최소화하는 것이 함수적 해법이다.



## 참조 투명성으로 프로그램을 더 안전하게 만들기

- 참조 투명성
  - 프로그램의 변경 없이 어떤 표현식을 값으로 대체할 수 있다는 뜻
- 참조 투명성의 장점
  - 프로그래머나 컴파일러가 평과 결과를 추론할 수 있다.
  - 코드에 예외가 사라져서 간결해지고 버그가 발생할 가능성은 낮아진다.
  - 멀티스레드 코드에서도 스레드 안정성에 대한 고민을 덜 수 있다.

### 참조 투명하지 않은 함수

```kotlin
var someName: String = "Joe"

fun hello1() {
    println("Hello $someName")
}

```

- 전역변수에 의존하기때문에 참조에 투명하지 않다.



### 참조 투명한 함수

```kotlin
fun main() {
    val result = transparent("Joe")
    print(result)
}

fun transparent(name: String): String {
    return "Hello $name"
}

fun print(helloStr: String) {
    println(helloStr)
}

```

- transparent 함수는 참조에 투명하다. 언제 어디서 호출해도 문제가 없기때문에 재사용성이 높고 테스트하기 쉽다.
- print는 부수효과이기때문에 함수의 본문에서 순수함수 본문에서 분리했다.
- 이렇게까지 해야돼?
  - 함수형 프로그래밍 관점에서 올바른 설계 방향이다.
  - 부수효과를 일으키는 영역과 순수한영역을 되도록 분리하고 참조에 투명한 함수들로 구성하는 것이 좋다.
  - 이렇게하면 코드에 버그가 생길 확률이 줄어들고 더 안전한 프로그램을 작성할 수 있다.



## 일급 함수란?

### 일급 객체

- 일급 객체의 세가지 조건
  - 객체를 함수의 매개변수로 넘길 수 있다.
  - 객체를 함수의 반환값으로 돌려줄 수 있다.
  - 객체를 변수나 자료구조에 담을 수 있다.

```kotlin
// Any를 함수의 매개변수로 넘길수 있다
fun doSomethingWithAny(any: Any) {
    // do something
}

// Any를 함수의 리턴값으로 돌려줄 수 있다
fun doSomethingWithAny(): Any {
    return Any()
}

// Any를 List 자료구조에 담을 수 있다
var anyList: List<Any> = listOf(Any())

```



### 일급 함수

- 일급 함수의 세가지 조건
  - 함수를 함수의 매개변수로 넘길 수 있다.
  - 함수를 함수의 반환값으로 돌려줄 수 있다.
  - 함수를 변수나 자료구조에 담을 수 있다.

```kotlin
// 함수를 함수의 매개변수로 넘길수 있다
fun doSomething(func: (Int) -> String) {
    // do something
}

// 함수를 함수의 리턴값으로 돌려줄 수 있다
fun doSomething(): (Int) -> String {
    return { value -> value.toString() }
}

// 함수를 List 자료구조에 담을 수 있다
var funcList: List<(Int) -> String> = listOf { value -> value.toString() }
```



## 일급 함수를 이용한 추상화와 재사용성 높이기

### 간단한 계산기 예제

```kotlin
fun main() {
    val calculator = SimpleCalculator()

    println(calculator.calculate('+', 3, 1))    // 4
    println(calculator.calculate('-', 3, 1))    // 2
}

class SimpleCalculator {
    fun calculate(operator: Char, num1: Int, num2: Int): Int = when (operator) {
        '+' -> num1 + num2
        '-' -> num1 - num2
        else -> throw IllegalArgumentException()
    }
}
```

- 좋은 프로그램은 아니다. 연산자가 추가될 때마다 프로그램이 변경되어야 한다.



### 객체지향적으로 개선한 계산기 예제

```kotlin

fun main() {
    val plusCalculator = OopCalculator(Plus())
    println(plusCalculator.calculate(3, 1))  // 4

    val minusCalculator = OopCalculator(Minus())
    println(minusCalculator.calculate(3, 1))  // 2
}

interface Calculator {
    fun calculate(num1: Int, num2: Int): Int
}

class Plus : Calculator {
    override fun calculate(num1: Int, num2: Int): Int {
        return num1 + num2
    }
}

class Minus : Calculator {
    override fun calculate(num1: Int, num2: Int): Int {
        return num1 - num2
    }
}

class OopCalculator(private val calculator: Calculator) {
    fun calculate(num1: Int, num2: Int): Int = calculator.calculate(num1, num2)
}
```

- 객체지향의 장점
  - 기능 추가 및 변경 시, 관련없는 모듈을 수정할 필요가 없고 내부에 대해서 알 필요도 없다.
  - 인터페이스를 이용해 기능을 쉽게 확장할 수 있다.
  - 클래스나 함수들이 한 가지 일만 하기 때문에 코드 재사용성이 높다.
  - 의존성 주입 덕분에 테스트하기가 쉽다.



### 함수형 프로그래밍 방식으로 개선한 계산기 예제

```kotlin
package fp.kotlin.example.chapter01

fun main() {
    val fpCalculator = FpCalculator()

    println(fpCalculator.calculate({ n1, n2 -> n1 + n2 }, 3, 1))    // 4
    println(fpCalculator.calculate({ n1, n2 -> n1 - n2 }, 3, 1))    // 2
}

class FpCalculator {
    fun calculate(calculator: (Int, Int) -> Int, num1: Int, num2: Int): Int = calculator(num1, num2)
}
```





## 게으른 평가로 무한 자료구조 만들기

- 일반적으로 명령형 언어는 코드가 실행되는 즉시 값이 평가된다.
- 함수형 언어는 기본적으로 값이 필요한 시점에 평가되므로 프로그래머가 평가 시점을 지정할 수도 있다.

```kotlin
fun main() {
    println(lazyValue)  // hello
}

val lazyValue: String by lazy {
    // 매우 오래걸리는 작업
    "hello"
}
```

- 중요한것은 lazyValue를 선언하는 시점에는 프로그램이 실행되지 않고 lazyValue가 실제 호출되는 시점에 실행된다는 점.
- by lazy는 여러번 호출되더라도 최초에 한 번만 평가를 실행한다.
  - 값이 한 번만 평가되기 떄문에 값을 바꿀 수 없다.
  - 따라서 var타입은 사용이 불가능하다.



### 무한대 값을 자료구조에 담다

- 함수형 언어에서는 lazy evaluation으로 무한대 값을 자료구조에 저장할 수 있다.

```kotlin
fun main() {
    val infiniteValue = generateSequence(0) { it + 5 }
    infiniteValue.take(5).forEach { print("$it ") }   // 0 5 10 15 20
}
```



## 마치며

# #2 코틀린으로 함수형 프로그래밍 시작하기

## 프로퍼티 선언과 안전한 널 처리

### 프로퍼티 선언

- 코틀린에서는 읽기 전용 프로퍼티와 가변 프로퍼티를 구별해서 선언할 수 있다.

```kotlin
// 읽기 전용
val value: Int = 10

// 가변
var variable: Int = 10

// 읽기 전용 타입 추론
val value = 10

// 가변 타입 추론
var variable = 10
```

- 타입이 명확한 경우에는 타입을 생략해도 괜찮지만 코드가 복잡하다면 가독성을 위해 타입을 의도적으로 명시하는게 좋다.



### 안전한 널 처리

```kotlin
val nonNull: Int = null // 컴파일 오류 발생
val nullable: Int? = null
```

- 코틀린에서 타입 뒤에 ?를 붙이면 해당 프로퍼티는 값으로 널을 할당할 수 있다.
- ?가 없이 선언된 프로퍼티에 널을 할당하면 컴파일 오류가 발생한다.



## 함수와 람다

### 함수를 선언하는 다양한 방법

```kotlin
fun twice1(value: Int): Int {
  return value * 2
}

fun twice2(value: Int): Int = value * 2
fun twice3(value: Int) = value * 2
```

- 코틀린에서 함수는 블록을 생략하거나 리턴 타입을 생략할 수 있다.

```kotlin
fun add(x: Int, y: Int): Int {
  return x + y
} 

fun add(x: Int, y: Int): Int = x + y
fun add(x: Int, y: Int) = x + y
```



### 매개변수에 기본값 설정하기

- 코틀린은 함수의 매개변수에 기본값을 할당할 수 있다.

```kotlin
fun add(x: Int, y: Int = 3): Int = x + y

println(add(9, 1)) // 10
println(add(10)) // 13
```

- 매개변수의 순서에 따라서 값이 할당되기 때문에 주의해야 한다.

```kotlin
fun add(x: Int = 10, y: Int = 3): Int = x + y

println(add()) // 13
println(add(7)) // 10
```

- 호출자가 값을 할당하고자 하는 매개변수명을 지정할 수 있다.

```kotlin
fun add(x: Int = 10, y: Int = 3): Int = x + y

println(add(y = 7)) // 17
println(add(x = 10, y = 20)) // 30
```



### 익명 함수와 람다 표현식

- 익명 함수
  - 함수 이름을 선언하지 않고 구현부만 작성하는 함수를 표현하는 방식의 일종

```kotlin
fun sum(x: Int, y: Int, calculate: (Int, Int) -> Int): Int {
  return calculate(x, y)
}

val value = sum(5, 10, { x, y -> x + y})
```



### 확장 함수

- 코틀린에서는 상속을 하거나 내부를 수정하지 않고도 이미 작성된 클래스에 함수나 프로퍼티를 추가할 수 있다.

```kotlin
fun Int.product(value: Int): Int {
  return this * value
}

println(10.product(2)) // 20
```



`연습문제 2 - 1`

```kotlin
/**
 * 연습문제 2-1
 *
 * ``String`` 값을 입력받아 "Hello, 입력받은 값"이 출력하는 확장함수를 구현하라. 예를 들어 "World"를 입력받으면 "Hello, World", "Kotlin"을
 * 입력받으면 "Hello, Kotlin"을 출력한다.
 */
fun main() {
    require("kotlin".addHelloPrefix() == "Hello, kotlin")
    require("FP".addHelloPrefix() == "Hello, FP")
}

private fun String.addHelloPrefix(): String = "Hello $value"
```



## 제어 구문

### if문

```kotlin
val max: Int

if (x > y) {
  max = x
} else {
  max = y
}
```

- 코틀린의 if문은 기본적으로 표현식이다. 표현식은 결과로서 어떤 값을 반환한다.

```kotlin
val max: Int = if (x > y) x else y
```

- 이런 경우 else 문을 반드시 작성해야 한다. (삼항연산자 같음)

### when문

```kotlin
when (x) {
  1 -> print("x == 1")
  2, 3 -> print("x == 2 or 3")
  parseInt("4") -> print("x == 4")
  else -> print("else number")
}
```

- when 문도 표현식이기 때문에 아래와 같이 사용할 수 있다.

```kotlin
val numType = when {
  x == 0 -> "zero"
  x > 0 -> "positive"
  else -> "negative"
}
```



### for문

```kotlin
val collection = listOf(1, 2, 3)

for (item in collection) {
  print(item) // 123
}

for ((index, item) in collection.withIndex()) {
  println("the element at $index is $item")
}
```

- 값의 범위와 증감 규칙을 사용할 수도 있다.

```kotlin
for (i in 1..3) {
  print(i) // 123
}

for (i until 3) {
  print(i) // 12
}

for (i in 6 downTo 0 step 2) {
  print(i) // 6420
}
```



## 인터페이스

### 인터페이스의 특징

- 코틀린에서 제공하는 인터페이스의 특징
  - 다중 상속이 가능하다.
  - 추상 함수를 가질 수 있다.
  - 함수의 본문을 구현할 수 있다.
  - 여러 인터페이스에서 같은 이름의 함수를 가질 수 있다.
  - 추상 프로퍼티를 가질 수 있다.

### 인터페이스 선언하고 상속하기

```kotlin
interface Foo {

}

interface Bar {

}

class Kotlin: Foo, Bar {

}
```



### 인터페이스에 추상 함수 선언하기

```kotlin
interface Foo {
  fun printFoo()
}

interface Bar {
  fun printBar()
}

class Kotlin: Foo, Bar {
  override fun printFoo() {
    //..
  }
  override fun printFoo() {
    //..
  }
}
```



### 추상 함수 구현하기

### 추상 프로퍼티의 선언과 사용

- 추상 프로퍼티
  - 해당 인터페이스를 상속한 클래스가 가질 프로퍼티를 말한다.

```kotlin
interface Foo {
  val bar: Int
}

class Kotlin : Foo {
  override val bar: Int = 3
}
```

- 추상 프로퍼티도 override 키워드로 재정의할 수 있다.

## 클래스

### 클래스와 프로퍼티

```kotlin
class User(var name: String, val age: Int)

val user = User("FP", 32)
println(user.name) // "FP"

user.name = "kotlin"
println(user.name) // "kotlin"
```

- 자동 getter setter
  - 프로퍼티는 자바의 멤버변수와 달리 게터와 세터를 내부에서 자동으로 생성해준다.
  - var로 선언된 프로퍼티는 게터와 세터를, val로 선언된 프로퍼티는 게터만 사용할 수 있다.
- 함수와 동일하게 클래스 셍성자에서도 프로퍼티의 기본값을 할당할 수 있다.

```kotlin
class User(var name: String, val age: Int = 17)
```



### data 클래스

- data class의 기능
  - 게터와 세터 생성
  - hashCode, eqauls, toString 메서드 override
  - copy, componentN 함수 제공

### enum 클래스

```kotlin
enum class Error(val num: Int) {
  WARN(2) {
    override fun getErrorName(): String {
      return "WARN"
    }
  },
  ERROR(3) {
    override fun getErrorName(): String {
      return "ERROR"
    }
  };
  
  abstract fun getErrorName(): String
}
```

### sealed 클래스

- sealed class
  - enum class의 확장 형태로 클래스를 묶은 클래스다.

```kotlin
sealed class Expr
data class Const(val number: Double): Expr()
data class Sum(val e1: Expr, val e2: Expr): Expr()
object NotANumber: Expr()
```

- enum 클래스와 달리 각 하위 클래스는 모두 다른 프로퍼티와 함수를 가질 수 있다.
- 단 sealed class는 동일한 파일에서만 선언이 가능하다.



## 패턴 매칭

### 다양한 패턴 정의 방법

```kotlin
fun main() {
    println(checkValue("kotlin"))   // kotlin
    println(checkValue(5))      // 1..10
    println(checkValue(15))     // 11 or 15
    println(checkValue(User("Joe", 76)))    // User
    println(checkValue("unknown"))  // SomeValue
}

data class User(val name: String, val age: Int)

fun checkValue(value: Any) = when (value) {
    "kotlin" -> "kotlin"
    in 1..10 -> "1..10"
    11, 15 -> "11 or 15"
    is User -> "User"
    else -> "SomeValue"
}
```



### 조건에 따른 패턴 매칭

```kotlin
fun main() {
    println(checkCondition("kotlin"))   // kotlin
    println(checkCondition(5))   // 1..10
    println(checkCondition(User("Joe", 76)))   // == User(Joe, 76)
    println(checkCondition(User("Sandy", 65)))   // is User
    println(checkCondition("unknown"))   // SomeValue
}

data class User(val name: String, val age: Int)

fun checkCondition(value: Any) = when {
    value == "kotlin" -> "kotlin"
    value in 1..10 -> "1..10"
    value === User("Joe", 76) -> "=== User"
    value == User("Joe", 76) -> "== User(Joe, 76)"
    value is User -> "is User"
    else -> "SomeValue"
}
```



### 코틀린 패턴 매칭의 제약

- 코틀린은 리스트와 같은 매개변수를 포함하는 타입이나 함수의 타입에 대핸 패턴매칭을 지원하지 않는다.

