



# 코틀린으로 배우는 함수형 프로그래밍

예제 참고

- https://github.com/funfunStory/fp-kotlin-example





# #1 함수형 프로그래밍이란?

## 함수형 프로그래밍의 특징

- 함수형 프로그래밍은 함수를 사용해서 데이터 처리의 참조 투명성을 보장하고 상태와 가변 데이터 생성을 피하는 프로글밍 패러다임이다.
- 함수형 프로그래밍의 특징
  - 불변성
  - 참조 투명성
  - 일급 함수
  - 게으른 실행
- 함수형 프로그래밍의 장점
  - 부수효과가 없는 프로그램을 만들 수 있어 동시성 프로그래밍에 적합하다.
  - 코드의 복잡도가 낮아 간결한 코드를 만들 수 있고, 모듈성이 높아져 유지보수하기 쉽다.
  - 프로그램의 예측성을 높여 컴파일러가 효율적으로 실행되는 코드를 만들어 준다.



## 순수한 함수란 무엇인가?

- 순수한 함수의 예

```kotlin
fun pureFunction(x: Int, y: Int): Int = x + y
```

- 순수 함수의 특징
  - 동일한 입력으로 실행하면 항상 동일한 결과가 나온다.
  - 부수효과가 없다.

### 동일 입력 동일 출력

- 동일한 입력으로 실행하면 항상 동일한 결과가 나온다.
- 순수하지 않은 함수의 특징
  - 전역 변수, 파일 네트워크 등으로부터 데이터를 가져오면서 같은 값을 입력해도 다른 결괏값을 낸다.

```kotlin
// 순수하지 않은 함수
fun impureFunction(x: Int, y: Int): Int = x + y + z

println(impureFunction(1, 2))   // 13
z = 20
println(impureFunction(1, 2))   // 23
```



### 부수효과 없는 코드

- 부수효과
  - 함수가 실행되는 과정에서 외부의 상태를 사용 또는 수정하는 것을 말한다.
  - 전역변수, 정적 변수, 파일, 네트워크를 출력하는 작업

```kotlin
fun withSideEffect(x: Int, y: Int): Int {
    z = y
    return x + y
}
```



### 순수한 함수의 효과와 그 외 고려사항

- 함수형 프로그래밍의 장점
  - 동일한 입력에 대해 동일한 결과를 반환하고 부수효과가 없기 때문에 결과에 대한 추론이 가능하고 테스트도 쉽다.
  - 컴파일 타임에 코드를 최적화하거나 오류 코드를 예측하고 경고하는 등 많은 것을 할 수 있다.
- 정말 부수효과가 없으면 안돼?
  - 순수한 함수형이 아닌 하이브리드 언어들은 파일 입출력이나 네트워크 통신 등등을 허용한다.



## 부수효과 없는 프로그램 작성하기

### 공유 변수 수정으로 인한 부수효과

- 함수 내에서 전역 변수와 같은 공유 변수를 수정하면 부수효과가 발생하고, 이 변수를 참조하는 변수는 결과가 외부 요인에 의해 달라진다.

```kotlin
// 순수하지 않은 함수
fun impureFunction(x: Int, y: Int): Int = x + y + z

// 부수 효과가 있는 함수
fun withSideEffect(x: Int, y: Int): Int {
    z = y
    return x + y
}

z = 10
println(impureFunction(1, 2))   // 13
println(withSideEffect(10, 20))   // 30
println(impureFunction(1, 2))   // 23
```

- 이러한 불확실성은 많은 노이즈코드를 생성하고 프로그램을 복잡하게 만든다.



### 객체의 상태 변경으로 인한 부수효과

```kotlin
data class MutablePerson(var name: String, var age: Int)

// 인자로 들어온 객체의 상태를 변경
fun addAge(person: MutablePerson, num: Int) {
    person.age += num
}
```

- 함수형 프로그래밍에서는 가변객체를 사용하지 않고 불변 객체를 사용한다.

```kotlin
// 객체의 속성을 val로 선언하면 수정이 불가능함
data class ImmutablePerson(val name: String, val age: Int)

// Person 객체를 수정하지않고, 새로운 객체로 생성하여 반환
fun addAge(person: ImmutablePerson, num: Int): ImmutablePerson {
    return ImmutablePerson(person.name, person.age + num)
}
```

- 불필요한 부수효과를 최소화하는 것이 함수적 해법이다.



## 참조 투명성으로 프로그램을 더 안전하게 만들기

- 참조 투명성
  - 프로그램의 변경 없이 어떤 표현식을 값으로 대체할 수 있다는 뜻
- 참조 투명성의 장점
  - 프로그래머나 컴파일러가 평과 결과를 추론할 수 있다.
  - 코드에 예외가 사라져서 간결해지고 버그가 발생할 가능성은 낮아진다.
  - 멀티스레드 코드에서도 스레드 안정성에 대한 고민을 덜 수 있다.

### 참조 투명하지 않은 함수

```kotlin
var someName: String = "Joe"

fun hello1() {
    println("Hello $someName")
}

```

- 전역변수에 의존하기때문에 참조에 투명하지 않다.



### 참조 투명한 함수

```kotlin
fun main() {
    val result = transparent("Joe")
    print(result)
}

fun transparent(name: String): String {
    return "Hello $name"
}

fun print(helloStr: String) {
    println(helloStr)
}

```

- transparent 함수는 참조에 투명하다. 언제 어디서 호출해도 문제가 없기때문에 재사용성이 높고 테스트하기 쉽다.
- print는 부수효과이기때문에 함수의 본문에서 순수함수 본문에서 분리했다.
- 이렇게까지 해야돼?
  - 함수형 프로그래밍 관점에서 올바른 설계 방향이다.
  - 부수효과를 일으키는 영역과 순수한영역을 되도록 분리하고 참조에 투명한 함수들로 구성하는 것이 좋다.
  - 이렇게하면 코드에 버그가 생길 확률이 줄어들고 더 안전한 프로그램을 작성할 수 있다.



## 일급 함수란?

### 일급 객체

- 일급 객체의 세가지 조건
  - 객체를 함수의 매개변수로 넘길 수 있다.
  - 객체를 함수의 반환값으로 돌려줄 수 있다.
  - 객체를 변수나 자료구조에 담을 수 있다.

```kotlin
// Any를 함수의 매개변수로 넘길수 있다
fun doSomethingWithAny(any: Any) {
    // do something
}

// Any를 함수의 리턴값으로 돌려줄 수 있다
fun doSomethingWithAny(): Any {
    return Any()
}

// Any를 List 자료구조에 담을 수 있다
var anyList: List<Any> = listOf(Any())

```



### 일급 함수

- 일급 함수의 세가지 조건
  - 함수를 함수의 매개변수로 넘길 수 있다.
  - 함수를 함수의 반환값으로 돌려줄 수 있다.
  - 함수를 변수나 자료구조에 담을 수 있다.

```kotlin
// 함수를 함수의 매개변수로 넘길수 있다
fun doSomething(func: (Int) -> String) {
    // do something
}

// 함수를 함수의 리턴값으로 돌려줄 수 있다
fun doSomething(): (Int) -> String {
    return { value -> value.toString() }
}

// 함수를 List 자료구조에 담을 수 있다
var funcList: List<(Int) -> String> = listOf { value -> value.toString() }
```



## 일급 함수를 이용한 추상화와 재사용성 높이기

### 간단한 계산기 예제

```kotlin
fun main() {
    val calculator = SimpleCalculator()

    println(calculator.calculate('+', 3, 1))    // 4
    println(calculator.calculate('-', 3, 1))    // 2
}

class SimpleCalculator {
    fun calculate(operator: Char, num1: Int, num2: Int): Int = when (operator) {
        '+' -> num1 + num2
        '-' -> num1 - num2
        else -> throw IllegalArgumentException()
    }
}
```

- 좋은 프로그램은 아니다. 연산자가 추가될 때마다 프로그램이 변경되어야 한다.



### 객체지향적으로 개선한 계산기 예제

```kotlin

fun main() {
    val plusCalculator = OopCalculator(Plus())
    println(plusCalculator.calculate(3, 1))  // 4

    val minusCalculator = OopCalculator(Minus())
    println(minusCalculator.calculate(3, 1))  // 2
}

interface Calculator {
    fun calculate(num1: Int, num2: Int): Int
}

class Plus : Calculator {
    override fun calculate(num1: Int, num2: Int): Int {
        return num1 + num2
    }
}

class Minus : Calculator {
    override fun calculate(num1: Int, num2: Int): Int {
        return num1 - num2
    }
}

class OopCalculator(private val calculator: Calculator) {
    fun calculate(num1: Int, num2: Int): Int = calculator.calculate(num1, num2)
}
```

- 객체지향의 장점
  - 기능 추가 및 변경 시, 관련없는 모듈을 수정할 필요가 없고 내부에 대해서 알 필요도 없다.
  - 인터페이스를 이용해 기능을 쉽게 확장할 수 있다.
  - 클래스나 함수들이 한 가지 일만 하기 때문에 코드 재사용성이 높다.
  - 의존성 주입 덕분에 테스트하기가 쉽다.



### 함수형 프로그래밍 방식으로 개선한 계산기 예제

```kotlin
package fp.kotlin.example.chapter01

fun main() {
    val fpCalculator = FpCalculator()

    println(fpCalculator.calculate({ n1, n2 -> n1 + n2 }, 3, 1))    // 4
    println(fpCalculator.calculate({ n1, n2 -> n1 - n2 }, 3, 1))    // 2
}

class FpCalculator {
    fun calculate(calculator: (Int, Int) -> Int, num1: Int, num2: Int): Int = calculator(num1, num2)
}
```





## 게으른 평가로 무한 자료구조 만들기

- 일반적으로 명령형 언어는 코드가 실행되는 즉시 값이 평가된다.
- 함수형 언어는 기본적으로 값이 필요한 시점에 평가되므로 프로그래머가 평가 시점을 지정할 수도 있다.

```kotlin
fun main() {
    println(lazyValue)  // hello
}

val lazyValue: String by lazy {
    // 매우 오래걸리는 작업
    "hello"
}
```

- 중요한것은 lazyValue를 선언하는 시점에는 프로그램이 실행되지 않고 lazyValue가 실제 호출되는 시점에 실행된다는 점.
- by lazy는 여러번 호출되더라도 최초에 한 번만 평가를 실행한다.
  - 값이 한 번만 평가되기 떄문에 값을 바꿀 수 없다.
  - 따라서 var타입은 사용이 불가능하다.



### 무한대 값을 자료구조에 담다

- 함수형 언어에서는 lazy evaluation으로 무한대 값을 자료구조에 저장할 수 있다.

```kotlin
fun main() {
    val infiniteValue = generateSequence(0) { it + 5 }
    infiniteValue.take(5).forEach { print("$it ") }   // 0 5 10 15 20
}
```



## 마치며



