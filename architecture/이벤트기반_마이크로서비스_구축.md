

# 이벤트 기반 마이크로서비스 구축





# #1 왜 이벤트 기반 마이크로서비스인가?

- 이벤트는 이제 엄청나게 큰 규모로 무기한 저장할 수 있고 모든 서비스가 필요할 때마다 몇 번이라도 소비할 수 있게 됐다.
- 이벤트를 통해 이제는 제약 없이 얼마든지 데이터를 저장/관리할 수 있게 됐다.

## 이벤트 기반 마이크로 서비스란?

- 현대 이벤트 기반 마이크로서비스 아키텍처에서는 시스템이 이벤트를 생산/소비하는 식으로 서로 통신한다.
- 이벤트를 소비해도 메시지를 전달한 시스템이 바로 사라지는건 아니고 같은 메시지를 필요로 하는 다른 컨슈머도 가져갈 수 있게 보존된다.
- 서비스는 입력 이벤트 스트림에서 이벤트를 받아 특정한 비즈니스 로직을 적용한 다음, 출력 이벤트를 내보내서 요청-응답 접근에 필요한 데이터를 제공하거나 서드파티 api와 통신, 또는 다른 필요한 일을 수행한다.

## 도메인 주도 설계와 경계 콘텍스트

- 도메인 주도 설계의 기본 개념

`도메인`

- 비지니스가 차지하고 솔루션이 제공하는 문제 공간.
- 규칙 프로세스, 아이디어, 비지니스 전문 용어 등 문제공간과 조금이라도 관련된 것들은 모두 포함된다.
- 도메인은 비지니스 존재 여부와 무관하게 존재한다.

`하위 도메인`

- 메인 도메인을 이루는 컴포넌트.
- 특정한 하위 업무에 집중하고 일반적으로 비지니스 조직 구조를 반영한다.
- 하위 도메인 하나를 하나의 도메인으로 볼 수 있다.
- 하위 도메인 역시 메인 도메인처럼 문제 공간에 속한다.

`도메인(및 하위 도메인) 모델`

- 비지니스 용도에 맞게 실제 도메인을 추상화한 비지니스에서 가장 중요한 도메인 조각 및 속성들로 모델을 생성한다.
- 도메인 모델은 솔루션 공간의 일부로 비지니스가 문제를 해결하기 위해 사용하는 구성체이다.

`경계 콘텍스트`

- 경계 콘텍스트는 솔루션 공간의 속성으로 마이크로서비스가 상호작용하는 방식에 상당한 영향을 미친다.

  

- 경계 콘텍스트는 응집력이 강해야 한다.
- 콘텍스트 내부 기능은 집약적이고 깊이 연관되어 있고 대부분의 통신이 내부에서만 일어나야 한다.
- 경계 콘텍스트는 느슨하게 결합해야 한다. 그래야 다른 콘텍스트에 영향이 없다.

### 도메인 모델과 경계 모텍스트 활용

- 모든 조직은 그 자신과 외부 사이에 하나의 도메인을 형성한다.
- 도메인은 다시 하위 도메인으로 나뉘고 계속 쪼개져서 작고 독립적인 서비스로 옮길 수 있을정도가 된다.
- 경계 콘텍스트는 이런 하위 도메인을 중심으로 형성되어 마이크로서비스가 탄생하는 기초가 된다.

### 비즈니스 요건에 따라 경계 콘텍스트 조정

- 경계 콘텍스트를 기술 요건이 아니라 비지니스 요건 중심으로 정해야 변경에도 영향이 없다
- 경계 콘텍스트를 비지니스 요건에 맞추면 팀별로 느슨하게 결합하며 고도로 응집된 마이크로서비스 구현체를 바꿀 수 있다. => 팀간의 의존도가 적어서 맡은 요건에만 독립적으로 전념할 수 있다.
- 마이크로서비스를 기술 요건에 맞추면 생기는 가장 큰 문제는 여러 경계 콘텍스트에 걸쳐 비지니스 기능을 수행할 책임이 여러 팀으로 분산되어 제각기 다른 스케줄로 다른 업무를 진행하게 된다.
- 전체를 아우르는 기술, 팀 간 의존성을 타파해야 시스템 변경 민감도를 낮출 수 있다.
- 이벤트 기반 마이크로서비스는 비지니스 요건에 따라 아키텍처를 모델링하는 것이 바람직하다.
- 위 과정에서 코드가 여러번 복제되거나 비슷한 서비스가 증가하는 트레이드 오프가 있다.
- 중복이 강결합보다 낫다.
- 경계 콘텍스트 간 결합은 느슨하게 유지하고 상호 의존 관계는 최소화하자. 그래야 필요시 다른 시스템에 해를 끼치지 않고 경계 컨텍스트를 변경할 수 있다.
- 팀마다 풀스택 전문성을 갖춰야 한다.

## 통신 구조

### 비즈니스 통신 구조

- 비즈니스 통신 구조는 팀과 부서 간의 통신을 결정하며 각 팀에 할당된 주된 요건 및 책임에 따라 달라진다.

![1](./images/building-event-driven-microservices/1.png)



### 구현 통신 구조

- 구현 통신 구조는 하위 도메인 모델에 대해 조직에서 규정한 데이터와 로직을 이용해 신속하고 효울적인 업무 수행을 위해 비지니스 프로세스, 데이터 구조, 시스템 설계를 정규화한 것이다.

![2](./images/building-event-driven-microservices/2.png)



### 데이터 통신 구조

- 데이터 통신구조는 비지니스 전반에 걸쳐, 특히 구현체간에 데이터를 주고 받는 프로세스를 말한다.

![3](./images/building-event-driven-microservices/3.png)

### 콘웨이의 법칙과 통신 구조

- 시스템 구조는 그 시스템을 설계하는 조직의 통신 구조를 그대로 따라갈 수밖에 없다. - 맬빈 콘웨이
- 조직에서 데이터 접근이 너무 어렵거나 모든 데이터가 구현체 하나에 몰려 있어 제품의 범위가 한정되어 있다면 필경 데이터 통신 구조가 부실한 대가를 치루고 있는 것이다.



## 기존 컴퓨팅의 통신 구조

- 한 조직의 통신 구조는 엔지니어링 결과물이 탄생하기까지 막대한 영향을 미친다. 팀 레벨도 마찬가지
- 단일 데이터 저장소에 기반한 단일 서비스를 담당하는 팀에 새로운 요건이 들어온 경우 아래와 같이 옵션1, 2 로 고민해볼 수 있음

### 옵션 1: 서비스를 새로 만듦

- 새로운 서비스를 만들어 운영하는 작업에는 데이터 동기화 등등 리스크가 있다.
- 데이터 저장소 2개, 서비스 2개, 데이터 의존, 로깅, 모니터링, 테스트 배포, 롤백 프로세스, 데이터 등등의 문제

### 옵션 2: 기존 서비스에 추가

- 여러 모듈이 동일한 코드 베이스에 함께 엮이는 경우가 많아 변경할 일이 생기면 구현체 내부에서 경계까 모호해질 가능성이 있다.
- 경계를 자유롭게 넘나들면서 모듈을 직접 결합시키면 ㅂ쉽고 빠르게 기능을 추가할 수 있지만 결합도는 올라가고 모듈성은 떨어진다.

### 옵션별 장단점

- 많은 팀들이 두번째 옵션을 선택하고 모놀리식 아키텍처는 아직 강력하고 비지니스에 탁월한 가치를 제공하므로 잘못된 선택은 아니다.
- 첫번째 옵션 요약
  - 다른 시스템의 데이터에 안정적으로 접근하기 어렵다. 특히 대규모 데이터를 실시간 접근하기 곤란하다.
  - 서비스를 새로 만들어 관리하는 오버헤드와 리스크를 무시할 수 없다. 특히 신규 서비스를 관리하는 체계가 조직 내에 아직 확립되어 있지 않다.
- 데이터를 얻기 위해서는 통신을 피할 수 없고 복제를하자니 점대점 결합이 발생할 수 밖에 없다.
- 데이터 복제는 데이터의 양이 많아질수록 더 많이 어긋나게 된다.
- **회사 곳곳에 정확한 데이터를 전달할 수 없는 까닭은 개념 자체에 근본적인 결함이 있어서가 아니다. 데이터 통신 구조가 취약하거나 전무하기 때문이다.**
- **핵심 비지니스 데이터는 이를 필요로 하는 모든 서비스가 쉽게 획득하고 사용할 수 있어야 한다. 이것이 이벤트 기반 마이크로서비스의 기본 교리중 하나이다.**



### 팀 시나리오(계속)

- 옵션2를 선택한 팀에서 1년 뒤에 새로운 요구사항에 맞이하게 되었을때의 문제
  - 어느 팀이 어떤 데이터를 소유해야 하나?
  - 데이터는 어디에 두어야 하나?
  - 두 팀 모두 값을 변경하는 데이터는 어떻게 처리할까?



### 상충되는 압력

- 발생되는 모든 문제들의 근원은 구현 통신 구조 간의 데이터 통신 수단이 취약하고 제대로 정의되지 않은 탓이다.

## 이벤트 기반 통신 구조

- 이벤트 기반 통신은 기존 구현/데이터 통신 구조의 대안이다.
- 이벤트 스트리밍 방식의 데이터 통신 구조에서는 데이터를 생산/소유하는 것과 데이터에 접근하는 행위가 철저히 분리되기 때문에 서비스는 더 이상 직접 요청-응답 API에 얽매이는 일 없이 이벤트 스트림 내부에 정의된 이벤트 데이터를 매개로 소통한다.
- 프로듀서는 그저 자신이 맡은 이벤트 스트림에 잘 정의된 데이터를 생산하는 일만 책임지면 된다.

### 이벤트는 통신의 근간이다

- 공유 데이터는 모조리 이벤트 스트림 세트에 발행함으로써 조직에서 일어난 모든 일은 지속적으로 정규화한 형태로 서술된다.
- **이벤트 = 데이터**
- 이벤트는 데이터 스토리지뿐만 아니라 서비스 간의 비동기 통신 수단 역할도 된다.

### 이벤트 스트림은 단일 진실 공급원이다

- 스트림 안에 있는 각 이벤트는 사실 진술서이고 이것들을 취합하면 시스템이 통신하는 근간인 단일 진실 공급원이 된다.

### 컨슈머가 스스로 모델링과 쿼리를 수행한다

- 이벤트 기반 데이터 통신 구조는 데이터 쿼리/검색 기능이 있다는 점에서 과도하게 확장된 구현 통신 구조와 다르다.
- 모든 비지니스 및 애플리케이션 로직은 반드시 이벤트 프로듀서/컨슈머 안에 캡슐화 되어야한다.
- 컨슈머는 여러 이벤트 스트림에서 들어온 데이터를 혼합하거나 특별한 쿼리를 하거나 특정한 비지니스를 수행한다.
- 이제는 각제 맡은 경계 컨텍스트의 니즈를 해결하는 일만 책임지면 된다.

### 조직 전반적으로 데이터 통신이 원활해진다

- 데이터는 공용 이벤트 스트림 세트에 발행함으로써 데이터의 생산과 소유권을 완전히 분리할 수 있다.
- 덕분에 느슨한 결합과 높은 응집도를 가져야하는 경계 컨텍스트 원칙을 더 준수할 수 있게 됐다.
- 애플리케이션을 이벤트 기반으로 개발하면 과거에 점대점 커넥션을 통해 힘들게 가져왔던 데이터에 쉽게 접근할 수 있다.

### 접근 가능한 데이터 덕분에 비즈니스 통신 변경이 가능하다

- 핵심 도메인 이벤트가 특정 구현체에 의존하지 않기 때문에 전반적으로 비지니스가 아주 유연해진다.



## 비동기식 이벤트 기반 마이크로 서비스

- 이벤트 기반 마이크로서비스를 구축하면 경계 컨텍스트 요건에 맞게 필요한 비지니스 로직 변환을 수행할 수 있다.
- 이벤트 기반 마이크로서비스의 중요한 이점

`세분성`

- 서비스가 경계 컨텍스트에 알맞게 매핑되고 비지니스 요건이 바뀌어도 쉽게 재작성할 수 있다.

`확장성`

- 개별 서비스는 필요시 규모를 늘리거나 줄일 수 있다.

`기술 유연성`

- 서비스마다 적합한 언어와 기술로 구현할 수 있고 첨단 기술을 적용해서 쉽게 프로토콜타이핑할 수 있다.

`비지니스 요건 유연성`

- 단위가 작은 마이크로서비스는 소유권을 재조정하기 쉽다
- 대규모 서비스보다 다른 팀에 덜 의존하기에 데이터 접근시 장애 요소가 적고 조직은 비즈니스 요건 변화에 신속하게 대응할 수 있다.

`느슨한 결합`

- 이벤트 기반 마이크로서비스는 도메인 데이터와 결합할 뿐, 어떤 특정한 구현 API에 구애받지 않는다.
- 데이터 스키마를 이용하면 보다 효율적으로 데이터 변경 관리를 할 수 있다.

`지속적 전달 지원`

- 작은 모듈로 나눈 마이크로서비스는 옮기기 쉽고 필요시 간편하게 롤백할 수 있다.

`우수한 시험성`

- 마이크로서비스는 덩치 큰 모놀리스보다 디펜던시가 적어서 필요한 테스트 엔드포인트를 모킹하고 코드 커버리지를 적절히 유지하기 쉽다.



### 이벤트 기반 마이크로서비스 예제



## 동기식 마이크로서비스

- 동기식 마이크로서비스는 요청-응답 방식으로 직접 API를 통해 소통함으로써 비즈니스 요건을 처리한다.



### 동기식 마이크로서비스의 단점

- 동기식 마이크로서비스는 대규모 환경에서는 문제가 많아 사용하기 곤란할 수 있다.

`점대점 결합`

- 동기식 마이크로서비스는 결국 자신이 할 일을 다른 서비스에서 의존할 수 밖에 없다.
- 의존 관계가 많아지면 많아질수록 비지니스 로직을 파악하기 쉽지 않다. 고치기도 힘들다.

`의존적 확장`

- 한 서비스의 확장 가능 여부는 그 서비스가 의존하는 다른 모든 서비스가 확장 가능한지, 또 통신의 팬아웃 정도와 직접 연관된다.

`서비스 실패 처리`

- 의존하는 서비스가 내려가는 예외 상황 발생 시 처리 방법을 정해야 한다.
- 데이터 정합성을 보장하려면 처리결과에 따라 절차를 마련해야 한다.

`API 버저닝과 디펜던시 관리`

- 다수의 서비스를 상대로 API 변경을 적용하는 일 자체가 꽤 복잡해질 수 있다.

`데이터 접근이 구현체에 종속된다`

- 동기식 마이크로서비스는 외부 데이터 접근 시 기존 서비스와 동일한 문제가 발생한다.

`분산 모놀리스`

- 서비스가 분산 모놀리스가 되어 서비스간 호출이 얽히고 설킨다.

`테스트`

- 각 서비스를 가동하려면 자신의 의존하는 서비스 역시 가동중이어야하고 물리고 물리기 때문에 테스트를 수행하기가 정말 어렵다.



### 동기식 마이크로서비스의 장점

- 사용자 인증, A/B 테스트 같은 데이터 접근 패턴은 직접 요청-응답을 주고 받는 방식이 더 유리하다.
- 여러 시스템에 걸친 작업을 추적하기도 동기식 환경이 더 용이하다. => 로그를 보기 쉬움 



## 마치며

- 조직의 소프트웨어를 개발하고 관리하는 방향은 통신 구조에 따라 결정된다.
- 이벤트 기반 시스템에 내재된, 쉽게 접근하고 저장할 수 있는 도메인 이벤트를 활용하면 더 작고 목적에 부합한 구현체를 만들 수 있다. 



# #2 이벤트 기반 마이크로서비스 기초

- 이벤트 기반 마이크로서비스는 특정한 경계 컨텍스트를 구현하기 위해 개발된 작은 애플리케이션이다.
- 컨슈머 마이크로서비스는 하나 이상의 입력 이벤트 스트림으로부터 이벤트를 소비 처리한다.
- 프로듀서 마이크로서비스는 다른 서비스가 소비할 수 있게 이벤트 스트림에 이벤트를 생산한다.
- 일반적으로 이벤트 기반 마이크로서비스는 컨슈머인 동시에 프로듀서이다.
- 이벤트 브로커는 이벤트 스트림을 제공한다.

## 토폴로지 구성

### 마이크로서비스 토폴로지

- 마이크로서비스 토폴로지는 마이크로서비스 내부의 이벤트 기반 토폴로지이다.

![4](./images/building-event-driven-microservices/4.png)

- 스트림 A에서 이벤트를 받아 데이터 저장소에 구체화하고 스트림 B에서 받은 데이터는 어떤 조건에 맞는 이벤트를 거르고 저쩌고 하고 새로운 이벤트 스트림으로 보낸다.



### 비지니스 토폴로지

- 비지니스 토폴로지는 복잡한 비지니스 로직을 처리하는 마이크로서비스, 이벤트 스트림 API 집합이다.
- 마이크로서비스는 비지니스 경계 컨텍스트를 구현하며 이벤트 스트림은 전체 컨텍스트의 도메인 데이터를 공유하기 위해 필요한 통신 수단이다.
- 마이크로서비스 토폴로지는 단일 마이크로서비스의 내부 작업에 초점을 두는 반면, 비지니스 토폴로지는 서비스 사이의 관계를 상술한다.

![5](./images/building-event-driven-microservices/5.png)

- 이리저리 엮이고 해서 마이크로서비스와 이벤트 스트림은 필요한 만큼 추가해서 비동기로 결합할 수 있다.



## 이벤트 콘텐츠

- 이벤트는 비즈니스 통신 구조 범위에서 발생한 무엇이라도 가능하다.
- 이벤트는 발생한 사건의 기록물이면서 단일 진실 공급원이다

## 이벤트 구조

- 이벤트는 크게 세 종류로 나뉜다.

### 키 없는 이벤트

- 키 없는 이벤트는 하나의 사실을 진술한 형태로 나타낸 이벤트이다.

| 키   | 값                                    |
| ---- | ------------------------------------- |
| N/A  | ISBN: 12341234, Timestamp: 1599393332 |

- 어떤 고객이 상품과 상호작용 했다는 사실을 알려주는 이벤트

### 엔티티 이벤트

- 엔티티 이벤트는 어느 시점의 엔티티 속성 및 상태를 기술한다.

| 키             | 값                     |
| -------------- | ---------------------- |
| ISBN: 12341234 | Author: Adam Bellemare |

- 엔티티 상태의 연속된 이력을 제공하고 상태를 구체화하는 용도로 사용 가능한 엔티티 이벤트는 이벤트 기반 아키텍처에서 특히 중요하다.
- 엔티티의 현재 상태는 마지막 엔티티 이벤트만 있어도 알 수 있다.

### 키 있는 이벤트

- 키 있는 이벤트는 키를 포함하지만 엔티티를 나타내지는 않는다.
- 주로 이벤트 스트림의 한 파티션 내에서 데이터 지역성을 보장하기 위해 이벤트 스트림을 파티셔닝하는 용도로 사용한다.

| 키            | 값          |
| ------------- | ----------- |
| ISBN:12341234 | UserId:1234 |
| ISBN:12341234 | UserId:1111 |

- 이벤트를 키별로 집계하면 ISBN별 사용자 리스트를 구성할 수 있다.

## 엔티티 이벤트에서 상태를 구체화

- 엔티티 이벤트 스트림에서 흘러온 엔티티 이벤트를 순서대로 적용하면 상태 저장 테이블을 구체화할 수 있다.
- 각 엔티티 이벤트는 키/값 테이블에 업서트되므로 가장 최근에 읽은 이벤트를 알 수 있다. 반대로 각 업데이트를 이벤트 스트림에 발행하여 테이블을 엔티티 이벤트의 스트림으로 바꿀 수도 있다. 이를 테이블-스트림 이원성이라고 하고 마이크로서비스에서 상태를 생성하는 기본 원리가 된다.
- **테이블-스트림 이원성을 통해 어떤 컨슈머 클라이언트라도 키 있는 이벤트의 스트림을 읽어 자신의 로컬 상태 저장소에 구체화할 수 있다.** 
- 붙임 전용 불변 로그는 컴팩션을 하지 않으면 무한정 커질 수 있기 때문에 가장 최근 값으로 업데이트하거나 툼스톤 이벤트(값이 null인 키 있는 이벤트)를 통해 해당 값을 지우는 방법으로 컴팩션을 한다.
- 이렇게 컴팩션했을때는 이벤트 스트림에 쌓인 이벤트 이력은 포기할 수밖에 없지만 디스크 사용량이 줄고 현재 상태까지 도달하기까지 처리할 이벤트 수도 감소한다.
- 비지니스 로직을 처리하기 위해 상태를 유지하는 것은 이벤트 기반 아키텍처에서 지극히 일반적인 패턴이다.

## 이벤트 데이터 정의와 스키마

- 이벤트 데이터는 프로듀서/컨슈머가 데이터의 의미를 똑같이 이해하는 것이 중요하다.
- 컨슈머가 서비스를 생산하는 프로듀서에게 따로 물어보지 않고도 이벤트 데이터를 해석할 수 있다면 가장 이상적이다.
- 아파치 아브로나 구글의 프로토콜 버퍼같은 스키마화 기술을 사용하면 스키마 변경을 안전하게 하고 정형 클래스 생성을 도와주기 때문에 더 단순하고 투명하게 만들 수 있다.

## 마이크로서비스 단일 작성자 원칙

## 마이크로서비스를 이벤트 브로커로 강화

- 이벤트브로커는 이벤트 기반 마이크로서비스 플랫폼의 핵심이다.
- 이벤트 브로커는 이벤트를 받아 큐 또는 파티션된 이벤트 스트림에 저장하고 다른 프로세스가 소비할 수 있또록 제공한다.
- 이벤트 브로커 시스템에서 제공하는 필수적인 기능

`확장성`

- 이벤트 브로커의 인스턴스를 추가하면 클러스터의 생산/소비 및 데이터 스토리지 용량을 늘릴 수 있다.

`보존성`

- 노드 간에 이벤트 데이터가 복제되므로 어느 한 브로커에 장애가 발생해도 데이터는 보존되며 서비스도 계속할 수 있다.

`고가용성`

- 이벤트 브로커를 클러스터링하면 한 브로커에 장애가 발생해도 클라이언트는 다른 노드에 접속 수 있어서 풀 가동상태를 유지할 수 있다.

`고성능`

- 여러 브로커 노드가 생산/소비 부하를 분담한다.

### 이벤트 보관 및 처리

- 브로커가 사용할 하부(내부적으로 기반이 되는 중요한) 데이터 스토리지의 최소 요건

`파티셔닝`

- 이벤트 스트림을 파티셔닝하면 여러 컨슈머 인스턴스가 하위 스트림을 각각 병렬처리해서 처리량을 높일 수 있다.

`순서보장`

- 이벤트 스트림 파티션 내에서 데이터 순서는 반드시 보장되므로 원래 발행된 순서대로 클라이언트에게 제공된다.

`불변성`

- 이벤트는 불변이다.
- 변경하려면 데이터를 업데이트한 새로운 이벤트를 발행해야 한다.

`인덱싱`

- 이벤트가 기록되는 시점에 오프셋이 할당된다.
- 컨슈머는 이 오프셋으로 특정하여 데이터를 소비한다.
- 컨슈머의 현재 인덱스와 마지막 인덱스의 간격을 컨슈머 랙이라고 한다.
- 컨슈머 랙에 따라 컨슈머 수를 늘리고 줄이는것을 판단하면 된다.

`무기한 보존`

- 이벤트 스트림은 이벤트를 무기한 보존할 수 있어야하고 이벤트 스트림에서 상태를 관리하면 꼭 필요한 기본 속성이다.

`재연성`

- 이벤트 스트림은 어떤 컨슈머라도 필요한 데이터를 골라서 읽을 수 있도록 재연 가능해야 한다.



### 추가 고려 사항

- 기술지원 받을 수 있는지 ... 팀에서 사용하는 언어를 지원하는지... 등등

## 이벤트 브로커 대 메시지 브로커

- 메시지브로커 != 이벤트 브로커
- 메시지브로커는 ACK를 받으면 메시지를 바로 삭제한다.
- 이벤트브로커는 모든 필요한 시간동안 이벤트를 보존할 수 있고 컨슈머가 모든 이벤트로그를 읽을 수 있다.

### 불변 로그에서 소비

- 이벤트 로그 끝부분에 자동증가 인덱스 id가 부여되고 컨슈머는 이 인덱스 id가 가르키는 위치부터 접근해서 비지니스에 따라 이벤트를 큐나 이벤트 스트림으로 소비한다.

`이벤트 스트림으로 소비`

- 각 컨슈머는 이벤트 스트림에서 이전에 읽은 인덱스를 가리키는 자신만의 위치를 알아서 업데이트한다.
- 오프셋을 통해 여러 컨슈머가 이벤트 스트림에 접속해도 서로 독립적으로 데이터를 소비하면서 진행 상황을 추적할 수 있다.
- 컨슈머 그룹은 여러 컨슈머를 하나의 동일한 엔티티로 나타낸 논리적 단위로, 메시지 소비를 수평 확장하는 데 활용한다.

`큐로 소비`

- 큐로 소비할 경우 각 이벤트는 오직 하나의 마이크로서비스 인스턴스만 소비한다.
- 큐에서 받은 이벤트는 순서가 보장되지 않는다.



### 단일 진실 공급원 제공

- 이벤트 브로커는 서비스가 데이터를 생산/소비하는 유일한 장소가 되고 모든 컨슈머에게 반드시 똑같은 데이터 사본을 제공한다.
- 이벤트 브로커가 단일 진실 공급원이 되려면 조직 문화도 달라져야한다. 예전에는 팀마다 SQL을 작성해서 DB에 붙었다면 이제 이벤트 스트림에서 데이터를 직접 가져다 쓰면 된다.
- 이벤트 스트림과 DB간의 불일치가 되지 않도록 정합성이 온전히 유지되는지 확인해야 한다.
- 이벤트 기반 마이크로서비스가 정착되면 이벤트 브로커만 있어도 데이터 저장/조회가 가능한 서비스를 만들 수 있다.

## 대규모 마이크로서비스 관리

- 마이크로서비스는 서비스가 늘어날수록 점점 더 관리하기 어려워진다.
- 컨테이너/가상화 기술을 해당 관리 시스템과 함께 사용하고 팀마다 단일 배포 단위를 통해 마이크로서비스 요건을 커스터마이징 해야 한다.

### 마이크로서비스를 컨테이너에 넣기

### 마이크로서비스를 가상 머신에 넣기

### 컨테이너 가상 머신 관리

## 마이크로서비스 세금 납부

- 모든것은 비용이다.
- 전체비용을 심사숙고하여 장기적인 비지니스 로드맵에 비추어보아 충분한 기대 효과를 거둘 수 있을지 따져봐야 한다.

## 마치며

- 이벤트 브로커는 데이터 통신의 메인 메커니즘으로서 다른 서비스가 소비할 대규모 실시간 이벤트 스트림을 제공하며 컨테이너화 및 CMS 덕분에 마이크로 서비스 역시 대규모로 실행할 수 있다.







# #3 통신 및 데이터 규약

- 프로듀서와 컨슈머는 메시지의 의미를 똑같이 이해해야 한다.
- 이벤트 기반 시스템에서 이벤트는 통신의 기본 단위다.

## 이벤트 기반 데이터 규약

- 데이터 규약은 주고받을 데이터의 포맷과 그 생성 로직을 정의한다.
- 이벤트 규약을 이용하면 이벤트가 생산되는 컨텍스트 이상의 의미를 부여할 수 있고 컨슈머 애플리케이션의 데이터 사용성을 넓힐 수 있다.

### 명시적인 스키마를 규약으로 활용

- 데이터 규약을 강제하여 일관성을 유지하는 가장 좋은 방법은 이벤트마다 스키마를 정의하는 것이다.
- 암묵적인 스키마는 컨슈머, 프로듀서 모두에게 좋지 않고 명시적인 스키마를 사용해서 보안과 안정성을 보장하자.

### 스키마 정의 주석

- 스키마 정의에서 통합된 주석과 메타데이터는 이벤트 의미를 제대로 전달하기 위해 꼭 필요하다.
- 이벤트 트리거 논리를 명시
  - 스키마 정의 맨 앞의 블록 헤더에 이벤트가 생성된 이유를 명확하게 밝힌다.
- 구조화한 스키마의 특정 필드에 대해 콘텍스트를 부여해서 밝힘
  - 예를 들어 datetime 필드의 날짜/시간 포맷이 UTC, ISO, 유닉스 타임 중 어느 것인지 주석에 명시한다.

### 완전한 스키마 진화

- 스키마 진화를 잘 활용하면 컨슈머는 중단 없이 이벤트를 계쏙 소비하면서 프로듀서가 서비스의 출력 포맷을 업데이트할 수 있다.
- 스키마 정의 프레임워크를 사용하면 변경에 안전하게 프로듀서/컨슈머를 서로 독립적으로 업데이트할 수 있게 보장해준다.
- 스키마 진화 규칙의 호환성 종류 세가지

`정방향 호환성`

- 새 스키마로 생성한 데이터를 마치 옛 스키마로 생성한 것처럼 읽을 수 있다.
- 컨슈머는 새로운 필드에 접근할 경우 코드와 스키마의 사본만 업데이트하면 된다.

`역방향 호환성`

- 옛 스키마로 생성한 데이터를 새 스키마로 생성한 것처럼 읽을 수 있다.
- 데이터 컨슈머는 새 스키마로 옛 데이터를 읽을 수 있다.
- 역방향 호환성이 유용한 경우
  - 업스트림 팀이 전달할 새로운 기능을 컨슈머가 기다릴 때 미리 새 스키마가 정의되어 있으면 컨슈머가 자신의 업데이트를 릴리스 할 수 있다.
  - 옛 스키마로 생성된 이벤트 스트림 데이터를 컨슈머 애플리케이션이 재처리 해야 하는 경우

`양방향 호환성`

- 가능하다면 양방향 호환성을 항상 적용하는게 좋다.



### 코드 생성기 지원

- 코드 생성기는 이벤트 스키마를 클래스 정의 또는 주어진 프로그래밍 언어에서 그와 동등한 구조로 변환한다.
- 프로듀서가 생성한 객체는 직렬화 포맷으로 변환되어 이벤트 브로커에게 전달된다.
  - 비즈니스 로직 출력 -> V2.class 객체 -> 시리얼라이저 -> 스키마: V2데이터 -> 이벤트 스트림에 생산
- 컨슈머는 이벤트를 읽어 그 안에 인코딩된 스키마 버전으로 이벤트를 역직렬화 한다.
- 이벤트 포맷을 메시지 안에 넣을 수 있지만 규모가 커질수록 비용도 커지기 때문에 스키마 레지스트리에 저장하거나 온디맨드 방식으로 접근한다.
- 원래 포맷으로 역직렬화한 이벤트는 컨슈머에서 지원되는 스키마 버전으로 바꿀 수 있다.
  - 이벤트 스트림 소비 -> 스키마 V2 데이터 -> 디시리얼라이저 및 스키마 변환기 -> 스키마 V1 데이터 -> 클래스 생성자 -> V1.class 객체 -> 비지니스 로직 출력
- 코드 생성기를 사용하면 원하는 언어의 클래스 정의에 맞게 애플리케이션을 작성할 수 있는 큰 장점을 갖고 있다. avro, proto buf 둘다 지원하는거 같다. 



### 중대한 스키마 변경

- 중대한 스키마 변경이 일어나는 경우에는 가급적 이른 시기에 다운스트림 컨슈머측과 명확하게 소통하는 것이 중요하다.
- 데이터 규약이나 도메인 모델을 변경해야 하는 경우에는 관련자 모두가 공감대를 형성하는것이 중요하다.

`엔티티의 중대한 스키마 변경 적용`

- 데이터 정의를 두 갈래로 분기하는 방법 두가지
  - 옛 스키마와 새 스키마를 함께 둔다.
  - 모든 엔티티를 새 스키마 포맷으로 재생성한다.
- 전자는 프로듀서 입장에서 가장 쉽지만 상이한 엔티티 정의를 컨슈머가 알아서 해석하도록 방치하는 것이다. 컨슈머가 책임을 전가하는 습관은 좋지 않다.
- 후자는 프로듀서 입장에서 조금 더 어렵지만 새 엔티티 모두 일관성 있게 재정의할 수 있다. 단, 엔티티가 무슨 의미인지 프로듀서, 컨슈머 모두 공감대가 있어야한다.

`이벤트에 관한 중대한 스키마 변경 적용`

- 가장 간단하게 새 이벤트 스트림을 만들어서 스트림 자체를 완전히 바꿔버린다.
- 하나의 이벤트 스트림에 여러 종류의 이벤트 타입을 사용하는 것은 좋지 않다.
- 언젠가 옜 이벤트 스트림에 이벤트가 더 이상 생산되지 않게 되면 모든 컨슈머는 최근 레코드를 따라잡게 되고 이후에 옛 이벤트 스트림을 삭제하면 된다.



## 이벤트 포맷 선택

- 이벤트 데이터는 여러 가지 방법으로 포맷팅/직렬화가 가능하지만 데이터 규약은 아브로, 스리프트, 프로토콜 버퍼처럼 엄격하게 정의된 포맷을 사용하는 편이 좋다.
- 카프카나 아파치 펄사의 스키마 레지스트리에서 거의 모든 포맷을 지원한다.
- 이벤트를 단순 키/값 구조의 평범한 텍스트로 나타내면 명시적인 스키마나 스키마 진화 프레임워크는 전혀 없기 때문에 팀 간에 더 많은 소통이 필요할 수 있다.
- 가능하면 아브로와 같은 포맷 + 스키마 레지스트리를 사용하는게 좋은 것 같다.

## 이벤트 설계

- 이벤트를 잘 설계해야만 프로듀서/컨슈머 모두에게 고통스러운 일을 최대한 덜 수 있다.

### 오직 진실만을 말할지어다

- 잘 정의된 이벤트는 단순히 뭔가가 일어났음을 전하는 메시지가 아니라 그 이벤트가 발생한 동안의 모든 일들을 빠짐없이 기술한다.
- 컨슈머는 그 이벤트가 발생했다는 사실을 다른 데이터 출처를 통해 확인팔 필요가 없을 정도로 투명하고 팩트만 전달해야 한다.

### 스트림당 이벤트 정의는 하나만 사용

- 이벤트 스트림에는 하나의 논리적 이벤트를 나타내는 이벤트가 포함돼야 한다.
- 종류가 다른 이벤트를 하나의 스트림에 섞지 말자.

### 가장 좁은 범위의 데이터 타입 사용

- 이벤트 데이터 타입은 가장 범위가 좁은 것을 사용하자.

`문자열을 이용해 숫자 값을 저장`

- 컨슈머가 문자열을 파싱해서 숫자 값으로 변환하는 경우, 널 값이나 공백 문자열이 절달될 때가 많기 때문에 에러가 날 수 있다.

`정수를 불리언으로 사용`

- 0, 1 이외에 다른 값이 들어올 수 있다.

`문자열을 enum으로 사용`

- 컨슈머나 프로듀서입장에서 문자열 값의 범위가 어떻게 바뀌더라도 보호받지 못한다.
- enum을 쓰면 잘 되나 보다.

​    

- enum은 잘 사용하지 않지만 프로토콜 버퍼와 아브로는 알 수 없는 enum 토큰을 우아하게 처리하는 방법을 제공하므로 참고하자.



### 이벤트는 하나의 목적만 갖도록

- 이벤트 정의에 타입 필드를 추가해서 하위 속성을 따로 두려고 하는 것은 흔한 안티 패턴중에 하나다.
- 이벤트 타입에 타입 매개변수까지 얹는 모양새는 좋지 않다.
- 이벤트가 논리적으로 두 개 이상의 의미를 갖는 순간 프로듀서, 컨슈머 입장에서 좋을게 없다.
- 이벤트는 수많은 종류의 데이터를 기록하는 일반 이벤트가 아닌, 하나의 비지니스 액션에 관한 것이어야 한다.
- 하나의 이벤트 스트림에는 하나의 이벤트만. 이 하나의 이벤트에는 다른 타입을 추가하지 않기.



### 이벤트 크기 최소화

- 이벤트는 크기가 작고, 잘 정의되어 있고, 쉽게 처리할 수 있어야 좋다.
- 이벤트크기가 크다면 그 서비스가 하는 역할이나 크기에 대해서 다시 고민해보는게 좋다.

### 미래의 컨슈머도 이벤트 설계에 반영

- 새 이벤트를 설계할 때는 그 데이터를 소비할 것으로 예쌍되는 컨슈머 부서와도 협의가 필요하다.

### 이벤트를 세마포어나 시그널로 사용하지 않는다

- 어떤 작업을 완료한다는 이벤트가 있다면 그 작업을 완료했다는 것은 알 수 있지만 실제로 완료된 작업 정보가 있는 곳을 찾아야한다. 이렇게 데이터 조각 하나에 진실 공급원이 2개가 생기게 되면 일관성에 문제가 생긴다.

## 마치며

- 비동기식 이벤트 기반 아키텍처는 이벤트 품질에 크게 의존한다.
- 암묵적인 스키마보다 명시적인 스키마를 사용해서 안전하게 스키마진화를 구현하자.
- 이벤트 정의는 가급적 범위를 좁혀 이벤트 도메인에 집중해야 한다.
- 이벤트에는 어떤 비지니스 사건을 나타내며 어떤 일이 일어났는지 적절한 데이터 필드가 포함되어 있어야 한다.
- 스키마 진화는 명시적 스키마에서 아주 중요한 요소다.
- 중대한 스키마 변경이 불가피핟면 프로듀서/컨슈머 등 이해 관계자들은 함께 모여 미래의 도메인 모델을 다듬어야 한다.

