

# 이벤트 기반 마이크로서비스 구축





# #1 왜 이벤트 기반 마이크로서비스인가?

- 이벤트는 이제 엄청나게 큰 규모로 무기한 저장할 수 있고 모든 서비스가 필요할 때마다 몇 번이라도 소비할 수 있게 됐다.
- 이벤트를 통해 이제는 제약 없이 얼마든지 데이터를 저장/관리할 수 있게 됐다.

## 이벤트 기반 마이크로 서비스란?

- 현대 이벤트 기반 마이크로서비스 아키텍처에서는 시스템이 이벤트를 생산/소비하는 식으로 서로 통신한다.
- 이벤트를 소비해도 메시지를 전달한 시스템이 바로 사라지는건 아니고 같은 메시지를 필요로 하는 다른 컨슈머도 가져갈 수 있게 보존된다.
- 서비스는 입력 이벤트 스트림에서 이벤트를 받아 특정한 비즈니스 로직을 적용한 다음, 출력 이벤트를 내보내서 요청-응답 접근에 필요한 데이터를 제공하거나 서드파티 api와 통신, 또는 다른 필요한 일을 수행한다.

## 도메인 주도 설계와 경계 콘텍스트

- 도메인 주도 설계의 기본 개념

`도메인`

- 비지니스가 차지하고 솔루션이 제공하는 문제 공간.
- 규칙 프로세스, 아이디어, 비지니스 전문 용어 등 문제공간과 조금이라도 관련된 것들은 모두 포함된다.
- 도메인은 비지니스 존재 여부와 무관하게 존재한다.

`하위 도메인`

- 메인 도메인을 이루는 컴포넌트.
- 특정한 하위 업무에 집중하고 일반적으로 비지니스 조직 구조를 반영한다.
- 하위 도메인 하나를 하나의 도메인으로 볼 수 있다.
- 하위 도메인 역시 메인 도메인처럼 문제 공간에 속한다.

`도메인(및 하위 도메인) 모델`

- 비지니스 용도에 맞게 실제 도메인을 추상화한 비지니스에서 가장 중요한 도메인 조각 및 속성들로 모델을 생성한다.
- 도메인 모델은 솔루션 공간의 일부로 비지니스가 문제를 해결하기 위해 사용하는 구성체이다.

`경계 콘텍스트`

- 경계 콘텍스트는 솔루션 공간의 속성으로 마이크로서비스가 상호작용하는 방식에 상당한 영향을 미친다.

  

- 경계 콘텍스트는 응집력이 강해야 한다.
- 콘텍스트 내부 기능은 집약적이고 깊이 연관되어 있고 대부분의 통신이 내부에서만 일어나야 한다.
- 경계 콘텍스트는 느슨하게 결합해야 한다. 그래야 다른 콘텍스트에 영향이 없다.

### 도메인 모델과 경계 모텍스트 활용

- 모든 조직은 그 자신과 외부 사이에 하나의 도메인을 형성한다.
- 도메인은 다시 하위 도메인으로 나뉘고 계속 쪼개져서 작고 독립적인 서비스로 옮길 수 있을정도가 된다.
- 경계 콘텍스트는 이런 하위 도메인을 중심으로 형성되어 마이크로서비스가 탄생하는 기초가 된다.

### 비즈니스 요건에 따라 경계 콘텍스트 조정

- 경계 콘텍스트를 기술 요건이 아니라 비지니스 요건 중심으로 정해야 변경에도 영향이 없다
- 경계 콘텍스트를 비지니스 요건에 맞추면 팀별로 느슨하게 결합하며 고도로 응집된 마이크로서비스 구현체를 바꿀 수 있다. => 팀간의 의존도가 적어서 맡은 요건에만 독립적으로 전념할 수 있다.
- 마이크로서비스를 기술 요건에 맞추면 생기는 가장 큰 문제는 여러 경계 콘텍스트에 걸쳐 비지니스 기능을 수행할 책임이 여러 팀으로 분산되어 제각기 다른 스케줄로 다른 업무를 진행하게 된다.
- 전체를 아우르는 기술, 팀 간 의존성을 타파해야 시스템 변경 민감도를 낮출 수 있다.
- 이벤트 기반 마이크로서비스는 비지니스 요건에 따라 아키텍처를 모델링하는 것이 바람직하다.
- 위 과정에서 코드가 여러번 복제되거나 비슷한 서비스가 증가하는 트레이드 오프가 있다.
- 중복이 강결합보다 낫다.
- 경계 콘텍스트 간 결합은 느슨하게 유지하고 상호 의존 관계는 최소화하자. 그래야 필요시 다른 시스템에 해를 끼치지 않고 경계 컨텍스트를 변경할 수 있다.
- 팀마다 풀스택 전문성을 갖춰야 한다.

## 통신 구조

### 비즈니스 통신 구조

- 비즈니스 통신 구조는 팀과 부서 간의 통신을 결정하며 각 팀에 할당된 주된 요건 및 책임에 따라 달라진다.

![1](./images/building-event-driven-microservices/1.png)



### 구현 통신 구조

- 구현 통신 구조는 하위 도메인 모델에 대해 조직에서 규정한 데이터와 로직을 이용해 신속하고 효울적인 업무 수행을 위해 비지니스 프로세스, 데이터 구조, 시스템 설계를 정규화한 것이다.

![2](./images/building-event-driven-microservices/2.png)



### 데이터 통신 구조

- 데이터 통신구조는 비지니스 전반에 걸쳐, 특히 구현체간에 데이터를 주고 받는 프로세스를 말한다.

![3](./images/building-event-driven-microservices/3.png)

### 콘웨이의 법칙과 통신 구조

- 시스템 구조는 그 시스템을 설계하는 조직의 통신 구조를 그대로 따라갈 수밖에 없다. - 맬빈 콘웨이
- 조직에서 데이터 접근이 너무 어렵거나 모든 데이터가 구현체 하나에 몰려 있어 제품의 범위가 한정되어 있다면 필경 데이터 통신 구조가 부실한 대가를 치루고 있는 것이다.



## 기존 컴퓨팅의 통신 구조

- 한 조직의 통신 구조는 엔지니어링 결과물이 탄생하기까지 막대한 영향을 미친다. 팀 레벨도 마찬가지
- 단일 데이터 저장소에 기반한 단일 서비스를 담당하는 팀에 새로운 요건이 들어온 경우 아래와 같이 옵션1, 2 로 고민해볼 수 있음

### 옵션 1: 서비스를 새로 만듦

- 새로운 서비스를 만들어 운영하는 작업에는 데이터 동기화 등등 리스크가 있다.
- 데이터 저장소 2개, 서비스 2개, 데이터 의존, 로깅, 모니터링, 테스트 배포, 롤백 프로세스, 데이터 등등의 문제

### 옵션 2: 기존 서비스에 추가

- 여러 모듈이 동일한 코드 베이스에 함께 엮이는 경우가 많아 변경할 일이 생기면 구현체 내부에서 경계까 모호해질 가능성이 있다.
- 경계를 자유롭게 넘나들면서 모듈을 직접 결합시키면 ㅂ쉽고 빠르게 기능을 추가할 수 있지만 결합도는 올라가고 모듈성은 떨어진다.

### 옵션별 장단점

- 많은 팀들이 두번째 옵션을 선택하고 모놀리식 아키텍처는 아직 강력하고 비지니스에 탁월한 가치를 제공하므로 잘못된 선택은 아니다.
- 첫번째 옵션 요약
  - 다른 시스템의 데이터에 안정적으로 접근하기 어렵다. 특히 대규모 데이터를 실시간 접근하기 곤란하다.
  - 서비스를 새로 만들어 관리하는 오버헤드와 리스크를 무시할 수 없다. 특히 신규 서비스를 관리하는 체계가 조직 내에 아직 확립되어 있지 않다.
- 데이터를 얻기 위해서는 통신을 피할 수 없고 복제를하자니 점대점 결합이 발생할 수 밖에 없다.
- 데이터 복제는 데이터의 양이 많아질수록 더 많이 어긋나게 된다.
- **회사 곳곳에 정확한 데이터를 전달할 수 없는 까닭은 개념 자체에 근본적인 결함이 있어서가 아니다. 데이터 통신 구조가 취약하거나 전무하기 때문이다.**
- **핵심 비지니스 데이터는 이를 필요로 하는 모든 서비스가 쉽게 획득하고 사용할 수 있어야 한다. 이것이 이벤트 기반 마이크로서비스의 기본 교리중 하나이다.**



### 팀 시나리오(계속)

- 옵션2를 선택한 팀에서 1년 뒤에 새로운 요구사항에 맞이하게 되었을때의 문제
  - 어느 팀이 어떤 데이터를 소유해야 하나?
  - 데이터는 어디에 두어야 하나?
  - 두 팀 모두 값을 변경하는 데이터는 어떻게 처리할까?



### 상충되는 압력

- 발생되는 모든 문제들의 근원은 구현 통신 구조 간의 데이터 통신 수단이 취약하고 제대로 정의되지 않은 탓이다.

## 이벤트 기반 통신 구조

- 이벤트 기반 통신은 기존 구현/데이터 통신 구조의 대안이다.
- 이벤트 스트리밍 방식의 데이터 통신 구조에서는 데이터를 생산/소유하는 것과 데이터에 접근하는 행위가 철저히 분리되기 때문에 서비스는 더 이상 직접 요청-응답 API에 얽매이는 일 없이 이벤트 스트림 내부에 정의된 이벤트 데이터를 매개로 소통한다.
- 프로듀서는 그저 자신이 맡은 이벤트 스트림에 잘 정의된 데이터를 생산하는 일만 책임지면 된다.

### 이벤트는 통신의 근간이다

- 공유 데이터는 모조리 이벤트 스트림 세트에 발행함으로써 조직에서 일어난 모든 일은 지속적으로 정규화한 형태로 서술된다.
- **이벤트 = 데이터**
- 이벤트는 데이터 스토리지뿐만 아니라 서비스 간의 비동기 통신 수단 역할도 된다.

### 이벤트 스트림은 단일 진실 공급원이다

- 스트림 안에 있는 각 이벤트는 사실 진술서이고 이것들을 취합하면 시스템이 통신하는 근간인 단일 진실 공급원이 된다.

### 컨슈머가 스스로 모델링과 쿼리를 수행한다

- 이벤트 기반 데이터 통신 구조는 데이터 쿼리/검색 기능이 있다는 점에서 과도하게 확장된 구현 통신 구조와 다르다.
- 모든 비지니스 및 애플리케이션 로직은 반드시 이벤트 프로듀서/컨슈머 안에 캡슐화 되어야한다.
- 컨슈머는 여러 이벤트 스트림에서 들어온 데이터를 혼합하거나 특별한 쿼리를 하거나 특정한 비지니스를 수행한다.
- 이제는 각제 맡은 경계 컨텍스트의 니즈를 해결하는 일만 책임지면 된다.

### 조직 전반적으로 데이터 통신이 원활해진다

- 데이터는 공용 이벤트 스트림 세트에 발행함으로써 데이터의 생산과 소유권을 완전히 분리할 수 있다.
- 덕분에 느슨한 결합과 높은 응집도를 가져야하는 경계 컨텍스트 원칙을 더 준수할 수 있게 됐다.
- 애플리케이션을 이벤트 기반으로 개발하면 과거에 점대점 커넥션을 통해 힘들게 가져왔던 데이터에 쉽게 접근할 수 있다.

### 접근 가능한 데이터 덕분에 비즈니스 통신 변경이 가능하다

- 핵심 도메인 이벤트가 특정 구현체에 의존하지 않기 때문에 전반적으로 비지니스가 아주 유연해진다.



## 비동기식 이벤트 기반 마이크로 서비스

- 이벤트 기반 마이크로서비스를 구축하면 경계 컨텍스트 요건에 맞게 필요한 비지니스 로직 변환을 수행할 수 있다.
- 이벤트 기반 마이크로서비스의 중요한 이점

`세분성`

- 서비스가 경계 컨텍스트에 알맞게 매핑되고 비지니스 요건이 바뀌어도 쉽게 재작성할 수 있다.

`확장성`

- 개별 서비스는 필요시 규모를 늘리거나 줄일 수 있다.

`기술 유연성`

- 서비스마다 적합한 언어와 기술로 구현할 수 있고 첨단 기술을 적용해서 쉽게 프로토콜타이핑할 수 있다.

`비지니스 요건 유연성`

- 단위가 작은 마이크로서비스는 소유권을 재조정하기 쉽다
- 대규모 서비스보다 다른 팀에 덜 의존하기에 데이터 접근시 장애 요소가 적고 조직은 비즈니스 요건 변화에 신속하게 대응할 수 있다.

`느슨한 결합`

- 이벤트 기반 마이크로서비스는 도메인 데이터와 결합할 뿐, 어떤 특정한 구현 API에 구애받지 않는다.
- 데이터 스키마를 이용하면 보다 효율적으로 데이터 변경 관리를 할 수 있다.

`지속적 전달 지원`

- 작은 모듈로 나눈 마이크로서비스는 옮기기 쉽고 필요시 간편하게 롤백할 수 있다.

`우수한 시험성`

- 마이크로서비스는 덩치 큰 모놀리스보다 디펜던시가 적어서 필요한 테스트 엔드포인트를 모킹하고 코드 커버리지를 적절히 유지하기 쉽다.



### 이벤트 기반 마이크로서비스 예제



## 동기식 마이크로서비스

- 동기식 마이크로서비스는 요청-응답 방식으로 직접 API를 통해 소통함으로써 비즈니스 요건을 처리한다.



### 동기식 마이크로서비스의 단점

- 동기식 마이크로서비스는 대규모 환경에서는 문제가 많아 사용하기 곤란할 수 있다.

`점대점 결합`

- 동기식 마이크로서비스는 결국 자신이 할 일을 다른 서비스에서 의존할 수 밖에 없다.
- 의존 관계가 많아지면 많아질수록 비지니스 로직을 파악하기 쉽지 않다. 고치기도 힘들다.

`의존적 확장`

- 한 서비스의 확장 가능 여부는 그 서비스가 의존하는 다른 모든 서비스가 확장 가능한지, 또 통신의 팬아웃 정도와 직접 연관된다.

`서비스 실패 처리`

- 의존하는 서비스가 내려가는 예외 상황 발생 시 처리 방법을 정해야 한다.
- 데이터 정합성을 보장하려면 처리결과에 따라 절차를 마련해야 한다.

`API 버저닝과 디펜던시 관리`

- 다수의 서비스를 상대로 API 변경을 적용하는 일 자체가 꽤 복잡해질 수 있다.

`데이터 접근이 구현체에 종속된다`

- 동기식 마이크로서비스는 외부 데이터 접근 시 기존 서비스와 동일한 문제가 발생한다.

`분산 모놀리스`

- 서비스가 분산 모놀리스가 되어 서비스간 호출이 얽히고 설킨다.

`테스트`

- 각 서비스를 가동하려면 자신의 의존하는 서비스 역시 가동중이어야하고 물리고 물리기 때문에 테스트를 수행하기가 정말 어렵다.



### 동기식 마이크로서비스의 장점

- 사용자 인증, A/B 테스트 같은 데이터 접근 패턴은 직접 요청-응답을 주고 받는 방식이 더 유리하다.
- 여러 시스템에 걸친 작업을 추적하기도 동기식 환경이 더 용이하다. => 로그를 보기 쉬움 



## 마치며

- 조직의 소프트웨어를 개발하고 관리하는 방향은 통신 구조에 따라 결정된다.
- 이벤트 기반 시스템에 내재된, 쉽게 접근하고 저장할 수 있는 도메인 이벤트를 활용하면 더 작고 목적에 부합한 구현체를 만들 수 있다. 



# #2 이벤트 기반 마이크로서비스 기초

- 이벤트 기반 마이크로서비스는 특정한 경계 컨텍스트를 구현하기 위해 개발된 작은 애플리케이션이다.
- 컨슈머 마이크로서비스는 하나 이상의 입력 이벤트 스트림으로부터 이벤트를 소비 처리한다.
- 프로듀서 마이크로서비스는 다른 서비스가 소비할 수 있게 이벤트 스트림에 이벤트를 생산한다.
- 일반적으로 이벤트 기반 마이크로서비스는 컨슈머인 동시에 프로듀서이다.
- 이벤트 브로커는 이벤트 스트림을 제공한다.

## 토폴로지 구성

### 마이크로서비스 토폴로지

- 마이크로서비스 토폴로지는 마이크로서비스 내부의 이벤트 기반 토폴로지이다.

![4](./images/building-event-driven-microservices/4.png)

- 스트림 A에서 이벤트를 받아 데이터 저장소에 구체화하고 스트림 B에서 받은 데이터는 어떤 조건에 맞는 이벤트를 거르고 저쩌고 하고 새로운 이벤트 스트림으로 보낸다.



### 비지니스 토폴로지

- 비지니스 토폴로지는 복잡한 비지니스 로직을 처리하는 마이크로서비스, 이벤트 스트림 API 집합이다.
- 마이크로서비스는 비지니스 경계 컨텍스트를 구현하며 이벤트 스트림은 전체 컨텍스트의 도메인 데이터를 공유하기 위해 필요한 통신 수단이다.
- 마이크로서비스 토폴로지는 단일 마이크로서비스의 내부 작업에 초점을 두는 반면, 비지니스 토폴로지는 서비스 사이의 관계를 상술한다.

![5](./images/building-event-driven-microservices/5.png)

- 이리저리 엮이고 해서 마이크로서비스와 이벤트 스트림은 필요한 만큼 추가해서 비동기로 결합할 수 있다.



## 이벤트 콘텐츠

- 이벤트는 비즈니스 통신 구조 범위에서 발생한 무엇이라도 가능하다.
- 이벤트는 발생한 사건의 기록물이면서 단일 진실 공급원이다

## 이벤트 구조

- 이벤트는 크게 세 종류로 나뉜다.

### 키 없는 이벤트

- 키 없는 이벤트는 하나의 사실을 진술한 형태로 나타낸 이벤트이다.

| 키   | 값                                    |
| ---- | ------------------------------------- |
| N/A  | ISBN: 12341234, Timestamp: 1599393332 |

- 어떤 고객이 상품과 상호작용 했다는 사실을 알려주는 이벤트

### 엔티티 이벤트

- 엔티티 이벤트는 어느 시점의 엔티티 속성 및 상태를 기술한다.

| 키             | 값                     |
| -------------- | ---------------------- |
| ISBN: 12341234 | Author: Adam Bellemare |

- 엔티티 상태의 연속된 이력을 제공하고 상태를 구체화하는 용도로 사용 가능한 엔티티 이벤트는 이벤트 기반 아키텍처에서 특히 중요하다.
- 엔티티의 현재 상태는 마지막 엔티티 이벤트만 있어도 알 수 있다.

### 키 있는 이벤트

- 키 있는 이벤트는 키를 포함하지만 엔티티를 나타내지는 않는다.
- 주로 이벤트 스트림의 한 파티션 내에서 데이터 지역성을 보장하기 위해 이벤트 스트림을 파티셔닝하는 용도로 사용한다.

| 키            | 값          |
| ------------- | ----------- |
| ISBN:12341234 | UserId:1234 |
| ISBN:12341234 | UserId:1111 |

- 이벤트를 키별로 집계하면 ISBN별 사용자 리스트를 구성할 수 있다.

## 엔티티 이벤트에서 상태를 구체화

- 엔티티 이벤트 스트림에서 흘러온 엔티티 이벤트를 순서대로 적용하면 상태 저장 테이블을 구체화할 수 있다.
- 각 엔티티 이벤트는 키/값 테이블에 업서트되므로 가장 최근에 읽은 이벤트를 알 수 있다. 반대로 각 업데이트를 이벤트 스트림에 발행하여 테이블을 엔티티 이벤트의 스트림으로 바꿀 수도 있다. 이를 테이블-스트림 이원성이라고 하고 마이크로서비스에서 상태를 생성하는 기본 원리가 된다.
- **테이블-스트림 이원성을 통해 어떤 컨슈머 클라이언트라도 키 있는 이벤트의 스트림을 읽어 자신의 로컬 상태 저장소에 구체화할 수 있다.** 
- 붙임 전용 불변 로그는 컴팩션을 하지 않으면 무한정 커질 수 있기 때문에 가장 최근 값으로 업데이트하거나 툼스톤 이벤트(값이 null인 키 있는 이벤트)를 통해 해당 값을 지우는 방법으로 컴팩션을 한다.
- 이렇게 컴팩션했을때는 이벤트 스트림에 쌓인 이벤트 이력은 포기할 수밖에 없지만 디스크 사용량이 줄고 현재 상태까지 도달하기까지 처리할 이벤트 수도 감소한다.
- 비지니스 로직을 처리하기 위해 상태를 유지하는 것은 이벤트 기반 아키텍처에서 지극히 일반적인 패턴이다.

## 이벤트 데이터 정의와 스키마

- 이벤트 데이터는 프로듀서/컨슈머가 데이터의 의미를 똑같이 이해하는 것이 중요하다.
- 컨슈머가 서비스를 생산하는 프로듀서에게 따로 물어보지 않고도 이벤트 데이터를 해석할 수 있다면 가장 이상적이다.
- 아파치 아브로나 구글의 프로토콜 버퍼같은 스키마화 기술을 사용하면 스키마 변경을 안전하게 하고 정형 클래스 생성을 도와주기 때문에 더 단순하고 투명하게 만들 수 있다.

## 마이크로서비스 단일 작성자 원칙

## 마이크로서비스를 이벤트 브로커로 강화

- 이벤트브로커는 이벤트 기반 마이크로서비스 플랫폼의 핵심이다.
- 이벤트 브로커는 이벤트를 받아 큐 또는 파티션된 이벤트 스트림에 저장하고 다른 프로세스가 소비할 수 있또록 제공한다.
- 이벤트 브로커 시스템에서 제공하는 필수적인 기능

`확장성`

- 이벤트 브로커의 인스턴스를 추가하면 클러스터의 생산/소비 및 데이터 스토리지 용량을 늘릴 수 있다.

`보존성`

- 노드 간에 이벤트 데이터가 복제되므로 어느 한 브로커에 장애가 발생해도 데이터는 보존되며 서비스도 계속할 수 있다.

`고가용성`

- 이벤트 브로커를 클러스터링하면 한 브로커에 장애가 발생해도 클라이언트는 다른 노드에 접속 수 있어서 풀 가동상태를 유지할 수 있다.

`고성능`

- 여러 브로커 노드가 생산/소비 부하를 분담한다.

### 이벤트 보관 및 처리

- 브로커가 사용할 하부(내부적으로 기반이 되는 중요한) 데이터 스토리지의 최소 요건

`파티셔닝`

- 이벤트 스트림을 파티셔닝하면 여러 컨슈머 인스턴스가 하위 스트림을 각각 병렬처리해서 처리량을 높일 수 있다.

`순서보장`

- 이벤트 스트림 파티션 내에서 데이터 순서는 반드시 보장되므로 원래 발행된 순서대로 클라이언트에게 제공된다.

`불변성`

- 이벤트는 불변이다.
- 변경하려면 데이터를 업데이트한 새로운 이벤트를 발행해야 한다.

`인덱싱`

- 이벤트가 기록되는 시점에 오프셋이 할당된다.
- 컨슈머는 이 오프셋으로 특정하여 데이터를 소비한다.
- 컨슈머의 현재 인덱스와 마지막 인덱스의 간격을 컨슈머 랙이라고 한다.
- 컨슈머 랙에 따라 컨슈머 수를 늘리고 줄이는것을 판단하면 된다.

`무기한 보존`

- 이벤트 스트림은 이벤트를 무기한 보존할 수 있어야하고 이벤트 스트림에서 상태를 관리하면 꼭 필요한 기본 속성이다.

`재연성`

- 이벤트 스트림은 어떤 컨슈머라도 필요한 데이터를 골라서 읽을 수 있도록 재연 가능해야 한다.



### 추가 고려 사항

- 기술지원 받을 수 있는지 ... 팀에서 사용하는 언어를 지원하는지... 등등

## 이벤트 브로커 대 메시지 브로커

### 불변 로그에서 소비

### 단일 진실 공급원 제공

## 대규모 마이크로서비스 관리

### 마이크로서비스를 컨테이너에 넣기

### 마이크로서비스를 가상 머신에 넣기

### 컨테이너 가상 머신 관리

## 마이크로서비스 세금 납부

## 마치며