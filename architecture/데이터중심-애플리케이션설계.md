# 데이터 중심 애플리케이션 설계



# #1 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

- 오늘날 많은 애플리케이션은 계산 중심과는 다르게 데이터 중심 적이다. 이는 CPU 성능이 아닌 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도가 더 중요하다.

## 데이터 시스템에 대한 생각

- 이 책에서는 대부분의 소프트웨어 시스템에서 중요하게 여기는 세가지 관심사에 중점을 둔다.

`신뢰성 Reliability`

- 하드웨어나 소프트웨어 겨함. 심지어 인적 오류 같은 역경에 직면하더라도 시스템은 지속적으로 올바르게 동작해야 한다.

`확장성 Scalability`

- 시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 한다.

`유지보수성 Maintainability`

- 시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 한다.



## 신뢰성

- 소프트웨어에서 기대하는 일반적인 기대치
  - 애플리케이션은 사용자가 기대한 기능을 수행한다.
  - 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.
  - 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.
  - 시스템은 허가되지 않은 접근과 오남용을 방지한다.
- 잘못될 수 있는 일을 결함 이라고 부르고 그 결함을 예측하고 대처할 수 있는 시스템을 내결함성 또는 탄력성을 지녔다고 말한다.
- 결함이 0일수는 없다. 하지만 특정 결함으로 인해 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 좋다.



### 하드웨어 결함

### 소프트웨어 오류

### 인적 오류

- 사람이 미덥지 않음에도 시스템을 어떻게 신뢰성 있게 만들까에 대한 아이디어들
  - 오류의 가능성을 최소화하는 방향으로 시스템을 설계하라. 잘 설계된 추상화, API, 관리 인터페이스를 사용하면 옳은 일은 쉽게하고 잘못된 일은 막을 수 있다. 인터페이스가 지나치게 제한적이면 사람들은 좋은 점을 잊은 채 제한된 인터페이스를 피해 작업한다. 이런 시스템 설계는 올바르게 작동하게끔 균형을 맞추기가 어렵다.
  - 사람이 가장 많이 실수하는 장소에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리하라. 비 프로덕션 샌드박스를 제공하라.
  - 단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트하라.
  - 장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복수할 수 있게 하라. 예를 들어 설정 변경 내역을 rollback하고 새로운 코드를 서서히 rollout 하게 만들기
  - 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련하라.
  - 조작 교육과 실습을 시행하라.



### 신뢰성은 얼마나 중요할까?

- 비즈니스 애플리케이션에서 버그는 생산성 저하의 원인이고 전자 상거래 사이트의 중단은 많은 비용을 초래한다.
- 모든 애플리케이션은 안정적으로 작동해야 한다.



## 확장성

- 시스템이 현재 안정적으로 동작한다고 해서 미래에도 안정적으로 동작한다는 보장은 없다.
- 성능 저하를 유발하는 흔한 이유중 하나는 부하 증가다.
- 확장성을 논한다는 것은 아래와 같은 질문을 고려한다는 의미다.
  - 시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?
  - 추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?

### 부하 기술하기

- 무엇보다 시스템의 현재 부하를 간결하게 기술해야 한다. 그래야 부하 성장 질문을 논의할 수 있다.

### 성능 기술하기

- 일단 시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다.
  - 부하 매개변수를 증가시키고 시스템 자원은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
  - 부하 매개변수를 증가시켰을 때 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?



### 부하 대응 접근 방식

- 다수의 장비에 부하를 분산하는 아키텍처를 비공유(shared-nothing) 아키텍처 라고 부른다.



## 유지보수성

- 소프트웨어 비용의 대부분은 초기 개발이 아니라 지속해서 이어지는 유지보수에 들어간다는 사실은 잘 알려져 있다.
- 주의를 기울여야 할 소프트웨어 시스템 설계 원칙

`운용성`

- 운영팀이 시슽메을 원활하게 운영할 수 있게 쉽게 만들어라

`단순성`

- 시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라

`발전성`

- 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라. 그래야 요구사항 변경 같은 예기치 않은 사용 하례를 적용하기가 쉽다.



#### 운용성: 운영의 편리함 만들기

- "좋은 운영은 나쁜 소프트웨어의 제약을 피하는 대안이 될 수 있다. 하지만 좋은 소프트웨어라도 나쁘게 운영할 경우 작동을 신뢰할 수 없다."
- 운영 중 일부 측면은 자동화할 수 있고 또 자동화 해야 한다.
- 좋은 운영팀의 역할
  - 시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 서비스를 복원
  - 시스템 장애, 성능 저하 등의 문제의 원인을 추적
  - 보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지
  - 다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단
  - 미래애 발생 가능한 문제를 예측해 문제가 발생하기 전에 해결
  - 배포, 설정 관리 등을 위한 모범 사례와 도구를 마련
  - 애플리케이션을 특정 플랫폼에서 다른 플랫폼으로이동하는 등 복잡한 유지보수 태스크 수행
  - 설정 변경으로 생기는 시스템 보안 유지보수
  - 예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의
  - 개인 인사 이동에도 시스템에 대한 조직의 지신을 보존함
- 좋은 운영성이랑 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중한다는 의미다.
- 동일 반복 태스크를 쉽게하기 위한 일
  - 좋은 모니터링으로 런타임 동작과 시스템의 내부에 대한 가시성 제공
  - 표준 도구를 이용해 자동화와 통합을 위한 우수한 지원을 제공
  - 개별 장비 의존성을 회피. 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야 함.
  - 좋은 문서와 이해하기 쉬운 운영 모델들 제공
  - 만족할만한 기본 동작을 제공하고 필요할 때 기본 값을 다시 정의할 수 있는 자유를 관리자에게 부여
  - 적절하게 자기 회복이 가능할 뿐 아니라 필요에 따라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함
  - 예측 가능하게 동작하고 예기치 않은 상황을 최소화함

### 단순성: 복잡도 관리

- 복잡도가 높아지면 유지보수 비용이 증가한다.
- 단순성은 시스템의 핵심 목표여야 한다.
- 우발적 복잡도를 제거하기 위한 최상의 도구는 추상화다. 좋은 추상화는 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.



### 발전성: 변화를 쉽게 만들기

- 시스템의 요구사항은 끊임없이 할 가능성이 훨씬 크다.
- 데이터 시스템 변경을 쉽게 하고 변화된 요구사항에 시스템을 맞추는 방법은 시스템의 간단함과 추상화와 밀접한 관련이 있다.



## 정리

- 애플리케이션이 유용하려면 다양한 요구사항을 충족시켜야 한다.
- 다양한 요구사항에는 기능적 요구사항(실제로 동작하는 기능), 비기능적 요구사항(신뢰성, 확장성, 유지보수성) 이 있다.
- 신뢰성은 결함이 발생해도 시스템이 올바르게 동작하게 만든다는 의미다. 결함은 하드웨어, 소프트웨어, 사람에게 있을 수 있고 내결함성 기술은 최종 사용자에게 특정 유형의 결함을 숨길 수 있게 해준다.
- 확장성은 부하가 증가해도 좋은 성능을 유지하기 위한 전략을 의미한다. 확장성을 설명하려면 먼저 양적으로 부하와 성능을 설명하는 방법이 필요하다. 확장 가능한 시스템에서는 부하가 높은 상태에서 신뢰성을 유지하기 위해 처리 용량을 추가할 수 있다.
- 유지보수성에는 많은 측면이 있지만 유지보수성의 본질은 시스템에서 작업하는 엔지니어와 운영 팀의 삶을 개선하는 데 있다. 좋은 추상화는 복잡도를 줄이고 쉽게 시스템을 변경할 수 있게 하며 새로운 사용 사례에 적용하는데 도움이 된다. 좋은 운용성이란 시스템의 건강 상태를 잘 관찰할 수 있고 시스템을 효율적으로 관리하는 방법을 보유한다는 의미다.





# #2 데이터 모델과 질의 언어

- 각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨긴다.
- 데이터 모델은 그 위에서 소프트웨어가 할 수 있는 일과 할 수 없는 일에 지대한 영향을 주므로 애플리케이션에서 적합한 데이터 모델을 선택하는 작업은 상당히 중요하다.

## 관계형 모델과 문서 모델

- 오늘날 가장 잘 알려진 데이터 모델
- 데이터는 관계로 구성되고 각 관계는 순서 없는 튜플(row) 모음이다.



### NoSQL의 탄생

- NoSQL은 비관계형 데이터베이스 밋업용 인기 트위터 해시태그였지만 시간이 지나면서 Not Only SQL로 재해석 됐다.
- NoSQL의 다양한 원동력
  - 대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게할 수 있는 뛰어난 확장성의 필요
  - 상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산
  - 관계형 모델에서 지원하지 않는 특수 질의 동작
  - 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람
- 관계형, 비관계형 데이터베이스를 함께사용하는 개념을 다중 저장소 지속성(polyglot persistence) 이라 한다.



### 객체 관계형 불일치

- 데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터 베이스 모델 객체 사이에 거추장스로운 전환 계층이 필요하다. 임피던스 불일치(impedance mismatch)
- 액티브레코드나 하이버네이트 같은 ORM 프레임워크는 전환 계층에 필요한 상용구 코드의 양을 줄이지만 두 모델 간의 차이를 완벽히 숨길 수는 없다.
- 이력서같은 데이터 구조는 모든 내용을 갖추고 있는 문서라서 JSON 표현에 매우 적합하다.
- 관계형 데이터베이스의 다중 테이블 스키마보다 JSON 표현이 더 나은 지역성을 갖는다.



### 다대일과 다대다 관계

- ID를 사용하는 장점으로 ID 자체는 아무런 의미가 없기 때문에 변경할 필요가 없다.
- 중복된 데이터를 정규화하려면 다대일 관계가 필요한데 다대일 관계는 문서 모델에 적합하지 않다.
- 문서 데이터베이스는 조인에 대한 지원이 보통 약하다.



### 문서 데이터베이스는 역사를 반복하고 있나?

#### 네트워크 모델

#### 관계형 모델

#### 문서 데이터베이스와의 비교

### 관계형 데이터베이스와 오늘날의 문서 데이터베이스

- 관계형 데이터베이스와 문서 데이터베이스의를 비교하는 경우 내결함성과 동시성 처리를 포함해 고려해야 할 차이점이 많이 있다.
- **문서 데이터 모델을 선호하는 주요 이유는 스키마 유연성, 지역성에 기인한 더 나은 성능이다**
- **관계형 모델은 조인, 다대일, 다대다 관계를 더 잘 지원함으로써 문서 데이터 모델에 대항한다.**

#### 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?

- 애플리케이션에서 데이터가 문서와 비슷한 구조라면 문서 모델을 사용하는 것이 좋다 (일대다 관계 트리로 보통 한 번에 전체 트리를 적재)
- 문서 모델은 중첩 항목을 바로 참조할 수 없어서 계층별로 탐색해야 하지만 문서가 너무 깊게 중첩되지 않으면 일반적으로 문제가 되지는 않는다.
- 애플리케이션에서 다대다 관계를 사용한다면 문서 모델은 매력이 떨어지게 된다.
- 일반적으로 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 만드는지 말할 수 없다. 데이터 항목 간에 존재하는 관계 유형에 따라 다르다.
- 상호 연결이 많은 데이터의 경우 문서 모델은 곤란하고 관계형 모델은 무난하다.

#### 문서 모델에서의 스키마 유연성

- 대부분의 문서 데이터베이스와 관계형 데이터베이스에서 지원하는 JSON은 문서의 데이터에 어떤 스키마를 강요하지는 않는다.
- 스키마가 없다는 뜻은 임의 키와 값을 문서에 추가할 수 있고 읽을 때 클라이언트는 문서에 포함된 필드의 존재 여부를 보장하지 않는다는 의미다.
- 스키마리스 방식은 컬렉션 안의 항목이 어떤 이유로 모두 동일한 구조가 아닐 때 유리하다
- 이런 경우 스키마는 득보다 실이 많다.
  - 다른 여러 유형의 오브젝트가 있고 각 유형의 오브젝트별로 자체 테이블에 넣는 방법은 실용적이지 않다.
  - 사용자가 제어할 수 없고 언제나 변경 가능한 외부 시스템에 의해 데이터 구조가 결정된다.

#### 질의를 위한 데이터 지역성

- 한번에 많은 문서에 접근해야 할때 저장소 지역성을 활용하면 성능 이점이 있다.
- 지역성의 이점은 한 번에 해당 문서의 많은 부분을 필요로 하는 경우에만 적용된다.
- 데이터베이스는 문서의 작은 부분만 접근해도 전체 문서를 적재해야 하기 때문에 큰 문서는 낭비일 수 있고 이러한 이유로 일반적으로 문서의 크기를 아주 작게 유지하라고 권장한다.
- 지역성을 위해 데이터를 함꼐 그룹화하는 개념은 문서 모델에만 국한되지 않는다. 구글의 스패너 데이터베이스, 오라클의 다중 테이블 색인 클러스터 테이블, 빅테이블 데이터 모델의 칼럼 패밀리 개념(카산드라 Hbase)이 지역성 관리와 유사한 목적이 있다.



#### 문서 데이터베이스와 관계형 데이터베이스의 통합

- 많은 DBMS가 JSON 문서에 대한 지원 기능을 제공하고 있다.
- 관계형 데이터베이스와 문서 데이터베이스는 시간이 지남에 따라 점점 더 비슷해지고 있다.
- 관계형과 문서의 혼합 모델은 미래 데이터베이스들이 가야 할 올바른 길이다.



## 데이터를 위한 질의 언어

- 명령형 언어는 특정 순서로 특정 연산을 수행하게끔 컴퓨터에게 지시한다.
- SQL같은 선언형 질의 언어는 목표를 달성하기 위한 방법이 아니라 알고자 하는 데이터의 패턴, 즉 결과가 충족해야 하는 조건과 데이터를 어떻게 변환잘지를 지정하기만 하면 된다.
- 어떤 색인과 어떤 조인 함수를 사용할지, 질의의 다양한 부분을 어떤 순서로 실행할지를 결정하는 일은 데이터베이스 시스템의 질의 최적화기가 할 일이다.
- SQL이 기능적으로 더 제한적이라는 사실은 데이터베이스에게 자동으로 최적화할 수 있는 여지를 더 많이 준다는 의미다.
- 선언형 언어는 결과의 패턴만 지정하기 때문에 병렬 실행으로 더 빨라질 가능성이 크다.



### 웹에서의 선언형 질의

- 웹 브라우저에서 선언형 CSS 스타일을 사용하는 편이 자바스크립트에서 명령형으로 스타일을 다루기보다 훨씬 낫다.

### 맵리듀스 질의

- 맵리듀스는 많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델로 구글에 의해 널리 알려졌다.
- 몽고db와 카우치db를 포함한 일부 nosql 데이터 저장소는 제한된 형태의 맵리듀스를 지원한다.
- 주로 많은 문서를 대상으로 읽기 전용 질의를 수행할 때 사용한다. 자세한 내용은 10장에서

## 그래프형 데이터 모델

- 애플리케이션이 주로 일대다 관계이거나 레코드 간 관계가 없다면 문서 모델이 적합하다.
- 애플리케이션이 다대다 관계가 매우 일반적이라면 관계형 모델은 복잡해질 수 있으므로 그래프로 데이터를 모델링하기 시작히는 편이 더 자연스럽다.
- 그래프는 정점과 간선으로 이루어져있고 많은 유형의 데이터를 그래프로 모델링할 수 있다.
  - 소셜 그래프
    - 정점은 사람이고 간선은 사람들이 서로 알고 있음을 나타낸다.
  - 웹 그래프
    - 정점은 웹 페이지고 간선은 다른 페이지에 대한 HTML링크를 나타낸다.
  - 도로나 철도 네트워크
    - 정점은 교차로이고 간선은 교차로 간 도로나 철로 선을 나타낸다.



### 속성 그래프

- 속성 그래프 모델에서 각 정점은 다음과 같은 요소로 구성된다.
  - 고유한 식별자
  - 유출(outgoing) 간선 집합
  - 유입(incoming) 간선 집합
  - 속성 컬렉션(키-값 쌍)
- 각 간선은 다음과 같은 요소로 구성된다.
  - 고유한 식별자
  - 간선이 시작하는 정점(꼬리 정점)
  - 간선이 끝나는 정점(머리 정점)
  - 두 정점 간 관계 유형을 설명하는 레이블
  - 속성 컬렉션(키-값 쌍)
- 그래프는 발전성이 좋아서 애플리케이션에 기능을 추가하는 경우 애플리케이션의 데이터 구조르 변경을 수용하게끔 그래프를 쉽게 확장할 수 있다.

### 사이퍼 질의 언어

- 사이퍼는 속성 그래프를 위한 선언형 질의 언어로 neo4j 그래프 데이터베이스용으로 만들어졌다.

### SQL의 그래프 질의

### 트리플 저장소와 스파클

### 초석: 데이터 로그

## 정리

- 데이터 모델은 광범위한 주제다.
- 역사적으로 데이터를 하나의 큰 트리로 표현하려고 노력했지만 다대다 관계를 표현하게아는 트리구조가 적절하지 않았다.
- 최근 개발자들은 관계형 모델에도 적합하지 않은 애플리케이션이 있다는 사실을 발견했다
- 새롭게 등장한 비관계형 데이터저장소 NoSQL은 다음과 같은 두 가지 주요 갈래가 있다.
  1. 문서 데이터베이스는 데이터가 문서 자체에 포함돼 있으면서 하나의 문서와 다른 문서 간 관계가 거의 없는 사용 사례를 대상으로 한다.
  2. 그래프 데이터베이스는 문서 데이터베이스와는 정 반대로 모든 것이 잠재적으로 관련 있다는 사용 사례를 대상으로 한다.
- 문서, 관계형, 그래프 모두 각기 목적에 맞는 다양한 시스템을 보유해야 한다.
- 문서 및 그래프 데이터베이스가 가진 공통점 중 하나는 일반적으로 스키마를 강제하지 않아 변화하는 요구사항을 맞춰 애플리케이션을 쉽게 변경할 수 있다는 점이다. 
- 각 데이터 모델은 고유한 질의 언어나 프레임워크를 제공한다.





# #3 저장소와 검색

- 대개 애플리케이션 개발자가 처음부터 자신의 저장소 엔진을 구현하기 보다는 사용 가능한 여러 저장소 엔진 중에 애플리케이션에 적합한 엔진을 선택하는 작업이 필요하다.

## 데이터베이스를 강력하게 만드는 데이터 구조

- 데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 다른 데이터구조가 필요하다. 바로 색인이다.
- 색인의 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것이다.
- 이 메타데이터는 이정표 역하을 해서 원하는 데이터의 위치를 찾는 데 도움을 준다.
- 색인 작업은 데이터베이스의 내용에는 영향을 미치지 않고 단지 질의 성능에만 영향을 준다. 하지만 데이터를 쓸 떄마다 매번 색인도 갱신해야 하기 때문에 쓰기 속도를 느리게 만든다.
- 색인을 잘 선택했다면 읽기 질의 속도가 향상된다. 하지만 모든 색인은 쓰기 속도를 떨어트린다. 이것은 저장소 시스템에서 중요한 트레이드오프다.

### 해시 색인

- 키-값 저장소는 대부분의 프로그래밍 언어에서 볼 수 있는 dictionary 타입과 매우 유사하다.

- 비트캐스크는 해시 맵을 전부 메모리에 유지하기 떄문에 사용 가능한 램에 모든 키가 저장된다는 조건을 전제로 고성능 읽기, 쓰기를 보장한다.

- 비트캐스크 같은 저장소 엔진은 각 키의 값이 자주 갱신되는 상황에 매우 적합하다. (키당 쓰기 수가 많지만 메모리에 모든 키를 보관할 수 있는 경우)

- 하지만 실제로 구현하려면 파일 형식, 레코드 삭제, 고장 복구, 부분적으로 레코드 쓰기, 동시성 제어 등등 세부적으로 많은 사항을 고려해야 한다.

  

### SS테이블과 LSM 트리

#### SS테이블 생성과 유지

#### SS테이블에서 LSM 트리 만들기

#### 성능 최적화

### B 트리

- B트리는 70년대 등장했고 여전히 거의 대부분의 관계형 데이터베이스에서 표준 색인 구현으로 B 트리를 사용하고 NoSQL에서도 사용한다.
- 한 페이지는 B 트리의 루트로 지정되고 색인에서 키를 찾으려면 루트에서 시작한다.
- 범위를 계속 좁혀가면서 최종적으로 개별 키(리프 페이지)를 포함하는 페이지에 도달한다. 이 페이지는 각 키의 값을 포함하거나 값을 찾을 수 있는 페이지의 참조를 포함한다.
- 이 알고리즘은 트리가 계속 균형을 유지하는 것을 보장한다.
- n 개의 키를 가진 B 트리는 깊이가 항상 O(log n) 이다.

#### 신뢰할 수 있는 B 트리 만들기

- B트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어쓴다. 페이지를 덮어 쓰더라도 페이지를 가리키는 참조는 모두 온전하게 남는다.
- 데이터베이스가 고장 상황에서 스스로 복구할 수 있게 만들려면 일반적으로 디스크 상에 쓰기 전 로그(redo log)라고 하는 데이터 구조를 추가해 B 트리를 구현한다.
- 동시성 제어는 보통 래치로 트리의 데이터 구조를 보호한다.

#### B 트리 최적화

### B 트리와 LSM 트리 비교

- 경험적으로 LSM 트리는 보통 쓰기에서 더 빠르고 B 트리는 읽기에서 더 빠른다고 여긴다.

#### LSM 트리의 장점

#### LSM 트리의 단점

### 기타 색인 구조

#### 색인 안에 값 저장하기

- 색인에서 키는 질의가 검색하는 대상이지만 값은 실제로우거나 저장된 로우를 가르키는 참조다.
- 저장된 로우를 가르키는 경우 저장된 곳을 힙파일이라고 하고 특정 순서 없이 데이터를 저장한다.
- 힙 파일 접근 방식은 키를 변경하지 않고 값을 갱신할 때 효율적이다.
- 어떤 상황에서는 색인 안에 바로 색인된 로우를 저장하는 편이 바람직한데 이를 클러스터드 색인 이라고 한다. MySQL의 InnoDbB의 기본키는 언제나 클러스터드 색인이고 보조 색인은 기본키를 참조한다.
- 클러스터드 색인과 비클러스터드 색인 사이의 절충안을 커버링 색인이라고하고 이 색인은 색인 안에 테이블의 칼럼 일부를 저장하는 것이다.
- 클러스터드 색인과 커버링 색인은 읽기 성능을 높일 수 있지만 추가적인 저장소가 필요하고 쓰기 과정에 오버헤드가 발생한다.

#### 다중 칼럼 색인

- 다차원 색인은 한 번에 여러 칼럼에 질의하는 조금 더 일반적인 방법이다.
- 특히 지리 공간 데이터에 중요하게 사용된다.

#### 전문 검색과 퍼지 색인

- 위에서 설명한 색인으로는 철자가 틀린 단어와 같이 유사한 키에 대해서는 검색을 할 수 없다.
- 전문 검색 엔진은 일반적으로 특정 단어를 검색할 때 해당 단어의 동의어로 질의를 확장한다.

#### 모든 것을 메모리에 보관

- 인메모리 데이터베이스가 재시작 되는 경우 특수 하드웨어를 사용하지 않는다면 디스크나 네트워크를 통해 복제본에서 상태를 다시 적재해야 한다.

## 트랜잭션 처리나 분석?

- 애플리케이션은 색인을 사용해 일부 키에 대한 적은 수의 레코드를 찾고 레코드는 사용자 입력을 기반으로 삽입되거나 갱신된다. 이런 접근 패턴을 온라인 트랜잭션 처리 (Online Transcation Processiong. OLTP) 라고 한다.
- 데이터베이스는 데이터 분석에도 점점 더 많이 사용하기 시작했다. 이런 데이터베이스의 사용 패턴을 트랜잭션 처리와 구별하기 위해 온라인 분석 처리(Online Analytic Processing. OLAP) 라고 한다.
- 초기에는 트랜잭션 처리와 분석 질의를 위해 동일한 데이터베이스를 사용했지만 시스템 분석 목적으로 사용하는 개별 데이터베이스를 사용했다 이것을 데이터 웨어하우스라고 부른다.

### 데이터 웨어하우징

- 트랜잭션이 필요한 사업은 일반적으로 높은 가용성과 낮은 지연 시간의 트랜잭션 처리를 기대한다. 하지만 분석질의는 비용이 높기 때문에 실행되는 트랜잭션의 성능을 저하시킬 가능성이 있다.
- 데이터 웨어하우스는 분석가들이 트랜잭션 작업에 영향을 주지 않고 마음껏 질의할 수 있는 개별 데이터베이스다.
- 데이터 웨어하우스는 회사 내의 모든 다양한 트랜잭션 사업 시스템에 있는 데이터의 읽기 전용 복사본이다.
- 데이터는 OLTP 데이터베이스에서 추출하고 분석 친화적인 스키마로 변환하고 정제된 데이터를 데이터 웨어하우스에 적재한다.
- 데이터 웨어하우스로 데이터를 가져오는 과정을 ELT(Extract Transform Load) 라고 한다.

#### OLTP 데이터베이스와 데이터 웨어하우스의 차이점

- SQL은 일반적으로 분석 질의에 적합하기 때문에 데이터 웨어하우스의 데이터 모델은 가장 일반저인 관계형 모델을 사용한다.
- OLAP와 OLTP 모두 SQL 질의 인터페이스를 지원하기 떄문에 비슷해보이지만 각각 매우 다른 질의 패턴에 맞체 괴적화 됐기 때문에 이제 다수의 데이터베이스 벤더는 트랜잭션 처리와 분석 작업부하 양쪽 모두 지원하기 보다는 둘 중 하나를 지원하는데 중점을 둔다.

### 분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마

- 분석에서는 데이터 모델의 다양성이 트랜잭션 처리영역보다 훨씬 적다.
- 많은 데이터 웨어하우스는 별 모양 스키마로 알려진 상당히 정형화된 방식을 사용한다.
- 스키마 중심에는 fact table이 있다.
- 이 fact table은 개별 이벤트를 담는다. ex 웹 페이지 뷰, 사용자 클릭 등등
- 별 모양 스키마인 이유는 사실 테이블이 중심에 있고 여러 테이블로 둘러싸고 있다는 사실에서 비롯됐다. 이 템플릿의 변형으로 눈꽃송이 모양 스키마도 있다.
- 일반적인 데이터 웨어하우스에서 테이블의 보통 폭이 매우 높다 100개 이상의 칼럼 + @ 

## 칼럼 지향 저장소

- 사실 테이블은 칼럼이 보통 100개 이상이지만 일반적인 데이터 웨어하우스 질의는 한 번에 4개 또는 5개 칼럼만 접근한다.
- 칼럼 지향 저장소의 기본개념은 모든 값을 하나의 로우에 함께 저장하지 않는 대신 각 칼럼별로 모든 값을 함께 저장한다.
- 각 칼럼을 개별 파일에 저장하면 질의에 사용되는 칼럼만 읽고 구분 분석하면 된다.
- 이 방식을 사용하면 작업량이 많이 줄어든다.

### 칼럼 압축

- 질의에 필요한 칼럼을 디스크에서 읽어 적재하는 작업 외에도 데이터를 압축하면 디스크 처리량을 더 줄일 수 있다.
- 칼럼 지향 저장소는 대개 압축에 적합하다.
- 각 칼럼의 값에 많은 값이 반복되면 압축에 매우 좋다.
- 데이터웨어하우스에서는 비트맵 부호화를 사용해서 압축을 시도한다.
- 보통 칼럼의 고유 값의 수는 로우 수의 비해 적기때문에 n개의 고유 값을 가진 칼럼을 가져와 n개의 개별 비트맵으로 변환할 수 있다.



#### 메모리 대역폭과 벡터화 처리

- 수백만 로우를 스캔해야 하는 데이터 웨어하우스 질의는 디스크로부터 메모리로 데이터를 가져오는 대역폭이 큰 병목이다.
- 이 병목 외에도 분석용 데이터베이스 개발자는 메인 메모리에서 CPU 캐시로 가는 대역폭을 효육적으로 사용하고 CPU 명령 처리 파이프라인에서 분기 예측 실패와 버블을 피하며 최신 CPU에서 단일 명령 다중 데이터 명령을 신중하게끔 신경써야 한다.

### 칼럼 저장소의 순서 정렬

#### 다양한 순서 정렬

### 칼럼지향 저장소에 쓰기

- 칼럼 지향 저장소, 압축, 정렬은 모두 읽기 질의를 더 빠르게 하지만 쓰기를 어렵게 한다는 단점이 있다.
- B트리 같은 제자리 갱신 접근 상식은 압축된 칼럼에서 사용이 불가능하다.
- LSM 트리처럼 모든 쓰기는 먼저 인메모리 저장소로 이동해 정렬된 구조에 추가하고 디스크에 쓸 준비를 한다. 충분한 쓰기를 모으면 디스크의 칼럼 파일에 병합하고 대량으로 새로운 파일에 기록한다.

### 집계: 데이터 큐브와 구체화 뷰

## 정리

- 고수준에서 저장소 엔진은 트랜잭션 처리 최적화(OLTP)와 분석 최적화(OLAP)라는 큰 두가지 범주로 나눈다.

`OLTP 시스템`

- 사용자 대면이기 떄문에 대량의 요청을 받을 수 있다.
- 부하를 처리하기 위해 보통 애플리케이션이 각 질의마다 작은 수의 레코드만 다룬다.
- 애플리케이션은 키의 일부만 사용하는 레코드를 요청하고 저장소 엔진은 요청한 키의 데이터를 찾기 위해 색인을 사용한다.
- 이 경우는 대개 디스크 탐색이 병목이다.

`데이터 웨어하우스와 유사한 분석 시스템 (OLAP)`

- 최종 사용자가 아닌 비즈니스 분석가가 주로 사용하기 때문에 덜 알려져 있다.
- OLTP 시스템보다 훨씬 더 적은 수의 질의를 다루지만 각 질의는 대개 매우 다루기 어렵고 짧은 시간에 수백만 개의 레코드를 스킨해야 한다.
- 이 경우 일반적으로 디스크 대역폭이 병목이다.
- 칼럼 지향 저장소는 이런 종류의 작업부하를 처리할 때 사용 가능한 날로 인기가 높아지고 있는 솔루션이다.

`OLTP 측면에서 두 가지 주요한 관점`

- 로그 구조화 관점에서 파일에 추가와 오래된 파일의 삭제만 허용하고 한 번 쓰여진 파일은 절대 갱신하지 않는다. 비트캐스크, SS테이블, LSM트리, 카산드라, Hbase, 루씬 등이 이 그룹에 속한다
- 제자리 갱신 관점에서 덮어쓰기 할 수 있는 고정 크기 페이지의 셋으로 디스크를 다룬다. 이 관점에서 가장 큰 예가 B트리다. B트리는 주요 관계형 데이터베이스와 많은 비정형 데이터베이스에서도 사용한다.

