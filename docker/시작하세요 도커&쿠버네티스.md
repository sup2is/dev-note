

github : https://github.com/alicek106/start-docker-kubernetes







# #1 도커란?

- 도커는 리눅스 컨테이너에 여러 기능을 추가함으로써 어플리케이션을 컨테이너로서 더 쉽게 사용할 수 있게 마늘어진 오픈소스 프로젝트
- 도커는 Go언어로 작성됨
- 도커의 생태계에 있는 여러 프로젝트들은 도커 엔진을 좀 더 효율적으로 사용하기 위한 것에 불과하기 때문에 핵짐이 되는 것은 도커 엔진임





## 가상 머신과 도커 컨테이너

- 기존에는 가상화 기술을 사용한 대표적인 VMware, VirtualBox 등의 Guest OS 기반으로 운영체제를 관리했는데 이런식의 방버은 비효율 적인 면이 많음 (성능, 이미지 크기 등등)
- 도커 컨테이너는 가상화된 공간을 생성하기 위해 리눅스의 자체 기능인 chroot, 네임스페이스, cgroup을 사용함으로써 프로세스 단위의 격리 환경을 만들기 때문에 성능 손실이 거의 없음.
- 도커 컨테이너는 어플리케이션에 구동에 필요한 라이브러리, 실행 파일만 갖기 때문에 경량임



## 도커를 시작해야 하는 이유



### 어플리케이션의 개발과 배포가 편해짐

- 서버를 부팅할때 실행되는 운영체제를 일반적으로 Host OS라 부름 도커 컨테이너는 호스트 OS 위에서 실행되는 격리된 공간
- 컨테이너 내부에서 수많은 설정과 설치를 해도 Host OS 에는 영향이 없음
- 컨테이너의 복제가 가능하기 때문에 개발/운영 환경의 통합이 가능함



### 여러 어플리케이션의 독립성과 확장성이 높아짐

- 도커는 마이크로서비스에 특화된 가상화 기술임
- 각 서비스별로 컨테이너를 분리하고 웹서비스에서 부하를 줄여야할 경우 수평적 확장이 손쉽게 가능함



### 리눅스 도커 엔진 설치시 확인사항

1. **최신 버전 커늘을 사용하고 있는지 확인:** 호스트 운영체제가 최소한 3.10 버전을 사용해야 도커 컨테이너를 정상적으로 사용 가능 
2. **지원 기간 내에 있는 배포판인지 확인:** 일부 오래된 리눅스 배포판은 업데이트 등의 지원을 받지 못할 수 있음.
3. **64비트 리눅스인지 확인:** 도커는 64비트에 최적화되어 있음
4. **sudo 명령어를 통해 설치하거나 root 권한을 소유한 계정에서 설치**



### 우분투16.04 도커 설치 스크립트

```
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo apt-get update
sudo apt-get install docker-ce
```



# #2 도커 엔진 





## 도커 이미지

- 이미지는 컨테이너를 생성할 때 필요한 요소 가상머신에서 .iso 파일과 비슷한 개념
- 도커에서 사용하는 이미지 이름은 근 기본적으로 [저장소 이름]/[이미지 이름]:[태그]의 형태로 구성
  - 저장소 이름은 이미지가 저장된 장소를 의미. 저장소 이름이 명시되지 않은 이미지는 도커 허브의 공식 이미지임
  - 이미지 이름은 해당 이미지가 어떤 역할을 하는지 나타냄 생략 불가
  - 태그는 버전관리, 리비전 관리에 사용 생략한다면 latest로 인식



## 도커 컨테이너

- 도커 컨테이너는 읽기 전용으로 사용하되 만약 컨테이너 내부에 변경이 있다고해도 이미지에 전혀 영향을 주지 않음
- 컨테이너 별로 독립된 공간에서 실행되기때문에 다른 컨테이너나 Host OS에 전혀 영향이 없음



### 컨테이너 실행하기



- `docker run`: docker pull -> docker create -> docker start -> docker attach (-it 옵션 사용시)

- `docker create`: docker pull -> docker create
- `docker ps`: 도커 프로세스 정보
  - **CONTAINER ID:** 컨테이너에게 자동으로 할당된 고유 ID 식별만 가능하다면 짧게 사용해도 되고 **docker inspect**를 사용하여 전체 컨테이너 아이디 조회 가능
  - **IMAGE:** 컨테이너를 생성할 때 사용된 이미지의 이름
  - **COMMAND:** 커맨드는 컨테이너가 시작될 때 실행될 명령어 커맨드는 대부분 이미지에 미리 내장되어 있음 ex: /bin/bash
  - **CREATE:** 컨테이너가 생성되고 난 뒤 흐른 시간
  - **STATUS:** 컨테이너의 상태 실행중일때 UP 종료된 상태일때 EXITED 일시중지 PAUSE 등등
  - **PORTS:** 컨테이너가 개방한 포트와 호스트에 연결한 포트를 나열
  - **NAMES:**컨테이너의 고유한 이름 **--name** 옵션으로 이름을 설정하지 않으면 도커 엔진이 임의로 형용사와 명사를 무작위로 조합해 이름을 설정함 **docker rename**으로 이름 변경 가능



### 컨테이너 삭제하기



- `docker rm`: 실행중이지 않을때만 가능
- `docker rm -f`: 실행중인 컨테이너도 삭제
- `docker container prune`: docker 컨테이너 전부 삭제



### 컨테이너 외부에 노출하기

- `docker run -i -t -p 80:80` : -p 옵션으로 포트매핑 [호스트]:[컨테이너] 여러개 가능



### 컨테이너 어플리케이션 구축

- 대부분의 서비스는 여러개의 단일 서비스가 연결되어 완전한 서비스로 동작하는 것이 일반적임
- 데이터베이스와 웹서버를 하나의 컨테이너의 구축하지 않고 각각 개별적인 컨테이너로 구축
- 한 컨테이너에는 프로세스 하나만 실행하는 것이 도커의 철학



```
 sudo docker run -d --name wordpressdb -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=wordpress mysql:5.7
```



```
sudo docker run -d -e WORDPRESS_DB_PASSWORD=password --name wordpress --link wordpressdb:mysql -p 80 wordpress
```



- -d 옵션으로 백그라운드 모드 실행
- -it 옵션으로 표준 입출력이 활성화된, 상호작용이 가능한 셀 환경을 사용
- -d 옵션으로 run을 실행하면 입출력이 없는 상태로 컨테이너를 실행함. 컨테이너 내부에서 프로그램이 터미널을 차지하는 포그라운드로 실행돼 사용자의 입력을 받지 않음. Detached 모드인 컨테이너는 반드시 컨테이너에서 프로그램이 실행되어야 하며, 포그라운드 프로그램이 실행되지 않으면 컨테이너는 종료됨 예를 들어 docker run -d -name detach_test ubunth:14 는 실행 즉시 stop된 상태가 됨
- 하나의 터미널을 차지하는 mysqld 프로그램이 -it 옵션으로 포그라운드 상태가 되면 mysql 이미지는 컨테이너가 시작될 때 mysqld가 동작하도록 설정됨. 이 상태에서는 상호 입출력이 불가능하고 단순히 프로그램이 포그라운드 모드로 동작하는 것만 지켜볼 수 있음 mysql은 -d로 올려야함
- -e 옵션으로 컨테이너 내부의 환경변수 설정
- --link를 이용해 alias 설정으로 컨테이너를 연결 가능하지만 deprecated됨 도커 브릿지를 사용하도록 !
- mysql 처럼 detach 모드에서 쉘환경을 실행하고 싶다면 exec 명령어를 사용 만약 명령어를 1회만 쓸 경우 -it 옵션은 없어도 됨

```
docker exec -it wordpressdb /bin/bash
```



### 도커 볼륨

- 도커 이미지로 컨테이너를 생성하면 이미지는 읽기 전용이 되며 컨테이너의 변경 사항만 별도로 저장해서 각 컨테이너의 정보를 보존함
- 이런 정보들은 컨테이너 삭제시 영구적으로 삭제되는데 도커 볼륨을 사용해서 손쉽게 데이터를 영속화시킬 수 있음
- 볼륨은 호스트와 볼륨을 공유할 수 있고 볼륨 컨테이너를 활용, 도커가 관리하는 볼륨을 생성하는 방법이 있음



#### 호스트 볼륨 공유

```
docker run -d \
--name wordpressdb_hostvolume \
-e MYSQL_ROOT_PASSWORD=password \
-e MYSQL_DATABASE=wordpress \
-v /home/wordpress_db:/var/lib/mysql \
mysql:5.7

```

- 위처럼 -v 옵션을 사용해서 도커 컨테이너와 호스트볼륨을 연결 가능 이것은 동기화가 아니라 완전히 같은 디렉토리가됨
- -v 옵션은 호스트의 디렉토리를 컨테이너 디렉토리에 마운트함

```
docker run -d \
-e WORDPRESS_DB_PASSWORD=password \
--name wordpress_hostvolume \
--link wordpressdb_hostvolume:mysql \
-p 80 \
wordpress

```



#### 볼륨 컨테이너

#### 도커 볼륨

- `docker volume create --name myvolume` 명령어로 생성 
- `docker volume ls` 로 볼륨 확인
- 컨테이너 생성시 -v [볼륨이름]:[컨테이너의 공유 디렉터리] 로 생성해야함



```
sudo docker run -i -t --name myv2 -v myvolume:/root/ ubuntu:14.04
```

- docker inspect로 컨테이너, 이미지, 볼륨 등 도커의 모든 구성단위의 정보를 확인 때 사용 할 수 있음



```
docker inspect --type volume myv
[
    {
        "CreatedAt": "2020-04-28T06:01:36Z",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/myv/_data",
        "Name": "myv",
        "Options": {},
        "Scope": "local"
    }
]

```

- Driver는 볼륨이 쓰는 드라이버를, Label은 볼륨을 구분하는 라벨, Mountpoint는 해당 볼륨이 실제로 호스트의 어디에 저장됐는지를 의미함 사용자 입장에서 알 필요는 없음
- docker volume create 명령을 별도로 입력하지 않아도 -v 옵션만 있으면 알아서 생성함 생성된 컨테이너가 생성된 볼륨을 사용하는 지확인하는 방법은 docker container inspect임
- docker volume prune을 사용해서 모든 볼륨삭제도 가능함
- 이처럼 컨테이너가 아닌 외부에 데이터를 저장하고 컨테이너는 그 데이터로 동작하도록 설계하는 것을 스테이트리스 하다고 말함 컨테이너 자체는 상태가 없고 상태를 결정하는 데이터는 외보로부터 제공받음 이런 설계는 올바른 설계임
- -v 와 비슷한 명령어로 --mount 도 있지만 생략함



### 도커 네트워크

- 도커는 각 컨테이너에 외부와의 네트워크를 제공하기 위해 컨테이너마다 가상 네트워크 인터페이스를 호스트에 생성하며 이 인터페이스의 이름은 veth로 시작
- veth로 시작하는 인터페이스는 컨테이너를 시작할 때 생성되며 각 컨테이너의 eth0과 연결되어 있음
- veth 인터페이스뿐 아니라 docker0이라는 브릿지도 존재하는데 docker0 브릿지는 각 veth 인터페이스와 바인딩돼 호스트의 eth0 인터페이스와 이어주는 역할을 함
- 연결 구조 -> 도커 컨테이너 eth0 -> 호스트 veth .. -> 호스트 docker0 브릿지 -> 호스트 eth0
- 컨테이너를 생성하면 기본적으로 docker0 브리지를 통해 외부와 통신할 수 있는 환경을 사용할 수 있지만 사용자의 선택에 따라 여러 네트워크 드라이버를 쓸 수 있음
- 도커가 자체적으로 제공하는 대표적인 네트워크 드라이버로는 브릿지, 호스트, 노누, 컨테이너, 오버리에가 있음
- `docker network` 명령어를 통해 확인
- `docker network inspect` 명령어를 통해 네트워크의 자세한 정보 확인 가능

```
sudo docker network create --driver bridge mybridge
```

- 위 명령어로 브릿지도 생성 가능
- 이런식으로 생성된 브릿지는 docker run --net 옵션으로 적용 가능함

```
sudo docker run -it --name mynet --net mybridge ubuntu
```



**호스트 네트워크**

```
sudo docker run -it --name mynet --net host ubuntu
```

- 호스트 머신에서 설정한 호스트 이름도 컨테이너가 물려받기 때문에 컨테이너의 호스트 이름도 무작위 16진수가 아닌 도커 엔진이 설치된 호스트 머신의 호스트 이름으로 설정됨
- 컨테이너의 네트워크를 호스트 모드로 설정하면 컨테이너 내부의 어플리케이션을 별도의 포트포워딩 없이 바로 서비스할 수 있음

**논 네트워크**

```
sudo docker run -it --name mynet --net none ubuntu
```

- 아무런 네트워크를 사용하지 않고 외부외 단절됨

**컨테이너 네트워크**

```
sudo docker run -it --name mynet --net container:[컨테이너이름] ubuntu
```

- 공유되는 속성은 내부 ip 네트워크 인터페이스의 맥 주소 등임
- 이런식으로 컨테이너 네트워크를 사용할 경우 호스트에 veth로 시작하는 가상 네트워크 인터페이스도 생성되지 않음. 완전히 같은 네트워크 정보를 사용함

**브리지 네트워크와 --net-alias**

- 브리지타입의 네트워크와 run 명령어의 --net-alias 옵션을 함께 쓰면 특정 호스트 이름으로 컨테이너 여러개에 접근 가능
- 도커는 기본 브릿지 네트워크가 아닌 사용자가 정의한 브릿지 네트워크에 사용되는 내장 dns 서버를 가지며 dns의 ip는 127.0.0.11임

**MacVLAN 네트워크**

- MacVLAN은 호스트으 네트워크 인터페이스 카드를 가상화해 물리 네트워크 환경을 컨테이너에게 동일하게 제공함
- MacVLAN을 사용하면 컨테이너는 물리 네트워크 상에서 가상의 맥 주소를 가지며 해당 네트워크에 연결된 다른 장치와의 통신이 가능해짐
- 나머지 설정은 책 보는거 추천 ...



## 컨테이너 로깅

### json-file 로그 사용하기

- `docker logs` 명령어로 컨테이너 내부 출력을 확인 가능함







