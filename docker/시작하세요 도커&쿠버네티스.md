

github : https://github.com/alicek106/start-docker-kubernetes







# #1 도커란?

- 도커는 리눅스 컨테이너에 여러 기능을 추가함으로써 어플리케이션을 컨테이너로서 더 쉽게 사용할 수 있게 마늘어진 오픈소스 프로젝트
- 도커는 Go언어로 작성됨
- 도커의 생태계에 있는 여러 프로젝트들은 도커 엔진을 좀 더 효율적으로 사용하기 위한 것에 불과하기 때문에 핵짐이 되는 것은 도커 엔진임





## 가상 머신과 도커 컨테이너

- 기존에는 가상화 기술을 사용한 대표적인 VMware, VirtualBox 등의 Guest OS 기반으로 운영체제를 관리했는데 이런식의 방버은 비효율 적인 면이 많음 (성능, 이미지 크기 등등)
- 도커 컨테이너는 가상화된 공간을 생성하기 위해 리눅스의 자체 기능인 chroot, 네임스페이스, cgroup을 사용함으로써 프로세스 단위의 격리 환경을 만들기 때문에 성능 손실이 거의 없음.
- 도커 컨테이너는 어플리케이션에 구동에 필요한 라이브러리, 실행 파일만 갖기 때문에 경량임



## 도커를 시작해야 하는 이유



### 어플리케이션의 개발과 배포가 편해짐

- 서버를 부팅할때 실행되는 운영체제를 일반적으로 Host OS라 부름 도커 컨테이너는 호스트 OS 위에서 실행되는 격리된 공간
- 컨테이너 내부에서 수많은 설정과 설치를 해도 Host OS 에는 영향이 없음
- 컨테이너의 복제가 가능하기 때문에 개발/운영 환경의 통합이 가능함



### 여러 어플리케이션의 독립성과 확장성이 높아짐

- 도커는 마이크로서비스에 특화된 가상화 기술임
- 각 서비스별로 컨테이너를 분리하고 웹서비스에서 부하를 줄여야할 경우 수평적 확장이 손쉽게 가능함



### 리눅스 도커 엔진 설치시 확인사항

1. **최신 버전 커늘을 사용하고 있는지 확인:** 호스트 운영체제가 최소한 3.10 버전을 사용해야 도커 컨테이너를 정상적으로 사용 가능 
2. **지원 기간 내에 있는 배포판인지 확인:** 일부 오래된 리눅스 배포판은 업데이트 등의 지원을 받지 못할 수 있음.
3. **64비트 리눅스인지 확인:** 도커는 64비트에 최적화되어 있음
4. **sudo 명령어를 통해 설치하거나 root 권한을 소유한 계정에서 설치**



### 우분투16.04 도커 설치 스크립트

```
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
sudo apt-get update
sudo apt-get install docker-ce
```



# #2 도커 엔진 





## 도커 이미지

- 이미지는 컨테이너를 생성할 때 필요한 요소 가상머신에서 .iso 파일과 비슷한 개념
- 도커에서 사용하는 이미지 이름은 근 기본적으로 [저장소 이름]/[이미지 이름]:[태그]의 형태로 구성
  - 저장소 이름은 이미지가 저장된 장소를 의미. 저장소 이름이 명시되지 않은 이미지는 도커 허브의 공식 이미지임
  - 이미지 이름은 해당 이미지가 어떤 역할을 하는지 나타냄 생략 불가
  - 태그는 버전관리, 리비전 관리에 사용 생략한다면 latest로 인식



## 도커 컨테이너

- 도커 컨테이너는 읽기 전용으로 사용하되 만약 컨테이너 내부에 변경이 있다고해도 이미지에 전혀 영향을 주지 않음
- 컨테이너 별로 독립된 공간에서 실행되기때문에 다른 컨테이너나 Host OS에 전혀 영향이 없음



### 컨테이너 실행하기



- `docker run`: docker pull -> docker create -> docker start -> docker attach (-it 옵션 사용시)

- `docker create`: docker pull -> docker create
- `docker ps`: 도커 프로세스 정보
  - **CONTAINER ID:** 컨테이너에게 자동으로 할당된 고유 ID 식별만 가능하다면 짧게 사용해도 되고 **docker inspect**를 사용하여 전체 컨테이너 아이디 조회 가능
  - **IMAGE:** 컨테이너를 생성할 때 사용된 이미지의 이름
  - **COMMAND:** 커맨드는 컨테이너가 시작될 때 실행될 명령어 커맨드는 대부분 이미지에 미리 내장되어 있음 ex: /bin/bash
  - **CREATE:** 컨테이너가 생성되고 난 뒤 흐른 시간
  - **STATUS:** 컨테이너의 상태 실행중일때 UP 종료된 상태일때 EXITED 일시중지 PAUSE 등등
  - **PORTS:** 컨테이너가 개방한 포트와 호스트에 연결한 포트를 나열
  - **NAMES:**컨테이너의 고유한 이름 **--name** 옵션으로 이름을 설정하지 않으면 도커 엔진이 임의로 형용사와 명사를 무작위로 조합해 이름을 설정함 **docker rename**으로 이름 변경 가능



### 컨테이너 삭제하기



- `docker rm`: 실행중이지 않을때만 가능
- `docker rm -f`: 실행중인 컨테이너도 삭제
- `docker container prune`: docker 컨테이너 전부 삭제



### 컨테이너 외부에 노출하기

- `docker run -i -t -p 80:80` : -p 옵션으로 포트매핑 [호스트]:[컨테이너] 여러개 가능



### 컨테이너 어플리케이션 구축

- 대부분의 서비스는 여러개의 단일 서비스가 연결되어 완전한 서비스로 동작하는 것이 일반적임
- 데이터베이스와 웹서버를 하나의 컨테이너의 구축하지 않고 각각 개별적인 컨테이너로 구축
- 한 컨테이너에는 프로세스 하나만 실행하는 것이 도커의 철학



```
 sudo docker run -d --name wordpressdb -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=wordpress mysql:5.7
```



```
sudo docker run -d -e WORDPRESS_DB_PASSWORD=password --name wordpress --link wordpressdb:mysql -p 80 wordpress
```



- -d 옵션으로 백그라운드 모드 실행
- -it 옵션으로 표준 입출력이 활성화된, 상호작용이 가능한 셀 환경을 사용
- -d 옵션으로 run을 실행하면 입출력이 없는 상태로 컨테이너를 실행함. 컨테이너 내부에서 프로그램이 터미널을 차지하는 포그라운드로 실행돼 사용자의 입력을 받지 않음. Detached 모드인 컨테이너는 반드시 컨테이너에서 프로그램이 실행되어야 하며, 포그라운드 프로그램이 실행되지 않으면 컨테이너는 종료됨 예를 들어 docker run -d -name detach_test ubunth:14 는 실행 즉시 stop된 상태가 됨
- 하나의 터미널을 차지하는 mysqld 프로그램이 -it 옵션으로 포그라운드 상태가 되면 mysql 이미지는 컨테이너가 시작될 때 mysqld가 동작하도록 설정됨. 이 상태에서는 상호 입출력이 불가능하고 단순히 프로그램이 포그라운드 모드로 동작하는 것만 지켜볼 수 있음 mysql은 -d로 올려야함
- -e 옵션으로 컨테이너 내부의 환경변수 설정
- --link를 이용해 alias 설정으로 컨테이너를 연결 가능하지만 deprecated됨 도커 브릿지를 사용하도록 !
- mysql 처럼 detach 모드에서 쉘환경을 실행하고 싶다면 exec 명령어를 사용 만약 명령어를 1회만 쓸 경우 -it 옵션은 없어도 됨

```
docker exec -it wordpressdb /bin/bash
```



### 도커 볼륨

- 도커 이미지로 컨테이너를 생성하면 이미지는 읽기 전용이 되며 컨테이너의 변경 사항만 별도로 저장해서 각 컨테이너의 정보를 보존함
- 이런 정보들은 컨테이너 삭제시 영구적으로 삭제되는데 도커 볼륨을 사용해서 손쉽게 데이터를 영속화시킬 수 있음
- 볼륨은 호스트와 볼륨을 공유할 수 있고 볼륨 컨테이너를 활용, 도커가 관리하는 볼륨을 생성하는 방법이 있음



#### 호스트 볼륨 공유

```
docker run -d \
--name wordpressdb_hostvolume \
-e MYSQL_ROOT_PASSWORD=password \
-e MYSQL_DATABASE=wordpress \
-v /home/wordpress_db:/var/lib/mysql \
mysql:5.7

```

- 위처럼 -v 옵션을 사용해서 도커 컨테이너와 호스트볼륨을 연결 가능 이것은 동기화가 아니라 완전히 같은 디렉토리가됨
- -v 옵션은 호스트의 디렉토리를 컨테이너 디렉토리에 마운트함

```
docker run -d \
-e WORDPRESS_DB_PASSWORD=password \
--name wordpress_hostvolume \
--link wordpressdb_hostvolume:mysql \
-p 80 \
wordpress

```



#### 볼륨 컨테이너

#### 도커 볼륨

- `docker volume create --name myvolume` 명령어로 생성 
- `docker volume ls` 로 볼륨 확인
- 컨테이너 생성시 -v [볼륨이름]:[컨테이너의 공유 디렉터리] 로 생성해야함



```
sudo docker run -i -t --name myv2 -v myvolume:/root/ ubuntu:14.04
```

- docker inspect로 컨테이너, 이미지, 볼륨 등 도커의 모든 구성단위의 정보를 확인 때 사용 할 수 있음



```
docker inspect --type volume myv
[
    {
        "CreatedAt": "2020-04-28T06:01:36Z",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/myv/_data",
        "Name": "myv",
        "Options": {},
        "Scope": "local"
    }
]

```

- Driver는 볼륨이 쓰는 드라이버를, Label은 볼륨을 구분하는 라벨, Mountpoint는 해당 볼륨이 실제로 호스트의 어디에 저장됐는지를 의미함 사용자 입장에서 알 필요는 없음
- docker volume create 명령을 별도로 입력하지 않아도 -v 옵션만 있으면 알아서 생성함 생성된 컨테이너가 생성된 볼륨을 사용하는 지확인하는 방법은 docker container inspect임
- docker volume prune을 사용해서 모든 볼륨삭제도 가능함
- 이처럼 컨테이너가 아닌 외부에 데이터를 저장하고 컨테이너는 그 데이터로 동작하도록 설계하는 것을 스테이트리스 하다고 말함 컨테이너 자체는 상태가 없고 상태를 결정하는 데이터는 외보로부터 제공받음 이런 설계는 올바른 설계임
- -v 와 비슷한 명령어로 --mount 도 있지만 생략함



### 도커 네트워크

- 도커는 각 컨테이너에 외부와의 네트워크를 제공하기 위해 컨테이너마다 가상 네트워크 인터페이스를 호스트에 생성하며 이 인터페이스의 이름은 veth로 시작
- veth로 시작하는 인터페이스는 컨테이너를 시작할 때 생성되며 각 컨테이너의 eth0과 연결되어 있음
- veth 인터페이스뿐 아니라 docker0이라는 브릿지도 존재하는데 docker0 브릿지는 각 veth 인터페이스와 바인딩돼 호스트의 eth0 인터페이스와 이어주는 역할을 함
- 연결 구조 -> 도커 컨테이너 eth0 -> 호스트 veth .. -> 호스트 docker0 브릿지 -> 호스트 eth0
- 컨테이너를 생성하면 기본적으로 docker0 브리지를 통해 외부와 통신할 수 있는 환경을 사용할 수 있지만 사용자의 선택에 따라 여러 네트워크 드라이버를 쓸 수 있음
- 도커가 자체적으로 제공하는 대표적인 네트워크 드라이버로는 브릿지, 호스트, 노누, 컨테이너, 오버리에가 있음
- `docker network` 명령어를 통해 확인
- `docker network inspect` 명령어를 통해 네트워크의 자세한 정보 확인 가능

```
sudo docker network create --driver bridge mybridge
```

- 위 명령어로 브릿지도 생성 가능
- 이런식으로 생성된 브릿지는 docker run --net 옵션으로 적용 가능함

```
sudo docker run -it --name mynet --net mybridge ubuntu
```



**호스트 네트워크**

```
sudo docker run -it --name mynet --net host ubuntu
```

- 호스트 머신에서 설정한 호스트 이름도 컨테이너가 물려받기 때문에 컨테이너의 호스트 이름도 무작위 16진수가 아닌 도커 엔진이 설치된 호스트 머신의 호스트 이름으로 설정됨
- 컨테이너의 네트워크를 호스트 모드로 설정하면 컨테이너 내부의 어플리케이션을 별도의 포트포워딩 없이 바로 서비스할 수 있음

**논 네트워크**

```
sudo docker run -it --name mynet --net none ubuntu
```

- 아무런 네트워크를 사용하지 않고 외부외 단절됨

**컨테이너 네트워크**

```
sudo docker run -it --name mynet --net container:[컨테이너이름] ubuntu
```

- 공유되는 속성은 내부 ip 네트워크 인터페이스의 맥 주소 등임
- 이런식으로 컨테이너 네트워크를 사용할 경우 호스트에 veth로 시작하는 가상 네트워크 인터페이스도 생성되지 않음. 완전히 같은 네트워크 정보를 사용함

**브리지 네트워크와 --net-alias**

- 브리지타입의 네트워크와 run 명령어의 --net-alias 옵션을 함께 쓰면 특정 호스트 이름으로 컨테이너 여러개에 접근 가능
- 도커는 기본 브릿지 네트워크가 아닌 사용자가 정의한 브릿지 네트워크에 사용되는 내장 dns 서버를 가지며 dns의 ip는 127.0.0.11임

**MacVLAN 네트워크**

- MacVLAN은 호스트으 네트워크 인터페이스 카드를 가상화해 물리 네트워크 환경을 컨테이너에게 동일하게 제공함
- MacVLAN을 사용하면 컨테이너는 물리 네트워크 상에서 가상의 맥 주소를 가지며 해당 네트워크에 연결된 다른 장치와의 통신이 가능해짐
- 나머지 설정은 책 보는거 추천 ...



## 컨테이너 로깅

### json-file 로그 사용하기

- `docker logs` 명령어로 컨테이너 내부 출력을 확인 가능함
- --tail 옵션으로 마지막 로그 줄부터 출력할 줄의 수를 설정 가능
- --since 옵션으로 특정 시간 이후의 로그 호가인 가능
- -t 타입스탬프 표시
- -f 실시간 로그 스트림 확인
- /var/lib/docker/containers/${CONTAINERID}/${CONTAINERID}-json.log에서 정제되지 않은 JSON 로그 확인 가능
- --log-opt 옵션으로 컨테이너 시작시 json 로그 파일의 최대 크기를 지정 가능 max-size는 최대 크기 max-file은 로그 파일의 개수



### syslog 로그

- json뿐만아니라 syslog로도 사용 가능
- syslog는 유닉스 계열 운영체제에서 로그를 수집하는 오래된 표준중 하나로서 커널, 보안 등 시스템과 관련된 로그, 어플리케이션의 로그 등 다양한 종류의 로그를 수집해 저장함
- syslog를 사용하면 로그 정보를 원격 서버로 보낼 수 있음



### fluentd 로깅







## 컨테이너 자원 할당

- 컨테이너를 생성하는 run, create에 자원 할당량을 조절하도록 옵션을 입력할 수 있음

- 아무런 옵션을 입력하지 않으면 컨테이너는 호스트의 자원을 제한 없이 쓸 수 있고 호스트의 자원을 전부 점유해 다른 컨테이너 뿐만아니라 호스트 자체의 동작이 멈출 수 있음

- 이미 run 상태의 컨테이너 자원 제한을 변경하려면 update 명령어를 사용함

- ```
  docekr update (변경할 자원 제한) (컨테이너 이름)
  ```

### 컨테이너 메모리 제한

- docker run 명령어에 --memory를 지정해 컨테이너의 메모리를 제한할 수 있음 m, g 단위 가능하고 최소 메모리는 4mb임
- 컨테이너 내에서 동작하는 포르세스가 컨테이너에 할당된 메모리를 초과하면 컨테이너는 자동으로 종료되므로 메모리를 적절하게 할당하는 것이 좋음



### 컨테이너 CPU 제한

#### --cpu-shares

- --cpu-shares 옵션은 컨테이너에 가중치를 설정해 해당 컨테이너가 CPU를 상대적으로 얼마나 사용할 수 있는지를 타나냄

- 즉 컨테이너에 cpu를 한 개씩 할당하는 방식이 아닌 시스템에 존재하는 cpu를 어느 비중만큼 나눠 쓸 것인지를 명시하는 옵션임

- ```
  docker run -it --name cpu_share --cpu-shares 1024 ubuntu:14.04
  ```



#### --cpuset-cpu

- 호스트에 cpu가 여러개 있을때 해당 옵션을 지정해 컨테이너가 특정 cpu만 사용하도록 설정할 수 있음

- ```
  docker run -it --name cpu_share --cpuset-cpus=2 1024 ubuntu:14.04
  ```



#### --cpu-period, --cpu-quota

- 컨테이너의 CFS 주기는 기본적으로 100ms로 설정되어있는데 이 명령어로 이 주기를 변경할 수 있음



#### --cpus

- --cpus 옵션은 --cpu-period, --cpu-quota와 동일한 기능을 하지만 좀 더 직관적으로 cpu의 개수를 직접 지정함 --cpus 옵션을 0.5 지정하는것과 --cpu-period 10000 , --cpu-quota 50000 과 같음





### Block I/O 제한

- 컨테이너를 생성할 때 아무런 옵션도 설정하지 않으면 컨테이너 내부에서 파일을 읽고 쓰는 대역폭에 재한이 설정되어 있지 않음

- --device-write-bps, --device-read-bps, --device-write-iops, --device-read-iops 옵션을 지정해 블록 입출력을 제한할 수 있음

- 단 DirectI/O의 경우에만 블록 입출력이 제한되며 Buffered I/O는 제한되지 않음

- ```
  docker run -it --device-write-bps /dev/xvda:1mb
  ```



## 도커 이미지

- docker search를 사용해 해당 키워드랑 관련된 이미지를 찾을 수 있음



### 도커 이미지 생성

- docker commit 을 이용해 이미지 생성 가능

### 이미지 구조의 이해 

- docker inspect로 이미지 정보를 살펴보면 Layer 항목을 보면 해시값이 있음
- 하나의 이미지로 여러개의 이미지를 만들면 이미지 크기 X 3 이 아니라 이미지크기 + 변경된 사항 +변경된 사항임

### 이미지 삭제하기

- docker rmi 을 이용해 이미지 삭제 가능
- 만약 run 중인 이미지가 있으면 삭제 불가
- 컨테이너가 사용중인 이미지를 docker rmi -f 로 강제로 삭제하면 이미지 이름이 none으로 변경되고 이런 이미지들을 댕글링 이미지라고 함 사용중이지 않은 댕글링 이미지는 docker image prune 으로 한꺼번에 삭제 가능
- 삭제되는 이미지의 부모 이미지가 존재하지 않아야만 해당 이미지의 파일이 실제로 삭제됨

### 이미지 추출하기

- docker save 명령어로 이미지를 단일 바이너리 파일로 저장할 수 있음 이명령어를 사용하면 컨테이너의 커맨드, 이미지 이름, 태그 등 이미지의 모든 메타데이터를 포함해 하나의 파일로 추출할 수 있음
- -o 옵션으로 추출될 파일명
- 추출된 이미지는 docker load로 다시 도커에 로드할 수 있음
- 비슷한 개념으로 export, import가 있고 export는 tar파일로 추출하고 컨테이너 및 이미지에 대한 설정 정보를 저장하지 않음 

### 이미지 배포

#### 도커 허브 저장소

- docker tag 명령어를 사용해서 이미지의 이름 변경 가능 그러나 기존 이미지를 변경하는 것은 아니고 같은 이미지를 가르키는 새로운 이름을 추가하는 것임
- docker login으로 접속해야 이미지 배포 가능함
- 조직에서 저장소를 생성하면 조직의 이름으로 저장소가 생김
- 웹훅으로 push 이벤트를 http 요청전달 가능

#### 도커 사설 레지스트리

- 도커 사설 레지스트리를 사용하면 개인 서버에 이미지를 저장할 수 있는 저장소를 만들 수 있음







## Dockerfile

### Dockerfile 작성

- Dockerfile은 한 줄이 하나의 명령어가 되고 명령어를 명시한 뒤에 옵션을 추가하는 방식임 명령어는 대문자가 관례
- FROM: 생성할 이미지의 베이스가 될 이미지를 뜻함. FROM 명령어는 Dockerfile을 작성할 때 반드시 한 번 이상 입력해야 함 이미지 이름의 포맷은 docker run 명령어에서 이미지 이름을 사용했을 때와 같음
- MAINTAINER: 이미지를 생성한 개발자의 정보를 나타냄. 일반적으로 Dockerfile을 작성한 사람과 연락할 수 있는 이메일 등을 입력함 단 도커 1.13.0 버전 이후로 사용하지 않고 LABEL maintainer 로 교체함
- LABEL: 이미지에 메타데이터를 추가함. 메타데이터는 키:값 형식으로 저장되며 여러 개의 메타데이터가 저장될 수 있음 추가된 메타데이터는 docker insepect 명령어로 이미지의 정보를 구해서 확인할 수 있음
- RUN: 이미지를 만들기 위해 컨테이너 내부에서 명령어를 실행함. 예제에서는 apt-get update와 apt-get install apache2 명령어를 실행하기 때문에 아파치 웹 서버가 설치된 이미지가 생성됨 단 Dockerfile에서 패키지 설치시 -y 옵션을 주지않으면 빌드가 종료됨
- ADD: 파일을 이미지에 추가함. 추가하는 파일은 Dockerfile이 위치한 디렉터리인 컨텍스트에서 가져옴 ADD명령어는 JSON 배열의 형태로 여러개 추가후 맨 마지막이 컨테이너에 추가될 위치로 사용됨
- WORKDIR: 명령어를 실행할 디렉터리를 나타냄 배시 셸에서 cd 명령어를 입력하는 것과 같음 명령어는 중복되기 때문에 이전 WORKDIR의 영향을 받음
- EXPOSE: Dockerfile의 빌드로 생성된 이미지에서 노출할 포트를 설정함. 그러나 EXPOSE 를 설정한 이미지로 컨테이너를 생성했다고 해서 반드시 이 포트가 호스트의 포트와 바인딩되는 것은 아니며 단지 컨테이너의 80번 포트를 사용할 것임을 나타내는 것 뿐임 이 EXPOSE를 호스트와 연결하려면 -P 옵션을 주면 됨
- CMD: 컨테이너가 시작될 때마다 실행할 명령어를 설정하며 Dockerfile에서 한 번만 사용할 수 있음 



#### 빌드과정

- 이미지 빌드를 시작하면 도커는 가장 먼저 빌드 컨텍스트를 읽어들임 빌드 컨텍스트는 이미지를 생성하는데 필요한 각종 파일, 소스코드, 메타데이터 등을 담고 있는 디렉터리임 Dockerfile이 위치한 디렉터리가 빌드 컨텍스트가 됨
- Dockerfile이 위치한 곳에는 이미지 빌드에 필요한 파일만 있도록 하는 것이 바람직함
- 깃에서 사용하는 gitignore같은 기능을 사용할 수 있음 .dockerignore라는 파일을 작성하면 빌드시 이 파일에 명시된 이름의 파일을 컨텍스트에서 제외함
- .dockerignore라는 파일은 Dockerfile과 같은 경로에 위치해야함 컨텍스트에서 제외하는 파일 위치도 Dockerfile의 위치와 같게 적용됨

##### Dockerfile을 이용한 컨테이너 생성과 커밋

- Dockerfile에서 명령어 한 줄이 실행될 때마다 이전 Step에서 생성된 이미지에 의해 새로운 컨테이너가 생성되며 Dockerfile에 적힌 명령어를 수행하고 다시 새로운 이미지 레이어로 저장됨
- 이미지 빌드가 완료되면 Dockerfile의 명령어 줄 수만큼의 레이어가 존재하고 중간에 컨테이너도 같은 수만큼 생성되고 삭제됨

##### 캐시를 이용한 이미지 빌드

- 한번 이미지 빌드를 마치고 난 뒤 다시 같은 빌드를 진행하면 이전의 이미지 빌드에서 사용했던 캐시를 사용함
- 이미지 빌드시 -f 옵션으로 dockerfile의 이름을 지정할 수 있음
- 이전에 빌드했던 Dockerfile과 같은 내용이 있다면 build 명령어는 이를 새로 빌드하지 않고 같은 명령어 줄까지 이전에 사용한 이미지 레이어를 활용해 이미지를 새엇ㅇ함
- 캐시가 필요하지 않을 경우 --no--cache 옵션으로 Dockerfile을 처음부터 다시 이미지레이어로서 빌드함
- --cache-from {이미지:태그} 를 이용해서 캐시로 사용할 이미지를 직접 지정할 수도 있음



#### 멀티 스테이지를 이용한 Dockerfile 빌드하기

- 17.05버전 이상을 사용하는 도커 엔진이라면 이미지의 크기를 줄이기 위해 멀티 스테이지 빌드 방법을 사용할 수 있음 멀티 스테이지 빌드는 하나의 Dockerfile 안에 여러 개의 FROM 이미지를 정의함으로써 빌드 완료 시 최정적으로 생성될 이미지의 크기를 줄이는 역할을 함
- 멀티스테이지 빌드를 사용하는 Dockerfile은 2개 이상의 이미지를 사용할 수 있으며 각 이미지는 먼저 FROM에 명시된 순서대로 차례되어 구분되어 사용됨 이를 활용하면 여러 개의 이미지를 사용해 멀티 스테이지 빌드를 활용할 수 있음

### 

### 기타 Dockerfile 명령어



#### ENV, VOLUME, ARG, USER

- ENV: Dockerfile에서 사용될 환경 변수를 지정함 설정한 환경변수는 ${ENV_NAME} 또는 $ENV_NAME의 형태로 사용 가능함 이 환경변수는 Dockerfile 뿐만 아니라 추후 생성될 이미지 컨테이너에서 사용 할 수 있음
- VOLUME: 빌드된 이미지로 컨테이너를 생성했을 때 호스트와 공유할 컨테이너 내부의 디렉터리를 설정함
- ARG: build 명령어를 실행할 때 추가로 입력을 받아 Dockerfile 내에서 사용될 변수의 값을 설정함 build할때 --build-arg 옵션으로 키:값 형식으로 값을 바인딩할 수 있음 ARG도 ${} 를 사용함
- USER: USER컨테이너 내에서 사용될 사용자 계정의 이름이나 UID를 설정하면 그 아래의 명령어는 해당 사용자 권한으로 실행됨 일반적인 RUN으로 사용자의 그룹과 계정을 생성한 뒤 사용하고 루트 권한이 필요하지 않다면 USER를 사용하는 것을 권장함 기본적으로 컨테이너 내부에서는 root 사용자를 사용함

#### Onbuild,Stopsignal, Healthcheck, Shell

- ONBUILD: 빌드된 이미지를 기반으로 하는 다른 이미지가 Dockerfile로 성성될 때 실행할 명령어를 추가함. 이 이미지를 통해 파생된 이미지의 명령어를 미리 지정해 놓을 수 있음 단순히 부모 자식관계만 형성됨ㅁ
- STOPSIGNAL: 컨테이너가 정지될 때 사용될 시스템 콜의 종류를 지정함 아무것도 설정하지 않으면 기본적으로 SIGTERM으로 설정되지만 Dockerfile에 STOPSIGNAL을 정의해 컨테이너가 종료되는 데 사용될 신호를 선택할 수 있음
- HEALTHCHECK: 이미지로부터 생성된 컨테이너에서 동작하는 어플리케이션의 상태를 체크하도록 설정함 컨테이너 내부에서 동작중인 어플리케이션의 프로세스가 종료되지는 않았으나 어플리케이션이 동작하고 있지 않은 상태를 방지하기 위해 사용할 수 있음
- SHELL: Dockerfile에서 기본적으로 사용하는  셸은 리눅스에서 "/bin/sh -c" 윈도우에서 "cmd /S /C" 임 이 셸을 따로 지정하고 싶을 경우에 사용 가능함



### ADD, COPY

- COPY는 로컬 디렉터리에서 읽어 들인 컨텍스트로부터 이미지에 파일을 복사하는 역할을 함 ADD와 사용 방법은 동일하지만 COPY의 기능이 ADD에 포함되어있음 ADD는 URL 및 tar파일에서도 파일을 추가할 수 있다는 점에서 다름 tar는 압출을 풀어서 추가함 ADD 가 좋아보이나 ADD를 사용을 그다지 권장하지는 않고 ADD로 URL이나 tar 파일을 추가할 경우 이미지에 정확히 어떤 파일이 추가될지 알 수 없기 때문임



### ENTRYPOINT, CMD

- ENTRYPOINT와 CMD는 동일하게 컨테이너가 시작될 때 수행할 명령을 지정한다는 점에서 같음 그러나 ENTRYPOINT는 커맨드를 인자로 받아 사용할 수 있는 스크립트의 역할을 할 수 있다는 점에서 다름 ENTRYPOINT가 설정되지 않았다면 CMD에 설정된 명령어를 그대로 실행하지만 ENTRYPOINT가 설정됐다면 CMD는 단지 ENTRYPOINT에 대한 인자의 기능을 함



### Dockerfile로 빌드할 때 주의할점

- ubuntu 이미지 위에 100m 짜리파일을 가상으로 만들고 지운다고 하더라도 이전 레이어에 남아있기때문에 파일이 없더라도 도커이미지는 100+ @ 상태임 이를 방지하기 위해서는 하나의 명령어를 &&으로 묶어서 하나의 레이어로 합치면 됨





## 도커데몬

### 도커의 구조

- 도커의 실제 명령어 위치는 /usr/bin/docker에 있음
- 도커는 클라이언트로서의 도커, 서버로서의 도커로 구조가 크게 두가지로 나눠짐
- 실제로 컨테이너를 생성하고 실행하며 이미지를 관리하는 주체는 도커 서버이고 이는 dockerd 프로세스로서 동작함 도커 엔진은 외부에서 API입력을 받아 도커 엔진의 기능을 수행하는데 도커 프로세스가 실행되어 서버로서 입력을 받을 준비가 된 상태를 도커 데몬이라고 이야기함
- 도커 데몬은 api 입력을 받아 도커 엔진의 기능을 수행하는데 이 api를 사용할 수 있도록 CLI 를 제공하는 것이 도커 클라이언트임. 사용자가 docker로 시작하는 명령어를 입력하면 도커 클라이언트를 사용하는 것이며 도커 클라이언트는 입력된 명령어를 로컬에 존재하는 도커 데몬에게 API로서 전달함 이때 도커 클라이언트는 /var/run/docker.sock에 위치한 유닉스 소켓을 통해 도커 데몬의 API를 호출함

1. 사용자가 docker ps 같은 도커 명령어를 입력함
2. /usrbin/docker는 /var/run/docker.sock 유닉스 소켓을 사용해 도커 데몬에게 명령어를 전달함
3. 도커 데몬은 이 명령어를 파싱하고 명령어에 해당하는 작업을 수행함
4. 수행 결과를 도커 클라이언트에게 반환하고 사용자에게 결과를 출력함

- 이것은 아무런 설정을 하지 않았을때 일반적으로 도커 데몬을 제어하는 순서임



### 도커 데몬 실행

- 도커데몬은 우분투에서는 자동으로 서비스가 등록되지만 레드햇 계열에서는 자동으로 등록되지 않음 systemctl enable docker로 등록해줘야함
- dockerd 명령어로 도커데몬을 실행할 수 있음



### 도커 데몬 설정

- dockerd --help로 옵션 확인 가능
- dockerd --insecure-registry=192.168. ... 같은 형태로 도커 데몬에 옵션을 줄 수 있지만 일반적인 방법은 아니고 우분투 14.04 기준으로 /etc/default/docker 라는 설정파일에 설정하는게 일반적임
- docker 설정파일에 옵션을 주고 싶다면 DOCKER_OPTS="dockerd -H tcp ...." 형태로 주면 됨

#### 도커 데몬 제어 -H

- -H 옵션은 도커 데몬의 API를 사용할 수 있는 방법을 추가함 아무런 옵션을 설정하지 않고 도커 데몬을 실행하면 도커 클라이언트인 /usr/bin/docker를 위한 유닉스소켓인 /var/run/docker.sock을 사용함 
- dockerd == dockerd -H unix:///var/run/docker.sock
- -H에 IP주소와 포트르 번호를 입력하면 원격 API인 Docker Remote API로 도커를 제어할 수 있음
- dockerd -H tcp://0.0.0.0:2375 <- 모든 호스트의 2375번으로 포트를 열어줌
- -H에 unix:///var/run/docker.sock을 지정하지 않고 위와 같이 Remote API만 바인딩하면 유닉스 소켓은 비활성화 되어 도커 클라이언트를 사용할 수 없음 따라서 일반적으로 도커 클라이언트를 위한 유닉스 소켓과 Remote API를 위한 바인딩 주소를 동시에 설정함
- curl같은 http 요청 도구를 사용해서 RemoteAPI를 사용할 수 있음 curl 127.0.0.1:2375/version 은 docker version을 사용하는 것과 동일함
- HTTP로 API를 직접 사용하는 것은 드물고 Remote API를 사용하기 위해 특정 라이브러리를 사용할 수 있음
- export DOCKER_HOST="tcp://192.168.99.100:2375" 로 바인딩해두면 해당 주소의 docker 클라이언트를 사용함
- 도커 클라이언트에 -H 옵션을 설정해 제어할 원격 도커 데몬을 설정할 수 있음
- docker -H tcp://192.168.99.100:2375 version



#### 도커 데몬에 보안 적용: --tlsverify

- 일반적으로 Remote API 도커에는 보안기능이 없음
- openssl로 필요한 key파일을 만들고 --tlsverify --tlscacert --tlscert --tlskey 같은 옵션을 이용해서 dockerd 실행하면 됨 이런 실행은 도커 서비스의 설정파일을 변경해서 사용할 수 있음
- 기본적으로 TLS 보안이 적용안된 포트는 2375번 포트, 적용된 포트는 2376이 관례임
- export DOCKER_CERT_PATH="/root/.docker" 를 통해 TLS 관련 파일을 위치시킬 수 있고
- export DOCKER_TLS_VERIFY를 통해 TLS 사용 여부를 결정할 수 있음



#### 도커 스토리지 드라이브 변경: --storage-driver

- 도커는 특정 스토리지 백엔드 기술을 사용해 도커 컨테이너와 이미지를 저장하고 관리함 일부 운영체제는 도커를 설치할 때 기본적으로 사용하도록 설정된 스토리지 드라이버가 있는데 데비안은 overlay2를 구버전의 centos는 devicemapper를 사용하는 것이 대표적인 예임
- 환경에 알맞게 설정되지만 --storage-dirver를 사용해서 변경할 수 있음
- 지원하는 드라이버는 OverlayFS, AUFS, Btrfs, Devicemapper, VFS, ZFS 등이 있음 이중에 한개만 선택 가능하며 적용된 스토리지 드라이버에 따라 컨테이너와 이미지가 별도로 생성됨
- 드라이버를 바꾸면 기존 드라이버로 생성한 이미지는 사용 불가한듯

##### 스토리지 드라이버의 원리

- 스냅숏의 기본 개념은 '원본 파일은 읽기 전용으로 사용하되 이 파일이 변경되면 새로운 공간을 할당한다'임
- 스토리지를 스냅숏으로 만들면 스냅숏 안에 어느 파일이 어디에 저장돼 있는지가 목록으로 저장되는데 이 스냅숏 안의 파일에 변화가 생기면 변경된 내역을 따로 관리함으로써 스냅숏을 관리함
- 여기에서 Copy on Write 와 Redirect on Write 개념이 나옴
- CoW는 스냅숏의 파일에 쓰기 작업을 수행할 때 스냅숏 공간에 원본 파일을 복사한 뒤 쓰기 요청을 반영함 이 과정에서 복사하기 위해 파일을 읽는 작업 한번 파일을 스냅숏 공간에 쓰고 변경된 사항을 쓰는 작업으로 총 2번의 쓰기 작업이 일어나므로 오버헤드가 발생함
- RoW는 CoW와 다르게 한 번의 쓰기 작업만 일어남 
- 별로 중요한 내용은 아니고 스냅숏 파일을 불변 상태로 유지할 수 있다는 점이 중요함
- 이미지 레이어는 각 스냅숏이고 컨테이너는 이 스냅숏을 사용하는 변경점임

##### AUFS 드라이버 사용하기

- AUFS 드라이버는 우분투에서는 자동 옵션이고 안정성 측면에서 좋고 많으 쓰지만 REHL, CentOS에서는 사용 불가함
- grp aufs /proc/filesystems 가 nodev aufs 면 사용 가능
- 많이 사용하고 PaaS에 적합함 빠름

##### Devicemapper

- CentOS를 포함한 대부분의 리눅스 배포판에서 사용 가능하지만 deprecated됨 대안으로 overlay, overlay2 스토리지 드라이버가 있음
- devicemapper 드라이버를 사용하는 컨테이너는 allocate-on-demand라는 원리로 컨테이너 내부에서 새로운 파일을 기록함 
- devicemapper 스토리지 풀에서 공간을 할당받고 이미지의 스냅숏을 만들어 상위 레이어를 생성함

##### OverlayFS 드라이버 사용하기

- 레드햇과 라즈비안 등에서 도커 설치시 자동 설정
- AUFS와 비슷하지만 좀 더 간단하고 성능도 좋음



#### 컨테이너 저장 공간 설정



### 도커 데몬 모니터링





# #3 도커 스웜



## 도커 스웜을 사용하는 이유

- 호스트머신에서 도커엔진을 사용하다가 호스트 자원이 부족하면 매우 좋은 성능의 서버를 사는게 가장 간단한 해답이지만 현실적으로 쉽지 않기때문에 여러대의 서버를 클러스터로 만들어 자원을 병렬로 확장함
- 새로운 서버가 있다고해도 적용이 쉽지 않지만 도커스웜과 스웜모드가 도와줌



## 스웜 클래식과 도커 스웜 모드

- 스웜 클래식과 스웜 모드는 여러대의 도커 서버를 하나의 클러스터로 만들어 컨테이너를 생성하는 여러 기능을 제공함
- 도커스웜에는 두가지 종류가 있는데 1.6이후부터 사용할 수 있는 컨테이너로서의 스웜이고 도커 1.12 이후부터 사용할 수 있는 도커 스웜 모드 임 첫번째가 스웜 클래식 두번째를 스웜 모드라고 부르겠음
- 스웜 클래식은 여러대의 도커 서버를 하나의 지점에서 사용하도록 단일 접근점을 제공한다면 스웜 모드는 마이크로서비스 아키텍처의 컨테이너를 다루기 위한 클러스터링 기능에 초점을 맞추고 있음
- 스웜 클래식은 docker run, docker ps 등 일반적인 도커 명령어와 도커 api로 클러스터의 서버를 제어하고 관리할 수 있는 기능을 제공함 이에 비해 스웜 모드는 같은 컨테이너를 동시에 여러개 생성해 필요에 따라 유동적으로 컨테이너의 수를 조절할 수 있으며, 컨테이너로의 연결을 분산하는 로드밸런싱 기능을 자체적으로 지원함
- 스웜 모드가 서비스 확장성과 안정성 등 여러 측면에서 스웜 클래식보다 뛰어나기 때문에 일반적으로는 스웜 모드를 더 많이 사용함
- 스웜 클래식과 스웜 모드의 다른 차이점은 분산 코디네이터, 에이전트와 같은 클러스터 툴이 별도로 구동되느냐임 스웜 클래식은 이런 에이전트가 필요한데 스웜모드는 모든 도구가 도커 엔진 자체에 있어서 더욱 쉽게 서버 클러스터를 구축할 수 있음



## 스웜 모드

- 기본적으로 스웜모드는 비활성화 되어있음

### 도커 스웜 모드의 구조

- 스웜 모드는 매니저 노드와 워커 노드로 구성돼 있음 워커 노드는 실제로 컨테이너가 생성되고 관리되는 도커 서버이고 매니저 노드는 워커 노드를 관리하기 위한 도커 서버임 매니저노드는 기본적으로 워커노드의 역할을 포함하고 있음
- 매니저노드는 1개이상 반드시필요하지만 워커노드는 그러지 않음 매니저노드가 워커노드의 기능을 할 수 있기 때문인데 구분해서 사용하는것을 권장함
- 매니저노드는 다중화하는것을 권장하고 가능한 홀수개로 사용할 것을 권장함 홀수개로 구성하면 짝수개 구성보다 매니저 노드의 장애를 더 허용하고 매니저 노드 사이의 데이터 일관성을 유지할 수 있음



### 도커 스웜 모드 클러스터 구축

- docker swam init --adverties-addr (매니저 노드의 public ip)
- 출력된 명령어중 --token 은 비밀키임
- 이제 워커노드를 추가하기 위해 다음 명령어를 사용함
- docker swarm join --token (매니저 노드에서 받은 토큰) (매니저노드 ip)
- 스웜 매니저는 기본적으로 2377번 포트를 사용하고 노드 사이의 통신에 7946/tcp, 7946/udp 포트를, 스웜이 사용하는 네트워크인 ingress 오버리에 네트워크에 4789/tcp, 4789,udp 포트를 사용함 스웜 클러스터 구성 이전에 포트들을 반드시 열어 둘 것

centos 기준

```
firewall-cmd --zone=public --permanent --add-port=2377/tcp 
firewall-cmd --zone=public --permanent --add-port=2377/udp 
firewall-cmd --zone=public --permanent --add-port=7946/tcp 
firewall-cmd --zone=public --permanent --add-port=7946/udp 
firewall-cmd --zone=public --permanent --add-port=4789/tcp 
firewall-cmd --zone=public --permanent --add-port=4789/udp 

firewall-cmd --reload 
firewall-cmd --zone=public --list-all
```

- 매니저노드에서 docker node ls 했을때 워커노드 등록 확인 가능 * 붙은 서버가 매니저노드 서버
- 매니저 노드는 일반적인 매니저 역할을 하는 노드와 리더 역할을 하는 노드로 나눠지는데 리더 매니저는 모든 매니저 노드에 대한 데이터 동기화의 관리를 담당하므로 항상 작동해야함. 고가용성을 위해 Raft Consensus 알고리즘을 사용해서 리더의 부재를 최소화함
- 새로운 매니저 노드를 추가하려면 docker swarm join 명령어를 사용함 토큰은 docker swarm join-token manager 명령어로 확인 가능 워커노드의 토큰은 docker swarm join-token worker로 확인 가능
- 토큰은 보안상의 이유로 노출되지 않도록 관리하고 만약 노출되었다면 docker swarm join-token --rotate manager 형식으로 토큰을 변경할 수 있음
- 워커노드의 삭제는 docker swarm leave 로 워커노드를 down 시키고 docker node rm {node id} 로 삭제할 수 있음 매니저 노드는 docker swarm leave 명령어에 --force로 삭제하고 매니저 노드를 삭자헤면 해당 스웜 클러스터는 더이상 사용을 못하는 상태가 됨
- 워커노드를 매니저 노드로 변경하려면 docker node promote 명령어를 사용하고 매니저노드를 워커노드로 변경하려면 docker node demote 명령어를 사용하면 됨 매니저 노드가 한개일때는 사용 불가



### 스웜 모드 서비스

#### 스웜 모드 서비스 개념

- 지금까지는 docker run은 도커의 컨테이너였지만 스웜모드에서는 제어하는 단위가 컨테이너가 아니라 서비스임 서비스는 같은 이미지에서 생성된 컨테이너의 집합이며 서비스를 제어하면 해당 서비스 내의 컨테이너에 같은 명령이 수행됨 서비스 내에는 컨테이너는 1개 이상 존재할 수 있고 컨테이너들은 각 워커노드와 매니저노드에 할다왿ㅁ 이러한 컨테이너들을 Task라고 함 하지만 이해를 돕기 위해 Task를 컨테이너로 부르도록 하겠음
- 예를들어 ubuntu 이미지로 서비스를 생성하고 컨테이너 수를 3개로 설정했다고 가정하면 스웜 스케쥴러는 서비스 정의에 따라 컨테이너를 할당할 적합한 노드를 선정하고 해당 노드에 컨테이너를 분산해서 할당함 이런 컨테이너를 레플리카 라고 하고 서비스에 설정된 레플리카 수 만큼의 컨테이너가 스웜 클러스터 내에 존재해야함
- 스웜은 컨테이너 상태를 모니터링하다가 레플리카의 상태가 다운되거나 종료되었을때 새로운 컨테이너를 클러스터에 추가해서 컨테이너 수를 일정하게 유지함
- 서비스는 롤링 업데이트 기능도 제공해서 서비스 내 컨테이너들의 이미지를 일괄적으로 업데이트해야 할 떄 컨테이너의 이미지를 순서대로 변경할 수 있음

#### 서비스 생성

- 서비스와 관련된 명령어는 매니저 노드에서만 가능함

##### 첫번째 서비스 생성하기

- docker service create 를 통해 서비스를 생성할 수 있음 
- 서비스 내의 컨테이너는 detached 모드로 즉 docker run 명령어의 -d 옵션을 사용해 동작할 수 있는 이미지를 사용해야함 컨테이너 내부에 동작하고 있는 프로세스가 없다면 스웜 매니저는 서비스의 컨테이너에 장애가 생긴것으로 판단해서 컨테이너를 계속 반복 생성하게됨
- 서비스 목록은 docker service ls로 확인
- 서비스의 자세한 정보는 docker service ps {서비스 이름}으로 확인
- 생성된 서비스의 삭제는 docker service rm을 사용함

##### nginx 웹 서버 서비스 생성하기

- sudo docker service create --name myweb --replicas 2 -p 80:80 nginx
- 이런식으로 nginx 서비스를 올리면 노드마다 레플리카를 생성하게되고 라운드 로빈 방식을 사용해서 서비스 내에 접근할 컨테이너를 결정함 만약에 노드가 20개가 있고 20개의 엔드포인트가 있다고 하더라도 80포트는 모든 노드의 엔드포인트로 접근 가능함 반드시 레플리카가 있는 노드만 접근 가능한 것이 아님
- 반드시 노드의 수와 레플리카의 수가 맞아야 할 필요는 없음
- docker service scale myweb=4 명령어로 레플리카의 수를 늘릴 수 있음

##### global 서비스 생성하기























