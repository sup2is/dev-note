# Spring Batch 내맘대로 번역





# Spring Batch

- 엔터프라이즈 시스템의 일상적인 작업에 필수적인 강력한 배치 응용 프로그램을 개발할 수 있도록 설계된 가볍고 포괄적 인 배치 프레임 워크 
- 로깅/추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작, 건너 뛰기, 리소스 관리 등 대량의 레코드 처리에 필수적인 재 사용가능한 기능을 제공함
- 최적화 및 파티셔닝 기술을 통해 대용량 및 고성능 배치 작업을 가능하게 하는 고급 기술 서비스 및 기능을 제공함
- 단순하고 복잡한 대용량 배치 작업은 확장성이 뛰어난 방식으로 프레임 워크를 활용하여 많은 양의 정보를 처리할 수 있음







# Spring Batch Introduction

- 엔터프라이즈 도메인 내의 많은 애플리케이션은 미션 크리티컬 환경에서 비지니스 운영을 수행하기 위해 대량 처리가 필요함. 이러한 비지니스 운영에는 다음이 포함됨
  - 사용자 상호 작용없이 가장 효율적으로 처리되는 대량 정보의 자동화 된 복잡한 처리. 이러한 작업에는 일반적으로 시간 기반 이벤트가 포함됨
  - 매우 큰 데이터 세트에서 반복적으로 처리되는 복잡한 비즈니스 규칙을 주기적으로 적용함
  - 일반적으로 형식화, 유효성 검사 및 트랜잭션 방식의 처리가 필요한 내부 및 외부 시스템에서 수신한 정보를 기록 시스템에 통합함 일괄 처리는 기업을 위해 매일 수십억 건의 트랜잭션을 처리하는데 사용함
- 스프링 배치는 스프링의 특성을 기반으로 구축됨
- 스프링 배치는 스케줄링 프레임워크가 아님 Quartz, Tivoli, Control-M 등이 스케줄러고 스프링 배치는 스케줄러와 함께 작동하기 위한것



# Background

- 많은 애플리케이션들이 java기반 일괄 처리 요구를 수용하기 위해 재사용 가능한 아키텍처 프레임 워크에 초점을 맞추지 못했음
- 표준 배치 아키텍처의 부재로 일회성 사내 솔루션이 급증했음
- pivotal과 accenture는 이 환경을 변경하기 위해 노력함



# Usage Scenarios

- 일반적인 배치프로그램의 동작
  - 데이터베이스, 파일 또는 큐에서 많은 수의 레코드를 읽음
  - 데이터를 어떤 방식으로 처리함
  - 수정된 형식으로 데이터를 다시 씀

- 스프링 배치는 이러한 기본 배치 반복을 자동화하여 일반적으로 사용자 상호 작용 없이 오프라인 환경에서 유사한 트랜잭션을 집합으로 처리할 수 있는 기능을 제공함

- 비지니스 시나리오

  - 주기적으로 배치 프로세스 커밋
  - 동시 일괄 처리 : 작업의 병렬 처리
  - 단계별 엔터프라이즈 메시지 기반 처리
  - 대규모 병렬 일괄 처리
  - 실패 후 수동 또는 예약된 재시작
  - 종속 단계의 순차적 처리
  - 부분 처리 : 레코드 건너 뛰기
  - 배치크기가 작거나 기존 저장 프로시저 / 스크립트가 있는 경우 전체 배치 트랜잭션

- 기술적 목표

  - 배치 개발자는 spring 프로그래밍 모델을 사용함 비지니스 로직에 집중하고 프레임워크가 인프라를 처리함
  - 인프라, 배치 실행 환경 및 배치 애플리케이션 간의 문제를 명확하게 구분함
  - 모든 프로젝트가 구현할 수 있는 인터페이스로 공통의 핵심 실행 서비스를 제공함
  - 즉시 사용할 수 있는 핵심 실행 인터페이스의 단순하고 기본 구현을 제공함
  - 모든 계층에서 스프링 프레임워크를 활용하여 서비스를 쉽게 구성, 사용자 지정 및 확장 할 수 있음
  - 기존의 모든 핵심 서비스는 인프라 계층에 영향을 주지 않고 쉽게 교체하거나 확장할 수 있어야함
  - Maven을 사용하여 빌드된 애플리케이션과 완전히 분리된 아키텍처 jar로 간단한 배포 모델 제공

  



# Spring Batch Architecture



![](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/spring-batch-layers.png)



- 애플리케이션에는 Spring Batch를 사용하는 개발자가 작성한 모든 배치 작업과 사용자 정의 코드가 포함
- Batch Core에는 배치 작업을 시작하고 제어하는데 필요한 핵심 런타임 클래스가 포함 여기에는 JobLauncher, Job 및 Step에 대한 구현이 포함



# General Batch Principles and Guidelines

- 배치 솔루션을 구축 할 때 다음과같은 원칙 지침 및 일반 고려사항을 고려해야함

  - 배치 아키텍처는 일반적으로 온라인 아키텍처에 영향을 미치며 그 반대의 경우도 마찬가지임 가능한 경우 공통 빌딩 블록을 사용하여 아키텍처와 환경을 모두 염두에 두고 설계할 것
  - 가능한 한 단순화하고 단일 배치 애플리케이션에서 복잡한 논리 구조를 구축하지 말것
  - 데이터 처리 및저장을 물리적으로 가깝게 유지할 것
  - 시스템 리소스 사용, 특히 I/O를 최소홯 할 것 내부 메모리에서 가능한 한 많은 작업을 수행할 것
  - 특히 다음 네가지 일반 결함을 찾을것
    - 테이터를 한 번 읽고 캐시하거나 작업 저장소에 보관할 수 있을떄 모든 트랜잭션에 대한 데이터 읽을때
    - 동일한 트랜잭션에서 이전에 데이터를 읽은 트랜잭션에 대한 데이터를 다시 읽을때
    - 불필요한 테이블 또는 인덱스 스캔을 유발할 때
    - sql 문의 where 절에 키 값을 지정하지 않았을때
  - 일괄 실행에서 작업을 두번 수행하지 말 것
  - 프로세스 중에 시간이 많이 걸리는 재 할당을 방지하려면 배치 애플리케이션을 시작할 떄 충분한 메모리를 할당할 것
  - 데이터 무결성과 관련하여 항상 최악의 상황을 가정할 것

  



# Batch Processing Strategies

은 패스







# The Domain Language of Batch



![](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/spring-batch-reference-model.png)



- 이 그림은 spring batch의 도메인 언어를 구성하는 주요 개념을 강조함
- 작업에는 일대 다 단계까 있고 정확히 하나의 itemReader, 하나의 ItemPRocessor 및 하나의 ItemWriter가 있음
- 작업을 시작(JobLauncher 사용)하고 현재 실행중인 프로세스에 대한 메타 데이터를 저장해야함 (JobRepository에)





# Job

- Job은 전체 배치 프로세스를 캡슐화하는 엔티티임
- xml 또는 java기반 구성과 함께 연결되고 이 구성을 작업 구성이라고 함
- 다음 다이어그램에 표시된 것처럼Job은 전체 계층 구조의 맨 위에 있음

![](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/job-heirarchy.png)



- Job은 단순히 Step 인스턴스의 컨테이너임
- 하나의 흐름에서 논리적으로 함께 속하는 여러 단계를 결합하고 재시작 가능성과 같은 모든 단계에 전역 속성을 구성할 수 있음
- 작업 구성에는 다음이 포함됨
  - 잡의 간단한 이름
  - stp 인스턴스의 정의 및 순서
  - 작업을 다시 시작할 수 있는지에 대한 여부
- java 구성을 사용하느 ㄴ사욪아를 위해 몇가지 표준 기능을 생성하는 SimpleJob 클래스의 형태로 Job인터페이스의 기본 구현을 제공함
- Java 기반 구성을 사용하는 경우 빌더 타입으로 Job인스턴스화에 사용할 수 있음

```java
@Bean
public Job footballJob() {
    return this.jobBuilderFactory.get("footballJob")
                     .start(playerLoad())
                     .next(gameLoad())
                     .next(playerSummarization())
                     .end()
                     .build();
}
```





# JobInstance

- JobInstance는 논리적 작업 실행의 개념을 나타냄
- Job의 각 개별 실행을 개별적으로 추적해야함
- 이 Job의 경우 하루 하나의 논리적 JobInstance가 있음 예를 들어 1월 1일 실행, 1월 2일 실행 등이 있음
- 1월 1일 실행이 처음에 실패하고 다음날 다시 실행되는 경우 여전히 1월 1일 실행임
- 따라서 각 JobInstance는 여러 번 실행 될 수 있고 특정 Job에 해당하고 JobParameter를 식별하는 하나의 JobInstance만 주어진 시간에 실행할 수 있음
- JobInstance의 정의는 로드 할 데이터와 전혀 관련이 없음
- 데이터 로드는 전적으로 ItemReader 구현에 달려 있음
- 동일한 JobInstance를 사용하면 이전 실행의 상태(ExecutionContext)가 사용되는지 여부가 결정됨
- 새 JobInstance를 사용하는 것은 처음부터 시작을 의미하고 기존 인스턴스를 사용하는 것은 일방적으로 중단한 곳에서의 시작을 의미함

> 아마 meta table에서 계속 관리할 수 있어서겠지 ?







# JobParameters

- JobInstance가 다른것과 어떻게 구별되냐가 질문이라면 바로 JobParameters가 그 답임
- JobParameters 개체에는 일괄 작업을 실행하는 데 사용되는 매개 변수 집합이 있음

![](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/job-stereotypes-parameters.png)

- 1월 1일과 1월 2일에 각각 하나씩 두개의 인스턴스가 있는 앞의 예에서는 실제로 하나의 Job만 있지 작업 매개변수가 다른 두개의 JobParamter 객체가 있음
- 따라서 JobInstance = Job + 식별 JobParameters로 정의할 수 있음 이를 통해 개발자는 전달되는 매개 변수를 제어하므로 JobInstance 저으이 방법을 효과적으로 제어할 수 있음



# JobExecution

- JobExecution은 작업을 실행하려는 단일 시도의 기술적 개념을 나타냄
- 실행은 실패 또는 성공으로 끝날 수 있지만 해당 실행에 해당 하는 JobInstance는 실행이 성공적으로 완료되지 않는 한 완료된 것으로 간주되지 않음
- 첫번째 실행과 동일한 Jobparameters를 사용하여 다시 실행하면 새 JobExecution이 생성됨 그러나 여전히 하나의 JobInstance만 있음

























