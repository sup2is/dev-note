



# DDD Start! 도메인 주도 설계 구현과 핵심 익히기



https://github.com/madvirus/ddd-start





# #1 도메인 모델 시작

- 온라인 서점의 도메인 모델
- 회원, 혜택, 주문, 배송, 결제, 카탈로그, 리뷰, 정산
- 도메인을 직접 개발하지 않고 외부것을 사용해도 됨
- 도메인 마다 고정된 하위 도메인이 존재하는 것은 아님 어떻게 구성할지 여부는 상황 구현에 따라 달라짐



## 도메인 모델

- 기본적으로 도메인 모델은 특정 도메인을 개념적으로 표현한 것

사진1 (객체를 이용한 도메인 모델)

- 도메인을 이해하려면 도메인이 제공하는 기능과 도메인의 주요 데이터 구성을 파악해야함
- 반드시 객체 모델링이 아니라 다이어그램등 으로도 표현 가능함 

사진2 (상태 다이어그램을 이용한 주문 상태 모델링)



- 도메인 모델은 기본적으로 도메인 자체를 이해하기 위한 개념 모델
- 도메인에 따라 용어의 의미가 결정되므로, 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안됨 하위 모델마다 별도로 모델을 만들어야함

## 도메인 모델 패턴

- 일반적으로 애플리케이션의 아키텍처는 다음과 같음
- 사용자 <-> 표현 <-> 응용 <-> 도메인 <->인프라 <-> db

| 계층           | 설명                                                         |
| -------------- | ------------------------------------------------------------ |
| ui, 또는 표현  | 사용자의 요청을 처리하고 사용자에게 정보를 보여줌, 외부 소프트웨어, 사용자가여기에 포함 |
| 응용           | 사용자가 요청한 기능을 실행함. 업무 로직을 직접 구현하지 않고 도메인 계층을 조합해서 기능을 실행함 |
| 도메인         | 시스템이 제공할 도메인의 규칙을 구현함                       |
| 인프라스트럭처 | 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리함 |

- 도메인 모델은 아키텍처상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴을 말함
- 도메인 계층은 도메인의 핵심 규칙을 구현함
- 주문 도메인의 경우 출고 전에 배송지를 변경할 수 있다 는 규칙과 주문 취소는 배송 전에만 할 수 있다 는 규칙을 구현한 코드가 도메인 계층에 위치하게 됨
- 중요한 점은 주문과 관련된 중요 업무 규칙을 주문 도메인 모델인 Order나 OrderState에서 구현한다는 점
- 핵심 규칙을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 됨

**개념 모델과 구현 모델**

- 개념 모델은 순수하게 문제를 분석한 결과물
- 처음부터 완벽한 개념 모델을 만들기 보다는 전반적인 개요를 알 수 있는 수준으로 개념 모델을 작성해야함
- 구현하는 과정에서 개념 모델을 구현 모델로 점진적으로 발전 시켜 나가야함



## 도메인 모델 도출

- 도메인을 모델링 할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성 요소, 규칙, 기능을 찾는 것
- 주문의 경우 다음의 요구사항이 있음
  - 출고 상태로 변경하기
  - 배송지 정보 변경하기
  - 주문 취소하기
  - 결제 완료로 변경하기
- 점진적으로 도메인 모델을 만들어나가고 이를 문서화할 것 문서화된 도메인 모델은 누구나 쉽게 접근할 수 있도록 하면 좋음

## 엔티티와 밸류

- 도출한 모델은 크게 엔티티와 밸류로 구분할 수 있음
- 엔티티와 밸류를 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있기 때문에 이 둘의 차이를 명확하게 이해하는 것은 도메인을 구현하는데 있어 중요함

### 엔티티

- 엔티티의 가장 큰 특징은 식별자를 갖는다는 것
- 식별자는 엔티티 객체마다 고유하고 각 엔티티는 서로 다른 식별자를 가짐
- 주문에서 배송지의 주소가 바뀌거나 상태가 바뀌더라도 주문 번호는 바뀌지 않는 것 처럼 엔티티의 식별자는 바뀌지 않음
- 엔티티를 생성하고 엔티티의 속성을 바꾸고 엔티티를 삭제할 때까지 식별자는 유지됨
- 엔티티의 식별자는 고유하기 때문에 같은 식별자를 갖는다면 두 엔티티는 같다고 판단할 수 있음
- eqauls(), hashcode()를 통해 구현 가능

### 엔티티의 식별자 생성

- 엔티티의 식별자를 생성하는 시점은 도메인의 특징과 사용하는 기술에 따라 달라짐
  - 특정 규칙에 따라 생성
  - uuid
  - 값을 직접 입력
  - 시퀀스나 db의 자동 증가 컬럼 사용, 일련번호
- db의 자동증가 같은 경우는 db 테이블에 직접 삽입하기 전까지는 식별자를 알 수 없음을 참고

### 밸류 타입

- 밸류 타입은 개념적으로 완전한 하나를 표현할 때 사용함
- 예를들어 배송 정보의 클래스 멤버변수에 receiverName 필드와 receiverPhoneNumber라는 필드는 Receiver라는 밸류 타입 클래스로 작성할 수 있음
- 밸류타입을 사용함으로써 개념적으로 완전한 하나를 잘 표현할 수 있음
- 반드시 멤버변수를 두 개 이상 묶지 않아도 의미를 부여할 수 있다면 밸류타입으로 지정해도 좋음
- 밸류 타입의 장점은 밸류 타입을 위한 기능을 밸류타입에 직접 추가할 수 있다는 장점이 있음
- 밸류 타입은 불변으로 생성할 것. 불변으로 사용해서 객체를 안전하게 보장해야함
- 밸류 타입의 객체 비교는 모든 속성이 같은지를 비교해야함

### 엔티티 식별자와 밸류 타입

- 식별자를 위한 밸류 타입을 사용해서 의미를 더 잘 드러내도록 할 수 있음

### 도메인 모델에 set 넣지 않기

- setX()의 경우 도메인 지식을 부여하기 힘듬
- 메서드 명에 도메인 지식을 녹이는게 중요함
- 도메인 객체가 불완전한 상태로 사용되는 것을 막기 위해 생성 시점에 필요한 것을 전달해주어야함
- 밸류타입도 마찬가지로 set 금지
- dto의 경우 예외지만 프레임워크가 직접 값을 할당하는 기능을 제공하면 그 기능을 사용할 것 

## 도메인 용어

- 코드를 작성할 때 도메인에서 사용하는 용어는 매우 중요함
- 도메인 용어를 사용해서 최대한 도메인 규칙을 코드로 작성하도록 할 것
- 알맞은 영어 단어를 찾도록 노력해야함









