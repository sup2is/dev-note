



# DDD Start! 도메인 주도 설계 구현과 핵심 익히기



https://github.com/madvirus/ddd-start





# #1 도메인 모델 시작

- 온라인 서점의 도메인 모델
- 회원, 혜택, 주문, 배송, 결제, 카탈로그, 리뷰, 정산
- 도메인을 직접 개발하지 않고 외부것을 사용해도 됨
- 도메인 마다 고정된 하위 도메인이 존재하는 것은 아님 어떻게 구성할지 여부는 상황 구현에 따라 달라짐



## 도메인 모델

- 기본적으로 도메인 모델은 특정 도메인을 개념적으로 표현한 것

사진1 (객체를 이용한 도메인 모델)

- 도메인을 이해하려면 도메인이 제공하는 기능과 도메인의 주요 데이터 구성을 파악해야함
- 반드시 객체 모델링이 아니라 다이어그램등 으로도 표현 가능함 

사진2 (상태 다이어그램을 이용한 주문 상태 모델링)



- 도메인 모델은 기본적으로 도메인 자체를 이해하기 위한 개념 모델
- 도메인에 따라 용어의 의미가 결정되므로, 여러 하위 도메인을 하나의 다이어그램에 모델링하면 안됨 하위 모델마다 별도로 모델을 만들어야함

## 도메인 모델 패턴

- 일반적으로 애플리케이션의 아키텍처는 다음과 같음
- 사용자 <-> 표현 <-> 응용 <-> 도메인 <->인프라 <-> db

| 계층           | 설명                                                         |
| -------------- | ------------------------------------------------------------ |
| ui, 또는 표현  | 사용자의 요청을 처리하고 사용자에게 정보를 보여줌, 외부 소프트웨어, 사용자가여기에 포함 |
| 응용           | 사용자가 요청한 기능을 실행함. 업무 로직을 직접 구현하지 않고 도메인 계층을 조합해서 기능을 실행함 |
| 도메인         | 시스템이 제공할 도메인의 규칙을 구현함                       |
| 인프라스트럭처 | 데이터베이스나 메시징 시스템과 같은 외부 시스템과의 연동을 처리함 |

- 도메인 모델은 아키텍처상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴을 말함
- 도메인 계층은 도메인의 핵심 규칙을 구현함
- 주문 도메인의 경우 출고 전에 배송지를 변경할 수 있다 는 규칙과 주문 취소는 배송 전에만 할 수 있다 는 규칙을 구현한 코드가 도메인 계층에 위치하게 됨
- 중요한 점은 주문과 관련된 중요 업무 규칙을 주문 도메인 모델인 Order나 OrderState에서 구현한다는 점
- 핵심 규칙을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 됨

**개념 모델과 구현 모델**

- 개념 모델은 순수하게 문제를 분석한 결과물
- 처음부터 완벽한 개념 모델을 만들기 보다는 전반적인 개요를 알 수 있는 수준으로 개념 모델을 작성해야함
- 구현하는 과정에서 개념 모델을 구현 모델로 점진적으로 발전 시켜 나가야함



## 도메인 모델 도출

- 도메인을 모델링 할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성 요소, 규칙, 기능을 찾는 것
- 주문의 경우 다음의 요구사항이 있음
  - 출고 상태로 변경하기
  - 배송지 정보 변경하기
  - 주문 취소하기
  - 결제 완료로 변경하기
- 점진적으로 도메인 모델을 만들어나가고 이를 문서화할 것 문서화된 도메인 모델은 누구나 쉽게 접근할 수 있도록 하면 좋음

## 엔티티와 밸류

- 도출한 모델은 크게 엔티티와 밸류로 구분할 수 있음
- 엔티티와 밸류를 제대로 구분해야 도메인을 올바르게 설계하고 구현할 수 있기 때문에 이 둘의 차이를 명확하게 이해하는 것은 도메인을 구현하는데 있어 중요함

### 엔티티

- 엔티티의 가장 큰 특징은 식별자를 갖는다는 것
- 식별자는 엔티티 객체마다 고유하고 각 엔티티는 서로 다른 식별자를 가짐
- 주문에서 배송지의 주소가 바뀌거나 상태가 바뀌더라도 주문 번호는 바뀌지 않는 것 처럼 엔티티의 식별자는 바뀌지 않음
- 엔티티를 생성하고 엔티티의 속성을 바꾸고 엔티티를 삭제할 때까지 식별자는 유지됨
- 엔티티의 식별자는 고유하기 때문에 같은 식별자를 갖는다면 두 엔티티는 같다고 판단할 수 있음
- eqauls(), hashcode()를 통해 구현 가능

### 엔티티의 식별자 생성

- 엔티티의 식별자를 생성하는 시점은 도메인의 특징과 사용하는 기술에 따라 달라짐
  - 특정 규칙에 따라 생성
  - uuid
  - 값을 직접 입력
  - 시퀀스나 db의 자동 증가 컬럼 사용, 일련번호
- db의 자동증가 같은 경우는 db 테이블에 직접 삽입하기 전까지는 식별자를 알 수 없음을 참고

### 밸류 타입

- 밸류 타입은 개념적으로 완전한 하나를 표현할 때 사용함
- 예를들어 배송 정보의 클래스 멤버변수에 receiverName 필드와 receiverPhoneNumber라는 필드는 Receiver라는 밸류 타입 클래스로 작성할 수 있음
- 밸류타입을 사용함으로써 개념적으로 완전한 하나를 잘 표현할 수 있음
- 반드시 멤버변수를 두 개 이상 묶지 않아도 의미를 부여할 수 있다면 밸류타입으로 지정해도 좋음
- 밸류 타입의 장점은 밸류 타입을 위한 기능을 밸류타입에 직접 추가할 수 있다는 장점이 있음
- 밸류 타입은 불변으로 생성할 것. 불변으로 사용해서 객체를 안전하게 보장해야함
- 밸류 타입의 객체 비교는 모든 속성이 같은지를 비교해야함

### 엔티티 식별자와 밸류 타입

- 식별자를 위한 밸류 타입을 사용해서 의미를 더 잘 드러내도록 할 수 있음

### 도메인 모델에 set 넣지 않기

- setX()의 경우 도메인 지식을 부여하기 힘듬
- 메서드 명에 도메인 지식을 녹이는게 중요함
- 도메인 객체가 불완전한 상태로 사용되는 것을 막기 위해 생성 시점에 필요한 것을 전달해주어야함
- 밸류타입도 마찬가지로 set 금지
- dto의 경우 예외지만 프레임워크가 직접 값을 할당하는 기능을 제공하면 그 기능을 사용할 것 

## 도메인 용어

- 코드를 작성할 때 도메인에서 사용하는 용어는 매우 중요함
- 도메인 용어를 사용해서 최대한 도메인 규칙을 코드로 작성하도록 할 것
- 알맞은 영어 단어를 찾도록 노력해야함





# #2 아키텍처 개요

## 네 개의 영역

- 아키텍처를 설계할 때 출현하는 전형적인 영역이 표현, 응용, 도메인, 인프라임
  - 표현
    - 사용자의 요청을 받아 응용 영역에 전달하고 다시 결과를 보여주는 역할
    - ex) Spring MVC 
    - 웹 애플리케이션의 경우 http를 사용함
  - 응용
    - 시스템이 사용자에게 제공해야 할 기능을 구현함
    - 도메인 영역의 도메인 모델을 사용함
    - 응용 서비스는 로직을 직접 수행하기 보다는 도메인 모델에 로직 수행을 위임함
    - ex) order.cancel() 호출
  - 도메인
    - 도메인 영역은 실제 도메인 모델을 구현함
  - 인프라
    - 구현 기술에 대한 것을 다룸
    - dbms 연동, 메시징 큐, nosql 등등을 사용하여 처리함

## 계층 구조 아키텍처

- 표현 -> 응용 -> 도메인 -> 인프라 순서대로 의존함 예를 들어 인프라는 표현계층은 응용계층에 의존하지만 도메인계층은 응용계층에 의존하지 않음 이런 방식으로 해야 계층 구조를 엄격하게 가져갈 수 있음
- 구현을 조금 더 편리하게 하기 위해서 구조를 유연하게 가져갈 수 있음 예를 들어 응용 서비스 단에서 인프라 계층에 의존하기도 함
- 인프라에 의존하면 테스트의 어려움과 기능확장의 어려움이라는 두가지 문제가 발생함 dip로 이 문제를 해결할 수 있음

## DIP

- 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야함. 하지만 고수준 모듈이 저수준 모듈을 사용하면 계층 구조 아키텍처에서의 테스트의 어려움, 기능 확장의 어려움이라는 두가지 문제가 발생함
- dip는 위 문제를 해갈하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꿈
- 저수준 모듈이 고수준 모듈에 의존하도록 하려면 추상화한 인터페이스를 사용하면 됨
- 의존 계층을 중간에 하나 더 둬서 고수준 모듈이 중간 의존 계층을 사용하도록 하면 됨

### DIP 주의사항

- dip의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함임
- 저수준 모듈에서 인터페이스를 추출하면 안됨 애플리케이션 개발자가 제어할 수 있도록 해야함

### DIP와 아키텍처

- 인프라는 저수준모듈, 응용영역과 도메인 영역은 고수준 모듈임
- 아키텍처 수준에서 dip를 적용하면 인프라영역이 응용 영역과 도메인 영역에 의존하는 구조가 됨
- 저수준 모듈에 직접적으로 의존성을 맺지 말고 저수준모듈과 고수준모듈 사이에 인터페이스를 두어 유연하게 프로그래밍 할 수 있음

## 도메인 영역의 주요 구성 요소



| 요소          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| 엔티티        | 고유 식별자를 갖는 객체, 자신의 라이프사이클이 있고 주문, 상품과 같이 도메인의 고유한 개념을 표현함. 도메인 모델의 데이터를 포함하며 해당데이터와 관련된 기능을 함께 제공함 |
| 밸류          | 고유의 식별자를 갖지 않는 객체. 주로 개념적으로 하나인 도메인 객체의 속성을 표현할 때 사용함. 주소를 표현하기 위한 주소, 동호수 등등 엔티티 속성뿐만 아니라 다른 밸류 타입의 속성으로도 사용될 수 있음 |
| 애그리거트    | 애그리거트는 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 주문 애그리거트로 묶을 수 있음 |
| 리포지터리    | 도메인 모델의 영속성을 처리함. dbms의 crud를 담당함          |
| 도메인 서비스 | 특정 엔티티에 속하지 않은 도메인 로직을 제공함. 예를 들면 할인 금액 계산은 상품, 쿠폰, 회원 등급 등 다양한 조건을 이용해서 구현함 |

### 엔티티와 밸류

- 도메인 모델과 db테이블의 가장 다른점은 도메인 모델은 데이터 + 도메인 기능을 함께 제공한다는 것
- 추가적으로 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다는 것
- 밸류타입은 불변으로 할 것

### 애그리거트

- 도메인이 커질수록 개발할 도메인 모델도 커지면서 많은 엔티티와 밸류가 출현함
- 도메인 모델 전체 구조를 이해하는데 도움이 되는것이 바로 애그리거트임
- 도메인 모델이 복잡해지면 개발자가 전체 구조가 아닌 한 개의 엔티티와 밸류에만 집중하게 되는 경우가 발생하는데 이때 애그리거트를 사용함
- 애그리거트는 관련 객체를 하나로 묶은 군집. 대표적으로 주문이라는 도메인 개념은 주문, 배송지 정보, 주문자 등등의 하위 모델로 구성되는데 이때 이 하위 개념을 표현한 모델을 하나로 묶어서 주문 이라는 사우이 개념으로 표현할 수 있음
- 애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있게됨
- 애그리거트를 통해 큰 틀에서 도메인 모델을 관리할 수 있게 됨
- 애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖고 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류  객체를 이용해서 애그리거트가 구현해야 할 기능을 제공함
- 애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 실행하고 애그리거트 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근하게 됨 이는 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화 할 수 있도록 도와줌 <- Order라는 공개된 엔티티를 통해 내부에 숨겨진 밸류타입으로 구현한다는 뜻인듯

### 리포지터리

- 도메인 객체를 지속적으로 사용하려면 RDBMS, NoSQL, 로컬 파일과 같은 물리적인 저장소에 도메인 객체를 보관해야함 이를 위한 도메인 모델이 리포지터리임
- 리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의함
- 리포지터리 인터페이스는 도메인 모델 영역에 속하고 실제 구현 클래스는 인프라 영역에 속함 ex JPA Hibernate
- 응용 서비스와 리포지터리의 밀접한 연관
  - 응용 서비스는 필요한 도메인 객체를 구하거나 저장할 때 리포지터리를 사용함
  - 응용 서비스는 트랜잭션을 관리하는데 트랜잭션 처리는 리포지터리 구현 기술에 영향을 받음
- 리포지터리의 사용 주체가 응용 서비스라서 리포지터리는 응용 서비스가 필요로하는 메서드를 제공함 ex CRUD

## 요청 처리 흐름

- 사용자가 앱에 기능 실행을 요청하면 그 요청을 처음 받는 영역은 표현 영역임 스프링 mvc라면 컨트롤러가 사용자의 요청을 받음
- 표현 영역은 사옹자의 데이터가 올바른지 검사하고 문제가 없다면 응용 서비스에 기능 실행을 위임함 이때 사용자의 데이터를 응용 서비스의 인터페이스에 맞춰서 데이터를 변환함
- 응용 서비스는 도메인 모델을 이용해서 기능을 구현함

## 인프라스트럭처 개요

- 인프라는 표현, 응용, 도메인 영역을 지원함
- dip로 유연하게 구성하는 것이 시스템을 더 유연하게 만들어줌
- dip를 반드시 피하지 말고 적절하게 인프라, 프레임워크에 의존을 두는것도 좋음 예를들면 @Transactional

## 모듈 구성

- 도메인이 작다면 하나의 com.example에 몰아넣고 도메인이 크다면 com.example.aaa.service, com.example.bbb.service 형태로 구성해도 됨
- 한 패키지에 너무 많은 타입이 몰려서 코드를 찾을 때 불편한 정도만 아니면 됨

# #3 애그리거트

## 애그리거트

- 도메인 모델 이전에 상위 모델 먼저 이해할 것
- 복잡한 도메인을 이해하고 관리 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데 이 방법이 바로 애그리거트임
- 애그리거트는 관련된 객체를 하나의 군으로 묶어줌
- 애그리거트를 사용하면 모델 간의 관계를 개별 모델 수준뿐만 아니라 상위 수준에서도 이해할 수 있음
- 애그리거트는 모델을 이해하는데 도움을 줄 뿐 아니라 일관성을 관리하는 기준이 됨
- 한 애그리거트에 속한 객체들은 거의 유사하거나 동일한 라이프사이클을 가짐
- 한 애그리거트에 속핸 각체들은 다른 애그리거트에 속하지 않음
- 애그리거트는 독립된 객체 군, 각각 자기만 관리하고 다른 애그리거트는 관리하지 않음
- 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항임. 도메인 규칙에 따라 함께 생성되는 구성 요소는 한 애그리거트에 속할 가능성이 높음
- 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높지만 반드시 이 법칙이 적용되는 것은 아님
- 대체로 하나의 애그리거트가 하나의 엔티티 객체를 가짐

## 애그리거트 루트

- 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이어서는 안됨 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상인 상태를 가져야함
- 애그리거트에 속한 모든 객체가 일관성을 가진 상태를 유지하려면 이 책임을 지는 루트가 필요한데 이게 바로 애그리거트 루트임
- 애그리거트의 대표 엔티티가 애그리거트 루트
- 예를들면 Order 엔티티가 주문정보, 배송정보 등등을 관리함

### 도메인 규칙과 일관성

- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것
- 애그리거트 루트에서 도메인 기능을 제공해야함
- 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안됨 <- 일관성을 깨는 원인
- 불필요한 중복과 일관성을 깨지 않도록 하려면 다음과 같은 원칙이 필요함
  - 단순히 필드를 변경하는 set 메서드를 공개범위로 만들지 않음
  - 밸류 타입은 불변으로 구현
- 밸류타입의 내부 상태 변경은 애그리거트 루트를 통해서만 가능함

### 애그리거트 루트의 기능 구현

- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성함
- 밸류타입은 무조건 불변타입으로 작성할 것 불가능하다면 변경기능을 패키지, protected 범위로 한정해서 외부에서 실행할 수 없도록 제한할 것

### 트랜잭션 범위

- 트랜잭션 범위는 작을수록 좋음
- 테이블락 기준에서도 하나의 비지니스 로직에서 한개를 잠그는것과 세개를 잠그는 것은 다름
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 함 <- 애그리거트에서 다른 애그리거트를 변경하지 않는다는 뜻
- 한 애그리거트 내부에서 다른 애그리거트 내부를 변경하는 경우는 절대 없어야함
- 부득이하게 한 트랜잭션에서 두개 이상의 애그리거트의 수정이 필요하다면 도메인 레벨에서가 아니라 응용 서비스 레벨에서 다뤄져야함
- 다음의 경우 이례적으로 한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있음
  - 팀 표준: 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우가 있을 때
  - 기술 제약: 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하는 대신 도메인 이벤트와 비동기를 사용하는 방식을 사용하는데 기술적으로 이벤트 방식을 도입할 수 없는 경우
  - UI 구현의 편리: 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을때

## 리포지터리와 애그리거트

- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재함
- 기본적으로 save, findById 메서드가 리포지터리의 기본 메서드임
- 리포지터리는 애그리거트 전체를 저장소에 영속화해야함
- 리포지터리가 애그리거트 전체를 관리하지 않으면 NPE같은 에러가 발생할 수 있음

## ID를 이용한 애그리거트 참조

- 한 객체가 다른 객체를 참조하는 것처럼 애그리거트도 다른 애그리거트를 참조함
- A애그리거트 루트에서 B애그리거트 루트를 참조
- JPA에서 @ManyToOne 같은 애너테이션으로 쉽게 구현 가능함
- 필드를 이용한 애그리거트 참조는 다음 문제를 야기함
  - 편한 탐색 오용
  - 성능 확장에 대한 고민
  - 확장 어려움
- 위 문제를 해결할 수 있는 방법은 id를 이용해서 애그리거트를 참조하는 것. 객체 레퍼런스가 아니라 다른 애그리거트 루트의 id를 참조
- 위 방법을 사용하면 모델 간 복잡도를 낮춰주고 편한 탐색 오용같은 문제, 성능 확장 문제 등등을 해결해줄 수 있음
- id를 이용한 애그리거트 참조를 이용하면 애그리거트 별로 다른 기술을 사용하는 것도 가능해짐

### ID를 이용한 참조와 조회 성능

- 여러 애그리거트를 읽을때 조회성능에 문제가 생길 수 있음
- N+1문제가 발생할 수 있으므로 조인같은 전략을 사용해서 풀어나가야함
- 조회부분만 mybatis로 실행할수도 있음
- 캐시나 조회 전용 저장소 등등을 사용할수도 있음

## 애그리거트 간 집합 연관

- 카테고리와 상품처럼 1:N 관계에 대한 이야기
- 애그리거트간의 1:N관계는 실무에서 페이징같은 경우를 생각했을때 N 전체를 가져야한다는 문제가 있어서 잘 사용하지 않고 N:1 형태로 관리함
- 실제구현에서는 M:N도 단방향 M:N으로 구현하면 됨

```
public class Product{
	private Set<CategoriyId> categoryIds;
}
```

## 애그리거트를 팩토리로 사용하기

- 팩토리 메서드에서도 중요한 도메인 로직을 구현할 수 있음
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 할때는 팩토리 메서드를 구현하는 것을 고려할 것

# #4 리포지터리와 모델구현

## JPA를 이용한 리포지터리 구현

### 모듈 위치

### 리포지터리 기본 기능 구현

## 매핑 구현

### 엔티티와 밸류 기본 매핑 구현

### 기본 생성자

### 필드 접근 방식 사용

### AttributeConverter를 이용한 밸류 매핑 처리

### 밸류 컬렉션: 별도 테이블 매핑

### 밸류 컬렉션: 한 개 칼럼 매핑

### 밸류를 이용한 아이디 매핑

### 별도 테이블에 저장하는 밸류 매핑

### 밸류 컬렉션을 @Entity로 매핑하기

### ID참조와 조인 테이블을 이용한 단방향 M-N 매핑

## 애그리거트 로딩 전략

## 애그리거트의 영속성 전파

## 식별자 생성 기능



# #5 리포지터리의 조회 기능(JPA 중심)

## 검색을 위한 스펙

### 스펙 조합

## JPA를 위한 스펙 구현

### JPA 스펙 구현

### AND/OR 스펙 조합을 위한 구현

### 스펙을 사용하는 JPA 리포지터리 구현

## 정렬 구현

## 페이징 개수 구하기 구현

## 조회 전용 기능 구현

### 동적 인스턴스 생성

### 하이버네이트 @Subselect 사용



# #6 응용 서비스와 표현 영역

## 표현 영역과 응용 영역

## 응용 서비스의 역할

### 도메인 로직 넣지 않기

## 응용 서비스의 구현

### 응용 서비스의 크기

### 응용 서비스의 인터페이스와 클래스

### 메서드 파라미터와 값 리턴

### 표현 영역에 의존하지 않기

### 트랜잭션 처리

### 도메인 이벤트 처리

## 표현 영역

## 값 검증

## 권한 검사

## 조회 전용 기능과 응용 서비스



# #7 도메인 서비스

## 여러 애그리거트가 필요한 기능

## 도메인 서비스

### 도메인 서비스의 패키지 위치

## 도메인 서비스의 인터페이스와 클래스



# #8 애그리거트 트랜잭션 관리

## 애그리거트와 트랜잭션

## 선전 잠금

### 선전 잠금과 교착 상태

## 비선점 잠금

### 강제 버전 증가

## 오프라인 선점 잠금

### 오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스

### DB를 이용한 LockManager 구현



# #9 도메인 모델과 BOUNDED CONTEXT

## 도메인 모델과 경계

## BOUNDED CONTEXT

## BOUNDED CONTEX의 구현

## BOUNDED CONTEXT 간 통합

## BOUNDED CONTEXT 간 관계

## 컨텍스트 맵





# #10 이벤트

## 시스템 간 강결합의 문제

## 이벤트 개요

### 이벤트 관련 구성요소

### 이벤트의 구성

### 이벤트 용도

### 이벤트 장점

## 이벤트, 핸들러, 디스패처 구현

### 이벤트 클래스

### EventHandler 인터페이스

### 이벤트 디스패처인 Event 구현

### 흐름 정리

### AOP를 이용한 Events.reset() 실행

## 동기 이벤트 처리 문제

## 비동기 이벤트 처리

### 로컬 핸들러의 비동기 실행

### 메시징 시스템을 이용한 비동기 구현

### 이벤트 저장소를 이용한 비동기 처리

### 이벤트 저장소 구현

### 이벤트 저장을 위한 이벤트 핸들러 구현

### REST API 구현

### 포워더 구현

## 이벤트 적용 시 추가 고려사항

# #11 CQRS

## 단일 모델의 장점

## CQRS

### 웹과 CQRS

### CRQS 장단점

















