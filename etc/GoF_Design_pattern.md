





# #1 서론

## 디자인 패턴이란?

- 하나의 패턴에는 다음의 네가지요소가 반드시 들어가 있음
  1. **패턴 이름(pattern name)**은 한 두단 어로 설계 문제와 해법을 서술함 패턴에 이름을 부여하는 것은 설계 어휘 늘리는 일이며, 높은 수준의 추상화된 설계를 할 수 있도록 해줌. 이름을 통해 설계의 의도를 표현하고 생각을 더욱 쉽게, 의사소통을 쉽게할 수 있음 따라서 좋은 이름을 만들어야함
  2. **문제(problem)**는 어떤 패턴을 사용하는가를 서술하며 해결할 문제와 그 배경을 설명함 즉 어떤 알고리즘을 객체로 만들까 와 같은 설계의 세밀한 문제를 설명할 수 있음 때론 유연성 없는 설계가 될 징조를 보이는 클래스나 객체의 구조를 제시하고 문제를 제시함으로써 패턴을 적용하는 것이 의미 있는 사례들을 정의하기도함
  3. **해법(solution)**은 설계를 구성하는 요소들과 그 요소들 간의 관계, 책임 그리고 협력 관계를 서술함.그렇다고 해법이 어떤 구체적인 설계나 구현을 설명하지는 않고 디자인 패턴은 문제에 대한 추상적인 설명을 제공하고 문제를 해결하기 위해서 클래스나 객체들의 나열 방법을 제공함
  4. **결과(consequence)** 는 디자인 패턴을 적용해서 얻는 결과와 장단점을 서술함.
- 디자인패턴은 연결 리스트와 해시 테이블 등을 클래스로 표현하고 그것 자체로 다시 쓸 수 있도록 설계하는 문제를 어떻게 푸느냐에 관한 것이 아님
- 디자인 패턴은 특정한 전후 관계에서 일반적설계 문제를 해결하기 위해 상호 교류하는 수정 가능한 객체와 클래스들에 대한 설명임



## 스몰 토크 MVC를 사용한 디자인 패턴

- MVC는 에서 M은 Model, 응용프로그램 객체이고 View는 스크린에 모델을 디스플레이하는 방법이며, Controller는 사용자 인터페이스가 사용자 입력에 반응하는 방법을 정의함
- 뷰는 그 외형이 반드시 모델의 상태를 반영하도록 보장해야함
- 이런 설계 방법은 더 일반적인 문제에서도 적용 가능한데 즉 한 객체에서 일어난 변경을 다른 객체들에게 반영하도록 별도의 객체를 둠으로써 변경이 일어난 객체는 변경 반영이 필요한 다른 객체들을 알 필요가  없게끔 객체를 분리함 <- 일반화한것이 옵저버 패턴
- 일반적으로 단일 객체처럼 복합 객체를 사용하고 싶을 때가 많음 <- 일반화한것이 컴포지트 패턴
- 뷰와 컨트롤러 관계는 전략 패턴의 한 예임 전략 패턴은 알고리즘을 표현하는 객체로 정적 또는 동적으로 알고리즘을 대체하고자 할 때 매우 유용한 방식
- 팩토리 메서드 패턴을 이용해서 뷰에 대한 기분 컨트롤러 클래스를 지정, 장식자 패턴을 이용해서 뷰에 스크롤을 추가함 등등 
- MVC에서 주로 사용하는 패턴은 감시자, 복합체, 전략 패턴임



## 디자인 패턴을 이용하여 문제를 푸는 방법



### 적당한 객체 찾기

- 객체지향 프로그램은 객체로 만듬. 객체는 데이터와 이 데이터에 연산을 가하는 프로시저(메서드, 연산)를 함께 묶은 단위임. 객체는 요청 또는 메시지를 사용자에게 받으면 연산을 수행함
- 디자인 패턴은 덜 명확한 추상적 개념과 이것을 잡아낸 객체를 알아보는데에 도움을 줌
- 객체를 잘 설계해야한다라는 말을 하는것 같음

### 객체의 크기 결정

- 객체의 크기 또한 디자인 패턴에서 이 문제의 답을 얻을 수 있음
- 퍼사드패턴은 서브시스템을 어떻게 객체로 표현할 수 있는지 설명하고, 플라이급 패턴은 규모는 작지만 개수는 많은 객체를 다루는 방법을 설명함 등등



### 객체 인터페이스의 명세

- 객체가 선언하는 모든 연산은 연산의 이름, 매개변수로 받아들이는 객체들, 연산의 반환값을 명세함 이를 연산의 시그니처라고함 
- 인터페이스는 객체가 정의하는 모든 시그니처들을 일컫는 말이고 객체 인터페이스는 객체가 받아서 처리할 수 있는 연산의 집합임
- 타입은 특정 인터페이스를 나타낼 때 사용하는 이름임 객체가 "Window" 타입을 갖는다는 것은 "Window" 인터페이스에 정의한 연산들을 모두 처리할 수 있다는 것을 의미함.
- 객체는 여러 타입을 가질 수 있고 서로 다른 객체가 하나의 타입을 공유할 수 있음
- 부모 자식 관계에따라 이를 서브타입 슈퍼타입이라고 부름
- 인터페이스의 개념은 객체지향 시스템에서 가장 기본적인 것임 외부에서 객체를 알 수 있는 방법이 인터페이스이기 때문에 인터페이스를 통해서만 처리를 요청할 수 있음
- 동일한 인터페이스를 갖는 두 객체가 완전히 다른 구현을 가질 수 있음
- 어떤 요청과 그 요청을 처리할 객체를 프로그램 런타임 시점에 연결 짓는 것을 동적 바인딩이라고 함
- 동적바인딩은 요청이 어떻게 구현되어 어떤 결과를 만들어 낼지를 런타임에 결정할 수 있음을 의미함
- 즉 프로그램을 작성할 때 객체가 어떤 특정 인터페이스를 갖도록 작성하며 이 객체는 요청을 처리할 정확한 인터페이스를 갖고 있고 동적 바인딩으로 프로그램이 기대하는 객체를 동일한 인터페이스를 갖는 다른 객체로 대체할 수 있을때 이런 대체성을 우리는 다형성이라고 부름
- 다형성은 객체지향 시스템의 핵심 개념임
- 다형성은 사용자의 정의를 단순화하고 객체 간의 결합도를 없애며, 프로그램 실행 중에는 서로 간의 관련성을 다양화할 수 있게 해줌
- 디자인 패턴은 인터페이스에 정의해야 하는 중요 요소가 무엇이고 어떤 종류의 데이터를 주고받아야 하는지 식별하여 인터페이스를 정의하도록 도와줌

### 객체 구현 명세하기

- 어떤 객체의 구현은 클래스에서 정의함 클래스는 객체의 내부 데이터와 표현 방법을 명세하고 그 객체가 수행할 연산을 정의함 
- 객체는 클래스를 인스턴스로 만듦으로써 생성됨 즉 객체는 클래스의 인스턴스임
- 새로운 클래스는 기존 클래스에 기반을 둔 클래스를 상속하여 정의할 수 있음
- 서브클래스는 부모클래스가 정의한 연산을 모두 수행할 수 있음
- 추상클래스는 모든 서브클래스 사이의 공통되는 인터페이스를 정의함
- 정의만하고 구현하지 않는 연산을 추상 연산이라하고 추상클래스가 아닌 클래스를 구체클래스라고함
- 서브클래스는 부모클래스가 정의한 행동을 재정의하거나 정제할 수 있는데 이것을 오버라이드라고 부름
- 믹스인 클래스는 다른 클래스들에게 선택적인 인터페이스 혹은 기능을 제공하려는 목적을 가진 클래스임 인스턴스로 만들 의도가 없다는 면에서 추상 클래스와 비슷함 <- 주로 이벤트 인터페이스를 설명하는것 같음

**클래스 상속 vs 인터페이스 상속**

- 객체의 클래스는 그 객체가 어떻게 구현되느냐를 정의함
- 객체의 타입은 그 객체의 인터페이스, 즉 그 객체가 응답할 수 있는 요청의 집합을 정의함
- 객체의 구현은 다를지라도 인터페이스는 같을 수 있음
- 클래스 상속은 코드와 내부 표현 구조를 공유하는 메커니즘임
- 인터페이스 상속은 어떤 객체가 다른 객체 대신에 사용될 수 있는 경우를 지정하느 메커니즘임



**구현에 따르지 않고, 인터페이스에 따르는 프로그래밍**

- 클래스 상속은 기본적으로 부모 클래스에서 정의한 구현을 재사용하여 응용프로그램의 기능성을 확장하려는 메커니즘임
- 상속이 가진 다른기능들 중에는 동일한 인터페이스를 갖는 객체군을 정의하는 것이 있는데 매우 중요한 특징임 <- 다형성
- 상속을 적절하게 이용하면 모든 클래스는 추상 클래스를 상속하도록 하여 인터페이스를 공유할 수 있게 됨
- 모든 서브클래스들은 추상 클래스에 정의한 인터페이스를 처리할 수 있음 
- 추상클래스를 정의하고 인터페이스 개념으로 객체를 다룰 때 얻을 수 있는 두가지 이점
  1. 사용자가 원하는 인터페이스를 그 객체가 만족하고 잇는 한, 사용자는 그들이 사용하는 특정 객체 타입에 대해 알아야 할 필요는 없음
  2. 사용자는 이 객체들을 구현하는 클래스를 알 필요가 없고, 단지 인터페이스를 정의하는 추상 클래스가 무엇인지만 알면 됨
- **구현이 아닌 인터페이스에 따라 프로그래밍 합니다.**

### 재사용을 실현 가능한 것으로

**상속 대 합성**

- 객체지향 시스템에서 기능의 재사용을 위해 구사하는 가장 대표적인 기법은 클래스 상속, 그리고 객체 합성임
- 서브클래싱에 의한 재사용을 화이트박스 재사용이라고함 화이트박스는 내부를 볼 수 있다는 의미를 가짐 상속을 받으면 부모클래스의 내부가 서브클래스에 의해 공개되기때문에 이런 용어를 씀
- 객체 합성은 클래스 상속에 대한 대안임 다른 객체를 여러개 붙여서 새로운 기능 혹은 객체를 구성하는 것. 객체를 합성하려면 합성에 들어가는 객체들의 인터페이스를 명확하게 정의해두어야함 이런 스타일의 재사용을 블랙바스 재사용이라고하는데 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문임
- 상속과 합성은 서로 장단점이 있음
- 클래스 상속은 컴파일 시점에 정적으로 정의도고 프로그래밍언어가 직접 지원하므로 그래도 사용하면 됨
- 클래스 상속의 단점 중 첫번째는 런타임에 상속받은 부모클래스의 구현을 변경할 수는 없다는 점임 <- 컴파일 시점에 결졍되기 때문
- 두번째단점은 부모 클래스는 서브클래스의 물리적 표현의 최소 부분만을 정의하기 때문에 서브클래스는 부모 클래스가 정의한 물리적 표현들을 전부 또는 일부 상속받는다는 점 부모에서 변경되면 서브에서도 변경되어야함
- 이런 단점을 보완하기 위해서는 추상클래스만을 부모타입으로 두는게 적절함. 추상클래스는 실제 구현이 없기 때문
- 객체의 합성은 한 객체가 다른 객체에 대한 참조자를 얻는 방식으로 런타임에 동적으로 정의됨
- 합성은 객체가 다른 객체의 인터페이스만을 바라보게 하기 때문에 인터페이스 저으이 더 많은 주의를 기울여야함 객체는 인터페이스에서만 접근하므로 캡슐화를 유지할 수 있음 동일 타입이면 런타임에 다른 객체로 대체 가능 
- 상속과 합성은 각자 장단점이 있음 적절히 조합되어야만 완벽한 재사용이 가능함

**위임**

- 위임은 합성을 상속만큼 강력하게 만드는 방법임 위임에서는 두 객체가 하나의 요청을 처리함 수신 객체가 연산의 처리를 위임자에게 보내면 이는 서브클래스가 부모 클래스에게 요청을 전달하는 것과 유사한 방식임
- 위임의 가장 중요한 장점은 런타임에 행동의 복합을 가능하게하고 복합하는 방식도 변경해준다는 것임
- 위임이 갖는 단점은 객체 합성을 통해 소프트웨어 설계의 유연성을 보장하는 방법과 동일하게 동적인데다가 고도로 매개변수화된 소프트웨어는 정적인 소프트웨어 구조보다 이해하기가 더 어렵다는 것임 그 이유는 정적이지 않고 프로그램 내부에서 동적이기 때문임
- 상태, 전략, 방문자 패턴에서 위임 방식을 사용함

**상속 대 매개변수화된 타입**

- 기능의 재사용에 이용할 수 있는 다른 방법을 매개변수화된 타입이라고 함



### 런타임 및 컴파일 타임의 구조를 관계 짓기

- 컴파일 시점의 구조와 런타임의 구조간에 차이가 있기 때문에 코드 자체가 시스템의 동작 방법을 모두 보여줄수는 없음
- 시스템의 런타임 구조는 언어가 아닌 설계자가 만들고 객체와 타입 사이의 관계는 대단히 세심하게 설계해야함
- 많은 디자인 패턴이 컴파일 시점과 런타임의 구조를 명시적으로 구분하고 있음



### 변화에 대비한 설계

- 재사용을 최대화 하기 위해서는 새로운 요구 사항과 기존 요구 사항에 발생한 변경을 예측하여 앞으로의 시스템 설계가 진화할 수 있도록 해야 함
- 변화에 잘 대응하기 위한 소프트웨어를 설계하기 위해서는 소프트웨어를 운영하는동안 앞으로 일어날 변화를 어떻게 수용할 것인가를 미리 고려해야함
- 예측하지 못한 변경에 대해서는 엄청나게 비싼 대가를 지불할 수 밖에 없음
- 디자인 패턴은 어떤 구체적인 원인으로 앞으로 시스템을 변경해야 한다는 것을 미리 보여줌으로써 이런 위험을 줄여줌
- 디자인 패턴을 써서 재설계를 할 수밖에 없게 하는 흔한 이유
  1. **특정 클래스에서 객체 생성:** 객체를 생성할 때 클래스 이름을 명시하면 어떤 특정 인터페이스가 아닌 어떤 특정 구현에 종속됨. 이런 종속은 앞으로의 변화를 수용하지 못함. 이르 ㄹ방지하려면 객체를 직접 생성해서는 안됨. <- 추상 팩토리, 팩토리 메서드, 원형
  2. **특정 연산에 대한 의존성:** 특정한 연산을 사용하려면 요청을 만족하는 한가지 방법에만 매이게 됨. 요청의 처리 방법을 직접 코딩하는 방식을 피하면 컴파일 시점과 런타임 모두를 만족하면서 요청 처리 방버을 쉽게 변경할 수 있음 <- 책임 연쇄, 명령
  3. **하드웨어와 소프트웨어 플랫폼에 대한 의존성:** 플랫폼 종속성을 제거하는 것은 시스템 설계에 있어서 매우 중요함 <- 추상 팩토리, 가교
  4. **객체의 표현이나 구현에 대한 의존성:** 사용자가 객체의 표현 방법, 저장 방법, 구현 방법, 존재의 위치에 대한 몯느 방법을 알고 있다면 객체르 ㄹ변경할 때 사용자도 함께 변경해야함 이런 정보를 사용자에게 감춤으로써 변화의 파급을 막을 수 있음 <- 추상 팩토리, 가교, 메멘토, 프록시
  5. **알고리즘 의존성:** 알고리즘에 종속된 객체라면 알고리즘이 변할 때마다 객체도 변경해야함 변경 가능한 알고리즘은 분리해내는것이 바람직함 <- 빌더, 반복자, 전략, 템플릿 메서드, 방문자
  6. **높은 결합도:** 높은 결합도를 갖게 되면 하나의 커다란 시스템이 되버림 낮은 결합도를 유지해야함 <- 추상 팩토리, 가교, 책임 연쇄, 명령, 퍼사드, 중재자, 감시자
  7. **서브클래싱을 통한 기능 확장:** 서브클래시응로 객체를 재정의하는 것은 쉬운 일이 아님 서브클래스를 정의한다는 것은 최상위 클래스부터 모든 자신의 부모클래스에 대한 것을 이해하고 있어야함 일반적으로 객체 합성과 위임은 행동 조합을 위한 상속보다 훨씬 유연한 방법임 상속을 사용하지 않고도 응용프로그램에 새로운 기능성을 추가할 수 있음 또 한편 객체 합성 위임을 너무 많이사용하면 시스템을 이해하기가 어려워짐  많은 디자인패턴에서는 그냥 서브클래스를 정의하고 다른 인스턴스와 새로 정의한 클래스의 인스턴스를 합성해서 기능을 재정의하는 방법을 도입함 <- 가교, 책임 연쇄, 장식자, 감시자, 전략
  8. **클래스 변경이 편하지 못한점:** 클래스를 변경하기 어려울때 <- 적응자, 장식자, 방문자



## 디자인 패턴을 고르는 방법

1. 패턴이 어떻게 문제를 해결하는지 파악하자.
2. 패턴의 의도 부분을 보자
3. 패턴들 간의 관련성을 파악하자
4. 비슷한 못적의 패턴들을 모아서 공부하자
5. 재설계의 원인을 파악하자
6. 설계에서 가변성을 가져야 하는 부분이 무엇인지 파악하자



## 디자인 패턴 사용 방법





# #3 생선 패턴

- 생선패턴은 인스턴스를 만드는 절차를 추상화 하는 패턴임
- 클래스 생성 패턴이 인스턴스로 만들 클래스를 다양하게 만들기 위한 용도로 상속을 사용하는 반면, 객체 생서 ㅇ패턴은 인스턴스화 작업을 다른 객체에게 떠넘길 수도 있음
- 생성 패턴은 시스템이 어떤 구체 클래스를 사용하는지에 대한 정보를 캡슐화함
- 생성 패턴은 이들 클래스의 인스턴스들이 어떻게 만들고 어떻게 서로 맞붙는지에 대한 부분을 완전히 가려줌
- 결론적으로 생성패턴을 이용하면 무엇이 생성되고 누가이것을 생성하면, 이것이 어떻게 생성되는지, 언제 생성할 것인지 결정하는데 유연성을 확보할 수 있게 됨
- 생성 패턴으로 분류되는 패턴은 여러개지만 서로 보완적일 수 있고 선택되기 위해 서로 경쟁적일 수 있음.
- 클래스들의 인스턴스를 직접 생성하도록 하드코딩하는 방법은 생성 패턴으로 해결할 수 있음 <- 팩토리 메서드패턴, 추사 ㅇ팩토리 패턴, 빌더 패턴, 원형 패턴

## 추상 팩토리 (Abstract Factory) 패턴

- 상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공함

### 활용성

- 객체가 생성되거나 구성 표현되는 방식과 무관하게 시스템을 독립적으로 만들고자 할 때
- 여러 제품군 중 하나를 선턱해서 시스템을 설정해야 하고 한번 구성한 제품을 다른 것으로 대체할 수 있을 때
- 관련된 제품 객체들이 함께 사용되도록 설계되었고, 이 부분에 대한 제약이 외부에도 지켜지도록 하고 싶을 때
- 제품에 대한 클래스 라이브러리를 제공하고, 그들의 구현이 아닌 인터페이스를 노출시키고 싶을 때

### 결과

- 추상 팩토리 패턴을 쓰면서 얻는 이익과 부담은 다음과 같음
  1. **구체적인 클래스를 분리함:** 추상 팩토리 패턴은 쓰면 응용프로그램이 생성할 객체의 클래스를 제어할 수 있음 팩토리는 제품 객체를 생성하는 과정과 책임을 캡슐화한 것이기 때문에 구체적인 구현 클래스가 사용자에게서 분리됨. 일반 프로그램은 추상 인터페이스를 통해서만 인스턴스를 조작함 제품 클래스 이름이 구체 팩토리의 구현에서 분리되므로, 사용자 코드에는 나타나지 않는 것
  2. **제품군 쉽게 대체할 수 있도록 함:** 구체 팩토리의 클래스는 응용프로그램에서 한 번만 나타나기 때문에 응용프로그램이 사용할 구체 팩토리를 변경하기는 쉬움 추상 팩토리는 필요한 모든 것을 생성하기 때문에 전체 제품군은 한번에 변경이 가능함
  3. **제품 사이의 일관성을 증진:** 하나의 군 안에 속한 제품 객체들이 함께 동작하도록 설계되어 있을 때, 응용프로그램은 한 번에 오직 한 군에서 만든 객체를 사용하도록 함으로써 프로그램의 일관성을 갖도록 해야 함
  4. **새로운 종류의 제품을 제공하기 어려움:** 새로운 종류의 제품을 만들기 위해 기존 추상 팩토리를 확장하기가 쉽지 않음. 생성되는 제품은 추상 팩토리가 생성할 수 있는 제품 집합에만 고정되어 있기 때문임. 만약 새로운 종류의 제품이 등장하면 팩토리의 구현을 변경해야함. 추상 팩토리와 모든 서브클래스의 변경을 가져옴.

### 구현

1. **팩토리를 단일체로 정의함:** 갖가지의 제품의 종류를 만들어 내는 팩토리는 제품군에 대해서 하나면 됨 그러므로 단일체로 구현하는 것이 바람직함., 이 단일체 역시 생성 패턴의 한 종류임
2. **제품을 생성함:** 추상 팩토리를 구현하느 서브클래스 인스턴스를 만듦 만약 구현이 다르다면 새로운 서브클래스를 작성하면됨
3. **확장 가능한 팩토리들을 정의함:** 여러 종류의 클래스들을 정의하고 새로운 종류의 제품이 추가되면 추상 팩토리의 인터페이스에도 새로운 연산을 추가해야함 



- 팩토리 메서드들이 모인 집합체인 추상 팩토리 인터페이스를 생성해서 추상 팩토리 패턴을 구현하는게 가장 일반적인 방법임

## 빌더(Builder) 패턴

### 의도

- 복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리하여, 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공할 수 있도록 함

### 활용성

- 복합 객체의 생성 알고리즘이 이를 합성하는 요소 객체들이 무엇인지 이들의 조립 방법에 독립적일 때
- 합성할 객체들의 표현이 서로 다르더라도 생성 절차에서 이를 지원해야 할 때

### 결과

1. **제품에 대한 내부 표현을 다양하게 변화할 수 있음:** builder 객체는 디렉터를 제공하고 제품을 복합하기 위해 필요한 추상 인터페이스를 정의함. 빌더를 사용하면 제품이 어떤 요소에 복합되는지, 그리고 각 요소들의 표현 방법이 무엇인지 가릴 수 있게 됨 즉 어떤 요소로 전체 제품을 복합하고 그 요소들이 어떤 타입들로 구현되는지 알고 있는 쪽은 빌더뿐임. 제품을 복합할 때는 빌더에 저으이된 추상 인터페이스를 통해 사용자가 동작하기 때문에 새로운 제품의 표현 방법이나 제품의 복합 방법이 바뀔 때 추상 인터페이스를 정의한 builder 클래스에서 상속을 통해 새로운 서브클래스를 정의하면됨
2. **생성과 표현에 필요한 코드를 분리함:** 빌더 패턴을 사용하면, 복합 객체를 생성하고 복합 객체의 내부 표현 방법을 별도의 모듈로 정의할 수 있음 사용자는 제품의 내부 구조를 정의한 클래스는 전혀 모른 채, 빌더와 상호작용을 통해서 필요한복합 객체를 생성하게 됨
3. **복합 객체를 생성하는 절차를 좀 더 세밀하게 나눌 수 있음:** 한번에 복합 객체를 생성하는 것처럼, 빌더 패턴은 디렉터의 통제 아래 하나씩 내부 구성요소들을 만들어 나감. 디렉터가 빌더에서 만든 전체복합 객체를 되돌려받을 떄까지 제품 복잡의 과정은 계속됨. 그렇기때문에 Builder 클래스의 인터페이스에는 이 제품을 생성하는 과정 자체가 반영되어 있음

### 관련 패턴

- 복잡한 객체를 생성해야할 때 추상 팩토리 패턴은 빌더 패턴과 비슷한 모습을 보임
- 근본적인ㅎ차이가 있다면 빌더 패턴은 복잡한 객체의 단계별 생성에 중점을 두고
- 추상팩토리패턴은 제품의 유사군들이 존재할 때 유연할 설계에 중심을 둔다는 것
- 빌더는 생성의 마지막 단계에서 생성한 제품을 반환하고 추상 팩토리 패턴에서는 만드는 즉시 제품을 반환함 추상팩토리 패턴에서는 만드는 제품은 꼭 모여야만 의미있는 것이 아니라 하나만으로도 의미가 있기 때문

## 팩토리 메서드(Factory Method) 패턴

### 의도

- 객체를 생성하기 위해 인터페이스를 정의하지만 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 함

### 활용성

- 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때
- 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때
- 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지 대한 정보를 국소화 시키고 싶을 때

### 결과

- 팩토리 메서드 패턴은 응용프로그램에 국한된 클래스가 코드에 종속되지 않도록 해줌
- **서브클래스에 대한 훅 메서드를 제공함:** 팩토리 메서드로 클래스 내부 에서 객체를 생성하는 것이 객체를 직접 생성하는 것보다 훨씬 응용성이 높아짐. 팩토리 메서드 패턴에서는 객체별로 서로 다른 버전을 제공하는 훅 기능을 서브클래스에 정의함
- **병렬적인 클래스 계통을 연결하는 역할을 담당함**



## 원형(Prototype) 패턴

### 의도

- 원형이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체를 생성함

### 활용성

- 인스턴스화할 클래스를 런타임에 지정할 때 또는
- 제품 클래스 계통과 병렬적으로 만드는 팩토리 클래스를 피하고 싶을때
- 클래스의 인스턴스들이 서로 다른 상태 조합중에 어느 하나일 때 원형 패턴을 사용, 이들을 미리 원형으로 초기화해두고 나중에 이를 복제해서 사용하는 것이 맨번 필요한 상태 조합의 값들을 수동적으로 초기화하는 것보다 더 편리할 수 있음

### 결과

- 원형 패턴은 추상 팩토리 및 빌더와 비슷함 클라이언트 쪽에는 어떤 구체적인 제품이 있는지 알리지 않아도 되기 때문에 클라이언쪽에서 상대해야 하는 클래스의 수가 적고 수정하지 않고도 응용프로그램에 따라 필요한 클래스들과 동작할 수 있게 됨
- **런타임에 새로운 제품을 추가하고 삭제 가능:** 원형 패턴을 이용하면 사용자에게 원형으로 생성되는인스턴스를 등록하는 것만으로도 시스템에 새로운 제품 클래스를 추가할 수 있게 됨. 런타임시점에도 변경가능해서 유연성 있음 
- **값들을 다양화함으로써 새로운 객체를 명세함:** 객체의 변수가 다른 클래스에 대한 참조자를 정의하고 있다면, 이 참조자가 합성한 새로운 클래스만 정의하고, 그 클래스의 인스턴스에 대한 참조자만을 넘겨주면, 새로운 행동이 정의되는 것처럼 보임
- **구조를 다양화함으로써 새로운 객체를 명세함:** 
- **서브클래스의 수를 줄임:** 팩토리 관련 패턴에서는 클래스가 추가됨에 따라 서브클래스 및 메서드가 증가하는 반면 프로토타입은 원형을 복제하기때문에 서브클래스를 상속할 일이 없게됨
- **동적으로 클래스에 따라 응용프로그램을 설정 할 수 있음:**
- 원형패턴을 사용할때 가장 신경써야하는 점은 원형의 서브클래스가 clone을 구현해야한다는것 
- 사용자는 clone 연산의 반환값을 자신이 원하는 타입으로 다운캐스트할 필요가 절대로 없어야한다는데 java의 clone은 Object타입이기때문에 Prototype이라는 상위 인터페이스를 생성해야 할 듯 ..





## 생성 패턴에 대한 논의

- 시스템이 생성하는 객체의 클래스로 시스템을 매개변수화하는 일반적인 방법은 두가지가 있음
- 하나는 객체를 생성하는 클래스를 상속해서 서브클래스를 만드는 것임, 팩토리 메서드가 이에 속함 허나 이 방법의 단점은 제품 클래스가 바뀔 때마다 새로운 서브클래스를 생성해야함 
- 또 다른 방법은 객체 합성으로 시스템을 배개변수화 하는것인데 이것이 바로 추상 팩토리, 빌더, 원형 패턴의 주요 특징임 이 세가지 패턴은 어쨋든 새로운 팩토리 객체를 만듦
- 추상팩토리 원형, 또는 빌더를 사용하는 설계는 팩토리 메서드를 사용하느 ㄴ설계보다 더 유연할 떄가 많음. 팩토리 메서드를 사용해서 시작한 설계에 좀 더 유연성을 부가할 필요가 있다면 다른 생성 패턴을 사용하는 패턴으로 진화





# #4 구조 패턴

- 구조패턴은 더 큰 구조를 형성하기 위해 어떻게 클래스와 객체를 합성하는가와 관련된 패턴임
- 구조 클래스 패턴은 상속 기법을 이용하여 인터페이스나 구현을 복합함
- 일반적으로 어댑터 패턴은 어떤 인터페이스가 다른 인터페이스를 따르게 만들어 서로 다른 인터페이들의 통일된 추상을 제공함 이를 가능하게하려고 어댑터 클래스는 적응 대상 클래스에서 특성들을 상속받아, 적응 대상자에게 정의된 인터페이스를 마치 자신이 제공하는 것처럼 보여줌
- 구조 객체 패턴은 인터페이스나 구현을 복합하는 것이 아니라 새로운 기능을 실현하기 위해 객체를 합성하는 방법을 제공함
- 복합체 패턴은 두 종류의 객체에 대한 클래스로 클래스 계층 구조를 어떻게 형성하는지 보여줌 복합 객체는 기본 객체와 또 다른 복합 객체를 모아서 임의의 복잡한 구조를 생성할 수 있도록 함
- 프록시 패턴에서 프록시는 다른 객체의 대리자 역할을 수행함. 이 프록시의 용도는 다양하게 동작하고 민감한 객체를 보호할 수도 있음 즉, 프록시ㅡㄹㄹ 통해 객체의 특정한 어떤 특성에 대해서는 직접 접근하지 못하게 함으로써 이 특성들을 아무 부담없이 수정하고 확장할 수 있게 됨
- 플라이급 패턴은 객체들을 공유할 수 있는 구조를 저으이함 객체의 공유가 필요한이유는 효율성과 일관성 보장임 플라이급 패턴의 목적은 효율적으로 공간을 활용하려고 객체를 공유하는 것 그러나 상태가 없어야함
- 퍼사드 패턴은 하나의 객체로 전체 서브시스템을 표현할 수 있을까를 고민한 패턴임 퍼사드는 여러 객체를 대표하는 객체로서 자신이 받은 메시지를 자신이 대표하고 있는 다른객체에게 전달하는 역할을 수행함
- 가교 패턴은 객체의 개념적 추상화와 구현을 분리하여 각각 독립적으로 다양하게 변형할 수 있게 해줌
- 장식자 패턴은 객체에 동적으로 새로운 책임을 추가할 수 있는 방법을 제공함



## 어댑터(Adapter) 패턴

### 의도

- 클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응시킴, 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킴

### 동기

- 이미 개발된 클래스의 인터페이스를 수정할 수 없다면 A와 B의 인터페이스에 둘 다 맞도록 우리가 개발한 C 클래스를 조정해야함 이를위해 취할 수 있는 방법은 두가지임
  1. A의 인터페이스와 B의 구현을 모두 상속
  2. B의 인스턴스를 C에 포함시키고 A인터페이스를 사용하여 B를 구현함



### 활용성

- 기존 클래스를 사용하고 싶은데 인터페이스가 맞지 않을 때
- 아직 예측하지 못한 클래스나 실제 관련되지 않는 클래스들이 기존 클래스를 재사용하고자 하지만, 이미 정의된 재사용 가능한 클래스가 지금 요청하느 인터페이스를 꼭 정의하고 있지 않을 때, 다시 말해 이미 만든 것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정할 수 없을 때
- [객체적응자만 해당됨] 이미 존재하는 여러개의 서브클래스를 사용해야 하는데, 이 서브클래스들의 상속을 통해서 이들의 인터페이스를 다 개조한다는 것이 현실성이 없을 때. 객체 적응자를 써서 부모 클래스의 인터페이스를 변형하는 것이 더 바람직함

### 결과

- 클래스적응자의 장단점
  - Adapter 클래스는 Adaptee 클래스를 Target 클래스로 변형하는데, 이를 위해서 Adaptee 클래스를 상속받아야 하기 때문에, 하나의 클래스와 이 클래스의 모든 서브클래스들을 개조할 때라면 클래스 적응자 방식을 사용할 수 없음 즉 Adapter는 명시적으로 Adaptee를 상속받고 있을 뿐 Adaptee의 서브 클래스들을 상속받는 것은 아니므로 Adaptee의 서브클래스에 정의된 기능들을 사용할 수 없음
  - Adapter 클래스는 Adaptee 클래스를 상속하기 때문에 Adaptee에 정의된 행동을 재정의 가능
  - 한 개의 객체만 사용하며 Adaptee로 가기 위한 추가적인 포인터 간접화는 필요 없음
- 객체 적응자의 장단점
  - Adapter 클래스는 하나만 존재해도 수많은 Adaptee 클래스들과 동작할 수 있음 Adapter ㅋ객체가 포함하는 Adaptee에 대한 참조자는 Adaptee의 인스턴스를 관리할 수도 있고 Adaptee 클래스를 상속받는 다른 서브클래스들의 인스턴스도 관리할 수 있기 때문임 그러므로 하나의 Adapter 클래스로 모든 Adaptee 클래스와 이를 상속받는 서브클래스 모두를 이용할 수 있게 됨
  - Adaptee 클래스들의 행동을 재정의하기개 매우어려움 따라서 Adaptee를 상속받는 서브클래스를 구현하고 Adapter 클래스는 이 서브클래스를 참조하도록 해야함

- Adapter 패턴을 사용하면서 고려해야 할 추가적인 사항
  - **Adapter 클래스가 실제 적응 작업을 위해 들어가는 품이 얼마나 되나?:** 이는 적응을 어떻게 시킬것인가에 따라 달라짐 작업량을 결정짓는 요인은 Target 인터페이스와 Adaptee간에 얼마만큼의 유사성을 갖는가의 부분임
  - **대체 가능 적응자:** 클래스의 재사용성을 높이려면, 누가 이 클래스를 사용할지에 대한 생각을 최소화해야함 즉 내가 개발한 클래스를 사용할 모든 사용자에게 동일한 인터페이스를 제공해야 한다는 가정을 배제해야함 다른 인터페이스를 원하는 사용자가 있다면 적응자 클래스를 만들면됨
  - **양방향 적응자를 통한 투명성 제공:** 적읒아의 잠재적인 문제는 적응자가 모든 사용자에게 투명하지 않다는 것



## 브릿지(Bridge) 패턴

### 의도

구현에서 추상을 분리하여 이들이 독립적으로 다양성을 가질 수 있도록 함

### 동기

- 하나의 추상적 개념이 여러가지 구현으로 구체화 될 수 있을 때 대부분 상속을 통해서 이 문제를 해결함
- 그러나 상속은 구현과 추상적 개념을 영구적으로 종속시키기때문에 추상적 개념과 구현을 분리해서 재사용하거나 수정 확장하기가 쉽지 않음
- 브릿지패턴은 추상적 개념에 해당하는 클래스계통과 구현에 해당하는 클래스 계통을 분리함으로써 문제를 해결함

### 활용성

- 추상적 개념과 이에 대한 구현 사이의 지속적인 종속 관계를 피하고싶을때 ex 런타임에 구현을 변경
- 추상적 개념과 구현 모두가독립적으로 서브클래싱을 통해 확장되어야 할 때 이때 브릿지패턴은 개발자가 구현을 또 다른 추상적 개념과 연결할 수 있게 할 뿐 아니라 각각을 독립적으로 확장 가능하게함
- 추상적 개념에 대한 구현 내용을 변경하는 것이 다른 관련 프로그램에 아무련 연관이 없을때 사용함 변경되더라도 다시 컴파일되지 않아야함
- 클래스의 구현과 속성에 대한 모든 표현 방식을 완전하게 은닉하고싶을때 단순히 구현방식은 멤버 변수로만 존재함

### 결과

1. **인터페이스와 구현 분리:** 구현이 인터페이스에 얽매이지 않게 됨. 추상적 개념에 대한 어떤 방식의 구현을 런타임에 결정지을 수 있음 이는 런타임에 어떤 객체가 자신의 구현을 수시로 변경할 수 있음을 의미함
2. Abstraction과 Implementor를 독립적으로 확장하 ㄹ수 있음
3. **구현 세부 사항을 사용자에게서 숨기기:** 상세한 구현 내용을 사용자에게서 은닉할 수 있음





## 컴포지트(Composite) 패턴

### 의도

- 부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성함
- 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴

### 동기

- 복합체 패턴의 가장 중요한 요소는 기본 클래스와 이들의 컨테이너를 모두 표현할 수 있는 하나의 추상화 클래스를 정의하는 것

### 활용성

- 부분 - 전체의 객체 계통을 표현하고 싶을 때
- 사용자가 객체의 합성으로 생긴 복합 객체와 개개의 객체 사이의 차이를 알지 않고도 자기 일을 할 수 있도록 만들고 싶을 때 사용자는 복합구조의 모든 객체를 똑같이 취급하게 됨

### 참여자

- Component: 집합 관계에 정의될 모든 객체에 대한 인터페이스를 정의함. 모든 클래스에 해당하는 공통의 행동을 구현함. 
- Leaf: 가장 말단 객체, 자식이 없고 객체 합성에 가장 기본이 되는 객체의 행동을 정의
- Composite: 자식이 있는 구성 요소에 대한 행동을 정의함 자신이 복합하는 요소들을 저장하면서, Component 인터페이스에 정의된 자식 관련 연산을 구현함

### 결과

- 기본 객체와 복합 객체로 구성된 하나의 일관된 클래스 계통을 정의함, 기본 객체는 더 복합적인 객체들에 속해있을 수 있고 복합 객체 역시 다른 것에 속해있을 수 있지만 사용자 코드는 일반화된 상위 개념의 객체를 조작하는 방식으로 프로그래밍하면 런타임 기본 객체와 복합 객체를 구분하지 않고 일관되게 프로그래밍 할 수 있게됨
- 사용자의 코드가 단순해짐사용자는 객체 특성이 복합 구조인지 단일 구조인지조차 모르고 개발할 수 있게됨 이런 구분이 필요하지 않으므로 개발자의 코드에 switch case 스타일의 함수를 쓸 필요가 없어지므로 코드가 단순해짐
- 새로운 종류의 구성요소를 쉽게 추가 가능 새롭게 정의된 Composite나 Leaf의 서브클래스들은 기존에 존재하는 구조들과 독립적으로 동작이 가능하게됨 새로운 요소가 추가되었다고 해서 사용자의 프로그램이 변경될 필요가 없음
- 설계가 지나치게 범용성을 많이가짐 새로운 요소를 쉽게 추가할 때의 단점은 복합체의 구성요소에 제약을 가하기 힘들다는 것 가끔 복합체가 오직 한 개의 구성요소만 가졌으면 할때가 있는데 타입시스템으로는 검사가 불가능하고 런타임시점에 검사해야함

## 데코레이터(Decorator) 패턴

### 의도

- 객체에 동적으로 새로운 책임을 추가할 수 있게 함
- 기능을 추가하려면 서브클래스를 생성하는 것 보다 융통성 있는 방법을 제공함

### 동기

- 전체 클래스에 새로운 기능을 추가할 필요는 없지만 개별적인 객체에 새로운 책임을 추가할 필요가 있음 
- 지금 필요한 기능을 추가하는 다른 객체에다가 해당 구성요소를 둘러 싸는것 이것을  데코레이터라고함
- 데코레이터는 자신이 둘러싼 요소, 구성요소가 갖는 인터페이스를 자신도 동일하게 제공하므로 데코레이터의 존재는 이를 사용하는 사용자에게 감춰짐
- 자신이 둘러싼 구성요소로 전달되는 요청을 중간에 가로채서 해당 구성요소에 전달해줌
- 데코레이터는 중첩이 가능하고 책임을 무한대로 추가할 수 있음

### 활용성

- 동적으로 투명하게 다른 객체에 영향을 주지 않고 객개의 객체에 새로운 책임을 추가하기 위해 사용함
- 제거될 수 있는 책임에 대해 사용함
- 실제 상속으로 서브클래스를 계속 만드는 방법이 실질적이지 못할 때 사용함 너무 많은 수의 독립된 확장이 가능할 때 모든 조합을 지원하기 위해 상속으로 해결하면 클래스 수가 폭발적으로 많아지게 됨

### 참여자

- Component : 동적으로 추가할 서비스를 가질 가능성이 있는 객체들에 대한 인터페이스
- ConcreteComponent : 추가적인 서비스가 실제로 저으이도어야 할 필요가 있는 객체
- Decorator: Component 객체에 대한 참조자를 관리하면서 Component에 저으이된 인터페이스를 만족하도록 인터페이스를 정의
- ConcreateDecorator: Component 에 새롭게 추가할 서비스를 실제로 구현하는 클래스

### 결과

- **단순한 상속보다 설계의 융통성을 더 많이 증대시킬 수 있음:** 데코레이터 패턴은 객체에 새로운 행동을 추가할 수 있는 가장 효과적인 방법임. 이런 행동의 추가 삭제가 런타임시점에 가능하게 됨
- **클래스 계통의 상부측 클래스에 많은 기능이 누적되는 상황을 피할 수 있음:** 필요한 비용만 그때 지불하는 방법을 제공함 지금 예상하지 못한 특성이나 기능들을 데코레이터 객체를 통해 지속적으로 추가할 수 있음
- **데코레이터와 데코레이터의 구성 요소가 동일한 것은 아님:** 데코레이터는 사용자에게 일관된 인터페이스를 제공하는 껍데기일 뿐
- **데코레이터를 사용하면 작은 규모의 객체들이 많아짐**: 수가 너무 많아짐에 따라 모두 이해하기 어렵고 수정하는 과정이 복잡해짐



## 퍼사드(Facade) 패턴

### 의도

- 한 서브시스템 내의 인터페이스 집합에 대한 획일화된 하나의 인터페이스를 제공하는 패턴으로, 서브시스템을 사용하기 쉽도록 상위 수준의 인터페이스를 정의함

### 동기

- 시스템을 서브시스템으로 구조화하면 복잡성을 줄이는 데에 큰 도움ㅇ ㅣ됨
- 공통적인 설계 목표는 서브시스템들 사이의 의사소통 및 종속성을 최소화 하려는 것임 이런 목표를 달성하도록 도와주는 패턴이 퍼사드 패턴 
- 주어진 서브시스템의 일반적인 기능애 대한 단순화된 인터페이스를 제공하려는 것 

### 활용성

- 복잡한 서브시스템에 대한 단순한 인터페이스 제공이 필요할 때. 시스템 범위가 확장되면 또한 구체적으로 설계되면 서브시스템은 계속 복잡해짐
- 패턴을 적용하면 확장성을 고려하여 설계하기 때문에, 작은 클래스가 만들어지게 됨. 이런 과정은 서브시스템을 재사용 가능한 것으로 만들어 주고 재정의 할 수 있는 단위가 되도록 해 주기도 하지만, 실제 이런 상세한 재설계나 정제의 내용까지 파악할 필요가 없는 개발자들에게는 복잡해진 각각의 클래스들을 다 이해하면서 서브클래스를 사용하기 어려움 이럴때 퍼사드 패턴을 사용하면 서브시스템에 단순하면서도 기본적인 인터페이스를 제공함으로써 대부분의 개발자들에게 적합한 클래스 형태를 제공함
- 추상 개념에 대한 구현 클래스와 사용자 사이에 너무 많은 종속성이 존재할 때 퍼사드의 사용을 통해 사용자와 다른 서브시스템 간의 결합도를 줄일 수 있음, 즉 서브시스템에 정의된 모든 인터페이스가 공개되면 빈번한 메서드 호출이 있을 수 있으나, 이런 호출은 단순한 형태로 통합하여 제공하고 나머지 부분은 실질적으로 감소하게 되는 효과
- 서브시스템을 계층화 시킬 때 퍼사드 패턴을 사용하여 각 서브시스템의 계층에 대한 접근점을 제공함 서브시스템이 다른 서브시스템에 종속적이라 하더라도 각자가 제공하는 퍼사드를 통해서만 대화를 진행하게 함으로써 서브시스템 간의 종속성을 줄일 수 있음  이로써 서브시스템 내부 설계의 변경이 다른 서브시스템에 독립적으로 자유롭게 될 수 있는 것

### 참여자

- 퍼사드: 단순하고 일관된 통합 인터페이스를 제공하며 서브시스템을 구성하는 어떤 클래스가 어떤 요청을 처리해야 하는지 알고 있으며, 사용자의 요청을 해당 서브시스템 객체에 전달함
- 서브시스템들: 서브시스템의 기능을 구현하고 퍼사드 객체로 할당된 작업을 실제로 처리하지만 퍼사드에 대한 아무런 정보가 없음.

### 결과

- 서브시스템의 구성요소를 보호할 수 있음. 사용자가 다루어야할 객체의 수가 줄어들며 서브시스템을 쉽게 사용할 수 있음
- 서브시스템과 사용자 코드 간의 결합도를 더욱 약하게 만듬

































