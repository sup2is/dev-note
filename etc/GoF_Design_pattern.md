





# #1 서론

## 디자인 패턴이란?

- 하나의 패턴에는 다음의 네가지요소가 반드시 들어가 있음
  1. **패턴 이름(pattern name)**은 한 두단 어로 설계 문제와 해법을 서술함 패턴에 이름을 부여하는 것은 설계 어휘 늘리는 일이며, 높은 수준의 추상화된 설계를 할 수 있도록 해줌. 이름을 통해 설계의 의도를 표현하고 생각을 더욱 쉽게, 의사소통을 쉽게할 수 있음 따라서 좋은 이름을 만들어야함
  2. **문제(problem)**는 어떤 패턴을 사용하는가를 서술하며 해결할 문제와 그 배경을 설명함 즉 어떤 알고리즘을 객체로 만들까 와 같은 설계의 세밀한 문제를 설명할 수 있음 때론 유연성 없는 설계가 될 징조를 보이는 클래스나 객체의 구조를 제시하고 문제를 제시함으로써 패턴을 적용하는 것이 의미 있는 사례들을 정의하기도함
  3. **해법(solution)**은 설계를 구성하는 요소들과 그 요소들 간의 관계, 책임 그리고 협력 관계를 서술함.그렇다고 해법이 어떤 구체적인 설계나 구현을 설명하지는 않고 디자인 패턴은 문제에 대한 추상적인 설명을 제공하고 문제를 해결하기 위해서 클래스나 객체들의 나열 방법을 제공함
  4. **결과(consequence)** 는 디자인 패턴을 적용해서 얻는 결과와 장단점을 서술함.
- 디자인패턴은 연결 리스트와 해시 테이블 등을 클래스로 표현하고 그것 자체로 다시 쓸 수 있도록 설계하는 문제를 어떻게 푸느냐에 관한 것이 아님
- 디자인 패턴은 특정한 전후 관계에서 일반적설계 문제를 해결하기 위해 상호 교류하는 수정 가능한 객체와 클래스들에 대한 설명임



## 스몰 토크 MVC를 사용한 디자인 패턴

- MVC는 에서 M은 Model, 응용프로그램 객체이고 View는 스크린에 모델을 디스플레이하는 방법이며, Controller는 사용자 인터페이스가 사용자 입력에 반응하는 방법을 정의함
- 뷰는 그 외형이 반드시 모델의 상태를 반영하도록 보장해야함
- 이런 설계 방법은 더 일반적인 문제에서도 적용 가능한데 즉 한 객체에서 일어난 변경을 다른 객체들에게 반영하도록 별도의 객체를 둠으로써 변경이 일어난 객체는 변경 반영이 필요한 다른 객체들을 알 필요가  없게끔 객체를 분리함 <- 일반화한것이 옵저버 패턴
- 일반적으로 단일 객체처럼 복합 객체를 사용하고 싶을 때가 많음 <- 일반화한것이 컴포지트 패턴
- 뷰와 컨트롤러 관계는 전략 패턴의 한 예임 전략 패턴은 알고리즘을 표현하는 객체로 정적 또는 동적으로 알고리즘을 대체하고자 할 때 매우 유용한 방식
- 팩토리 메서드 패턴을 이용해서 뷰에 대한 기분 컨트롤러 클래스를 지정, 장식자 패턴을 이용해서 뷰에 스크롤을 추가함 등등 
- MVC에서 주로 사용하는 패턴은 감시자, 복합체, 전략 패턴임



## 디자인 패턴을 이용하여 문제를 푸는 방법



### 적당한 객체 찾기

- 객체지향 프로그램은 객체로 만듬. 객체는 데이터와 이 데이터에 연산을 가하는 프로시저(메서드, 연산)를 함께 묶은 단위임. 객체는 요청 또는 메시지를 사용자에게 받으면 연산을 수행함
- 디자인 패턴은 덜 명확한 추상적 개념과 이것을 잡아낸 객체를 알아보는데에 도움을 줌
- 객체를 잘 설계해야한다라는 말을 하는것 같음

### 객체의 크기 결정

- 객체의 크기 또한 디자인 패턴에서 이 문제의 답을 얻을 수 있음
- 퍼사드패턴은 서브시스템을 어떻게 객체로 표현할 수 있는지 설명하고, 플라이급 패턴은 규모는 작지만 개수는 많은 객체를 다루는 방법을 설명함 등등



### 객체 인터페이스의 명세

- 객체가 선언하는 모든 연산은 연산의 이름, 매개변수로 받아들이는 객체들, 연산의 반환값을 명세함 이를 연산의 시그니처라고함 
- 인터페이스는 객체가 정의하는 모든 시그니처들을 일컫는 말이고 객체 인터페이스는 객체가 받아서 처리할 수 있는 연산의 집합임
- 타입은 특정 인터페이스를 나타낼 때 사용하는 이름임 객체가 "Window" 타입을 갖는다는 것은 "Window" 인터페이스에 정의한 연산들을 모두 처리할 수 있다는 것을 의미함.
- 객체는 여러 타입을 가질 수 있고 서로 다른 객체가 하나의 타입을 공유할 수 있음
- 부모 자식 관계에따라 이를 서브타입 슈퍼타입이라고 부름
- 인터페이스의 개념은 객체지향 시스템에서 가장 기본적인 것임 외부에서 객체를 알 수 있는 방법이 인터페이스이기 때문에 인터페이스를 통해서만 처리를 요청할 수 있음
- 동일한 인터페이스를 갖는 두 객체가 완전히 다른 구현을 가질 수 있음
- 어떤 요청과 그 요청을 처리할 객체를 프로그램 런타임 시점에 연결 짓는 것을 동적 바인딩이라고 함
- 동적바인딩은 요청이 어떻게 구현되어 어떤 결과를 만들어 낼지를 런타임에 결정할 수 있음을 의미함
- 즉 프로그램을 작성할 때 객체가 어떤 특정 인터페이스를 갖도록 작성하며 이 객체는 요청을 처리할 정확한 인터페이스를 갖고 있고 동적 바인딩으로 프로그램이 기대하는 객체를 동일한 인터페이스를 갖는 다른 객체로 대체할 수 있을때 이런 대체성을 우리는 다형성이라고 부름
- 다형성은 객체지향 시스템의 핵심 개념임
- 다형성은 사용자의 정의를 단순화하고 객체 간의 결합도를 없애며, 프로그램 실행 중에는 서로 간의 관련성을 다양화할 수 있게 해줌
- 디자인 패턴은 인터페이스에 정의해야 하는 중요 요소가 무엇이고 어떤 종류의 데이터를 주고받아야 하는지 식별하여 인터페이스를 정의하도록 도와줌

### 객체 구현 명세하기

- 어떤 객체의 구현은 클래스에서 정의함 클래스는 객체의 내부 데이터와 표현 방법을 명세하고 그 객체가 수행할 연산을 정의함 
- 객체는 클래스를 인스턴스로 만듦으로써 생성됨 즉 객체는 클래스의 인스턴스임
- 새로운 클래스는 기존 클래스에 기반을 둔 클래스를 상속하여 정의할 수 있음
- 서브클래스는 부모클래스가 정의한 연산을 모두 수행할 수 있음
- 추상클래스는 모든 서브클래스 사이의 공통되는 인터페이스를 정의함
- 정의만하고 구현하지 않는 연산을 추상 연산이라하고 추상클래스가 아닌 클래스를 구체클래스라고함
- 서브클래스는 부모클래스가 정의한 행동을 재정의하거나 정제할 수 있는데 이것을 오버라이드라고 부름
- 믹스인 클래스는 다른 클래스들에게 선택적인 인터페이스 혹은 기능을 제공하려는 목적을 가진 클래스임 인스턴스로 만들 의도가 없다는 면에서 추상 클래스와 비슷함 <- 주로 이벤트 인터페이스를 설명하는것 같음

**클래스 상속 vs 인터페이스 상속**

- 객체의 클래스는 그 객체가 어떻게 구현되느냐를 정의함
- 객체의 타입은 그 객체의 인터페이스, 즉 그 객체가 응답할 수 있는 요청의 집합을 정의함
- 객체의 구현은 다를지라도 인터페이스는 같을 수 있음
- 클래스 상속은 코드와 내부 표현 구조를 공유하는 메커니즘임
- 인터페이스 상속은 어떤 객체가 다른 객체 대신에 사용될 수 있는 경우를 지정하느 메커니즘임



**구현에 따르지 않고, 인터페이스에 따르는 프로그래밍**

- 클래스 상속은 기본적으로 부모 클래스에서 정의한 구현을 재사용하여 응용프로그램의 기능성을 확장하려는 메커니즘임
- 상속이 가진 다른기능들 중에는 동일한 인터페이스를 갖는 객체군을 정의하는 것이 있는데 매우 중요한 특징임 <- 다형성
- 상속을 적절하게 이용하면 모든 클래스는 추상 클래스를 상속하도록 하여 인터페이스를 공유할 수 있게 됨
- 모든 서브클래스들은 추상 클래스에 정의한 인터페이스를 처리할 수 있음 
- 추상클래스를 정의하고 인터페이스 개념으로 객체를 다룰 때 얻을 수 있는 두가지 이점
  1. 사용자가 원하는 인터페이스를 그 객체가 만족하고 잇는 한, 사용자는 그들이 사용하는 특정 객체 타입에 대해 알아야 할 필요는 없음
  2. 사용자는 이 객체들을 구현하는 클래스를 알 필요가 없고, 단지 인터페이스를 정의하는 추상 클래스가 무엇인지만 알면 됨
- **구현이 아닌 인터페이스에 따라 프로그래밍 합니다.**

### 재사용을 실현 가능한 것으로

**상속 대 합성**

- 객체지향 시스템에서 기능의 재사용을 위해 구사하는 가장 대표적인 기법은 클래스 상속, 그리고 객체 합성임
- 서브클래싱에 의한 재사용을 화이트박스 재사용이라고함 화이트박스는 내부를 볼 수 있다는 의미를 가짐 상속을 받으면 부모클래스의 내부가 서브클래스에 의해 공개되기때문에 이런 용어를 씀
- 객체 합성은 클래스 상속에 대한 대안임 다른 객체를 여러개 붙여서 새로운 기능 혹은 객체를 구성하는 것. 객체를 합성하려면 합성에 들어가는 객체들의 인터페이스를 명확하게 정의해두어야함 이런 스타일의 재사용을 블랙바스 재사용이라고하는데 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문임
- 상속과 합성은 서로 장단점이 있음
- 클래스 상속은 컴파일 시점에 정적으로 정의도고 프로그래밍언어가 직접 지원하므로 그래도 사용하면 됨
- 클래스 상속의 단점 중 첫번째는 런타임에 상속받은 부모클래스의 구현을 변경할 수는 없다는 점임 <- 컴파일 시점에 결졍되기 때문
- 두번째단점은 부모 클래스는 서브클래스의 물리적 표현의 최소 부분만을 정의하기 때문에 서브클래스는 부모 클래스가 정의한 물리적 표현들을 전부 또는 일부 상속받는다는 점 부모에서 변경되면 서브에서도 변경되어야함
- 이런 단점을 보완하기 위해서는 추상클래스만을 부모타입으로 두는게 적절함. 추상클래스는 실제 구현이 없기 때문
- 객체의 합성은 한 객체가 다른 객체에 대한 참조자를 얻는 방식으로 런타임에 동적으로 정의됨
- 합성은 객체가 다른 객체의 인터페이스만을 바라보게 하기 때문에 인터페이스 저으이 더 많은 주의를 기울여야함 객체는 인터페이스에서만 접근하므로 캡슐화를 유지할 수 있음 동일 타입이면 런타임에 다른 객체로 대체 가능 
- 상속과 합성은 각자 장단점이 있음 적절히 조합되어야만 완벽한 재사용이 가능함

**위임**

- 위임은 합성을 상속만큼 강력하게 만드는 방법임 위임에서는 두 객체가 하나의 요청을 처리함 수신 객체가 연산의 처리를 위임자에게 보내면 이는 서브클래스가 부모 클래스에게 요청을 전달하는 것과 유사한 방식임
- 위임의 가장 중요한 장점은 런타임에 행동의 복합을 가능하게하고 복합하는 방식도 변경해준다는 것임
- 위임이 갖는 단점은 객체 합성을 통해 소프트웨어 설계의 유연성을 보장하는 방법과 동일하게 동적인데다가 고도로 매개변수화된 소프트웨어는 정적인 소프트웨어 구조보다 이해하기가 더 어렵다는 것임 그 이유는 정적이지 않고 프로그램 내부에서 동적이기 때문임
- 상태, 전략, 방문자 패턴에서 위임 방식을 사용함

**상속 대 매개변수화된 타입**

- 기능의 재사용에 이용할 수 있는 다른 방법을 매개변수화된 타입이라고 함



### 런타임 및 컴파일 타임의 구조를 관계 짓기

- 컴파일 시점의 구조와 런타임의 구조간에 차이가 있기 때문에 코드 자체가 시스템의 동작 방법을 모두 보여줄수는 없음
- 시스템의 런타임 구조는 언어가 아닌 설계자가 만들고 객체와 타입 사이의 관계는 대단히 세심하게 설계해야함
- 많은 디자인 패턴이 컴파일 시점과 런타임의 구조를 명시적으로 구분하고 있음



### 변화에 대비한 설계

- 재사용을 최대화 하기 위해서는 새로운 요구 사항과 기존 요구 사항에 발생한 변경을 예측하여 앞으로의 시스템 설계가 진화할 수 있도록 해야 함
- 변화에 잘 대응하기 위한 소프트웨어를 설계하기 위해서는 소프트웨어를 운영하는동안 앞으로 일어날 변화를 어떻게 수용할 것인가를 미리 고려해야함
- 예측하지 못한 변경에 대해서는 엄청나게 비싼 대가를 지불할 수 밖에 없음
- 디자인 패턴은 어떤 구체적인 원인으로 앞으로 시스템을 변경해야 한다는 것을 미리 보여줌으로써 이런 위험을 줄여줌
- 디자인 패턴을 써서 재설계를 할 수밖에 없게 하는 흔한 이유
  1. **특정 클래스에서 객체 생성:** 객체를 생성할 때 클래스 이름을 명시하면 어떤 특정 인터페이스가 아닌 어떤 특정 구현에 종속됨. 이런 종속은 앞으로의 변화를 수용하지 못함. 이르 ㄹ방지하려면 객체를 직접 생성해서는 안됨. <- 추상 팩토리, 팩토리 메서드, 원형
  2. **특정 연산에 대한 의존성:** 특정한 연산을 사용하려면 요청을 만족하는 한가지 방법에만 매이게 됨. 요청의 처리 방법을 직접 코딩하는 방식을 피하면 컴파일 시점과 런타임 모두를 만족하면서 요청 처리 방버을 쉽게 변경할 수 있음 <- 책임 연쇄, 명령
  3. **하드웨어와 소프트웨어 플랫폼에 대한 의존성:** 플랫폼 종속성을 제거하는 것은 시스템 설계에 있어서 매우 중요함 <- 추상 팩토리, 가교
  4. **객체의 표현이나 구현에 대한 의존성:** 사용자가 객체의 표현 방법, 저장 방법, 구현 방법, 존재의 위치에 대한 몯느 방법을 알고 있다면 객체르 ㄹ변경할 때 사용자도 함께 변경해야함 이런 정보를 사용자에게 감춤으로써 변화의 파급을 막을 수 있음 <- 추상 팩토리, 가교, 메멘토, 프록시
  5. **알고리즘 의존성:** 알고리즘에 종속된 객체라면 알고리즘이 변할 때마다 객체도 변경해야함 변경 가능한 알고리즘은 분리해내는것이 바람직함 <- 빌더, 반복자, 전략, 템플릿 메서드, 방문자
  6. **높은 결합도:** 높은 결합도를 갖게 되면 하나의 커다란 시스템이 되버림 낮은 결합도를 유지해야함 <- 추상 팩토리, 가교, 책임 연쇄, 명령, 퍼사드, 중재자, 감시자
  7. **서브클래싱을 통한 기능 확장:** 서브클래시응로 객체를 재정의하는 것은 쉬운 일이 아님 서브클래스를 정의한다는 것은 최상위 클래스부터 모든 자신의 부모클래스에 대한 것을 이해하고 있어야함 일반적으로 객체 합성과 위임은 행동 조합을 위한 상속보다 훨씬 유연한 방법임 상속을 사용하지 않고도 응용프로그램에 새로운 기능성을 추가할 수 있음 또 한편 객체 합성 위임을 너무 많이사용하면 시스템을 이해하기가 어려워짐  많은 디자인패턴에서는 그냥 서브클래스를 정의하고 다른 인스턴스와 새로 정의한 클래스의 인스턴스를 합성해서 기능을 재정의하는 방법을 도입함 <- 가교, 책임 연쇄, 장식자, 감시자, 전략
  8. **클래스 변경이 편하지 못한점:** 클래스를 변경하기 어려울때 <- 적응자, 장식자, 방문자



## 디자인 패턴을 고르는 방법

1. 패턴이 어떻게 문제를 해결하는지 파악하자.
2. 패턴의 의도 부분을 보자
3. 패턴들 간의 관련성을 파악하자
4. 비슷한 못적의 패턴들을 모아서 공부하자
5. 재설계의 원인을 파악하자
6. 설계에서 가변성을 가져야 하는 부분이 무엇인지 파악하자



## 디자인 패턴 사용 방법





# #3 생선 패턴

- 생선패턴은 인스턴스를 만드는 절차를 추상화 하는 패턴임
- 클래스 생성 패턴이 인스턴스로 만들 클래스를 다양하게 만들기 위한 용도로 상속을 사용하는 반면, 객체 생서 ㅇ패턴은 인스턴스화 작업을 다른 객체에게 떠넘길 수도 있음
- 생성 패턴은 시스템이 어떤 구체 클래스를 사용하는지에 대한 정보를 캡슐화함
- 생성 패턴은 이들 클래스의 인스턴스들이 어떻게 만들고 어떻게 서로 맞붙는지에 대한 부분을 완전히 가려줌
- 결론적으로 생성패턴을 이용하면 무엇이 생성되고 누가이것을 생성하면, 이것이 어떻게 생성되는지, 언제 생성할 것인지 결정하는데 유연성을 확보할 수 있게 됨
- 생성 패턴으로 분류되는 패턴은 여러개지만 서로 보완적일 수 있고 선택되기 위해 서로 경쟁적일 수 있음.
- 클래스들의 인스턴스를 직접 생성하도록 하드코딩하는 방법은 생성 패턴으로 해결할 수 있음 <- 팩토리 메서드패턴, 추사 ㅇ팩토리 패턴, 빌더 패턴, 원형 패턴

## 추상 팩토리 (Abstract Factory) 패턴

- 상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체의 군을 생성하기 위한 인터페이스를 제공함

### 활용성

- 객체가 생성되거나 구성 표현되는 방식과 무관하게 시스템을 독립적으로 만들고자 할 때
- 여러 제품군 중 하나를 선턱해서 시스템을 설정해야 하고 한번 구성한 제품을 다른 것으로 대체할 수 있을 때
- 관련된 제품 객체들이 함께 사용되도록 설계되었고, 이 부분에 대한 제약이 외부에도 지켜지도록 하고 싶을 때
- 제품에 대한 클래스 라이브러리를 제공하고, 그들의 구현이 아닌 인터페이스를 노출시키고 싶을 때

### 결과

- 추상 팩토리 패턴을 쓰면서 얻는 이익과 부담은 다음과 같음
  1. **구체적인 클래스를 분리함:** 추상 팩토리 패턴은 쓰면 응용프로그램이 생성할 객체의 클래스를 제어할 수 있음 팩토리는 제품 객체를 생성하는 과정과 책임을 캡슐화한 것이기 때문에 구체적인 구현 클래스가 사용자에게서 분리됨. 일반 프로그램은 추상 인터페이스를 통해서만 인스턴스를 조작함 제품 클래스 이름이 구체 팩토리의 구현에서 분리되므로, 사용자 코드에는 나타나지 않는 것
  2. **제품군 쉽게 대체할 수 있도록 함:** 구체 팩토리의 클래스는 응용프로그램에서 한 번만 나타나기 때문에 응용프로그램이 사용할 구체 팩토리를 변경하기는 쉬움 추상 팩토리는 필요한 모든 것을 생성하기 때문에 전체 제품군은 한번에 변경이 가능함
  3. **제품 사이의 일관성을 증진:** 하나의 군 안에 속한 제품 객체들이 함께 동작하도록 설계되어 있을 때, 응용프로그램은 한 번에 오직 한 군에서 만든 객체를 사용하도록 함으로써 프로그램의 일관성을 갖도록 해야 함
  4. **새로운 종류의 제품을 제공하기 어려움:** 새로운 종류의 제품을 만들기 위해 기존 추상 팩토리를 확장하기가 쉽지 않음. 생성되는 제품은 추상 팩토리가 생성할 수 있는 제품 집합에만 고정되어 있기 때문임. 만약 새로운 종류의 제품이 등장하면 팩토리의 구현을 변경해야함. 추상 팩토리와 모든 서브클래스의 변경을 가져옴.

### 구현

1. **팩토리를 단일체로 정의함:** 갖가지의 제품의 종류를 만들어 내는 팩토리는 제품군에 대해서 하나면 됨 그러므로 단일체로 구현하는 것이 바람직함., 이 단일체 역시 생성 패턴의 한 종류임
2. **제품을 생성함:** 추상 팩토리를 구현하느 서브클래스 인스턴스를 만듦 만약 구현이 다르다면 새로운 서브클래스를 작성하면됨
3. **확장 가능한 팩토리들을 정의함:** 여러 종류의 클래스들을 정의하고 새로운 종류의 제품이 추가되면 추상 팩토리의 인터페이스에도 새로운 연산을 추가해야함 



- 팩토리 메서드들이 모인 집합체인 추상 팩토리 인터페이스를 생성해서 추상 팩토리 패턴을 구현하는게 가장 일반적인 방법임

## 빌더(Builder) 패턴

### 의도

- 복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리하여, 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공할 수 있도록 함

### 활용성

- 복합 객체의 생성 알고리즘이 이를 합성하는 요소 객체들이 무엇인지 이들의 조립 방법에 독립적일 때
- 합성할 객체들의 표현이 서로 다르더라도 생성 절차에서 이를 지원해야 할 때

### 결과

1. **제품에 대한 내부 표현을 다양하게 변화할 수 있음:** builder 객체는 디렉터를 제공하고 제품을 복합하기 위해 필요한 추상 인터페이스를 정의함. 빌더를 사용하면 제품이 어떤 요소에 복합되는지, 그리고 각 요소들의 표현 방법이 무엇인지 가릴 수 있게 됨 즉 어떤 요소로 전체 제품을 복합하고 그 요소들이 어떤 타입들로 구현되는지 알고 있는 쪽은 빌더뿐임. 제품을 복합할 때는 빌더에 저으이된 추상 인터페이스를 통해 사용자가 동작하기 때문에 새로운 제품의 표현 방법이나 제품의 복합 방법이 바뀔 때 추상 인터페이스를 정의한 builder 클래스에서 상속을 통해 새로운 서브클래스를 정의하면됨
2. **생성과 표현에 필요한 코드를 분리함:** 빌더 패턴을 사용하면, 복합 객체를 생성하고 복합 객체의 내부 표현 방법을 별도의 모듈로 정의할 수 있음 사용자는 제품의 내부 구조를 정의한 클래스는 전혀 모른 채, 빌더와 상호작용을 통해서 필요한복합 객체를 생성하게 됨
3. **복합 객체를 생성하는 절차를 좀 더 세밀하게 나눌 수 있음:** 한번에 복합 객체를 생성하는 것처럼, 빌더 패턴은 디렉터의 통제 아래 하나씩 내부 구성요소들을 만들어 나감. 디렉터가 빌더에서 만든 전체복합 객체를 되돌려받을 떄까지 제품 복잡의 과정은 계속됨. 그렇기때문에 Builder 클래스의 인터페이스에는 이 제품을 생성하는 과정 자체가 반영되어 있음

### 관련 패턴

- 복잡한 객체를 생성해야할 때 추상 팩토리 패턴은 빌더 패턴과 비슷한 모습을 보임
- 근본적인ㅎ차이가 있다면 빌더 패턴은 복잡한 객체의 단계별 생성에 중점을 두고
- 추상팩토리패턴은 제품의 유사군들이 존재할 때 유연할 설계에 중심을 둔다는 것
- 빌더는 생성의 마지막 단계에서 생성한 제품을 반환하고 추상 팩토리 패턴에서는 만드는 즉시 제품을 반환함 추상팩토리 패턴에서는 만드는 제품은 꼭 모여야만 의미있는 것이 아니라 하나만으로도 의미가 있기 때문

## 팩토리 메서드(Factory Method) 패턴

### 의도

- 객체를 생성하기 위해 인터페이스를 정의하지만 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 함

### 활용성

- 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때
- 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때
- 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지 대한 정보를 국소화 시키고 싶을 때

### 결과

- 팩토리 메서드 패턴은 응용프로그램에 국한된 클래스가 코드에 종속되지 않도록 해줌
- **서브클래스에 대한 훅 메서드를 제공함:** 팩토리 메서드로 클래스 내부 에서 객체를 생성하는 것이 객체를 직접 생성하는 것보다 훨씬 응용성이 높아짐. 팩토리 메서드 패턴에서는 객체별로 서로 다른 버전을 제공하는 훅 기능을 서브클래스에 정의함
- **병렬적인 클래스 계통을 연결하는 역할을 담당함**



## 원형(Prototype) 패턴

### 의도

- 원형이 되는 인스턴스를 사용하여 생성할 객체의 종류를 명시하고, 이렇게 만든 견본을 복사해서 새로운 객체를 생성함

### 활용성

- 인스턴스화할 클래스를 런타임에 지정할 때 또는
- 제품 클래스 계통과 병렬적으로 만드는 팩토리 클래스를 피하고 싶을때
- 클래스의 인스턴스들이 서로 다른 상태 조합중에 어느 하나일 때 원형 패턴을 사용, 이들을 미리 원형으로 초기화해두고 나중에 이를 복제해서 사용하는 것이 맨번 필요한 상태 조합의 값들을 수동적으로 초기화하는 것보다 더 편리할 수 있음

### 결과

- 원형 패턴은 추상 팩토리 및 빌더와 비슷함 클라이언트 쪽에는 어떤 구체적인 제품이 있는지 알리지 않아도 되기 때문에 클라이언쪽에서 상대해야 하는 클래스의 수가 적고 수정하지 않고도 응용프로그램에 따라 필요한 클래스들과 동작할 수 있게 됨
- **런타임에 새로운 제품을 추가하고 삭제 가능:** 원형 패턴을 이용하면 사용자에게 원형으로 생성되는인스턴스를 등록하는 것만으로도 시스템에 새로운 제품 클래스를 추가할 수 있게 됨. 런타임시점에도 변경가능해서 유연성 있음 
- **값들을 다양화함으로써 새로운 객체를 명세함:** 객체의 변수가 다른 클래스에 대한 참조자를 정의하고 있다면, 이 참조자가 합성한 새로운 클래스만 정의하고, 그 클래스의 인스턴스에 대한 참조자만을 넘겨주면, 새로운 행동이 정의되는 것처럼 보임
- **구조를 다양화함으로써 새로운 객체를 명세함:** 
- **서브클래스의 수를 줄임:** 팩토리 관련 패턴에서는 클래스가 추가됨에 따라 서브클래스 및 메서드가 증가하는 반면 프로토타입은 원형을 복제하기때문에 서브클래스를 상속할 일이 없게됨
- **동적으로 클래스에 따라 응용프로그램을 설정 할 수 있음:**
- 원형패턴을 사용할때 가장 신경써야하는 점은 원형의 서브클래스가 clone을 구현해야한다는것 
- 사용자는 clone 연산의 반환값을 자신이 원하는 타입으로 다운캐스트할 필요가 절대로 없어야한다는데 java의 clone은 Object타입이기때문에 Prototype이라는 상위 인터페이스를 생성해야 할 듯 ..





## 생성 패턴에 대한 논의

- 시스템이 생성하는 객체의 클래스로 시스템을 매개변수화하는 일반적인 방법은 두가지가 있음
- 하나는 객체를 생성하는 클래스를 상속해서 서브클래스를 만드는 것임, 팩토리 메서드가 이에 속함 허나 이 방법의 단점은 제품 클래스가 바뀔 때마다 새로운 서브클래스를 생성해야함 
- 또 다른 방법은 객체 합성으로 시스템을 배개변수화 하는것인데 이것이 바로 추상 팩토리, 빌더, 원형 패턴의 주요 특징임 이 세가지 패턴은 어쨋든 새로운 팩토리 객체를 만듦
- 추상팩토리 원형, 또는 빌더를 사용하는 설계는 팩토리 메서드를 사용하느 ㄴ설계보다 더 유연할 떄가 많음. 팩토리 메서드를 사용해서 시작한 설계에 좀 더 유연성을 부가할 필요가 있다면 다른 생성 패턴을 사용하는 패턴으로 진화





# #4 구조 패턴

- 구조패턴은 더 큰 구조를 형성하기 위해 어떻게 클래스와 객체를 합성하는가와 관련된 패턴임
- 구조 클래스 패턴은 상속 기법을 이용하여 인터페이스나 구현을 복합함
- 일반적으로 어댑터 패턴은 어떤 인터페이스가 다른 인터페이스를 따르게 만들어 서로 다른 인터페이들의 통일된 추상을 제공함 이를 가능하게하려고 어댑터 클래스는 적응 대상 클래스에서 특성들을 상속받아, 적응 대상자에게 정의된 인터페이스를 마치 자신이 제공하는 것처럼 보여줌
- 구조 객체 패턴은 인터페이스나 구현을 복합하는 것이 아니라 새로운 기능을 실현하기 위해 객체를 합성하는 방법을 제공함
- 복합체 패턴은 두 종류의 객체에 대한 클래스로 클래스 계층 구조를 어떻게 형성하는지 보여줌 복합 객체는 기본 객체와 또 다른 복합 객체를 모아서 임의의 복잡한 구조를 생성할 수 있도록 함
- 프록시 패턴에서 프록시는 다른 객체의 대리자 역할을 수행함. 이 프록시의 용도는 다양하게 동작하고 민감한 객체를 보호할 수도 있음 즉, 프록시ㅡㄹㄹ 통해 객체의 특정한 어떤 특성에 대해서는 직접 접근하지 못하게 함으로써 이 특성들을 아무 부담없이 수정하고 확장할 수 있게 됨
- 플라이급 패턴은 객체들을 공유할 수 있는 구조를 저으이함 객체의 공유가 필요한이유는 효율성과 일관성 보장임 플라이급 패턴의 목적은 효율적으로 공간을 활용하려고 객체를 공유하는 것 그러나 상태가 없어야함
- 퍼사드 패턴은 하나의 객체로 전체 서브시스템을 표현할 수 있을까를 고민한 패턴임 퍼사드는 여러 객체를 대표하는 객체로서 자신이 받은 메시지를 자신이 대표하고 있는 다른객체에게 전달하는 역할을 수행함
- 가교 패턴은 객체의 개념적 추상화와 구현을 분리하여 각각 독립적으로 다양하게 변형할 수 있게 해줌
- 장식자 패턴은 객체에 동적으로 새로운 책임을 추가할 수 있는 방법을 제공함



## 어댑터(Adapter) 패턴

### 의도

- 클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응시킴, 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킴

### 동기

- 이미 개발된 클래스의 인터페이스를 수정할 수 없다면 A와 B의 인터페이스에 둘 다 맞도록 우리가 개발한 C 클래스를 조정해야함 이를위해 취할 수 있는 방법은 두가지임
  1. A의 인터페이스와 B의 구현을 모두 상속
  2. B의 인스턴스를 C에 포함시키고 A인터페이스를 사용하여 B를 구현함



### 활용성

- 기존 클래스를 사용하고 싶은데 인터페이스가 맞지 않을 때
- 아직 예측하지 못한 클래스나 실제 관련되지 않는 클래스들이 기존 클래스를 재사용하고자 하지만, 이미 정의된 재사용 가능한 클래스가 지금 요청하느 인터페이스를 꼭 정의하고 있지 않을 때, 다시 말해 이미 만든 것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정할 수 없을 때
- [객체적응자만 해당됨] 이미 존재하는 여러개의 서브클래스를 사용해야 하는데, 이 서브클래스들의 상속을 통해서 이들의 인터페이스를 다 개조한다는 것이 현실성이 없을 때. 객체 적응자를 써서 부모 클래스의 인터페이스를 변형하는 것이 더 바람직함

### 결과

- 클래스적응자의 장단점
  - Adapter 클래스는 Adaptee 클래스를 Target 클래스로 변형하는데, 이를 위해서 Adaptee 클래스를 상속받아야 하기 때문에, 하나의 클래스와 이 클래스의 모든 서브클래스들을 개조할 때라면 클래스 적응자 방식을 사용할 수 없음 즉 Adapter는 명시적으로 Adaptee를 상속받고 있을 뿐 Adaptee의 서브 클래스들을 상속받는 것은 아니므로 Adaptee의 서브클래스에 정의된 기능들을 사용할 수 없음
  - Adapter 클래스는 Adaptee 클래스를 상속하기 때문에 Adaptee에 정의된 행동을 재정의 가능
  - 한 개의 객체만 사용하며 Adaptee로 가기 위한 추가적인 포인터 간접화는 필요 없음
- 객체 적응자의 장단점
  - Adapter 클래스는 하나만 존재해도 수많은 Adaptee 클래스들과 동작할 수 있음 Adapter ㅋ객체가 포함하는 Adaptee에 대한 참조자는 Adaptee의 인스턴스를 관리할 수도 있고 Adaptee 클래스를 상속받는 다른 서브클래스들의 인스턴스도 관리할 수 있기 때문임 그러므로 하나의 Adapter 클래스로 모든 Adaptee 클래스와 이를 상속받는 서브클래스 모두를 이용할 수 있게 됨
  - Adaptee 클래스들의 행동을 재정의하기개 매우어려움 따라서 Adaptee를 상속받는 서브클래스를 구현하고 Adapter 클래스는 이 서브클래스를 참조하도록 해야함

- Adapter 패턴을 사용하면서 고려해야 할 추가적인 사항
  - **Adapter 클래스가 실제 적응 작업을 위해 들어가는 품이 얼마나 되나?:** 이는 적응을 어떻게 시킬것인가에 따라 달라짐 작업량을 결정짓는 요인은 Target 인터페이스와 Adaptee간에 얼마만큼의 유사성을 갖는가의 부분임
  - **대체 가능 적응자:** 클래스의 재사용성을 높이려면, 누가 이 클래스를 사용할지에 대한 생각을 최소화해야함 즉 내가 개발한 클래스를 사용할 모든 사용자에게 동일한 인터페이스를 제공해야 한다는 가정을 배제해야함 다른 인터페이스를 원하는 사용자가 있다면 적응자 클래스를 만들면됨
  - **양방향 적응자를 통한 투명성 제공:** 적읒아의 잠재적인 문제는 적응자가 모든 사용자에게 투명하지 않다는 것



## 브릿지(Bridge) 패턴

### 의도

구현에서 추상을 분리하여 이들이 독립적으로 다양성을 가질 수 있도록 함

### 동기

- 하나의 추상적 개념이 여러가지 구현으로 구체화 될 수 있을 때 대부분 상속을 통해서 이 문제를 해결함
- 그러나 상속은 구현과 추상적 개념을 영구적으로 종속시키기때문에 추상적 개념과 구현을 분리해서 재사용하거나 수정 확장하기가 쉽지 않음
- 브릿지패턴은 추상적 개념에 해당하는 클래스계통과 구현에 해당하는 클래스 계통을 분리함으로써 문제를 해결함

### 활용성

- 추상적 개념과 이에 대한 구현 사이의 지속적인 종속 관계를 피하고싶을때 ex 런타임에 구현을 변경
- 추상적 개념과 구현 모두가독립적으로 서브클래싱을 통해 확장되어야 할 때 이때 브릿지패턴은 개발자가 구현을 또 다른 추상적 개념과 연결할 수 있게 할 뿐 아니라 각각을 독립적으로 확장 가능하게함
- 추상적 개념에 대한 구현 내용을 변경하는 것이 다른 관련 프로그램에 아무련 연관이 없을때 사용함 변경되더라도 다시 컴파일되지 않아야함
- 클래스의 구현과 속성에 대한 모든 표현 방식을 완전하게 은닉하고싶을때 단순히 구현방식은 멤버 변수로만 존재함

### 결과

1. **인터페이스와 구현 분리:** 구현이 인터페이스에 얽매이지 않게 됨. 추상적 개념에 대한 어떤 방식의 구현을 런타임에 결정지을 수 있음 이는 런타임에 어떤 객체가 자신의 구현을 수시로 변경할 수 있음을 의미함
2. Abstraction과 Implementor를 독립적으로 확장하 ㄹ수 있음
3. **구현 세부 사항을 사용자에게서 숨기기:** 상세한 구현 내용을 사용자에게서 은닉할 수 있음





## 컴포지트(Composite) 패턴

### 의도

- 부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성함
- 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴

### 동기

- 복합체 패턴의 가장 중요한 요소는 기본 클래스와 이들의 컨테이너를 모두 표현할 수 있는 하나의 추상화 클래스를 정의하는 것

### 활용성

- 부분 - 전체의 객체 계통을 표현하고 싶을 때
- 사용자가 객체의 합성으로 생긴 복합 객체와 개개의 객체 사이의 차이를 알지 않고도 자기 일을 할 수 있도록 만들고 싶을 때 사용자는 복합구조의 모든 객체를 똑같이 취급하게 됨

### 참여자

- Component: 집합 관계에 정의될 모든 객체에 대한 인터페이스를 정의함. 모든 클래스에 해당하는 공통의 행동을 구현함. 
- Leaf: 가장 말단 객체, 자식이 없고 객체 합성에 가장 기본이 되는 객체의 행동을 정의
- Composite: 자식이 있는 구성 요소에 대한 행동을 정의함 자신이 복합하는 요소들을 저장하면서, Component 인터페이스에 정의된 자식 관련 연산을 구현함

### 결과

- 기본 객체와 복합 객체로 구성된 하나의 일관된 클래스 계통을 정의함, 기본 객체는 더 복합적인 객체들에 속해있을 수 있고 복합 객체 역시 다른 것에 속해있을 수 있지만 사용자 코드는 일반화된 상위 개념의 객체를 조작하는 방식으로 프로그래밍하면 런타임 기본 객체와 복합 객체를 구분하지 않고 일관되게 프로그래밍 할 수 있게됨
- 사용자의 코드가 단순해짐사용자는 객체 특성이 복합 구조인지 단일 구조인지조차 모르고 개발할 수 있게됨 이런 구분이 필요하지 않으므로 개발자의 코드에 switch case 스타일의 함수를 쓸 필요가 없어지므로 코드가 단순해짐
- 새로운 종류의 구성요소를 쉽게 추가 가능 새롭게 정의된 Composite나 Leaf의 서브클래스들은 기존에 존재하는 구조들과 독립적으로 동작이 가능하게됨 새로운 요소가 추가되었다고 해서 사용자의 프로그램이 변경될 필요가 없음
- 설계가 지나치게 범용성을 많이가짐 새로운 요소를 쉽게 추가할 때의 단점은 복합체의 구성요소에 제약을 가하기 힘들다는 것 가끔 복합체가 오직 한 개의 구성요소만 가졌으면 할때가 있는데 타입시스템으로는 검사가 불가능하고 런타임시점에 검사해야함

## 데코레이터(Decorator) 패턴

### 의도

- 객체에 동적으로 새로운 책임을 추가할 수 있게 함
- 기능을 추가하려면 서브클래스를 생성하는 것 보다 융통성 있는 방법을 제공함

### 동기

- 전체 클래스에 새로운 기능을 추가할 필요는 없지만 개별적인 객체에 새로운 책임을 추가할 필요가 있음 
- 지금 필요한 기능을 추가하는 다른 객체에다가 해당 구성요소를 둘러 싸는것 이것을  데코레이터라고함
- 데코레이터는 자신이 둘러싼 요소, 구성요소가 갖는 인터페이스를 자신도 동일하게 제공하므로 데코레이터의 존재는 이를 사용하는 사용자에게 감춰짐
- 자신이 둘러싼 구성요소로 전달되는 요청을 중간에 가로채서 해당 구성요소에 전달해줌
- 데코레이터는 중첩이 가능하고 책임을 무한대로 추가할 수 있음

### 활용성

- 동적으로 투명하게 다른 객체에 영향을 주지 않고 객개의 객체에 새로운 책임을 추가하기 위해 사용함
- 제거될 수 있는 책임에 대해 사용함
- 실제 상속으로 서브클래스를 계속 만드는 방법이 실질적이지 못할 때 사용함 너무 많은 수의 독립된 확장이 가능할 때 모든 조합을 지원하기 위해 상속으로 해결하면 클래스 수가 폭발적으로 많아지게 됨

### 참여자

- Component : 동적으로 추가할 서비스를 가질 가능성이 있는 객체들에 대한 인터페이스
- ConcreteComponent : 추가적인 서비스가 실제로 저으이도어야 할 필요가 있는 객체
- Decorator: Component 객체에 대한 참조자를 관리하면서 Component에 저으이된 인터페이스를 만족하도록 인터페이스를 정의
- ConcreateDecorator: Component 에 새롭게 추가할 서비스를 실제로 구현하는 클래스

### 결과

- **단순한 상속보다 설계의 융통성을 더 많이 증대시킬 수 있음:** 데코레이터 패턴은 객체에 새로운 행동을 추가할 수 있는 가장 효과적인 방법임. 이런 행동의 추가 삭제가 런타임시점에 가능하게 됨
- **클래스 계통의 상부측 클래스에 많은 기능이 누적되는 상황을 피할 수 있음:** 필요한 비용만 그때 지불하는 방법을 제공함 지금 예상하지 못한 특성이나 기능들을 데코레이터 객체를 통해 지속적으로 추가할 수 있음
- **데코레이터와 데코레이터의 구성 요소가 동일한 것은 아님:** 데코레이터는 사용자에게 일관된 인터페이스를 제공하는 껍데기일 뿐
- **데코레이터를 사용하면 작은 규모의 객체들이 많아짐**: 수가 너무 많아짐에 따라 모두 이해하기 어렵고 수정하는 과정이 복잡해짐



## 퍼사드(Facade) 패턴

### 의도

- 한 서브시스템 내의 인터페이스 집합에 대한 획일화된 하나의 인터페이스를 제공하는 패턴으로, 서브시스템을 사용하기 쉽도록 상위 수준의 인터페이스를 정의함

### 동기

- 시스템을 서브시스템으로 구조화하면 복잡성을 줄이는 데에 큰 도움ㅇ ㅣ됨
- 공통적인 설계 목표는 서브시스템들 사이의 의사소통 및 종속성을 최소화 하려는 것임 이런 목표를 달성하도록 도와주는 패턴이 퍼사드 패턴 
- 주어진 서브시스템의 일반적인 기능애 대한 단순화된 인터페이스를 제공하려는 것 

### 활용성

- 복잡한 서브시스템에 대한 단순한 인터페이스 제공이 필요할 때. 시스템 범위가 확장되면 또한 구체적으로 설계되면 서브시스템은 계속 복잡해짐
- 패턴을 적용하면 확장성을 고려하여 설계하기 때문에, 작은 클래스가 만들어지게 됨. 이런 과정은 서브시스템을 재사용 가능한 것으로 만들어 주고 재정의 할 수 있는 단위가 되도록 해 주기도 하지만, 실제 이런 상세한 재설계나 정제의 내용까지 파악할 필요가 없는 개발자들에게는 복잡해진 각각의 클래스들을 다 이해하면서 서브클래스를 사용하기 어려움 이럴때 퍼사드 패턴을 사용하면 서브시스템에 단순하면서도 기본적인 인터페이스를 제공함으로써 대부분의 개발자들에게 적합한 클래스 형태를 제공함
- 추상 개념에 대한 구현 클래스와 사용자 사이에 너무 많은 종속성이 존재할 때 퍼사드의 사용을 통해 사용자와 다른 서브시스템 간의 결합도를 줄일 수 있음, 즉 서브시스템에 정의된 모든 인터페이스가 공개되면 빈번한 메서드 호출이 있을 수 있으나, 이런 호출은 단순한 형태로 통합하여 제공하고 나머지 부분은 실질적으로 감소하게 되는 효과
- 서브시스템을 계층화 시킬 때 퍼사드 패턴을 사용하여 각 서브시스템의 계층에 대한 접근점을 제공함 서브시스템이 다른 서브시스템에 종속적이라 하더라도 각자가 제공하는 퍼사드를 통해서만 대화를 진행하게 함으로써 서브시스템 간의 종속성을 줄일 수 있음  이로써 서브시스템 내부 설계의 변경이 다른 서브시스템에 독립적으로 자유롭게 될 수 있는 것

### 참여자

- 퍼사드: 단순하고 일관된 통합 인터페이스를 제공하며 서브시스템을 구성하는 어떤 클래스가 어떤 요청을 처리해야 하는지 알고 있으며, 사용자의 요청을 해당 서브시스템 객체에 전달함
- 서브시스템들: 서브시스템의 기능을 구현하고 퍼사드 객체로 할당된 작업을 실제로 처리하지만 퍼사드에 대한 아무런 정보가 없음.

### 결과

- 서브시스템의 구성요소를 보호할 수 있음. 사용자가 다루어야할 객체의 수가 줄어들며 서브시스템을 쉽게 사용할 수 있음
- 서브시스템과 사용자 코드 간의 결합도를 더욱 약하게 만듬



## 플라이급

### 의도

- 공유를 통해 많은 수의 소립 객체들을 효과적으로 지원함

### 동기

- 객체는 공유 가능한 객체로, 그러나 각각 상황에서는 동작함
- 플라이급 패턴에서 중요한 개념은 본질적 상태와 부가적 상태의 구분임 본질적 상태는 플라이급 객체에 저장되어야 하며 이것이 적용되느 상황과 상관 없는 본질적 특성 정보들이 객체를 구성함 본질적이지 않은 부가적 상태는 플라이급 객체가 사용될 상황에 따라 달라질 수 있고 그 상황에 종속적임
- 플라이급 패턴으로 모델링되는 개념이나 개체들은 객체로 표현하기에는 규모가 너무 작은 ex 문서에서 각 글자

### 활용성

- 응용프로그램이 대량의 객체를 사용해야 할 때
- 객체의 수가 너무 많아져 저장 비용이 너무 높아질 때
- 대부분의 객체 상태를 부가적인 것으로 만들 수 있을 때
- 부가적인 속성들을 제거한 후 객체들을 조사해보니 객체의 많은 묶음이 비교적 적은 수의 공유된 객체로 대체될 수 있을 때 현재 서로 다른 객체로 간주한 이유는 이들 부가적인 속성 때문이 었는지 본질이 달랐던 것은 아닐 때
- 응용프로그램이 객체의 정체성에 의존하지 않을때 플라이급 객체들은 공유될 수 있음을 의미하는데 식별자가 있다는 것은 서로 다른 객체로 구별해야 한다는 의미이므로 플라이급 패턴 사용 X

### 참여자

- Flyweight: Flyweight가 받아들일 수 있고 부가적 상태에서 동작해야 하는 인터페이스를 선언
- ConcreateFlyweight: Flyweight인터페이스를 구현하고 내부적으로 갖고 있어야 하는 본질적 상태에 대한 저장소를 정의, ConcreateFlyweight 객체는 공유할 수 있는 것이어야 함. 고나리하는 어떤 상태라도 본질적인 것이어야 함
- UnsharedConcreateFlyweight: 모든 플라이급 서브클래스들이 공유될 필요는 없음 Flyweight 인터페이스는 공유를 가능하게 하지만 그것을 가용해서는 안됨 
- FlyweightFactory: 플라이급 객체를 생성하고 관리하며 플라이급 객체가 제대로 공유되도록 보장함 사용자가 플라이급 객체를 요청하면 Flyweight-Factory 객체는 이미 존재하는 인스턴스를 제공하거나 없으면 새로 생성함
- Client: 플라이급 객체에 대한 참조자를 관리하며 플라이급 객체의 부가적 상태를 저장함

### 결과

- 공유해야하는 인스턴스의 전체 수를 줄이 수 있음
- 객체별 본질적 상태의 양을 줄일 수 있음
- 부가적인 상태는 연산되거나 정의될 수 있음
- 더 많은 플라이웨이가 공유될수록 저장소는 절약됨 
- 대부분의 본질적인 상태가 저장되고 부가적인 상태는 연산될 때라면 절약의 효과가 가장 큼 이때는 본질적 상태를 저장하는 비용이 줄어드는 대신 부가적 상태를 만들기 위한 연산의 시간을 투자해야함
- 플라이급 패턴은 복합체 패턴과 조합하여 그래프와 같이 계층적 구조를 모델링하는데 사용함 

### 구현

- 부가적 상태를 제외함
- 공유할 객체를 관리함



## 프록시(Proxy) 패턴

### 의도

- 다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리채움자 역을 하는 객체를 둠

### 동기

- 어떤 객체에 대한 접근을 제어하는 한 가지 이유는 실제로 그 객체를 사용할 수 있을 때까지 객체 생성과 초기화에 들어가는 비용 및 시간을 물디 않겠다는 것임

### 활용성

- 원격지 프록시는 서로 다른 주소 공간에 존재하는 객체를 가리키는 대표 객체임
- 가상 프록시는 요청이 있을 때만 필요한 고비용 객체를 생성함
- 보호용 프록시는 원래 객체에 대한 실제 접근을 제어함 객체별로 제어 접근 권한이 다를 때 유용하게 사용 가능
- 스마트 참조자는 원시 포인터의 대체용 객체로 실제 객체에 접근이 일어날 때 추가적인 행동을 수행함

### 참여자

- proxy:
  - 실제로 참조할 대상에 대한 참조자를 관리함 
  - subject와 동일한 인터페이스를 제공하여 실제 대상을 대체할 수 있어야함
  - 실제 대상에 대한 접근을 제어하고 실제 대상의 생성과 삭제를 책임짐
  - proxy 종류에 따라서 다음을 수행함
    - 원격지 프록시는 요청 메시지와 인자를 인코딩하여 이를 다른 주소 공간에 잇는 실제 대상에게 전달
    - 가상의 프록시는 실제 대상에 대한 추가적 정보를 보유하여 실제 접근을 지연할 수 있도록 해야 함
    - 보호용 프록시는 요청한 대상이 실제 요청할 수 있는 권한이 있는지 확인할 것
- subject: realsubject와 proxy에 공통적인 인터페이스를 정의하고 realsubject가 요청되는 곳에 proxy를 사용할 수 있게 함
- realsubect: 프록시가 감싸는 실제 객체

### 결과

- 프록시 패턴은 어떤 객체에 접근할 때 추가적인 간접화 통로를 제공함 
  - 원격지 프록시(remote proxy)는 객체가 다른 주소 공간에 존재한다는 사실을 숨길 수 있음
  - 가상 프록시(virtual proxy)는 요구에 따라 객체를 생성하는 등 처리를 최적화 할 수 있음
  - 보호용 프록시(protect) 및 스마트 참조자는 객체가 접근할 때마다 추가 관리를 책임짐 
- 비슷한 개념으로 기록 시점 복사가 있음

## 구조 패턴에 대한 논의

- 구조 패턴에서 구조나 동작 방법을 살펴보면  코드와 객체를 구조화하려고 언어가 제공하는 아주 작은 범위의 개념을 이용하기 때문에 각 패턴의 구조가 비슷할 수밖에 없음

**적응 패턴 대 가교 패턴**

- 둘 다 다른 객체에 대한 직접 접근 대신에 다른 우회적 방법으로 접근하여 유연성을 증대시킴
- 적응자의 목적은 이미 존재하는 두 인터페이스 간의 불일치를 해결하려는 것
- 가교패턴은 추상적 개념과 구현을 따로 만들고 이를 연결시키려는 것이 주 목적
- 적응자는 이미 개발이 완료되어 운영 중인 두 클래스 사이에서 호환되지 않은 부분을 찾았을 때 적용하는 패턴
- 가교 패턴은 이미 사용자가 추상적 개념을 구현하는 방법이 여러가지이고, 이를 각각 독립적으로 진화할 수 있음을 파악한 상태에서 적용하는 패턴
- 적응자 패턴은 설계가 완료된 후에 , 가교패턴은 설계 완료 이전에 수행

**복합체 패턴 대 장식자 패턴 대 프록시 패턴**

- 복합체랑 장식자랑 비슷함 객체를 조직화하기 위해 재귀적 합성 기법을 사용하기 때문임
- 장식자 패턴은 상속 없이 객체에 새로운 서비스를 추가하려는 것이 목적임 그러므로 이미 만든 서비스 클래스의 조합이 필요할 때마다 클래스를 생성해야 하는 문제를 해결해야함 
- 복합체 패턴은 클래스 구조화에 초점을 맞춘 것으로 어떻게 관련된 객체들을 하나의 인터페이스로 다룰수 있도록 일관성을 부여할 것인가가 중요한 관건임
- 프록시 패턴과 장식자도 비슷하지만 프록시는 장식자와 달리 동적으로 어떤 기능성을 추가 제거하지는 않고 대상에 대한 참조자를 직접 관리하는 불편함을 해결하려는 것





# #5 행동 패턴(Behavioral pattern)

- 행동 패턴은 어떤 처리의 책임을 어느 객체에 할당하는 것이 좋은지, 알고리즘을 어느 객체에정의하는 것이 좋은지 등을 다룸
- 응용프로그램에 따라서 행동이 다른 객체로 옮겨가거나 알고리즘이 대체될 때가 생기기 마련임 이때 변화의 개념을 만족할 수 있는 것이 행동 패턴임
- 이 행동 패턴을 사용하면 우리는 객체 간의 제어 구조보다는 객체들을 어떻게 연결시킬 것인가에 좀 더 중점을 둘 수 있음



## 책임 연쇄(Chain of Responsibility) 패턴

### 의도

- 메시지를 보내는 객체와 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴 하나의 요청에 대한 처리가 반드시 한 객체에서만 되지 않고 여러 객체에게 그 처리 기회를 주려는 것

### 동기

- 이 패턴의 아이디어는 메시지 송신 측과 수신 측을 분리하는 것임 이를 위해 이 요청을 처리하는 기회를 다른 객체에 분산함 요청은 실제 이 요청을 처리할 객체를 찾을 때까지 객체 연결 고리를 따라 전달됨
- 즉 송신하는 측이 자신이 아는 주체에게 처리를 요청하면 이를 수신한 객체가 자신과 연결된 고리를 따라서 계속 이 요청을 전달하고 이 중에 어느 한 객체가 실제 상황에 적합하다고 판단되면 자신에게 정의된 서비스를 제공함

### 활용성

- 하나 이상의 객체가 요청을 처리해야하고 그 요청 처리자 중 어떤 것이 선행자 인지 모를 때 처리자가 자동으로 확정 되어야 함
- 메시지를 받을 객체를 명시하지 않은 채 여러 객체 중 하나에게 처리를 요청하고 싶을 때
- 요청을 처리할 수 있는 객체 집합이 동적으로 정의되어야 할 때

### 참여자

- Handler: 요청을 처리하는 인터페이스를 정의하고 후속 처리자와 연결을 구현함. 연결고리에 연결된 다음 객체에게 다시 메시지를 보냄
- ConcreateHandler: 책임져야 할 행동이 있다면 스스로 요청을 처리하여 후속 처리자에 접근할 수 있음 즉 자신이 처리할 행동이 있으면 처리하고 그렇지 않으면 후속 처리자에 다시 처리를 요청함
- Client: ConcreateHandler 객체에게 필요한 요청을 보냄

### 결과

- **객체 간의 행동적 결합도가 적어짐:** 다른 객체가 어떻게 요청을 처리하는지 몰라도됨 단지 요청을 보내는 객체는 이 메시지가 적절하게 처리될 것이라는 것만 확신하면 됨, 송수신측 모두 서로를 모르고 연결된 객체들 조차도 그 연결구조가 어떻게 되는 지 모름 
- **객체에게 책임을 할당하는데 유연성을 높일 수 있음:**  객체의 책임을 여러 객체에게 분산시킬 수 있으므로 런타임에 객체 연결 고리를 변경하거나 추가하여 책임을 변경하거나 확장할 수 있음
- **메시지 수신이 보장되지 않음:** 어떤 객체가 이 처리에 대한 수신을 담당한 다는 것을 명시하지 않으므로 요청이 처리된다는 보장이 없음 만약 연결고리가 잘 성립이 안되었다면 요청은 무시될 수 있음



## 커맨드(Command) 패턴

### 의도

- 요청 자체를 캡슐화 시킴, 이를 통해 요청이 서로 다른 사용자를 매개변수로 만들고 요청을 대기시키거나 로깅하며 되돌릴 수 있는 연산을 지원함

### 동기

- 항상 그렇지는 않지만 요청 받은 연산이 무엇이며 이를 처리할 객체가 누구인지에 대한 아무런 정보 없이 임의의 객체에 메시지를 보내야 할 때가 간간이 있음
- 이 패턴의 핵심은 연산을 실행하는데 필요한 인터페이스를 선언해 놓는 Command 추상 클래스임 이 클래스에 가장 기본적인 연산이 Execute()인데 Command 추상 클래스에서 상속받은 Command 서브클래스들은 수신 객체에 대한 참조자를 인스턴스 변수로 저장하며 이 수신 객체에 정의된 요청을 호출하도록 Execute를 구현하여 수신자-작동 쌍을 정의함 수신 객체는 자신에게 전달된 요청을 어떻게 처리해야 하는지 안다.
- 커맨드 패턴이 연산을 호출하는 객체와 수행하는 객체를 분리함
- 이로써 사용자 인터페이스를 구현하는 데 많은 융통성을 부여할 수 있음 단지 이들 인터페이스 요소가 커맨드를 상속하는 동일한 서브클래스를 공유함으로써 동일하게 처리되기 때문임 
- 커맨드를 동적으로 교체할 수 도 있음

### 활용성

- 수행할 동작을 객체로 매개변수화하고자 할 때 절차지향 프로그램에서는 이를 콜백 함수, 즉 어딘가 등록되었다가 나중에 호출되는 함수를 사용해서 이러한 매개변수화를 표현할 수 있음 커맨드 패턴은 콜백을 객체지향 방식으로 나타낸 것임 
- 서로 다른 시간에 요청을 명시하고, 저장하며, 실행하고 싶을때 커맨드 객체는 원래의 요청과 다른 생명주기가 있음 요청을 받아 처리하는 객체가 주소 지정 방식과는 독립적으로 표현될 수 있다면 커맨드 객체를 다른 프로세스에게 넘겨주고 거기서 해당 처리를 진행하게 할 수 있음
- 실행 취소 기능을 지원하고 싶을 때. 커맨드의 execute 연산은 상태를 저장할 수 있는데 이를 이용해서 지금까지 얻은 결과를 바꿀 수 있음 이를 위해 Unexecute 연산을 커맨드 클래스의 인터페이스 추가함 실행된 명령어를 모두 기록해 두었다가 이 리스트를 역으로 탐색해서 다시 Unexecute를 수행하게 함
- 시스템이 고장났을 때 재적용이 가능하도록 변경 과정에 대한 로깅을 지원하고 싶을 때. 커맨드 인터페이스를 확장해ㅐ서 load와 store 연산을 정의하면 상태의 변화를 지속적 저장소에 저장해 둘 수 있음 시스템 장애가 발생핬을때 해당 저장소에서 저장된 명령어를 읽어 다시 Execute 연산을 통해 재실행 하면 됨
- 기본적인 연산의 조합으로 만든 상위 수준 연산을 써서 시스템을 구조화하고 싶을 때 정보 시스템의 일반적인 특성은 트랜잭션을 처리해해야 한다는 것임 커맨드 클래스는 일관된 인터페이스를 정의하는데 이로써 모든 트랜잭션이 동일한 방식으로 호출됩니다. 새로운 트랜잭션을 만들면 상속으로 command 클래스를 확장하면 되므로 시스템 확장도 어렵지 않음

### 참여자

- Command: 연산 수행에 필요한 인터페이스를 선언
- ConcreateCommand : 객체와 액션 간의 연결성읠 정의함 또한 처리 객체에 정의된 연산을 호출하도록 execute를 구현함 
- client: 객체를 생성하고 처리 객체로 정의함
- Invoker: 명령어에 처리를 수행할 것을 요청함
- Receiver: 요청에 관련된 연산 수행 방법을 알고있음 어떤 클래스도 요청 수신자로서 동작할 수 있음

### 결과

- 커맨드는 연산을 호출하는 객체와 연산 수행 방법을 구현하는 객체를 분리함
- 커맨드는 일급 클래스임 다른 객체와 같은 방식으로 조작되고 확장할 수 있음
- 명령을 여러개 복합해서 복합 명령을 만들 수 있음 복합체 패턴을 이용하여 여러 명령어를 구성할 수 있음
- 새로운 커맨드 객체를 추가하기 쉬움 기존 클래스를 변경할 필요 없이 단지 새로운 명령어에 대응하는 클래스만 정의하면 됨





## 인터프리터(Interpreter) 패턴

### 의도

- 어떤 언어에 대해 그 언어의 문법에 대한 표현을 정의하면서 그 표현을 사용하여 해당 언어로 기술된 문장을 해석하는 해석자를 함께 정의

### 동기

- 특정한 종류의 문제가 자주 발생할때는  어떤 간결한 언어를 써서 그 문제를 문장으로 표현하는 것이 나을 수 있음. 그 뒤 그 문장을 해성하는 해석자를 만들어 그 문장을 해석해서 문제를 해결할 수 있는 해석자를 만드는것임
- 문자열에서 어떤 패턴을 매번 찾는것보다 정규식을 해석하는 알고리즘을 한 번 만드는 것이 더 나음
- 해석자 패턴은 간단한 언어의 문법을 정의하는 방법과 그 언어로 문장을 구성하는 방법 이들 문장을 해석하는 방법을 설명함

### 활용성

- 해석이 필요한 언어가 존재하거나 추상 구문 트리로서 그 언어의 문장을 표현하고자 한다면 해석자 패턴을 사용해야함
- 정의할 언어의 문법이 간단해짐 문법이 복잡하다면 문법을 정의하는 클래스 계통이 복잡해지고 관리가 어려워짐
- 효율성은 별로 고려할 사항이 아님

### 참여자

- AbstractExpression: 추상 구문 트리에 속한 모든 노드에 해당하는 클래스들이 공통적으로 가져가야할 interpret 연산을 추상 연산으로 정의함
- TerminalExpression: 문법에 정의한 터미널 기호와 관련된 해석 방법을 구현함 문장을 구성하는 모든 터미널 기호에 대해서 해당 클래스를 만들어야함
- NonterminalExpression: 문법의 오른편에 나타나는 모든 기호에 대해서 클래스를 정의해야함
- Context: 번역기에 대한 포괄적인 정보를 포함함
- Client: 언어로 정의한 특정 문장을 나타내는 추상 구문 트리

### 결과

- 문법의 변경과 확장이 쉬움
- 문법의 구현이 용이함
- 복잡한 문법은 관리하기 어려움
- 표현식을 해석하는 새로운 방법을 추가할 수 있음

## 중재자(Mediator) 패턴

### 의도

- 한 집합에 속해있는 객체의 상호작용을 캡슐화하는 객체를 정의함 객체들이 직접 서로를 참조하지 않도록 하여 객체 사이의 소결합을 촉진시키며 개밸자가 객체의 상호작용을 독립적으로 다양호화시킬 수 있게 만듦

### 동기

- 객체지향에서는 여러 객체에게 행동을 분산시키고 각 객체마다 연결관계가 있음 시스템은 자신의 행동을 처리하기 위해 다른 모든 객체에 대한 참조자를 관리해야 하는 최악의 상황에 직면할지도 모름
- 중재자 객체를 사용하면 상호작용과 관련된 행동을 하나의 객체로 모아서 이런 문제를 피해갈 수 있음 중재자 객체는 객체 그룹 간의 상호작용을 제어하고 조화를 이루는 역할을 함 그룹 내 객체들에 대한 포인터를 중재자 객체가 관리하기 때문에 객체들은 다른 객체에 대한 참조자 대신 단지 해당 중재자만 알면 됨 즉, 객체 사이의 연결 정도가 줄어듦
- 실제 상호작용하는 객체들은 직접적인 연관이 없고 중재자만 객체들의 상태를 전부 갖고 있어서 중간에 다리 역할을 함

### 활용성

- 여러 객체가 잘 정의된 형태이기는 하지만 복잡한 상호작용을 가질 때, 객체 간의 의존성이 구조화되지 않으며 잘 이해하기 어려울 때
- 한 객체가 다른 객체를 너무 많이 참조하고 너무 많은 의사소통을 수행해서 그 객체를 재사용하기 힘들 때
- 여러 클래스에 분산도니 행동들이 상속 없이 상황에 맞게 수정되어야 할 때

### 참여자

- Mediator: Colleague 객체와 교류하는데 필요한 인터페이스를 정의함
- ConcreateMediator: Colleague 객체와 조화를 이뤄서 협력 행동을 구현하며, 자신이 맡을 동료를 파악하고 관리함
- Colleague 클래스들: 자신의 중재자 객체가 무엇인지 파악함. 다른 객체와 통신이 필요하면 그 중재자를 통해 통신되도록 하는 동료 객체를 나타내는 클래스임

### 결과

- 서브클래싱을 제한함 중재자는 다른 객체 사이에 분산된 객체들의 행동들을 하나의 객체로 국한함
- Colleague 객체 사이의 종속성을 줄임, 중재자는 행동에 참여하는 객체 간의 소결합을 증진시킴
- 객체 프로토콜을 단순화함, 중자재는 n:n 관계를 1:n으로 축소시켜서 이해와 유지보수를 쉽게 함
- 객체간의 협력 방법을 추상화함, 객체 사이의 중재를 독립적인 개념으로 만들고 이것을 캡슐화함으로써 사용자는 각 객체의 행동과 상고나없이 객체간 연결 방법에만 집중할 수 있음
- 통제가 집중화됨: 중자재 패턴은 상호작용의 복잡한 모든 것들이 자신 내부에서만 오가게함 중재자 객체는 동료 객체 간의 상호작용에 관련된 포로토콜을 모두 캡슐화하기 때문에 어느 동료 객체보다도 훨씬 복잡해질 수 있음

### 구현

- 관련 객체들이 오직 하나의 Mediator 클래스와 동작한다면 추상클래스로 정의할 필요 없음 다른 상호작용을 정의할 새로운 midiator 서브클래스를 만들 때를 대비하는 것임
- ex: 항공쪽에서 중앙 컨트롤러, 비행기끼리는 서로 통신하지않고 중앙 컨트롤 타워랑만 통신하기 때문에 중재자 패턴을 적용할 수 있음

## 메멘토(Memento) 패턴

### 의도

- 캡슐화를 위배하지 않은 채 어떤 객체의 내부 상태를 잡아내고 실체화시켜 둠으로써 이후 해당 객체가 그 상태로 되돌아올 수 있게 함

### 동기

- 때에 따라 객체의 내부 상태를 기록해둘 필요가 있음 객체를 이전 상태로 복구하려면 복구할 시점의 상태 정보가 있어야 함 
- 메멘토 패턴은 다른 객체, 원조 객체가 가진 내부 상태의 스냅샷을 저장하는 객체를 만드는 것
- 실행 취소 매커니즘은 원조본 객체의 상태를 확인할 필요가 있을 때 원조본이 메멘토에게 상태를 알려달라는 요청을 보낼 수 있을 것임 원조본은 현재 상텨를 알려주는 정보로 메멘토를 초기화함 메멘토에 정보를 저장하고 메멘토에서 정보를 검색할 수 있는 것은 원조본의 자긱을 가진 객체 뿐 

### 활용성

- 어떤 객체의 상태에 대한 스냅샷을 저장한 후 나중에 이 상태로 복구해야 할 때
- 상태를 얻는 데 필요한 직접적인 인터페이스를 두면 그 객체의 구현 세부 사항이 드러날 수 밖에 없고 이것으로 객체의 캡슐화가 깨질 때

### 참여자

- Memento: 원조본 객체의 내부 상태를 저장함 메멘토는 원조본 객체를 제외한 다른 객체는 자신에게 접근할 수 없도록 막음  그래서 메멘토 클래스에는 의 인터페이스에는 Caretaker 클래스와 Originator 클래스가 있음
- Caretaker는 메멘토를 다른 객체에게 넘겨줄 수만 있음
- Originator는 메멘토의 보관을 책임지는 























