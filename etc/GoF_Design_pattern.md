





# #1 서론

## 디자인 패턴이란?

- 하나의 패턴에는 다음의 네가지요소가 반드시 들어가 있음
  1. **패턴 이름(pattern name)**은 한 두단 어로 설계 문제와 해법을 서술함 패턴에 이름을 부여하는 것은 설계 어휘 늘리는 일이며, 높은 수준의 추상화된 설계를 할 수 있도록 해줌. 이름을 통해 설계의 의도를 표현하고 생각을 더욱 쉽게, 의사소통을 쉽게할 수 있음 따라서 좋은 이름을 만들어야함
  2. **문제(problem)**는 어떤 패턴을 사용하는가를 서술하며 해결할 문제와 그 배경을 설명함 즉 어떤 알고리즘을 객체로 만들까 와 같은 설계의 세밀한 문제를 설명할 수 있음 때론 유연성 없는 설계가 될 징조를 보이는 클래스나 객체의 구조를 제시하고 문제를 제시함으로써 패턴을 적용하는 것이 의미 있는 사례들을 정의하기도함
  3. **해법(solution)**은 설계를 구성하는 요소들과 그 요소들 간의 관계, 책임 그리고 협력 관계를 서술함.그렇다고 해법이 어떤 구체적인 설계나 구현을 설명하지는 않고 디자인 패턴은 문제에 대한 추상적인 설명을 제공하고 문제를 해결하기 위해서 클래스나 객체들의 나열 방법을 제공함
  4. **결과(consequence)** 는 디자인 패턴을 적용해서 얻는 결과와 장단점을 서술함.
- 디자인패턴은 연결 리스트와 해시 테이블 등을 클래스로 표현하고 그것 자체로 다시 쓸 수 있도록 설계하는 문제를 어떻게 푸느냐에 관한 것이 아님
- 디자인 패턴은 특정한 전후 관계에서 일반적설계 문제를 해결하기 위해 상호 교류하는 수정 가능한 객체와 클래스들에 대한 설명임



## 스몰 토크 MVC를 사용한 디자인 패턴

- MVC는 에서 M은 Model, 응용프로그램 객체이고 View는 스크린에 모델을 디스플레이하는 방법이며, Controller는 사용자 인터페이스가 사용자 입력에 반응하는 방법을 정의함
- 뷰는 그 외형이 반드시 모델의 상태를 반영하도록 보장해야함
- 이런 설계 방법은 더 일반적인 문제에서도 적용 가능한데 즉 한 객체에서 일어난 변경을 다른 객체들에게 반영하도록 별도의 객체를 둠으로써 변경이 일어난 객체는 변경 반영이 필요한 다른 객체들을 알 필요가  없게끔 객체를 분리함 <- 일반화한것이 옵저버 패턴
- 일반적으로 단일 객체처럼 복합 객체를 사용하고 싶을 때가 많음 <- 일반화한것이 컴포지트 패턴
- 뷰와 컨트롤러 관계는 전략 패턴의 한 예임 전략 패턴은 알고리즘을 표현하는 객체로 정적 또는 동적으로 알고리즘을 대체하고자 할 때 매우 유용한 방식
- 팩토리 메서드 패턴을 이용해서 뷰에 대한 기분 컨트롤러 클래스를 지정, 장식자 패턴을 이용해서 뷰에 스크롤을 추가함 등등 
- MVC에서 주로 사용하는 패턴은 감시자, 복합체, 전략 패턴임



## 디자인 패턴을 이용하여 문제를 푸는 방법



### 적당한 객체 찾기

- 객체지향 프로그램은 객체로 만듬. 객체는 데이터와 이 데이터에 연산을 가하는 프로시저(메서드, 연산)를 함께 묶은 단위임. 객체는 요청 또는 메시지를 사용자에게 받으면 연산을 수행함
- 디자인 패턴은 덜 명확한 추상적 개념과 이것을 잡아낸 객체를 알아보는데에 도움을 줌
- 객체를 잘 설계해야한다라는 말을 하는것 같음

### 객체의 크기 결정

- 객체의 크기 또한 디자인 패턴에서 이 문제의 답을 얻을 수 있음
- 퍼사드패턴은 서브시스템을 어떻게 객체로 표현할 수 있는지 설명하고, 플라이급 패턴은 규모는 작지만 개수는 많은 객체를 다루는 방법을 설명함 등등



### 객체 인터페이스의 명세

- 객체가 선언하는 모든 연산은 연산의 이름, 매개변수로 받아들이는 객체들, 연산의 반환값을 명세함 이를 연산의 시그니처라고함 
- 인터페이스는 객체가 정의하는 모든 시그니처들을 일컫는 말이고 객체 인터페이스는 객체가 받아서 처리할 수 있는 연산의 집합임
- 타입은 특정 인터페이스를 나타낼 때 사용하는 이름임 객체가 "Window" 타입을 갖는다는 것은 "Window" 인터페이스에 정의한 연산들을 모두 처리할 수 있다는 것을 의미함.
- 객체는 여러 타입을 가질 수 있고 서로 다른 객체가 하나의 타입을 공유할 수 있음
- 부모 자식 관계에따라 이를 서브타입 슈퍼타입이라고 부름
- 인터페이스의 개념은 객체지향 시스템에서 가장 기본적인 것임 외부에서 객체를 알 수 있는 방법이 인터페이스이기 때문에 인터페이스를 통해서만 처리를 요청할 수 있음
- 동일한 인터페이스를 갖는 두 객체가 완전히 다른 구현을 가질 수 있음
- 어떤 요청과 그 요청을 처리할 객체를 프로그램 런타임 시점에 연결 짓는 것을 동적 바인딩이라고 함
- 동적바인딩은 요청이 어떻게 구현되어 어떤 결과를 만들어 낼지를 런타임에 결정할 수 있음을 의미함
- 즉 프로그램을 작성할 때 객체가 어떤 특정 인터페이스를 갖도록 작성하며 이 객체는 요청을 처리할 정확한 인터페이스를 갖고 있고 동적 바인딩으로 프로그램이 기대하는 객체를 동일한 인터페이스를 갖는 다른 객체로 대체할 수 있을때 이런 대체성을 우리는 다형성이라고 부름
- 다형성은 객체지향 시스템의 핵심 개념임
- 다형성은 사용자의 정의를 단순화하고 객체 간의 결합도를 없애며, 프로그램 실행 중에는 서로 간의 관련성을 다양화할 수 있게 해줌
- 디자인 패턴은 인터페이스에 정의해야 하는 중요 요소가 무엇이고 어떤 종류의 데이터를 주고받아야 하는지 식별하여 인터페이스를 정의하도록 도와줌

### 객체 구현 명세하기

- 어떤 객체의 구현은 클래스에서 정의함 클래스는 객체의 내부 데이터와 표현 방법을 명세하고 그 객체가 수행할 연산을 정의함 
- 객체는 클래스를 인스턴스로 만듦으로써 생성됨 즉 객체는 클래스의 인스턴스임
- 새로운 클래스는 기존 클래스에 기반을 둔 클래스를 상속하여 정의할 수 있음
- 서브클래스는 부모클래스가 정의한 연산을 모두 수행할 수 있음
- 추상클래스는 모든 서브클래스 사이의 공통되는 인터페이스를 정의함
- 정의만하고 구현하지 않는 연산을 추상 연산이라하고 추상클래스가 아닌 클래스를 구체클래스라고함
- 서브클래스는 부모클래스가 정의한 행동을 재정의하거나 정제할 수 있는데 이것을 오버라이드라고 부름
- 믹스인 클래스는 다른 클래스들에게 선택적인 인터페이스 혹은 기능을 제공하려는 목적을 가진 클래스임 인스턴스로 만들 의도가 없다는 면에서 추상 클래스와 비슷함 <- 주로 이벤트 인터페이스를 설명하는것 같음

**클래스 상속 vs 인터페이스 상속**

- 객체의 클래스는 그 객체가 어떻게 구현되느냐를 정의함
- 객체의 타입은 그 객체의 인터페이스, 즉 그 객체가 응답할 수 있는 요청의 집합을 정의함
- 객체의 구현은 다를지라도 인터페이스는 같을 수 있음
- 클래스 상속은 코드와 내부 표현 구조를 공유하는 메커니즘임
- 인터페이스 상속은 어떤 객체가 다른 객체 대신에 사용될 수 있는 경우를 지정하느 메커니즘임



**구현에 따르지 않고, 인터페이스에 따르는 프로그래밍**

- 클래스 상속은 기본적으로 부모 클래스에서 정의한 구현을 재사용하여 응용프로그램의 기능성을 확장하려는 메커니즘임
- 상속이 가진 다른기능들 중에는 동일한 인터페이스를 갖는 객체군을 정의하는 것이 있는데 매우 중요한 특징임 <- 다형성
- 상속을 적절하게 이용하면 모든 클래스는 추상 클래스를 상속하도록 하여 인터페이스를 공유할 수 있게 됨
- 모든 서브클래스들은 추상 클래스에 정의한 인터페이스를 처리할 수 있음 
- 추상클래스를 정의하고 인터페이스 개념으로 객체를 다룰 때 얻을 수 있는 두가지 이점
  1. 사용자가 원하는 인터페이스를 그 객체가 만족하고 잇는 한, 사용자는 그들이 사용하는 특정 객체 타입에 대해 알아야 할 필요는 없음
  2. 사용자는 이 객체들을 구현하는 클래스를 알 필요가 없고, 단지 인터페이스를 정의하는 추상 클래스가 무엇인지만 알면 됨
- **구현이 아닌 인터페이스에 따라 프로그래밍 합니다.**

### 재사용을 실현 가능한 것으로

**상속 대 합성**

- 객체지향 시스템에서 기능의 재사용을 위해 구사하는 가장 대표적인 기법은 클래스 상속, 그리고 객체 합성임
- 서브클래싱에 의한 재사용을 화이트박스 재사용이라고함 화이트박스는 내부를 볼 수 있다는 의미를 가짐 상속을 받으면 부모클래스의 내부가 서브클래스에 의해 공개되기때문에 이런 용어를 씀
- 객체 합성은 클래스 상속에 대한 대안임 다른 객체를 여러개 붙여서 새로운 기능 혹은 객체를 구성하는 것. 객체를 합성하려면 합성에 들어가는 객체들의 인터페이스를 명확하게 정의해두어야함 이런 스타일의 재사용을 블랙바스 재사용이라고하는데 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문임
- 상속과 합성은 서로 장단점이 있음
- 클래스 상속은 컴파일 시점에 정적으로 정의도고 프로그래밍언어가 직접 지원하므로 그래도 사용하면 됨
- 클래스 상속의 단점 중 첫번째는 런타임에 상속받은 부모클래스의 구현을 변경할 수는 없다는 점임 <- 컴파일 시점에 결졍되기 때문
- 두번째단점은 부모 클래스는 서브클래스의 물리적 표현의 최소 부분만을 정의하기 때문에 서브클래스는 부모 클래스가 정의한 물리적 표현들을 전부 또는 일부 상속받는다는 점 부모에서 변경되면 서브에서도 변경되어야함
- 이런 단점을 보완하기 위해서는 추상클래스만을 부모타입으로 두는게 적절함. 추상클래스는 실제 구현이 없기 때문
- 객체의 합성은 한 객체가 다른 객체에 대한 참조자를 얻는 방식으로 런타임에 동적으로 정의됨
- 합성은 객체가 다른 객체의 인터페이스만을 바라보게 하기 때문에 인터페이스 저으이 더 많은 주의를 기울여야함 객체는 인터페이스에서만 접근하므로 캡슐화를 유지할 수 있음 동일 타입이면 런타임에 다른 객체로 대체 가능 
- 상속과 합성은 각자 장단점이 있음 적절히 조합되어야만 완벽한 재사용이 가능함

**위임**

- 위임은 합성을 상속만큼 강력하게 만드는 방법임 위임에서는 두 객체가 하나의 요청을 처리함 수신 객체가 연산의 처리를 위임자에게 보내면 이는 서브클래스가 부모 클래스에게 요청을 전달하는 것과 유사한 방식임
- 위임의 가장 중요한 장점은 런타임에 행동의 복합을 가능하게하고 복합하는 방식도 변경해준다는 것임
- 위임이 갖는 단점은 객체 합성을 통해 소프트웨어 설계의 유연성을 보장하는 방법과 동일하게 동적인데다가 고도로 매개변수화된 소프트웨어는 정적인 소프트웨어 구조보다 이해하기가 더 어렵다는 것임 그 이유는 정적이지 않고 프로그램 내부에서 동적이기 때문임
- 상태, 전략, 방문자 패턴에서 위임 방식을 사용함

**상속 대 매개변수화된 타입**

- 기능의 재사용에 이용할 수 있는 다른 방법을 매개변수화된 타입이라고 함



### 런타임 및 컴파일 타임의 구조를 관계 짓기

- 컴파일 시점의 구조와 런타임의 구조간에 차이가 있기 때문에 코드 자체가 시스템의 동작 방법을 모두 보여줄수는 없음
- 시스템의 런타임 구조는 언어가 아닌 설계자가 만들고 객체와 타입 사이의 관계는 대단히 세심하게 설계해야함
- 많은 디자인 패턴이 컴파일 시점과 런타임의 구조를 명시적으로 구분하고 있음



### 변화에 대비한 설계

- 재사용을 최대화 하기 위해서는 새로운 요구 사항과 기존 요구 사항에 발생한 변경을 예측하여 앞으로의 시스템 설계가 진화할 수 있도록 해야 함
- 변화에 잘 대응하기 위한 소프트웨어를 설계하기 위해서는 소프트웨어를 운영하는동안 앞으로 일어날 변화를 어떻게 수용할 것인가를 미리 고려해야함
- 예측하지 못한 변경에 대해서는 엄청나게 비싼 대가를 지불할 수 밖에 없음
- 디자인 패턴은 어떤 구체적인 원인으로 앞으로 시스템을 변경해야 한다는 것을 미리 보여줌으로써 이런 위험을 줄여줌
- 디자인 패턴을 써서 재설계를 할 수밖에 없게 하는 흔한 이유
  1. **특정 클래스에서 객체 생성:** 객체를 생성할 때 클래스 이름을 명시하면 어떤 특정 인터페이스가 아닌 어떤 특정 구현에 종속됨. 이런 종속은 앞으로의 변화를 수용하지 못함. 이르 ㄹ방지하려면 객체를 직접 생성해서는 안됨. <- 추상 팩토리, 팩토리 메서드, 원형
  2. **특정 연산에 대한 의존성:** 특정한 연산을 사용하려면 요청을 만족하는 한가지 방법에만 매이게 됨. 요청의 처리 방법을 직접 코딩하는 방식을 피하면 컴파일 시점과 런타임 모두를 만족하면서 요청 처리 방버을 쉽게 변경할 수 있음 <- 책임 연쇄, 명령
  3. **하드웨어와 소프트웨어 플랫폼에 대한 의존성:** 플랫폼 종속성을 제거하는 것은 시스템 설계에 있어서 매우 중요함 <- 추상 팩토리, 가교
  4. **객체의 표현이나 구현에 대한 의존성:** 사용자가 객체의 표현 방법, 저장 방법, 구현 방법, 존재의 위치에 대한 몯느 방법을 알고 있다면 객체르 ㄹ변경할 때 사용자도 함께 변경해야함 이런 정보를 사용자에게 감춤으로써 변화의 파급을 막을 수 있음 <- 추상 팩토리, 가교, 메멘토, 프록시
  5. **알고리즘 의존성:** 알고리즘에 종속된 객체라면 알고리즘이 변할 때마다 객체도 변경해야함 변경 가능한 알고리즘은 분리해내는것이 바람직함 <- 빌더, 반복자, 전략, 템플릿 메서드, 방문자
  6. **높은 결합도:** 높은 결합도를 갖게 되면 하나의 커다란 시스템이 되버림 낮은 결합도를 유지해야함 <- 추상 팩토리, 가교, 책임 연쇄, 명령, 퍼사드, 중재자, 감시자
  7. **서브클래싱을 통한 기능 확장:** 서브클래시응로 객체를 재정의하는 것은 쉬운 일이 아님 서브클래스를 정의한다는 것은 최상위 클래스부터 모든 자신의 부모클래스에 대한 것을 이해하고 있어야함 일반적으로 객체 합성과 위임은 행동 조합을 위한 상속보다 훨씬 유연한 방법임 상속을 사용하지 않고도 응용프로그램에 새로운 기능성을 추가할 수 있음 또 한편 객체 합성 위임을 너무 많이사용하면 시스템을 이해하기가 어려워짐  많은 디자인패턴에서는 그냥 서브클래스를 정의하고 다른 인스턴스와 새로 정의한 클래스의 인스턴스를 합성해서 기능을 재정의하는 방법을 도입함 <- 가교, 책임 연쇄, 장식자, 감시자, 전략
  8. **클래스 변경이 편하지 못한점:** 클래스를 변경하기 어려울때 <- 적응자, 장식자, 방문자



## 디자인 패턴을 고르는 방법

1. 패턴이 어떻게 문제를 해결하는지 파악하자.
2. 패턴의 의도 부분을 보자
3. 패턴들 간의 관련성을 파악하자
4. 비슷한 못적의 패턴들을 모아서 공부하자
5. 재설계의 원인을 파악하자
6. 설계에서 가변성을 가져야 하는 부분이 무엇인지 파악하자



## 디자인 패턴 사용 방법









