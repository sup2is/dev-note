

# 훌륭한 프로그래머 되는 법







# #1 코드에 신경쓰기

## 코드가 중요하다

- 좋은 코드를 작성하고 싶다면. 좋은 프로그래머가 되고 싶다면 그만큼 코드에 신경써야함.
- 단지 작동하는 코딩은 거부하고 올바르게 작동하는 훌륭한 코드를 짜도록 노력해야함 + 테스트
- 의도가 드러나는 코드. 유지보수가 쉬운 코드. 정확한 코드
- 훌륭한 결과물을 자랑스러워하거나 더러운 코드에 혐오감을 느끼는 것은 자신이 건전하다는 증거





# #2 정돈된 코드 유지하기

- 누구도 지저분한 코드로 작업하는 걸 좋아하지 않음
- 코드의 레이아웃에 대한 논쟁이 증가할수록 의미 없는 논쟁으로 빠지게 될 확률이 높아짐
- 코드 레이아웃에 대해 싸우는 것을 멈추고, 자신만의 코드 레이아웃을 만드는 올바른 방법을 익히자. <= 이걸로 싸워본적이 없는거같은데.... 쩝



## 보이는 것은 강력하다

- 좋은 코드는 명백하고 일관성이 있음
- 좋은 표현 기법은 아름다움을 위해서가 아니라 실수를 줄이기 위해서임
- 일관성이 없는 레이앗과 뒤죽박죽인 명명은 코드의 품질이 높지 않다는 징후임



## 의사소통

- 컴파일러와 동료 프로그래머를 위한 코딩을 할 것
- 읽기 어려운 코드는 작업하기도 어려움 다른사람을 위해 코딩하는 것을 잊지 말 것
- *로 둘러쌓인 주석같은건 쓰지말것 <= 수정이 어려움



## 레아이웃

- 어떤 레이아웃을 쓰던지 상관 없고 단지 전체 형태와 구조를 파악할 수 있어야함

### 구조 잘 잡기

- 비슷한 것끼리 묶고 다른 것은 나눌것
- 자연적인 문단 나눔이 있지 않은 한, 빈 줄은 넣지 말것
- 코드 연관성과 관련된 순서는 중요함. 코드를 읽을 사람을 고려할것
- 합리적인 순서로 API 를배치할것 private 보다는 public을 먼저 적을것
- 객체 생성은 객체 사용 이전에



### 일관성

- 한꺼번에 모든 레이아웃 스타일을 지키려 애쓰지 말자.
- 딱 하나만 골라서 일관성있게 사용할 것
- 사용하는 언어에 가장 잘 맞는 걸 고르는 것이 좋음. 기본 라이브러리의 스타일을 따를것
- 팀의 다른 동료들과 동일한 레이아웃 규칙으로 코드를 작성할 것
- 자신만의 고유한 스타일을 사용하지 않을 것
- 프로젝트에 일관성이 없다면 표준 코딩 스타일 가이드를 적용할 것.
- 길거나 엄격한 문서가 아닌, 레이아웃에 대한 약간의 규칙만으로도 팀의 협업을 충분히 끌어낼 수 있음
- 단 강압적이 아닌 상호 합의하에 이루어져야함
- 레이아웃 규칙을 따르지 않은 파일을 작업하는 경우에는 해당 파일의 레이아웃 규칙을 따를것
- 팀 전체의 ide와 소스 코드 편집기가 같은 환경으로 설정되어 있는지 확인할 것



## 명명

- 이름짓는것을 중요하게 생각해야함.



### 불필요한 반복을 피하라

- 둘러싸인 클래스의 문맥이 확실하게 정의되어 있으면 이걸 메서드에 굳이 쓰지 않아도됨
- 클래스 + 메서드명으로 표현할 수 있으면 그렇게 하면 됨



### 명확하게 하라

- 간결함보다 명확함

## 

### 관용어법을 지키라

- 언어별로 있는 관용적 이름을 선호할 것
- ex 클래스명이 파스칼 케이스인것



### 정확하게 하라

- 위젯 배열이름을 Widget Set으로 짓지 말 것
- 정확한 이름을 사용할 것



## 스스로 가다듬기

- 코드를 정리해야한다면 기능 변경과 모양 변경을 동시에 진행하지 말 것
- 소스 관리 시스템에 모양 변경과 기능 변경을 별도의 단계로 나누어 커밋할 것
- 코드를 읽고 배우고 자신만의 레이아웃 스타일을 발전시켜나갈것



## 마치며

- 개인적으로 선호하는 레이아웃이 아니더라도 프로젝트의 공통 관습을 따를것
- 다만 어떤 레이아웃이 왜 좋은지에 대해서는 개인적인 의견을 갖자
- 지속적으로 다른 코드를 읽어가며 경험을 쌓고 배우자.
- 코드 레이아웃에 일관성과 명확함을 사수하자



# #3 코드 적게 쓰기

- 많은 양의 코드 작성이 곧 다량의 소프트웨어 개발을 의미하지는 않음
- 소프트웨어를 개선하는 최고의 방법 가운데 하나는 바로 코드를 제거하는 것



## 코드에 신경 써야 하는 이유

- 각 줄의 코드마다 비용이 듬. 코드를 길게 많이 쓸수록 유지보수 비용은 높아짐
- 수많은 코드란 읽고 이해해야 할 내용이 많음을 의미함
- 코드가 많을수록 수정해야 할 부분도 많아짐. 수정하기 어려움
- 코드가 많을수록 버그가 숨을 수 있는 공간도 많아짐
- 중복코드는 특히 치명적. 



## 허술한 논리

```
if (expression)
	return true;
else
	return false;

```

- 위 코드보단 아래 코드 형식으로 사용할 것

```
return expression
```

- 명백하고 간결하게 표현하면 됨
- 언어가 작동하는 방식에 대해 아는 것을 부끄럽게 생각하지 말 것



## 중복

- 불필요한 코드 중복은 보통 잘라내기와 붙여넣기를 통해 발생함
- 코드의 일부를 복사하지 말고 공통 함수에 넣을 것. 다른 부분은 매개변수를 사용할 것
- Don't Repeat Yourself!
- 다만 비슷한 코드를 하나의 공통 함수에 넣으면 해당 함수를 사용하는 코드들은 긴밀한 결합도를 가지게 된다는 사실을 알아야함 이는 장기적으로 더 많은 문제를 초래할 수 있기 때문에 코드에 대한 책임감이 필요함



## 죽은 코드

- 죽은 코드란 실행되거나 호출되지 않는 생명력 없는 코드를 말함
- 실행되지 않는 코드는 정리할 것
- 죽은 코드를 포함했을 때 나타나는 징후
  - 한 번도 호출되지 않는 함수
  - 선언되었지만 할당되지는 않은 변수
  - 내부 메서드에 전달되었지만 사용되지는 않은 매개 변수
  - 전혀 사용되지 않는 열거형, 구조체, 클래스, 인터페이스



## 주석

- 좋은 코드는 작동법을 설명하는 대량의 주석을 필요로 하지 않음
- 변수, 함수, 클래스 이름의 적절한 서택과 올바른 구조는 코드를 더 명확하게 만듦
- 주석에서 모든 정보를 복사해 표현하는 것이야말로 불필요한 중복임
- 특정 알고리즘에 주석이 필요해보인다면 잘 명명된 새로운 함수들로 로직을 재구성하는 편이 더 나을 수도 있음
- 이전 코드는 완벽하게 제거할 것
- 코드가 어떤 역할을 하는지 설명하는 주석을 달지 말 것



## 장황한 내용

- 삼항연산자를 잘 사용해서 장황하게 풀어진 코드의 수를 줄일 것
- 변수의 선언부분과 정의 부분을 같은 위치에 쓸 것



## 나쁜 설계

- 모든 불필요한 코드는 낮은 수준의 실수나 부적절한 관리로 인한 결과물로 치부될 수는 없음. 높은 수준의 설계상의 결점 탓일 수도 있기 때문
- 나쁜 설계는 분명한 이유 없이 수많은 여분의 데이터를 정렬하는 등의 오류
- 오래된 것들을 바꾸는 것에 두려워하지 말 것
- 설계시점에는 기존에 있는 라이브러리에 이미 구현되어있는지 확인할 것 이름값 하는 라이브러리는 강건하고 확장성도 있고 자주 이용됨



## 공백

- 공백은 코드 구조에 도움이 됨



## 그래서 무엇을 해야 할까

- 불쾌한 코드는 고의성을 띠지 않음
- 책임감을 느껴야함. 불필요한 코드를 쓰지 말고, 레ㅐ거시 코드를 작업할 때는 경고 표시에 주의할 것
- 코드 정돈은 다른 기능적 변화와는 별개로 전개되어야 함



## 마치며

- 소프트웨어 기능은 코드의 줄 수나 컴포넌트 수와는 연관이 없음
- 더 많은 줄의 코드가 더 좋은 소프트웨어를 의미하지 않음
- 필요하지 않다면 코딩하지 말 것
- 적게 쓰고 그 대신 더 재미난 것을 찾을 것



# #4 코드 줄여 개선하기 

- 새로운 코드를 추가해서 시스템을 개선할 수 있음. 반대로 코드를 제거하여 시스템을 개선할 수도 있음



## 제멋대로인 코드

- 제 멋대로인 코드는 프로그래머가 제멋대로 코드를 작성했을 확률이 높음
- 의미가 있을때만 코드를 작성하고 미래에 필요한 기능을 앞당기지 말 것



## 불가피한 결과물

- 언젠가 필요할 것 같다는 코드, 지금 제거되지 않아도 괜찮을 것 같은 코드
- 더는 사용되지 않는 자료형 또는 클래스가 프로젝트에 남아있는 경우
- 기존 제품의 기능들이 거의 제거되지 않은 경우
- 코드에 대한 오랜 기간의 유지 보수로 인해 함수 일부가 실행되지 않는 경우
- 잘 사용되지 않는 이벤트 핸들러가 있는 경우
- 전혀 사용되지 않는 함수 반환 값이 있는 경우
- 디버그 코드가 괴사하는 경우



## 어떻게 해야 하나

- 죽은 코드는 불가피하다는 사실을 받아들이고 프로젝트가 잗공하는 한 지나친 걱정은 하지 말 것
- 불필요한코드의 대가
  - 불필요한 코드 역시 다른 필요한 코드와 마찬가지로 유지보수되어야 한다는 점은 명백함 여기엔 시간과 돈이 듬
  - 여분의 코드는 프로젝트를 파악하기 어렵게 만드는 만큼 추가적인 이해와 검토가 필요함
  - 실제 사용 여부와 상관 없이 백만 개의 메서드를 가진 클래스는 주의 깊게 프로그래밍할 수 없으며 엉성하게 작성할 수 밖에 없음
  - 가장 빠른 장비, 가장 좋은 컴파일러를 사들여도 불필요한 코드는 빌드를 지체시키고 덜 생산적이게 만듦
  - 코드가 좀비 코드로 가득차면 리팩토링이나 간소화, 최적화는 더 어려워짐



## 죽은 코드 탐색

- 가장 좋은 방법은 코드베이스에서 작업할 때 주의를 기울이는 것
- 자신의 행동에 대해 책임을 지고 작업 후에는 확실하게 정리. 
- 정기적인 코드 리뷰는 죽은 코드를 찾는 데 도움이 됨
- ide의 기능을 잘 활용할 것



## 외과적 적출

- 죽은코드, 미래에 필요할지도 모르는 기능을 가진 코드 등등 과감하게 제거할것 그리고 필요하면 버전관리 시스템으로 손쉽게 가져오면됨
- 코드를 정리하는 작업과 개발 작업의 히스토리는 구분되어있어야함



## 마치며

- 가장 훌륭한 코드베이스에도 불필요한 코드는 만들어짐 이것은 실패의 징조가 아님
- 죽은 코드가 있음에도 아무런 조치도 취하지 않는 것은 실패 징조
- 필요하지 않는 기능은 추가하지 말것. 정말 필요할때 추가하면됨





# #5 코드 베이스의 망령

- 오래된 코드를 다시 살펴보는 것은 코딩 기술 등을 향상시키는데 도움을 줌

## 외관

## 최신 기술

## 관례

## 설계 결정 사항

## 버그

## 마치며

- 기존의 코드를 돌아보는 것은 자신을 위한 코드 리뷰이자 가치있는 행동임
- 더 이상 적절하지 않다고 느껴지는 예전의 코드를 찾아내는 것은 좋은일임 이는 성장했다는 뜻.



# #6 경로 탐색하기

- 프로젝트에 투입된 최초 시점에서 성과를 낼 수 있는 상태에 빠르게 도달하기 위해 어떻게 해야할지에 대한 고민...
- 하나의 팀에서 영원히 하나의 코드베이스만 다루다가 고인물이 되지 말아야함
- 이미 존재하는 거대한 코드베이스에 적응하는 것은 어려운 일임.
- 적응을 위한 작업
  - 코드의 어느 부분부터 보아야 하는지 파악하기
  - 코드의 부분별 기능을 알아내고 그 기능을 어떻게 수행하는지 살펴보기
  - 코드의 품질을 가늠하기
  - 시스템 내부를 어떻게 탐색할 것인지 계획하기
  - 코딩 관례를 이해하고, 본인의 수정 사항이 그것과 어울리도록 만들기
  - 특정 기능이 있을 법한 위치를 파악하고, 그 기능에 의해 발생하는 버그 찾아보기



## 친구들의 작은 도움

- 코드에 정통한 누군가와 함께 일을 할 수 있다면 그 점을 활용할 것. 질문하기를 주저하지 말 것
- 주변에 없다면 커뮤니티, 오픈소스를 찾아볼 것
- 도움을 요청할 때는 언제나 공손해야 하고 감사해야함. 
- 합리적이고 적절한 질문을 할 것 
- 도움을 받았으면 그에 대한 답례로 다른 이를 도울 준비를 할 것
- 혼자 쉽게 알아낼 수 있는 바보같은 질문을 하지 않는 것은 최소한의 예의



## 단서 찾기

- 도와주는 사람이 없을때는 단서들을 찾아야함

**소스 획득의 용이성**

- 건전한 프로젝트에서는 전체 코드베이스를 얻기 위해 코드를 한 번만 체크아웃 해도됨.
- 빌드 머신의 그 어떤 디렉터리에 두어도 상관 없음 경로를 하드코딩해서는 안됨



**코드 빌드의 용이성**

- 건전한 빌드는 핱나의 단계만으로 수행되고 사용자의 개입을 필요로 하지 않음



**테스트**

- 좋은 테스트를 포함하는 코드는 일반적으로 적절히 분류되고 심사숙고되며 제대로 설계됨

**파일 구조**

- 코드 형태와 어울리는지

**문서**

- 문서가 잘 되어있는지

**정적 분석**

**요구사항**

- 최초 프로젝트 요규사항 문서나 기능 명세서가 있는지

**프로젝트 의존성**

- 코드에서 특정 프레임워크와 서드파티 라이브러리를 사용하는지

**코드 품질**

- 코드의 품질에 대해 살펴보기

**구조**



## 실행을 통해 배우기

- 자전거를 책으로본다고해서 자전거 타는 실력이 늘지 않음. 코드도 만찬가지. 코드도 지속적으로 많이 봐야 실력이 늘 수 있음

### 낮게 매달려 있는 과일

- 간단하고 사소한 일부터 도전해볼것.
- 바로 확인해볼 수 있고 코드와 직접 관련이 있는 작언 버르를 찾아내는 것 등
- 어마어마하게 복잡한 오류보다는 사소하고, 재현 가능하며, 위험성이 적은 오류 보고부터 시작

### 코드 조사하기

- 컴파일러 경고를 확인.
- 기능과 무관한 코드 변경 작업을 통해 코드의 각 요소가 어떻게 서로 들어맞고 어울리는 지 알 수 있음



### 확인한 뒤에 행동하라

- 코드의 작은 부분부터 확인. 테스트. 리팩토링.
- 변수명과 함수명을 적절하게 바꿔볼것
- 코드를 작성하는것이 읽는것보다 쉬움



### 테스트부터 하라

- 테스트를 찾고 새로운 단위테스를 어떻게 추가하는지. 테스트를 어떻게 실행하는지 확인해볼것

### 잡다한 일을 처리하라

- 사용자 ui 개선작업. 소스파일 정리. 디렉터리 구조 변경 등등



### 알아낸 것을 기록하라

- README 문서가 있으면 사용하고 그렇지 않다면 지금까지 알아낸것들에 대한 기록
- 많은 프로그래머들에게 README파일을 리뷰 요청할것



## 마치며

- 경험이 쌓일수록 고통은 줄어들고 이득은 커짐. 코딩도 마찬가지
- 새로운 코드베이스에서 더 많이 작업해볼 수록, 새로운 코드를 더 효과적으로 이해할 수 있음





# #7 똥통에서 뒹굴기

- 똥 덩어리 코드를 다루기 위한 전략 ...?

## 똥냄새 맡기

- 훌륭한 코드만 만날 수 없음.
- 나쁜 코드를 언제든 만날 수 있다는 마음의 준비를 할것
- 나쁜 코드를 다룰 때 쓸 강력한 도구들을 미리 준비해둘것
- 이상한 코드를 효과적으로 다루기 위해서는 문제 지점을 어떻게 찾고 다룰지 알아야함



## 똥통 헤치고 나아가기

- 더러운 코드를 만들게 된 이유부터 냉정하게 분석해야함
- 충분히 살펴보기 전까지는 코드나 코드를 작성한 사람에 대해 경솔한 판단을 하지 말아야함
- 개인적 이유로 판단하지 말 것 조잡한 코드를 일부러 짜는 사람은 거의 없음
- 나쁜 코드를 만났을 때 느껴지는 혐오감을 참고 대신 그걸 나아지게 할 방법을 찾을 것



## 똥통 조사 결과

- 다음과 같은 평가 기준에 따라 코드의 품질을 측정할 수 있음
  - 외부에 노출하는 api는 깔끔하고 합리적인가?
  - 자료형을 잘 고르고 변수 명을 적절히 지었는가?
  - 코드의 레이아웃을 정돈하여 일관성있게 작성했는가?
  - 객체들의 협업 구조가 보기에 간결하고 명확한가? 아니면 코드베이스 전반에 제어 구조가 예측할 수 없게 얽혀있는가?\
  - 특정 기능을 구현하는 코드 부분이 어디에 있는지 쉽게 찾을 수 있는가?



## 수렁에서 일하기

- 헤어나기 어려운 늪이나 다름없는 코드를 찾아냈다면 긴급상황에 속한것. 적절한 전략이 필요함 적절한 공략 계획은?
  - 나쁜 코드를 고쳐야만 할까?
  - 현재의 문제를 해결할 최소한의 수정만 한 뒤 달아나야 할까? ㅎ...
  - 괴사 부위를 도려내고, 새롭고 더 나은 코드로 바꿔야할까?
- 시간이 없으면 전체를 다 뒤엎을 생각을 하지 말 것
- 시간을 지혜롭게 쓸 것. 코드가 별로여도 별다른 수정없이 몇년동안 적절하게 동작했다면 지금 수정하는 것은 적절하지 않을 수 있음
- 지금 수정하지 않고 이후에 점진적으로 수정해나가면서 코드를 개선할 수 있음



## 똥 치우기

- 어떤 코드를 건드리든 이전보다 나아지도록 할 것. 보이스카웃 규칙
- 간단한 수정이라도 좋음
- 주기적으로 코드 일부라도 확인하고 그때마다 조금씩 나아지게 만들면 머지않아 좋은 결과물을 만들 수 있음



## 수정하기

- **코드 수정은 천천히. 주의깊게. 한번에 하나씩 수정**
  - 기능을 변경하면서 코드의 레이아웃 변경 금지
  - 수정으로 인해 기존 기능에 문제가 생기지 않음을 보장할 수 있는 모든 수단을 사용할 것. 신뢰할만한 자동화 도구, 변경사항에 대한 충분한 검토 .. 
  - 적절한 단위 테스트들로 코드를 충분히 둘러 싸야함. 문제되는 코드 주변에 테스트 코드가 전혀 없다면 먼저 테스트부터 만들것
  - 코드를 감싼 api를 수정하되 내부 로직을 직접 수정하지 말 것. 적절ㄹ한 명칭과 매개 변수 타입, 순서를 가지도록 수정할것. 이는 코드 전벤에 걸쳐 일관되어야함. 아니면 새로운 외부 인터페이스를 만들 수도 있음. 기존 api를 통해 새로운 외부 인터페이스를 작성하고, 이후 내부 구조를 변경할 때 이인터페이스의 내부도 변경하면 됨
- 코드 변경에 대해 할 수 있다는 용기를 가질것. 잘못되면 다시 되돌리면됨



## 나쁜 코드? 나쁜 프로그래머?

- 일부러 잘못된 코드를 작성하려는 사람은 거의 없음. 나쁜 코드에 비난을 퍼부을 필요도 없음
- 가능하다면 코드를 변경할 기회를 즐길것.



## 마치며





# #8 오류 무시하지 않기

- 코드에서 발생할 수 있는 모든 오류를 무시하지 말 것. 
- 더 늦기 전에 오류 처리를 미루지 말라. 자꾸 미루다보면 처리하기 더 어려워짐



## 메커니즘

- 우리는 아래의 여러 방법으로  코드의 오류를 확인함

**코드 응답**

- 리턴 값은 가장 보편적인 오류 검출 방법. 함수들은 값을 반환하고. 운영체제 프로세스도 값을 반환함

**부수적 작용**

**예외**

- try-catch에서 catch문에 아무런 동작도 하지 않는것.
- 규칙에 맞춰서 예외를 잘 사용해야함



## 광기

- 요류를 적절히 처리하지 않으면 다음과 같은 일이 발생할 수 있음

**불안정한 코드**

- 이러한 유형의 코드는 찾아내기 어려운 충돌로 가득 차 있음

**불안전한 코드**

- 크래커들은 소프트웨어 시스템을 파괴하기 위해 종종 오류 처리 과정의 취약점을 이용함

**나쁜 구조**

- 만약 반복적으로 다루어야 하는 오류로 인해 코드가 지루해진다면. 그것은 좋지 않은 인터페이스 때문임 인터페이스를 개선해야함.



- 코드에서 모든 잠재적인 오류를 확인해야 하는 것처럼. 사용자 인터페이스에서도 모든 잠재적인 잘못된 상황을 노출시켜야함. 숨기지 말고 정상적으로 동작하는것처럼 보이게 만들지 말 것.



## 감형 사유



## 마치며

- 오류를 무시하지 말 것!



# #9 예상하지 못한 것을 예상하기

- 모든 단계에서 조금이라도 발생할 가능성이 있는 특이 사항들은 모두 고려해야함



## 오류

- 호출되는 어떤 함수도 예상대로 작동하지 않을 수 있음
- 운이 좋다면 오류 코드를 전달받을 수 있음. 무조건 확인할 것
- 함수는 자신의 기능이 제대로 이행되지 않을 때 예외를 던질 수 있음. 코드가 예외 발생에 대해 대처하도록 할 것.
- 항상 오류를 고려한 코드를 작성하여 그로부터 복구할 수 있도록 할 것. 복구하지 못할 오류 역시 고려할 것.



## 스레딩

- 멀티스레드 환경에서 예측 불가능한 수준을 다루기 위해서는 기본적인 동시 실행의 원리와 함께 스레드 간의 결합도를 완화하여 위험하게 상호 작용하지 않도록 하는 방법을 반드시 이해해야함



## 셧다운

- 리소스의 누출이나 데드락, 충돌 없이 코드를 우아하게 중단시킬 수 있는지에 대해서는 잘 확인하지 않음



## 이 이야기의 교훈

- 코드 작성시 가능한 모든 코드 경로를 고려해야함. 나중에 비정상적인 경우에 대응하려 하지 말라. 그렇게 할 일을 미루다보면 이후 그와 같은 경로 자체가 있음을 잊어버리게 되고 코드는 버그로 가득 찰 것.





# #10 버그 사냥하기

- 버그는 생기기 마련. 피하지 말것



## 경제적 우려

## 대비책

- 버그가 생긴 뒤에 고치기보다는 처음부터 버그가 생기지 않도록 적극적으로 예방하는 편이 훨씬 나음
- 섬세한 설계, 코드 검토, 짝프로그래밍. 심사숙고한 테스트 전략...
- 적절한 공학적 방법론을 채택하여 코드에 버그가 생성되는 것을 막을 것. 빠르게 대충 작성한 코드의 품질이 높을 것이라는 기대는 하지 말라.
- 버그를 피할 수 있는 가장 좋은 충고는 믿기 힘들정도로 영리한(복잡한) 코드를 만들지 말라는 것. 



## 버그 잡기

- 코드 작성법과 상관없이, 유해한 버그 중 일부는 항상 방어막을 뚫고 들어옴
- 버그의 대부분은 쉽게 찾아내고 금방 수정이 가능하지만 아래의 경우는 힘듦
  - 재현 가능성이 얼마나 되는가, 즉 항상 재현 가능한가. 재현하기는 쉬운가.
  - 버그의 원인, 즉 나쁜 코드나 코드 통합 시의 잘못된 가설과 같은 소프트웨어 결함이 코드에 포함된 시점과, 이를 발견한 시점 사이의 간격이 얼마나 되는가.
- 가장 중요한 것은 버그를 체계적으로 조사하고 특징을 잡아내는 것. 
  - 버그 재현 과정을 가능한 한 가장 단순하게 줄일 것. 산만하기만하고 도움이 되지 않는 모든 관련 없는 항목들을 걸러내라
  - 단 하나의 문제에 집중할 수 있도록 함. 서로 관련된 두 버그를 하나로 착각한 채로 이를 깨닫지 못할 경우 코드는 금세 뒤죽박죽이 될 수 있음
  - 해당 문제를 얼마나 반복할 수 있는지 알아볼 것.



### 함정 파기

- assert와 로그는 강력한 디버깅 도구임.
- 진단 로그와 assert는 문제를 발견하고 해결한 이후 코드를 남겨놓는 확실한 방법임



### 이진 탐색 배우기

- 가능한 한 빨리 버그에 포커스를 맞추도록 이진 탐색 전략을 목표로 할 것.
- 문제 공간을 이진 탐색하여 문제의 원인에 더 빨리 도달하라.



### 소프트웨어 고고학을 채택하라

- 소프트웨어 고고학은 과거 이력을 바탕으로 버전 관리 시스템을 뒤져보는 방법에 대해 설명함
- 문제가 되는 코드 변경을 찾아낼 수만 있다면, 그 실패의 원인은 대개 명백해지고 수정 방법도 자명해짐



### 테스트하고 테스트하고 테스트해라

- 소프트웨어를 개발했다면 단위 테스트를 작성하는 데 시간을 투자하라.
- 단위 테스트를 작성하는 것은 전체시스템을 실행하여 버그를 찾는 것보다 버그를 증면하는데 더 바람직함
- 특정 코드가 테스트 범위에 들어가지 않는다면 제대로 작동한다고 신뢰할 수 없다는 것임.
- 테스트하지 않은 코드는 버그의 번식지나 다름 없음.



### 예리한 도구에 투자하라

- 각 작업에 알맞은 도구를 사용하는 것을 두려워하지 말 것.
- 디버거 사용법을 잘 익힌 다음 필요한 때에 사용하라



### 원인 분석 과정에서 제외하기 위해 코드를 제거하라.

- 실패 재현 시 문제가 되는 코드 부분을 해결하는 데 기여하지 않는 모든 부분을 삭제할 것인지 판단 할 것.
- 연관되지 말아야 할 주제들은 서로 엮이지 않도록 할것



### 청결은 감역을 막는다

- 버그가 소프트웨어에 필요 이상으로 오래 머물지 않도록 해야 함
- 깨진 유리창 신드롬을 일으켜서 점차 버그의 행동이 일상적이고 자연스로운 것처럼 느껴지게 만들 수 있음
- 최대한 빨리 버그를 고칠것.



### 간접적 전략

- 아래의 간접적 접근 전략을 시도하여 디버깅 구덩이에 빠져 있는 상황을 벗어날 것

**쉬어가기**

- 작업을 멈추고 코드에서 떨어져 있어야 할 때를 배우는 것은 중요함.
- 휴식을 통해 새로운 관점을 얻을 수 있고 이를 통해 더욱 신중하게 생각할 수 있음

**다른 사람에게 설명해보라**

- 문제를 다른 사람에게 설명해볼것.
- 어떤 문제를 다른 사람에게 설명하다 보면 동시에 자신에게도 설명하게 되고 문제를 해결하게됨



### 도망가지 말라

- 버그에 해당되는 코드 구역에 숨어 있는 또다른 관련된 문제들이 있는지 고려해볼것



## 재현할 수 없는 버그

- 이들 버그를 찾고 수정하는 방법
  - 실패를 유발하는 요소들을 기록해두고 반복하다보면 어떤 패턴을 찾아내는데 도움을 줄 수 있음
  - 베타 버전이나 출시 버전에 더많은 로그와 assert를 추가하여 실제 사용자의 사용 시 정보를 획득하는 방법
  - 매우 힘든 문제일 경우 테스트 팜을 세팅하여 오랫동안 가동하는 스트레스 테스트를 실행할 수 있도록 하라. 만약 대표적인 방식으로 시스템을 자동화하여 가동할 수 있다면 버그 사냥 작업이 더 가속화될 수 있음

- 안정적이지 않은 버그 생성에 기여하는 것들
  - 스레드를 이용하는
  - 네트워크 상호 작용
  - 저장 장치의 다양한 속도
  - 메모리 손상
  - 전역 변수/싱글톤



## 마치며

- 디버깅은 쉽지 않지만 우리 스스로의 실수에서 비롯된 것.
- 버그를 만들어내는 것은 우리 자신임.
- 효과적인 디버깅은 모든 프로그래머들의 필수적 기술!





# #11 테스트하기

- TDD는 더 나은 소프트웨어를 만들기 위한 중요한 기법중 하나



## 왜 테스트하는가

- 자신의 코드는 자신이 테스트해야함. 



### 피드백 과정 줄이기

- 가능하면 자주 그리고 빨리 피드백 받는것이 좋음.
- 좋은 테스트 전략이란 피드백 절차를 간소화하는 것으로, 이를 통해 더 효율적으로 일할 수 있음
- 피드백 과정이 짧을수록 설계 변경을 더 빠르게 반복할 수 있고 코드에 대해 더 강하게 확신할 수 있음
- 문제를 빨리 알수록 수정은 쉬워지고 비용은 낮아짐 그 이유는 코드를 짜는 시점에 가까운 만큼 코드에 대해 더 명확하게 파악하고 있기 때문임
- 소프트웨어 개발 과정을 개선하려면 빠른 피드백을 통해 문제 파악에 소모되는 시간을 줄여야함. 좋은 테스트 전략이란 바로 피드백 절차를 줄이는데 있음
- 자동화된 테스트를 통해 피드백 과정을 줄이면 코드 개발 과정에 도움을 주고 재활용 가능하다는 이점도 있음



### 테스트 코드 짜기

- 가장 이상적인 방법은 최대한 많은 개발자가 테스트를 자동화하는 것.
- 서둘러야하는 상황에서는 오히려 더 천천히.



### 누가 테스트 코드를 짜야 할까

- 가장 적절한 방법은 코더 자신이 자신의 코드에 대한 테스트코드를 작성하는 것



## 테스트 유형

**유닛 테스트**

- 가장 작은 단위의 기능에 대한 테스트를 단독으로 수행하는 것. 
- 단일 단위의 코드에 대해 테스트가 수행되지 않는다면, 그것은 유닛테스트가 아님
- 이 단독이라는 말은 그 어떤 외부에 대한 접속도 하지 않는다는 뜻.



**통합 테스트**

- 각각의 단위 모듈을 더 큰 결합체로 통합하여 작동시키는 복합 기능을 검증할 수 있음
- 테스트 대상이 하나 이상의 객체들인 테스트



**시스템 테스트**

- 통합된 소프트웨어 스택 전체에 수행되는 테스트



## 언제 테스트를 작성할까

- 독단적으로 테스트를 먼저 작성하지 않아도 데스트를 통한 피드백을 통해 설계를 개선해 나갈 수 있음 하지만 테스트 작성을 미룰수록 테스트는 덜 효과적.
- 테스트를 우선으로 하는 tdd의 단계
  1. 다음으로 구현해야 하는 기능을 결정한 뒤, 해당 기능에 대한 테스트를 작성. 물론 테스트는 실패함
  2. 테스트를 작성한 뒤 최대한 간단한 방법으로 기능을 구현함. 테스트가 통과했다면 기능이 적절히 구현되었음을 알 수 있음. 각 테스트가 작은 만큼 실행도 빠름
  3. 코드를 정리할것. 이상한 공통분모를 리팩토링할것. 
  4. 첫 단계로 돌아가서. 요구사항에 대한 테스트 케이스 전체를 통과할때까지 테스트를 반복하라.
- 위 단계는 레드 그린 리팩토링 주기로도 불림.
- 코드를 작성하면서 테스트를 같이 작성할 것. 테스트 작성을 미루면 그만큼 테스트 효과가 줄어듦
- 코드 수정에 무작정 달려들기보다는 우선 버그의 원인을 설명하는 실패 유닛 테스트를 작성할 것



## 언제 테스트를 실행하는가

- 테스트코드를 tdd를 사용해 개발하면 각각의 기능을 구현하면서 테스트를 계속 실행할 수 있음
- 버전 관리 도구에 구현 코드와 테스트 코드를 모두 추가할것. 만약 이후에 누군가 코드를 잘못 수정한다면 그에 대한 경고를 받게됨
- 모든 테스트는 지속적 통합 도구의 일부인 빌드 서버에서 실행해야함 실패한 테스트가 있다면 컴파일 자체를 실패함
- 코드 수준의 자동화된 테스트를 하더라도 출시 전 사람에 의한 qa 검수 과정은 필요함. 진정한 테스트 전문가에 의한 탐색적 테스트는 매우 유용함
- 아무리 좋은 개발자 테스트라 해도 qa테스트를 대치할 수는 없음



## 무엇을 테스트할 것인가

- 애플리케이션에서 중요한 부분은 모두 테스트할것.
- 요구사항의 모든것들은 테스트가 되어야함. 성능이 주요 요구사항이라면 코드의 성능을 모니터링하는 테스트도 수행해야함



## 좋은 테스트

- 좋은 테스트 코드를 작성하려면 연습과 경험이 필요함
- 테스트가 쓸모없을까 걱정하지 말고 테스트를 쓰기 시작하고 배워 나가라
- 나쁜 테스트는 짐이 될 수 있음 이로 인해 개발 과정이 지연될 수 있음
- 좋은 테스트의 특징
  - 짧고 명확한 이름을 갖고 있어 실패했을 때 무엇이 문제인지 쉽게 알 수 있음
  - 유지 보수가 가능함 작성은 물론 읽고 수정도 쉬움
  - 수행에 오랜 시간이 걸리지 않음
  - 최신 구현 코드에 맞춰져 있음
  - 특별한 머신 설정이 필요 없음.
  - 다른 테스트에 대한 의존성이 없어서 특정 테스트 전후에 실행할 필요가 없음. 외부 상태나 코드상의 어떤 공유 변수에 대한 의존성이 없음
  - 실제 구현 코드를 테스트함.
- 나쁜 테스트의 특징
  - 때로는 성공하고 떄로는 실패하는 테스트
  - 이상해보이고 읽거나 수정하기 힘든 테스트
  - 지나치게 큰 테스트
  - 하나의 테스트 케이스에서 둘 이상을 수행하는 테스트
  - 클래스 api에 대해 개별 형태를 확인하는 것이 아닌 함수마다 공격을 하는 테스트
  - 직접 작성하지 않은 서드파티 코드에 대한 테스트
  - 클래스의 주요 기능이나 행태에 대해 실제로 테스트를 하지 않는데다 별다른 필요없는 테스트들로 상황을 숨기는 테스트
  - 지나치게 상세하여 중구난방인 테스트
  - 단 하나의 머신에서만 수행 가능한 테스트



## 테스트는 어떠해야 하는가

- 일반적으로 각 테스트에는 몇가지 준비 과정이 필요하고 준비가되면 실제 실행. 마지막으로 실행 결과를 검증함
- arrange-act-assert 패턴 <= given-when-then



### 테스트 이름

- 하나의 기능 검증에 집중하는 테스트에는 명확한 이름이 붙어 있어서 간단한 문장처럼 읽힘
- 테스트 케이스의 이름을 간단히 붙일 수 없다면 요구사항이 모호하거나 혹은 여러가지를 한꺼번에 테스트하려는 것일 수 있음
- 테스트들이 코드에 대한 명세 사항으로서 읽힌다고 가정할것
- 테스트의 이름을 굳이 구현 코드와 같은 형식으로 지을 필요는 없음



## 테스트 구조

- 테스트가 코드의 중요 기능을 모두 다룬점을 보장하라
- 테스트는 중복해서 수행하지 않음
- 각 테스트 케이스는 하나의 정의만을 검증해야함



### 테스트 유지 보수

- 테스트 코드도 유지보수할 것
- 테스트를 막아버리고 도망쳐서는 안됨. 서두르는 과정에서 세심하지 못하면 결국 뒷통수맞음



### 테스트 프레임워크 고르기

- 너무 복잡하거나 기능이 많을 필요는 없고 거추장스러운 도구는 고르지 않는 편이 나음
- 그냥 assert 함수 를 사용해도 된다는 점을 기억할것



## 어떤 코드도 혼자가 아니다

- 글로별 변수나 싱글턴 객체는 신뢰할만한 테스트에 대한 저주와 같음. 숨겨진 의존성이 있다면 하나의 유닛을 쉽게 테스트할 수 없음
- 하나의 클래스와 상호 작동하는 객체들은 생성자의 매개 변수로서 전달되어야함. 상위로부터의 매개 변수화
- 클래스와 상호 작동하는 객체들의 자료형에 대해 직접적으로 의존하기보다 객체들이 특정 인터페이스를 통해 간접적으로 연결됨으로써, 클래스와 객체들 간의 상호 작동에 대한 테스트를 수행할 수 있음
- 특정 상호 작동을 정의하는 인터페이스를 최소화하는 훌륭한 일례로서, 작동이 전체 클래스에 의존하기보다 간단한 인터페이스에 의존하도록 할 수 있음
- 테스트 대역의 일반적인 형태

**견본(Dummies)**

- 견본 객체는 보통 빈껍데기. 테스트에서 견본을 실행하지는 않지만 인자 목록을 채우기 위해 필요함

**짝(Stubs)**

- 짝 객체는 인터페이스의 단순화된 구현체로서, 미리 정의된 응답을 반환하고 자신에 대한 호출과 관련된 정보를 저장하곤함

**모조(Mocks)**

- 목 객체를 적절히 사용하면 테스트가 더 간단하고 쉬워짐
- 너무 많은 목 객체들을 복합적으로 사용하여 테스트가 엉켜버리면 문제를 파악하기 어렵고 유지보수도 쉽지 않음





## 마치며

- 테스트는 코드 작성에 도움을 줌. 테스트를 통해 좋은 코드를 작성할 수 있고 코드의 품질을 유지할 수 있음.
- 테스트를 통해 코드의 설계를 개선할 수 있고 코드가 구현하는 기능을 어떻게 사용할지 문서화할 수 있음
- 하지만 소프트웨어 개발 과정에서 발생하는 모든 문제를 해결할 수는 없음
- 어떤 테스트도 오나벽하지는 않지만, 테스트의 존재를 통해 작성중인 코드나 유지보수하는 코드에 대한 확신을 키울 수는 있음
- 반드시 테스트할것!





# #12 복잡도 다루기



## 블럽

- 소프트웨어 복잡도에서 고려해야 할 첫번째 요소, 즉 컴포넌트는 블럽과 관련이 있음
- 블럽의 크기와 수가 복잡도를 결정함
- 문제는 코드를 어떻게 구성하는가 하는 점, 크기를 어떻게 배분할지에 대한 문제
- 거대한 덩어리보다 작고 수많은 일을 잘 해내는 응집도가 높은 클래스를 선호
- 되도록이면 하나의 일만 처리하도록



## 케이스 스터디 : 블럽 복잡도 줄이기

## 라인

- 더많은 블럽들을 추가하고 그 블럽들 사이에 연결을 추가하면서 더욱 복잡한 시스템을 만드는것.
- 객체들이 상호 종속적 관계일 경우, 구들의 구조는 융통성이 없고 쉽게 변하지도 않으며 작업하기도 어려움





## 마지막 요소, 사람

- 소프트웨어의 복잡도는 블럽과 라인의 구조에 따라 달라짐
- 책임은 코드를 작성하는 사람에게 있음
- 복잡도를 줄일 수 있는 유일한 방법은 소프트웨어에 책임감을 가지고, 업무 압박으로 인해 적절하지 않은 구조로 코드를 밀어넣는 상황을 피하고자 노력하는 것



## 마치며

- 복잡도는 블럽과 라인에서 비롯되지만 대부분은 소프트웨어를 만든 사람이 그원인임





# #13 두 개의 시스템에 대한 이야기

- 직접적인 경험이야 말로 가장 위대한 선생이지만, 다른 사람들의 경험도 꽤 괜찮은 선생이 될 수 있음



## 지저분한 대도시

- 소프트웨어는 건강하지 못한 회사 구조와 개발 절차로 인해 잘못 설계될 수 있음

### 이해 불가

- 소프트웨어 설계의 품질을 유지보수해야함. 나쁜 설계는 더 나쁜 설계를 불러들임 



### 응집도의 부족

- 개발팀의 작업자들 간의 관계가 얼마나 건강하지는 소프트웨어 설계의 품질에 직접적 영향을 끼침. 부적절한 관계와 자만심은 잘못된 소프트웨어를 만듦



> **응집도와 결합도**
>
> - 강력한 응집도: 응집도는 기능적으로 연관된 것끼리 얼마나 모여 있고 하나의 모듈 내에서 내부 부분들이 얼마나 유기적으로 작동하는지에 대한 척도임. 응집도는 모듈을 단단하게 뭉쳐 놓는 접착제에 비유할 수 있음. 한편 빈약한 응집도를 가진 모듈은 잘못된 기능 분해의 징후임. 각 모듈은 명확하게 정의된 역할을 가져야 하며, 관련 없는 기능을 마구잡이로 모아 놓은 덩어리여서는 안됨
> - 느슨한 결합도: 결합도는 모듈 상호 간의 의존성에 대한 지표임. 서로 얼마나 얼기설기 엮여 있는가에 대한 것임. 간결한 설계에서는 모듈 간 결합도가 낮아 상호 독립적임. 물론 모듈들이 완전히 독립적일 수는 없고, 완전히 독자적으로 작동한다는 건 말이 되지 않음. 상호 작용하는 모듈들은 직접적 혹은 간접적으로 서로에 대해 의존성을 가짐. 하나의 모듈은 다른 모듈의 함수를 호출할 수 있고, 다른 모듈에 의해 하나의 모듈 내 함수가 호출될 수 있음. 웹 서비스를 사용하거나 다른 모듈에 의해 공개된 기능을 이용할 수도 있음. 아니면 다른 모듈의 자료형을 사용하거나 어떤 데이터를 공유할 수도 있음. 여기서 데이터란 변수나 파일 같은것



### 불필요한 결합

- 좋은 설계는 상호 연결 구조나 컴포넌트 간 연결의 분량을 검토함.
- 시스템의 개별 부분은 단독으로 작동할 수 있어야 함. 밀착 결합은 테스트를 하기 어렵게 만듦



### 코드 문제

- 나쁜 설계로 인한 문제는 코드에 까지 영향을 미침
- 방만하고 명확하지 않은 구조는 각가의 컴포넌트가 잘못 작성되고 서로 들어맞지 않는 결과를 낳음. 코드 본제와 반복된 작업 또한 가져옴



### 코드 외부 문제

- 신규 직원들이 힘들어함
- 유지보수 힘듦
- 지원 엔지니어도 힘들어함
- 서드 파티 엔지니어들도 힘들어함
- 회사 전반적으로 모든팀들과 안좋아짐



### 대도시로부터의 엽서

- 지저분한 대도시의 설계는 거의 돌이킬 수 없었음
- 나쁜 설계로 회사 자체가 힘들어짐



## 디자인 타운

- 디자인타운은 잘 짜여진 프로젝트임

### 기능 위치 선정

#### 일관성

- 명확한 구조 설계를 통해 일관된 시스템을 구성할 수 있음. 모든 설계 결정은 전체 구조 설계의 관점에서 수행해야함
- 명확한 구조를 통해 기능 복제를 줄일 수 있음



### 구조 확장

- 소프트웨어의 구조는 불변의 것이 아님. 필요하다면 변경할 것. 변경 가능하게 만들려면 구조를 간결하게 유지해야함



### 설계 관련 결정 연기하기

- Don't do anything if You Aren't Going to Need It!
- 필요하지 않다면 아무것도 하지 말라!
- 발생할 수 이쓴ㄴ 가장 나쁜 상황 중 하나는 아직 모르는 것을 설계하는 경우
- 필요해질때까지 설계상의 결정을 미룰것. 요구사항을 파악하기 전까지 구조 설계를 하지 말라. 추측하지 말라.



### 품질 유지

- 설계 품질을 반드시 유지해야함. 이는 개발자들이 의무감을 가지고 진지하게 대할 때에만 가능



### 기술 부채 관리

- 기술 부채는 리팩토링이나 설계 조정의 지연, 다음 업데이트까지 라이브러리나 빌드 도구의 업데이트를 미루는 것. 합리화
- 의식적으로 기술 부채를 다룬다면 개발팀에게는 강력한 무기가 될 수 있음 부채가 쌓이지 않도록 하되 항상 그것을 가시화하라.
- 실제 부채처럼 최대한 빨리 갚아서 과도한 이자와 비용이 들지 않도록 하라 <= 굿 ..



### 설계 방향을 잡는 테스트

- 유닛테스트, 통합테스트, 인수테스트가 되어있는 프로젝트는 어떤것도 망가뜨릴 걱정 없이 소프트웨어를 변경할 수 있음
- 훌륭한 자동화 테스트를 시스템에 적용하면 최소한의 위험만으로 근본적인 구조 변경을 수행할 수 있음. 이는 작엽에 여유를 보장해줌
- 유닛 테스트를 작성함으로써, 각 모듈이 내부적으로는 응집도가 높으면서도 시스템의 나머지 부분과는 결합도가 낮도록 만들 수 있음



### 설계를 위한 시간

- 좋은 프로젝트 계획을 통해 훌륭한 설계를 얻을 수 있음. 구조적인 완성은 순식간에 만들어낼 수 없으며 충분한 시간을 들여야만 함.



### 설계를 가지고 작업하기

- 팀 구성은 작성하는 코드에 피할 수 없는 영향을 미침. 시간이 지나면 반대로 소프트웨어의 구조가 팀이 일을 얼마나 잘하는지에 영향을 줌
- 팀이 분열되어 있다면 코드도 어색하게 엮임 반면 팀이 서로 긴밀하게 작업한다면 구조 역시 적절히 통합됨





## 마치며

- 구조가 소프트웨어 프로젝트에 얼마나 심대한 영향을 끼치는지 알아야함
- 좋은 소프트웨어 구조는 프로젝트 참여자들에게 번영과 성공을 가져올 수 있음
- 좋은 구조는 다음과 같은 요소들의 산물
  - 코드 작성에 앞서 계획적으로 설계하기: 많은 프로젝트가 일을 시작하기도 전에 이 과정에서실패함. 적절한 긴장감이 필요함 알맞게 설계!
  - 설계자들의 역량과 경험; 약간의 실수를 미리 경험해두면 이후 적절한 결정을 내릴 수 있음. 
  - 개발 진행에 맞춰 설계 명확하게 유지하기
  - 소프트웨어의 전체 설계에 대한 책임감을 팀 단위로 모두에게 지우기
  - 설계 변경을 두려워하지 않기: 변하지 않는 것은 없음
  - 적절한 구성원으로 팀 짜기: 디자이너, 프로그래머, 관리자... 건전한 업무 관계는 코드 구조에 영향을 미침
  - 적절한 시점에 설계에 대해 결정하기: 아직 만들 수 없다면 설게에 대한 결정 미루
  - 적절한 프로젝트의 관리와 적절한 일정






# #14 소프트웨어 개발이란



## 소프트웨어(음식) 성분

- 양심적인 소프트웨어 개발자로서, 우리는 적절한 방식으로 적절한 제품을 작성하길 갈망해야 함.
- 훌륭한 프로그래머의 주요 특징 중 하나는 작성한 소프트웨어와 그 작성법에 대해 진슴으로 주의를 기울이는것



## 소프트웨어 개발은 예술이다

- 뛰어난 코드를 작성하고자 하는 프로그래머는 좋은 취향과 미적 감각을 지녀야함
- 창조적: 상성력이 필요함. 소프트웨어는 능숙하게 구축하고 정확하게 설계해야함. 프로그래머는 자신이 만들고자 하는 코드에 대한 비전, 그리고 만드는 방법에 대한 계획이 있어야함.
- 미학적: 좋은 코드의 특징은 우아함, 아름다움, 그리고 균형에서 찾을 수 있음. 
- 기계적, 수동적: 예술가에 비유하자면, 지정된 매개물을 가지고 지정된 도구와 절차, 기법으로 작업하는 것이나 마찬가지
- 팀기반: 수많은 형태의 예쑬은 한 사람이 아닌 여러 사람의 노고에서 비롯된 결과물.



## 소프트웨어 개발은 과학이다

- 엄격함: 좋은 소프트웨어는 정확하고, 입증되고, 측정되고, 실험되며, 검증되어야함. 좋은 테스트가 있어야함
- 체계화: 계획을 세우고 설계를 하며, 예산 계획은 세우고 체계적으로 구성할 필요가 있음
- 통찰력: 소프트웨어 개발에는 지적 노력과 더불어 기민한 분석력이 필요함



## 소프트웨어 개발은 스포츠다

- 팀워크: 서로 다른 기술을 보유한 채 한데 어우러지는 많은 사람의 협업이 필요함
- 훈련: 각 구성원은 자신의 팀에 전념해야 하고 기꺼이 최선을 다해야함
- 규칙: 일련의 규칙과 특정 팀 문화를 기반으로 개발을 진행함



## 소프트웨어 개발은 아이들 놀이다

- 학습: 겸손, 자신이 모든것을 알고 있다는 사람은 협업하기 힘듦. 더 나아지기를 원한다면 더 배워야 함을 깨달아야함. 아는것과 모르는 것을 받아들이고 새로운 것을 배우고 찾는 것을 즐길것
- 단순함: 끊임없이 질문해야함. 지금 무엇을 하고 있는지, 그렇게 하는 이유는 무엇인지에 대한 질문을 해야함. 
- 즐기기:



## 소프트웨어 개발은 집안일이다

- 청소하기: 문제를 찾아내 해결해야 함. 넘기지말고 책임져야함
- 보이지 않는 곳에서 작업하기: 청소부는 각광받으면서 일하지 않음
- 유지보수: 죽은 코드를 제거하고, 망가진 코드를 수정함



## 은유 과부하



## 마치며





# #15 규칙 가지고 놀기

## 더 많은 규칙이 필요해

- 프로그래밍팀에는 일련의 규칙이 있음. 무엇을 하고 어떻게 하는지를 정하는 규칙
- 좋은 코드를 작성하기 위한 세개의 강력한 규칙
  - 간결하게 하라
  - 머리를 쓰라
  - 변하지 않는 것은 없다

## 규칙 정하기

- 모호하게 구도로 전해지는 팀의 규칙에 의존하지 말고 무언의 규칙을 명백하게 만들고 코딩 문화를 다스릴 것





# #16 간결하게 하기

- 간결한 코드는 투명하고 구조가 명확하고 버그를 숨기지 않으며, 배우기쉽고 작업하기도 쉬움
- 단순함은 의심할 여지 없이 훌륭한 목표이고 코드에서 이를 확실하게 추구해야함
- 간결한 코드는 설계하는데 많은 노력이 필요함. 다남 간결한 코드가 곧 과도하게 단순한 코드를 의미하지는 않음



## 간결한 설계

- 간결한 설계는 빠르고 명확하게 묘사할 수 있고, 쉽게 이해할 수 있음

### 사용이 간편하다

- 간결한 설계란 사용이 간편한것

### 오용을 방지한다

- 간결한 설계는 오용하거나 악용하기 어려움
- 간결함의 비결은 복잡한 부분을 적절한 곳에 위치시키는 것.



### 크기가 중요하다

- 간결한 코드는 설계에서 구성 요소의 수를 최소화함
- 간결한 설계는 가능한 한 작은 크기로 이루어짐. 그보다 더 작을 수가 없는 수준의 작은 크기



### 짧은 코드 경로

- 간결한 설계는 우회를 줄여주고 기능과 데이터가 필요한 곳 근처에 있도록 만듦

### 안전성

- 간결한 설계는 많은 양의 코드를 고쳐 쓰지 않고도 개선하고 확장할 수 잇다는 점



## 코드의 간결함

- 간결한 코드는 읽기 쉽고 이해하기 쉬움. 따라서 작업하기도 쉬움
- 일관성은 간결한 코드로 이끄는 주역
- 일관성은 명확성으로 이어짐



## 어리석지 않게, 간결하라

- 오류를 발견했다면 증상 부위가 아닌 근본 원인에 대해 버그 수정을 적용할 것.



## 가설은 간결함을 낮출 수 있다

- 코드에서 은연중에 가설을 만들지 않도록 할 것

## 너무 이른 최적화를 피하라

- 지나치게 조급한 최적화는 프로그래밍에서 모든 악의 근원이다. - 커누스
- 우선 명확한 코드를 작성하고 복잡한 것은 필요할 때 만들것



## 충분하게 간결하기

- 가장 간결한 방법으로 작업하고 가장 간결한 코드를 작성해야함
- 문제를 해결하기 위해 딱 필요한 양의 코드를 작성할것
- 지나치게 복잡한 해결책을 내놓지 말 것
- 딱필요한 양의 코드만 작성할 것





## 마치며

- You Aren't Going To Need It: YAGMI
- Don't Repeat Yourself: DRY





# #17 머리 쓰기

## 바보짓을 하지 말라

- 우연하게라도 지나치게 복잡한 설계를 하지 않도록 할것
- 일을 멈추고 생각하고 바보같은 코드를 작성하지 말 것
- 실수했음을 인정하고 실수를 바로잡을 용기를 가질 것 바보같은 코드로 인해 절뚝거리는 것보다 훨씬 용기있는 행동



## 어리석은 습관성 행동을 피하라

- 일단 작업을 멈추고 대안이 있는지 생각해볼것
- 처음 세운 계획을 고집하고 이쓴ㄴ것은 아닌지 확인해볼 것
- 주의를 기울이고 부주의하게 코드를 작성하지 말 것



## 당신은 생각해도 된다!

- 기계적으로 코딩하지말고 머리를 쓸 것
- 개선이나 변화가 요구되든 간에, 그에 관한 결정을 내림에 있어 능동적이 될 것.
- 기존 코드 패턴에 의문이 든다면 그것을 변경해야할지를 고민해볼 것
- 가차없이 수정이 필요한 누더기 코드를 발견했을 때는 거기에 또 다른 누더기 코드를 덧씌우지 말 것
- 위와같은 종류의 문제에 대해 고민하는 것은 자신의 책임임



## 마치며 



# #18 변하지 않는 것은 없다

- 아직 완벽하게 알지 못하는 코드를 바꿔야 할 때 현실적 불안감을 느낌
- 소프트웨어는 단단하지 않고 부드러워야함
- 코드는 변해야함. 제품 중에 불변의 코드가 있다면 그 제품은 썩어버릴 것
- 코드는 절대로 불변이어서는 안되며 그 어떤 코드도 완벽할 수는 없음
- 요구사항은 언제나 끊임없이 변화함
- 자신이 작성한 소프트웨어의 주인은 바로 자신. 코드나 개발 절차를 풀어두지 말고 코드가 성장하는 방향을 지배할 것



## 용감한 수정

- 오류에 대한 두려움 속에서도 용기 있게 수정하는 방법
  - 좋은 수정을 가하는 방법을 배울 것. 작업의 안전성을 높이고 오류의 가능성을 줄일 수 있는 실천 방법이 존재함
  - 소프트웨어를 쉽게 바꿀 수 있게 만드는 것이 무엇인지를 배우고, 이런 특성을 가진 소프트웨어를 만들기 위해 노력할것
  - 매일 코드를 개선하여 더욱 수정이 용이한 상태로 만들라. 코드의 품질에 대해서는 타협을 거부하라.
  - 건강한 코드로 이끄는 건강한 태도를 포용하라
- 어떠한 수정에 대해서도 출시 이전에 충분한 테스트와 검증을 거쳤음을 보장할것



## 태도 바꾸기

- 좋은 코드는 다른 사람의 문제가 아니라 자신의 책임임.
- 수정하기 두려운 코드를 발견하면 반드시 수정해야함
- 실수하거나 잘못된 코드를 작성하는 것은 범죄가 아님 배우고 성장할것
- 어떤사람의 코드를 다른사람의 코드보다 더 정확하거나 보다 나은것으로 취급하는 것은 코드를 거짓된 기초 위에 서우는 것이며 팀의 나머지 사람들의 기여를 손상시키는 일임
- 좋은 프로그래머는 변화를 기대함.



## 수정하기

- 중요한 것은 코드 속을 돌아다니는 길을 찾아내는 방법을 배우는 것이 아니라 부작용이 숨어 있는 곳을 지도에서 찾고 따라가고 부작용이 튀어나오는 지점을 파악하는 방법을 배울것

### 수정을 위한 설계

- 두가지 기능을 하는 함수를 만났다면 두 부분으로 나눌 것.
- 융통성 없는 결합과 불필요한 복잡함을 피할것
- 한번에 전체 코드베이스와 싸우려하지 말것



### 수정을 위한 도구

- 좋은 도구는 가장 빠른 속도로 안전하게 변경하는데 도움이 됨
- 자동화된 테스트는 코드 수정에 대한 확신을 심어줄 수 있는 귀중한 안전 도구임



### 싸워야 할 때를 가려라

- 추후 개선할 때까지 감수해야 할 기술 부채의 일정량이 존재함. 부채의 상당수가 그대로 잊히고 곪아가도록 버려두기 보다는 개발 일정표에 넣어 작업 대상으로 만들것







# #19 코드 재사용 사례

## 재사용 사례 1 : 복사 & 붙여넣기

- DRY코드는 금물
- 복붙 코딩은 자제할것. 로직을 공통 함수와 공통 라이브러리에 넣을것
- 구글에서 찾은 코드를 복붙하지 말것 그전에 아래의 내용을 한번 확인해볼것
  - 코드가 정말로 완벽하게 들어맞는가?
  - 모든 에러를 적절하게 다루는가?
  - 단순한 예제인가? 버그는 없는가?
  - 필요한 것을 이루기 위해 가장 좋은 방법인가?
  - 오래된 예제는 아닌가?
  - 당신의 코드에 적용해도 되는 권리가 있는가? <- 저작권
  - 얼마나 철저하게 테스트했는가?
- 주의 깊게 조사하지 않은 채 웹에서 찾은 코드를 프로젝트에 복사하는 일이 없도록 할 것



## 재사용 사례 2 : 재사용을 위한 설계

- 처음부터 다양하게 사용될 수 있도록 처리하는 것은 가치없는 일임
- YAGNI, 아직 필요하지 않으면 작성하지 말라
- 당장의 요구사항을 모두 만족시킬 수 있는 가장 간단한 코드를 만드는 데에만 집중할 것.
- 종종 다음에 사용하리라는 예측은 절대로 실형되지 않고 다음 사용자는 전혀 예상하지 못한 다른 요구사항을 요구함



## 재사용 사례 3 : 개선하고 리팩토링하기

- 작고 모듈화된 코드를 작성하고 깨끗하고 정돈된 상태를 유지할것
- 한곳이 아닌 여러곳에서 사용되어야 한다는 것을 깨닫는 순간 바로 리팩토링 할 것
- 다음 사용자에게 맞추기 위해 가능한 가장 작은 범위로 api를 확장할 것
- 인터페이스의 재설계가 아닌 수정을 최소화하고 단순화하는 것에만 집중할 것
  - 현재의 코드가 잘 작동하기 때문에 인터페이스 재설계는 X
  - 아주 약간의 변경사항을 요구하는 세번째 클라이언트가 곧 나타날 수도 있음
- 코드는 공토오하 되어야함. 이는 다수의 클라이언트에게 유용해서이지 개발자가 멋진 공통 라이브러리를 만들고 싶어서가 아님



## 재사용 사례 4 : 매입하라, 아니면 시간 낭비다

- 자신만의 코드로 시작할지, 오픈소르를 쓸지, 서드파티 솔루션을 쓸지 어느것이 더 경제적으로 합리적일지 주의 깊게 고려할것
- 구매 비용을 개발 비용과 코드 품질, 각 솔루션의 유지 보수 및 통합의 용이함과 서로 비교해봐야 함
- 다른사람의 코드를 무시하지 말것. 자신만의 버전을 작성하는 것보다 이미 존재하는 라이브러리를 사용하는 편이 나을 수도 있음



## 마치며



# #20 효과적인 버전 관리

- 버전 관리는 중요함 버전 관리는 아래와 같은 이점을 얻을 수 있음
  - 협업의 중심으로서 개발자들간의 협력을 조율함
  - 최신 상태를 정의하고 게재함.
  - ci, 배포 공학, 코드검증 시스템을 도입할 수 있음
  - 프로젝트 내에서 이루어진 작업들의 기록을 유지하고, 각 배포 버전에 포함되어야 하는 정확한 콘텐츠들을 모아둠.
  - 소프트웨어 고고학을 수행할 수 있음. 특정 파일들의 변경 내역을 추적할 수 있음
  - 작업에 대한 중추적 백업 도구로서 역할을 함
  - 개발자에게 안정망을 제공함
  - 하나의 코드베이스에서 여러 방향으로 개발을 수행하는 동안 서로의 작업이 꼬이지 않도록 함
  - 작업을 되돌릴 수 있음.



## 사용하거나 잃거나

- 프로젝트의 시작 시점부터 버전관리를 적용할것. 예외는 없음
- 버전 관리 도구를 사용할것. 필수사항임. 버전 관리 도구야말로 개발의 중추
- 소프트웨어는 본질적으로 안전하지 않음



## 무엇이든 하나를 골라라

- 현대적이고 지원 기능이 많으며, 많은 사람들이 사용하는 도구를 선택할것



## 적절한 것 저장하기

### 첫번째 대답 : 모든것을 저장하라

- 소프트웨어를 다시 만들 수 있도록 필요한 모든 파일을 저장해야함.

### 두번째 대답 : 가능하면 적게 저장하라

- 확실히 많은 것을 저장해야하지만 혼란을 초래하고 쓸데없이 용량을 늘리거나 방해가 되는 불필요한 것까지 포함해서는 안됨.
- 저장소를 간결하게 유지할 것



### 소프트웨어 배포본 저장하기 

### 저장소의 내부 배치

- 저장소의 내부 배치에 대해 주의깊게 생각할 것. 디렉터리 구조가 명확해지도록 코드의 형태를 드러낼 것
- 복제는 철저히 피할것

 

## 버전 관리 도구를 잘 활용하라

### 원자적 커밋을 수행하라

- 작고 원자적인 커밋을 수행하라
- 자주 조금씩 변경 사항을 체크인할 것
- 한꺼번에 체크인하게되면 여러가지 문제가 발생할 수 있음
- 한번에 두가지 이상의 변경 사항을 다루는 체크인을 해서는 안됨
- 각각의 커밋은 하나의 완결적 단계로서 존재해야함



### 적절한 메시지 보내기

- 각각의 커밋에 적절한 체크인 메시지를 포함시킬것



### 좋은 커밋을 고안하라

- 빌드를 깨트리지 말 것
- 모든사람이 동의하지 않는 이상 어떤 파일이든 삭제하거나 이동시키지 말 것



## 브랜치 : 숲을 보기 위해 나무 보기

- 브랜치는 버전 관리 도구에서 근본적이고 중요한 기능임
- 실험적 개발, 개별적 버그 수정, 주요 변경사항에 관한 작업 등등의 작업을 할 수 있음
- 사용하기를 두려워하지 말고 별도의 브랜치에서 다루도록 할 것



## 코드의 고향

## 마치며

- 버전 관리는 핵심적인 소프트웨어 개발 도구중 하나임
- 버전관리는 비협업적인 경우에도 유용하게 사용될 수 있음



# #21 골키퍼 있다고 골 안 들어가랴

## 소프트웨어 개발 : 삽으로 비료 퍼 담기

- 소프트웨어 개발을 선형적 절차로 바라보는 시각은 잘못된 것임
- QA팀과 지속적인 의사소통을 추구해야함



## 잘못된 이분법 : QA와 개발자

- QA와 개발을 별도의 단계이자 행위로 보고 다른 팀으로 나누어버리면 경쟁심은 커지고 단절감은 심해짐
- 품질 보장 업무는 개발자들과 테스터들이 긴밀히 연결될 때 비로소 효과적으로 수행될 수 있음
- 개발과 테스트 사이에 인위적인 단절을 만들지 않도록 주의할 것
- 개발자와 QA는 같은편임 !!



## 코드를 고치려면 팀을 개선하라

- 팀 간의 의사소통이 건전하지 않으면 코드도 건전해지지 않음
- QA는 협업하는 동료 개발자는 반드시 QA와 좋은 관게를 유지해야 하고 우정과 동지애를 가져야함



## QA에게 배포하기

- 개발 절차는 결코 선형적이지 않음
- 매끄러운 빌드 및 전달을 위한 절차 마련은 필수적임
- 코드는 책임감 있게 작성해야 하고 사려 깊게 배포해야함
- 사려깊게 주의하여 QA 배포 버전을 만들지 않는 것은 테스터들을 존중하지 않는 것



### 자신의 작업물 부터 테스트하라

- 개발자는 배포 빌드를 만들기에 앞서 자신의 결과물이 정확하게 구현되었음을 증명하는 테스트를 실시해야함
- 자동화된 테스트를 통해 바보같은 실수나 당황스러운 오류를 제거하면 테스터의 시간을 낭비하거나 더 중요한 문제를 발견하지 못하게 가로막는 일을 방지할 수 있음



### 의도를 가지고 배포하라

- QA에 새로운 버전을 배포할때 개발자는 그것이 어떻게 작동하기를 기대하는지에 관해 정확하게 설명해야함
- 명확하고 적절한 일련의 배포 메모를 작성하는 작업은 중요함
- 각 배포마다 배포 메모를 통해 무엇을 변경했고 어느 부분을 좀 더 테스트해야 하는지 명확하게 기술해야함



### 서두르되 급하지 않게

- 아무리 훌륭해 보여도 빌드를 너무 급하게 배포해서는 안됨
- 다시 배포해야할 느낌을 받는다면 분명 무언가 잘못된 것. 멈추고 다시 생각할 것
- 빌드를 급하게하면 실수함



### 자동화하라

- 수작업 절차를 자동화하면 언제나 인간 오류의 가능성을 제거할 수 있음
- 빌드나 배포를 최대한 자동화하라



### 존중하라

- QA에게 코드를 전달하는 행위는 안정적이고 가치 있는 무언가를 생산하기 위한 것이어야만 함
- 담장 너머로 코드 폭탄을 던지거나 소프트웨어 쓰레기를 퍼붓지 말라



## 오류 보고서를 받아들이는 자세

- 테스터가 오류를 발견했다면 그 오류는 처음부터 개발자의 책임임
- 오류 보고서는 개인적 경멸의 표시가 아님. 개인적으로 받아들이지 말것
- QA에서 고객보다 먼저 발견했음에 오히려 기뻐할 것
- 건전하고 프로다운 태도는 제품 전체에 대해 책임의식을 가지는 것



## 서로의 차이가 서로를 더 강하게 만든다

- 테스터와 개발자는 서로 많이 다름
- 테스터들은 제품 품질에 대해 인지한 수준에서도 값진 피드백을 줄 수 있음
- 개발자들은 기능에 대해 긍정적으로 생각하는 편이라 다양한 방향성을 간과할 수 있음.
- QA팀과 건전한 관계를 조성할것. 훌륭한 소프트웨어를 만드려면 그들과 일하는 것을 즐길것



## 퍼즐 조각들

- 테스트를 마지막 행위로 보는 일은 없어야함
- QA팀은 품질에 대한 유일한 책임자나 문지기가 아님. 품질은 모두의 책임
- 높은 품질의 소프트웨어를 만들기 위해서는 모든 개발자가 QA 절차를 이해하고 섬세한 시각에 대해 감사해야함



## 마치며



# #22 동결된 코드의 신기한 사례

## 코드 동결 추적하기

- 코드 동결은 코드가 완전해졌다고 판단되는 시점으로 모든 기능이 구현되었을 뿐 아니라 어처구니없는 버그가 없는 때를 의미함

## 신세계의 질서

- 코드 동결은 변경을 완전히 막는다기보다는 개발 작업에 대해 새로운 규칙을 적용한다는 의미에 가까움.
- 개발 작업의 속도를 낮추어 출시하기 위한 코드를 신중하게 다루고 최종 수정이나 변경을 주의 깊게 관리함

## 동결의 형태

- 기능 동결 : 버그 수정만 허용할 뿐, 그 어떤 새로운 기능도 개발을 허용하지 않음
- 코드 동결 : 우선순위가 높지 않은 기능이나 버그에 대해서는 작업하지 않음
- 단단한 코드 동결 : 변경을 일절 하용하지 않음



## 분기를 통한 코드 관리

- 코드 동결을 선언할 때는 보통 버전 관리에서 출시 분기를 만듦
- 코드는 언제나 분기들 사이에서 더 안정적인 쪽으로 흘러야함. 이미 입증된 품질에 기분을 둔 변경점만을 세상에 내보내야 함
- 동결된 분기, 출시분기에 변경사항을 적용할때 고려할 점
  - 모든 변경 사항을 신중하게 검토한다
  - 더 집중적인 테스트를 거친다
  - 위험성을 분석하는 칸큼, 잠재적 차이를 잘 이해하고 필요한 경우에는 차이점을 완화시킨다
  - 각 변경 사항에 대해 우선순위를 설정한다 출시에 적합한지를 신중히 검토한다
- 분기는 코드 동결 관리의 핵심



## 하지만 실제 동결은 아니다!

- 코드 동결이라고해서 안전한게 아님. 언제나 프로젝트의 상태에 현실적으로 평가하는 것이 중요함

## 동결 기간

## 동결을 느껴라

- 개발자는 코드 동결 후에 언제든 실망할 수 있고 후회할 수 있지만 이상한일도 아니고 잘못된 일도 아님
- 동결 후 버그들을 발견했다면 다음번 출시에서 수정하면됨
- 동결 기간에 기술적 부채를 얻을 것을 기대할 것



## 끝이 다가왔다

- 유일하고 참된 코드 동결은 납득할만한 출시가 이루어진 시점을 가리킴. 이는 곧 코드에 더이상의 변경이 가해지지 않게 된 시점



## 부동액

- 다음과 같은 방법을 통해 코드 동결 기간을 최소화하거나 심지어 없앨 수 있음
  - 지속적 배포 적용하기 : 각 빌드를 언제나 완전히 적용 가능한 상태로 만드는 과정. 이를 통해 언제나 배포 준비가 완료된 상태임을 보장할 수 있음
  - 적절한 범위에 걸쳐 훌륭하게 자동화된 테스트 도구 구축하기: 이를 통해 제품의 상태에 관해 적절한 피드백을 얼ㄷ을 수 있는 코드 수준의 테스트, 통합 테스트, 시스템에 대한 사용자 관점의 최종 테스트를 모두 실행할 수 있어야함
  - 적절한 허용 기준에 대한 테스트하기: Cucumber와 같은 도구를 통해, 소프트웨어가 높은 수준의 사용자 요구사항을 완전히 충족시키는지를 보장할 수 있음
  - 테스트 기간 줄이기: 프로젝트의 범위나 크기를 줄이면, 각 출시에 대한 긴 잠금 기간을 가지지 않아도 됨
  - 간단하고 신뢰할 수 있는 출시 과정 구축하기: 이를 통해 사람이 아예 관여하지 않거나 아주 적은 노력을 들이는 상태에서도 배포할 수 있음
- 엄청나게 짧은 개발 주기를 실현하기 위해서는 전반적으로 원칙을 더 철저히 지키는 사고 방식이 필요함



## 마치며

- 코드 동결이라는 용어는 문제있는 잘못된 은유임. 코드는 실제로 동결되거나 해동되지 않음
- 코드는 변경 가능한 물질로서 끊임없이 변화하고 주변에 적응함. 코드 동결 기간에 실제로 일어나는 일은 개발 과정에서의 변경 비율이 낮아지는 것 뿐.



# #23 제발 저를 배포해주세요

- 소프트웨어 배포 버전을 만드는 과정에는 규율과 계획이 필요함

## 절차의 일부

- 더 효율적인 배포를 위한 요소
  - 단순함
  - 반복 가능함
  - 신뢰할 수 있음
- 정확히 똑같이 빌드할 수 있는, 정학히 똑같은 코드를 소스 관리 시스템에서 받을 수 있는지 확인할 것
- 어떻게 빌드하는지를 정확하게 기록할 것
- 나중에 참조할 수 있도록 빌드 로그를 캡처 할 것



## 기계의 톱니바퀴

### 배포에 착수하라

- 새로운 디렉터리에서 작업할것. 

### 배포를 준비하라

- 어떤 코드를 이번 배포 버전에 포함시킬 것인지 명확히 할 것
- 개발 분기에서 직접 배포하는 일이 있어서는 안됨
- 배포 분기에서 어떤 일이 일어나고 있는지 소스 관리 시스템에서 태그 기능을 활용하여 기록할 것

### 배포 버전을 빌드하라

- 소프트웨어는 항상 새로운 체크아웃에서 빌드할 것. 기존에 사용하던 빌드의 일부분을 재사용하는 일이 절대 없도록 할 것
- 빌드 과정을 단순한 하나의 과정으로 만들고 모든 절차를 자동화할 것. 
- 빌드의 건전성을 보장하기 위해  CI 서버를 사용할 것. 동일한 시스템에서 공식적인 배포 버전을 만들 것

### 배포 버전을 패키징하라

-  과거의 배포버전과 이번 배포의 차이점을 묘사하는 배포노트를 만들것

### 배포 버전을 밸포하라

- 현 단계에서의 배포 버전 테스트는 모든것이 정확하고 적합한지 확인해야함
- 소프트웨어의 배포 버전을 충분히 확인하기 전에는 배포해서는 안됨
- 자동화가 중요한 핵심



## 일찍 자주 배포하라

- 소프트웨어 배포 절차를 계획하고 구축하는 일을 마지막까지 미루지 말 것. 조기에 구축하고 자주 빠르게 빌드를 반복할 것



## 마치며





# #24 배움을 사랑하며 살기

- 지속적으로 배우는 상태를 유지할것. 배울만한 새로운 무언가를 항상 찾아볼것
- 배움을 즐기는 것을 배우라

## 무엇을 배워야 하나

- 배우면 재미있을만한 것들을 리스트업하고 그 중 흥미를 끌고 자신에게 이득을 줄 수 있는 것을 선택할 것
- 새로운 기술을 습득하고 사람들과 함께 일하는 것을 배울 것
- 새로운 문제 영역에 대해 배울것
- 어떻게 배워야할 지 배울것
- 완전히 다른 것을 배울것



## 배우는 방법 배우기

- 더 넓은 분야에 대해 참고할것
- 자신의 성향을 제대로 이해하면 배우는 방법을 최대한 효과적으로 이끌 수 있는 구체적인 방법을 찾을 수 있음
- 배움의 질을 더 향상시키기 위해 가능한 한 많은 자료들을 활용할 것
- 당신에게 효과적일 수 있는 방법
  - 일하는 동안 음악 듣기
  - 생각하는 동안 낙서하기
  - 무엇이든 만지작거리기
  - 일하면서 말하기
  - 사고 절차를 추상적이기보다는 구체적이 되도록 하기
  - 명상 연습 하기
- 나중에 버릴지언정 지금 배우고 있는 것을 기록할것
- 배움에 대해 긍정적인 태도로 일관하는 것이 기억력을 강화시킨다는 연구 결과가 있음
- 스트레스와 수면부족은 집중력저하와 학습 능력 하락의 원인



## 학습 모델

- 어떤 주제에 대해 전문가이지만 다른 분야에서는 완전히 초보자일 수 있음. 항상 겸손할 것
- 모든 주제에 대해 박식한 전문가가 아니라는 것을 인정해야함
- 누구도 모든것을 아는 척하는 사람을 좋아하지 않음



### 지식 포트폴리오

- 목적을 가지고 자신만의 지식 포트폴리오를 관리할것

## 배우기 위해 가르쳐라

- 배움의 가장 효과적인 방법중 하나는 직접 가르쳐보는 것
- 무언가에 대해 설명해야 할 때, 그에 대해 깊게 알아야 하는 만큼 해당 주제를 진정으로 이해할 수 있음
- 간단하게 설명할 수 없다면, 충분히 잘 이해하지 못했다는 증거이다 - 아인슈타인



## 배우기 위해 실천하라

- 배움에 있어 핵심적인 기술은 행동하는 것
- 실제로 사용하기 전까지는 머릿속에만 존재하는 추상적 개념 직접 실행해볼것



## 우리는 무엇을 배웠는가

- 자신의 학습은 아무도 책임져주지 않음 오로지 본인 몫



## 마치며



# #25 테스트 기반 개발자

- 운전과 개발에대해 묘사한 글 ..

## 운전하기

- 소프트웨어 개발자가 도구와 언어에 통달하고 나면 주제에 대한 더 큰 그림을 보게됨
- 문제를 처리하는 세세한 방법까지 신경쓰는 대신 문제를 해결하는 대략적인 경로를 계획할 수 있음



## 성공은 안일함을 낳는다

- 의식적 능력 단계에 도달했을 때 안일해지지 않도록 주의해야함
- 자신의 머리로 코드에 항상 집중하고 어이없고 위험성 높은 오류를 피해야함



## 시험시간

## 테스트 기반 개발자

- 오랜경력이 있다고 누구나 전문적인 기술자가 되지 않음



## 마치며





# #26 도전 즐기기

- 성공은 끝이 아니며 실패는 치명적이지 않다. 중요한 것은 계속할 수 있는 용기다 - 윈스턴 처칠
- 적극적이고 활동적인 프로그래머는 새롭고 흥미로운 도전을 지속적으로 찾아다님



## 동기 부여

- 아무도 진부한 프로그래머를 좋아하지 않음



## 도전의 정의

- 지금 자신의 관심을 끄는 것이 무엇인지 되돌아볼것



## 금기사항

- 지루한 부분은 다른 프로그래머가 하도록 하고 자신은 항상 즐거운 일만 찾아서 하는 것은 이기적임
- 사업적 가치를 불러들이지 않고 단순한 변덕으로 인한 변경은 불필요한 변화와 위험을 추가하는 일임
- 좋아하는 사업이나 과학적 실험으로 탈선한다면 진짜 작업은 절대 끝낼 수 없음
- 모든 프로그래밍 업무개 며력적이거나 흥미롭지는 않음
- **"인생은 짧다. 필자 역시 여가 시간을 코드 작성에 낭비하고 싶지 않다"**
- 이미 존재하는 무언가를 재작성하는 것은 총체적인 노력 낭비



## 자극받기

- 코딩 연습하기
- 재미삼아 해결하고 싶은 코딩 문제 찾기
- 개인프로젝트 시작하기 but 모든 여가시간을 쏟지말기
- 폭넓은 분야에 개인적인 흥미 유지하기
- 다른 플랫폼이나 패러다임을 무시하지말기 비교해보기
- 일하는 곳이 기대에 못미치거나 자극을 주지 않는다면 이직하기
- 다른 프로그래머들을 만나고 개발 컨퍼런스에 참석하기
- 작업중인 진행사항을 볼 수 있도록 하기
- 활기를 잃지 않도록 하기
- 시간낭비를 두려워하지 말기



## 마치며

- 실제적이고 유용한 코드를 작성하지 않고, 항상 새롭고 빛나는 것만 쫓는 행위는 비실용적이며 위험함





# #27 부진 피하기

- 안전지대는 유해한 영역. 정체에 주의하고 더 나은 프로그래머가 되기 위한 과정이 아님

## 자신의 기술이야말로 투자 대상이다

- 의식적으로 자신의 기술에 투자하려 해야함
- 기술 향상을 위해 시간과 노력을 투자할 것

## 실천 방안

- 안전지대 밖으로 자신을 밀어내는 몇가지 방법
  - 동일한 도구만 사용하는 습관을 멈출것.
  - 모든 문제에 대해 동일한 프로그래밍 언어를 적용하는 것을 그만둘 것.
  - 다른 OS를 사용해볼것
  - 다른 텍스트 편집기를 사용해볼것
  - 키보드 단축키에 대해 알아보고 마우스를 사용하지 않도록 의식하기
  - 새로운 주제에 대해 알아볼 것
  - 개인적인 프로젝트를 시작할것
  - 프로젝트의 새로운 부분을 담당할것
  - 새로운 언어를 배워볼 것 굳이 프로그래밍 언어가 아니라도..
  - 책상위를 재배치해볼것
  - 새로운 활동을 시작해볼것 ex 블로그
  - 운동을 시작할것
  - 더 많은 사교활동
  - 식단 조절, 일찍 잠자기

## 고용 안정

- 한가지 직업 혹은 역할에 너무 오래 머물거나 아무런 도전거리도 없이 같은 일만 반복하는 것은 위험함



# #28 윤리적인 프로그래머

- 코드와 사람들에 대한 자신의 태도를 고려햐애함

## 코드를 대하는 태도

- 의도적으로 읽기 어려운 코드를 작성하고나 그 누구도 따라하기 어려울 만큼 복잡한 방법으로 코드를 설계하지 말 것
- 적당히 석고를 붙이거나 땜질하는 식의 방법으로 버그를 수정하지 말것
- 윤리적인 프로그래머들은 버그를 찾아내고 이해한 뒤, 적절하고 견고하며 검증된 방법으로 수정함
- 윤리적인 프로그래머들은 기술부채를 추후 탕감하기 위해 작업 목록에 새로운 업무로 추가함
- 윤리적인 프로그래머들은 가능한 한 최고의 코드를 만드는 것을 목표로함
- 어떤 시간이나 상황에서도 자신의 능력 안에서 최선을 다할것
- 품질을 보장하는 자동화된 테스트를 적용하고, 실수를 잡아내고 설계를 가다듬는 페어 프로그래밍과 코드 리뷰를 도입할 것



## 법률적 이슈

- 소프트웨어 저적관을 준수할것
- 코드베이스에서 재사용한 코드에 적절한 저작권 표시를 포함할것



### 사람들에 대한 태도

- 어떤 문제를 프로그램으로 해결할 때 그 해결 방법에 있어서 기술적인 속성이 아무리 클지라도 언제나 사람에 관한 문제가 더 중요함
- 코드에 대한 좋은 태도는 곧 다른 프로그래머에 대한 좋은 태도임
- 다른 사람의 인생을 저해할 수 있는 소프트웨어를 만들지 말 것



### 동료들

- 윤리적인 프로그래머는 팀원들과 양심적으로 일하고 각팀 구성원들을 존중하고 가장 좋은 결과를 이끌어낼 수 있도록 협업함
- 모든 사람과 적절히 대화하고 소문과 뒷담화에 연루되지 말 것
- 의견을 무시당하지 않고 주장을 관철할 수 있는 기회을 그들에게 주어야함
- 정직하고 신뢰할 수 있는 사람이 되자
- 수용적인 마인드로 모든 사람들을 대하자
- 건설적인 의견 충돌과 합리적인 논의는 코드 설계를 결정할 때 더 나은 방향으로 이끌 수 있음
- 대접 받고 싶은 대로 대접할 것

### 관리자

- 자신의 것이 아닌 일에 공을 차지해서는 안됨
- 작업의 복잡성을 불필요하게 높게 측정한 뒤 복잡한 문제를 푸는척하면 안됨 ..
- 프로젝트의 원활한 진행을 방해하는 이슈들의 낌새가 느껴진다면 발견 즉시 보고할 것
- 나쁜 소식을 숨기지 말 것
- 윤리적인 프로그래머는 생산물의 품질에 대해 항상 책임을 짐
- 윤리적인 프로그래머는 체면을 차리기 위한 목적으로 가만히 있지 않음
- 책임을 다하기 위해 최선을 다할 것



### 고용주

- 고용주를 존중해야함
- 공개적인 자리에서 고용주를 나쁘게 표현하거나 험담해서는 안됨



### 나 자신

- 윤리적인 프로그래머로서 좋은 프로그래밍 연습을 꾸준히 해나가야함
- 윤리적인 프로그래머는 지쳐 나가 떨어질만큼 무리하게 일하지 않음
- 피곤에 절은 프로그래머는 누구에게도 쓸모가 없음. 초과 작업을 하지말것
- 자신의 한계를 인정할것



## 히포크라테스 선서

- 나는 개인적인 이득을 위해 그리고 작섭상의 이득을 위해 코드나 비즈니스에 해를 끼치지 않겠다고 맹세한다. 능력껏 최선을다해 주어진 일을 충실히 수행하며, 팀 내에서도 적절히 조화를 이루도록 하겠다. 다른 사람들에게 진실될 것이고, 프로젝트와 팀을 최대한 효율적이고 가치 있게 만드는 방향으로 일할 것이다.



## 마치며

- 자신의 태도를 선택할 수 있음
- 윤리적인 프로그래밍 경력자가 되기위한 최소 두단계
  - 해가 되지 않게 하라 : 남을 이용하고 짓밟지 말 것
  - 윤리적 만트라 : 자신의 재능으로 더 나은 세상을 구체화하고 프로그래밍 기술을 향상시키기 위해 지식을 공유하기





# #29 언어에 대한 사랑

- 좋은 프로그래머가 되기 위해서는 지속적으로 새로운 도전을 접하고 배우며 새로운 문제를 해결하고 새로운 기술을 사용해야함
- 한가지 재주만 있는 사람이 되지 말것



## 모든 언어를 사랑하라

- 하나 이상의 언어로 프로그래밍하는 것 역시 성장 과정의 일환임
- 좋은 프로그래머들은 다양한 언어와 방법론을 알고 있는 만큼 문제 해결의 범위가 넓음. 이는 좋은 코드를 작성하는데 도움을 줌
- 전부하지말고 가능성이 있는 두개정도만



## 자신의 언어를 사랑하라

- 그 어떤 언어라도 숙달되려면 몰입해야함



## 언어와의 관계를 발전시켜라

### 사랑하고 존중하라

- 자신의 언어를 사랑하라! 증길 수 있는 언어로 작업하라

### 몰입

- 그 어떤 언어나 기술을 막론하고 전문 프로그래머가 되려면 배우고 시간을 투자하며, 그것을 가지고 일하는 데 몰입해야함
- 하나의 언어로 좋은 코드를 작성하려면 자신의 스타일을 고집하기보다는 언어 고유의 방식과 관습에 몰이해야함

### 의사소통

- 좋은 의사소통은 고품질 소프트웨어 개발자에게 요구되는 필수 기술임
- 의사소통은 말하는 것만큼이나 듣는 것도 중요함
- 좋은 프로그래머는 좋은 의사소통을 함.

### 인내

- 해당 언어를 완벽하게 마스터하기까지는 긴 시간이 필요함
- 하루아침에 언어를 마스터하려 하지 말고 작업하는 동안 좌절하지 말것

### 가치 공유



## 완벽한 비유?



## 마치며

- 좋은 프로그래머는 단순한 코드 개행이나 분리된 코드 구조 그 이상에 대해 고민함
- 단순한 사실 기반의 지식만큼이나 도구를 사용하고 도구와 상호작용하는 방법에 대해 그리고 도구를 가장 잘 다루는 방법에 대해 생각함
- 좋은 프로그래머는 문제에 대한 빠른 해답을 기대하지 않지만 도구와 더불어 살아가는 방법을 익히고 도구의 강점과 약점을 이해함
- 도구와의 인생에 몰입하고 도구를 알기 위해 시간과 노력을 투자함. 즉 그들은 이해하고 소중하게 여김



# #30 프로그래머의 자세

## 컴퓨터 앞에 앉는 기본 자세

### 디버깅 시의 자세

### 완전히 개판인 상황에서의 자세

### 철야 작업시의 자세

### 자유를 맞이하는 자세

### 설계 시의 자세

## 눈의 자세

## 마치며

- 지금까지 읽었던 장중에서 가장 농담이 짙은 장
- 업무 환경을 인체 공학적으로 건강한 상태로 유지할것!





# #31 '더 열심히'보다는 '더 현명하게'

- 문제를 해결할 떄 하나의 도구나 한 가지 방법에 지나치게 몰입하는건 언제나 위험함



## 전투를 선택하라

- 생상적인 프로그래머가 되기 위해서는, 더 열심히 하기보다 더 현명하게 일하는 방법을 배워야 함
- 능숙한 프로그래머의 특징 중 하나느 단지 기술적 통찰력만이 아닌 문제를 풀고 전투를 선택하는 방법에서 찾아볼 수 있음
- 좋은 프로그래머는 일을 빠르게 끝냄
- 단순히 똑똑해서가 아니라 경험에서 나오는 여러 해결 방법을 돌아볼 수 있음



## 전투 전략

### 현명하게 재사용하라 

- 이미 라이브러리가 있거나 재사용가능한 코드가 있다면 직접 코드를 작성하지 말 것
- 이미 작동한다면 다시 작성할 필요는 없음
- 만약 자신의 시스템에 통합해야 한다면 퍼사드 패턴을 사용할 것



### 다른 사람의 일로 만들라

- 어떤 작업을 진행하는 방법에 대해 이미 다른 사람이 알고 있다면 그 일을 직접 해결하려 들지 말것
- 배우고싶지만 빨리해야한다면 다른사람에게 도움을 요청할 것



### 해야 하는 것만 하라

- 리팩토링과 유닛 테스트가 반드시 필요하지만 경우에 따라 필요하지 않을 수 있음
- 모든 메서드를 테스트하려 하지말 것



### 거칠더라도 빠르게 해결하라

- 여러 설계 방안 가운데 어떤 것을 선택해야 할지 결정할 수 없을 때는 최선책을 골라내기 위해 심사숙고하느라 많은 시간을 소모하지 말것
- 스파이크 솔루션, 프로토타입을 적절하게 사용할 것



### 우선순위를 설정하라

- 우선순위가 가장 높은 일에 노력을 집중할것. 가장 긴급한 작업 혹은 가장 가치가 높은 작업은 무엇인가?
- 사소한것에 몰두하지 말 것
- 중요하지 않은 수많은 업무를 조심할것
- 하루 중 특정 시각에 한꺼번에 처리할것



### 정말 필요한 것은 무엇인가

- 새로운 업무가 할당될 때는 지금 당장 필요한 일인지부터 확인할 것
- 굳이 필요하지 않은 상황에서 100%의 완성도를 낼 필요는 없음



### 한 번에 하나씩

- 한 번에 하나씩 작업을 수행할 것



### 작고 간결하게 유지하라

- 코드와 설계를 가능한 한 작고 간결하게 유지할것
- 나중에 고쳐야할 수 있지만 미래의 요구사항은 알 수 없음
- 언젠가 발생할 가능성이 있는 기능을 미리 만들어두는 것은 더 어렵고 어리석음



### 문제를 미루고 쌓아두지 말라

- 어려운 일을 미뤄두지 말것. ex 머지
- 현명한 방법은 더 일찍 문제가 작을때 어려울일에 직면할 것
- 눈덩이가 커지면 더 힘들어짐



### 자동화하라

- 한 번 이상 반복해야 하는 일이 있다면 그것을 수행하는 스크립트를 작성할 것



### 오류 방지

- 오류를 더 빨리 발견할 것
- 고객에게 자주 피드백받아서 오류를 빨리 발견할 것
- 다른 사람들과 코드 설계에 관해 토론할 것
- 작고 이해 가능한 범위에서 코드를 리뷰할 것
- 처음부터 유닛 테스트를 작성할 것



### 의사소통하라

- 의사소통을 더 잘할수 있는 방법을 배울것
- 적절한 질문을 하는 방법을 배울것



### 지쳐 나가떨어지지 말라

- 몇 시간에 걸친 어리석은 업무로 자신을 불태우지 말라
- 건전한 프로젝트는 연속된 야근을 요구하지 않음

### 

### 강력한 도구

- 항상 업무 흐름을 가속화해줄 새로운 도구를 찾을것
- 그러나 새로운 도구를 찾는 일에 너무 몰두하지 말 것



## 마치며

- 더 열심히 일하기 보다는 더 현명하게 일할것!

























