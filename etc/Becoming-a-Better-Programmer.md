

# 훌륭한 프로그래머 되는 법







# 코드에 신경쓰기

## 코드가 중요하다

- 좋은 코드를 작성하고 싶다면. 좋은 프로그래머가 되고 싶다면 그만큼 코드에 신경써야함.
- 단지 작동하는 코딩은 거부하고 올바르게 작동하는 훌륭한 코드를 짜도록 노력해야함 + 테스트
- 의도가 드러나는 코드. 유지보수가 쉬운 코드. 정확한 코드
- 훌륭한 결과물을 자랑스러워하거나 더러운 코드에 혐오감을 느끼는 것은 자신이 건전하다는 증거





# 정돈된 코드 유지하기

- 누구도 지저분한 코드로 작업하는 걸 좋아하지 않음
- 코드의 레이아웃에 대한 논쟁이 증가할수록 의미 없는 논쟁으로 빠지게 될 확률이 높아짐
- 코드 레이아웃에 대해 싸우는 것을 멈추고, 자신만의 코드 레이아웃을 만드는 올바른 방법을 익히자. <= 이걸로 싸워본적이 없는거같은데.... 쩝



## 보이는 것은 강력하다

- 좋은 코드는 명백하고 일관성이 있음
- 좋은 표현 기법은 아름다움을 위해서가 아니라 실수를 줄이기 위해서임
- 일관성이 없는 레이앗과 뒤죽박죽인 명명은 코드의 품질이 높지 않다는 징후임



## 의사소통

- 컴파일러와 동료 프로그래머를 위한 코딩을 할 것
- 읽기 어려운 코드는 작업하기도 어려움 다른사람을 위해 코딩하는 것을 잊지 말 것
- *로 둘러쌓인 주석같은건 쓰지말것 <= 수정이 어려움



## 레아이웃

- 어떤 레이아웃을 쓰던지 상관 없고 단지 전체 형태와 구조를 파악할 수 있어야함

### 구조 잘 잡기

- 비슷한 것끼리 묶고 다른 것은 나눌것
- 자연적인 문단 나눔이 있지 않은 한, 빈 줄은 넣지 말것
- 코드 연관성과 관련된 순서는 중요함. 코드를 읽을 사람을 고려할것
- 합리적인 순서로 API 를배치할것 private 보다는 public을 먼저 적을것
- 객체 생성은 객체 사용 이전에



### 일관성

- 한꺼번에 모든 레이아웃 스타일을 지키려 애쓰지 말자.
- 딱 하나만 골라서 일관성있게 사용할 것
- 사용하는 언어에 가장 잘 맞는 걸 고르는 것이 좋음. 기본 라이브러리의 스타일을 따를것
- 팀의 다른 동료들과 동일한 레이아웃 규칙으로 코드를 작성할 것
- 자신만의 고유한 스타일을 사용하지 않을 것
- 프로젝트에 일관성이 없다면 표준 코딩 스타일 가이드를 적용할 것.
- 길거나 엄격한 문서가 아닌, 레이아웃에 대한 약간의 규칙만으로도 팀의 협업을 충분히 끌어낼 수 있음
- 단 강압적이 아닌 상호 합의하에 이루어져야함
- 레이아웃 규칙을 따르지 않은 파일을 작업하는 경우에는 해당 파일의 레이아웃 규칙을 따를것
- 팀 전체의 ide와 소스 코드 편집기가 같은 환경으로 설정되어 있는지 확인할 것



## 명명

- 이름짓는것을 중요하게 생각해야함.



### 불필요한 반복을 피하라

- 둘러싸인 클래스의 문맥이 확실하게 정의되어 있으면 이걸 메서드에 굳이 쓰지 않아도됨
- 클래스 + 메서드명으로 표현할 수 있으면 그렇게 하면 됨



### 명확하게 하라

- 간결함보다 명확함

## 

### 관용어법을 지키라

- 언어별로 있는 관용적 이름을 선호할 것
- ex 클래스명이 파스칼 케이스인것



### 정확하게 하라

- 위젯 배열이름을 Widget Set으로 짓지 말 것
- 정확한 이름을 사용할 것



## 스스로 가다듬기

- 코드를 정리해야한다면 기능 변경과 모양 변경을 동시에 진행하지 말 것
- 소스 관리 시스템에 모양 변경과 기능 변경을 별도의 단계로 나누어 커밋할 것
- 코드를 읽고 배우고 자신만의 레이아웃 스타일을 발전시켜나갈것



## 마치며

- 개인적으로 선호하는 레이아웃이 아니더라도 프로젝트의 공통 관습을 따를것
- 다만 어떤 레이아웃이 왜 좋은지에 대해서는 개인적인 의견을 갖자
- 지속적으로 다른 코드를 읽어가며 경험을 쌓고 배우자.
- 코드 레이아웃에 일관성과 명확함을 사수하자



# 코드 적게 쓰기

- 많은 양의 코드 작성이 곧 다량의 소프트웨어 개발을 의미하지는 않음
- 소프트웨어를 개선하는 최고의 방법 가운데 하나는 바로 코드를 제거하는 것



## 코드에 신경 써야 하는 이유

- 각 줄의 코드마다 비용이 듬. 코드를 길게 많이 쓸수록 유지보수 비용은 높아짐
- 수많은 코드란 읽고 이해해야 할 내용이 많음을 의미함
- 코드가 많을수록 수정해야 할 부분도 많아짐. 수정하기 어려움
- 코드가 많을수록 버그가 숨을 수 있는 공간도 많아짐
- 중복코드는 특히 치명적. 



## 허술한 논리

```
if (expression)
	return true;
else
	return false;

```

- 위 코드보단 아래 코드 형식으로 사용할 것

```
return expression
```

- 명백하고 간결하게 표현하면 됨
- 언어가 작동하는 방식에 대해 아는 것을 부끄럽게 생각하지 말 것



## 중복

- 불필요한 코드 중복은 보통 잘라내기와 붙여넣기를 통해 발생함
- 코드의 일부를 복사하지 말고 공통 함수에 넣을 것. 다른 부분은 매개변수를 사용할 것
- Don't Repeat Yourself!
- 다만 비슷한 코드를 하나의 공통 함수에 넣으면 해당 함수를 사용하는 코드들은 긴밀한 결합도를 가지게 된다는 사실을 알아야함 이는 장기적으로 더 많은 문제를 초래할 수 있기 때문에 코드에 대한 책임감이 필요함



## 죽은 코드

- 죽은 코드란 실행되거나 호출되지 않는 생명력 없는 코드를 말함
- 실행되지 않는 코드는 정리할 것
- 죽은 코드를 포함했을 때 나타나는 징후
  - 한 번도 호출되지 않는 함수
  - 선언되었지만 할당되지는 않은 변수
  - 내부 메서드에 전달되었지만 사용되지는 않은 매개 변수
  - 전혀 사용되지 않는 열거형, 구조체, 클래스, 인터페이스



## 주석

- 좋은 코드는 작동법을 설명하는 대량의 주석을 필요로 하지 않음
- 변수, 함수, 클래스 이름의 적절한 서택과 올바른 구조는 코드를 더 명확하게 만듦
- 주석에서 모든 정보를 복사해 표현하는 것이야말로 불필요한 중복임
- 특정 알고리즘에 주석이 필요해보인다면 잘 명명된 새로운 함수들로 로직을 재구성하는 편이 더 나을 수도 있음
- 이전 코드는 완벽하게 제거할 것
- 코드가 어떤 역할을 하는지 설명하는 주석을 달지 말 것



## 장황한 내용

- 삼항연산자를 잘 사용해서 장황하게 풀어진 코드의 수를 줄일 것
- 변수의 선언부분과 정의 부분을 같은 위치에 쓸 것



## 나쁜 설계

- 모든 불필요한 코드는 낮은 수준의 실수나 부적절한 관리로 인한 결과물로 치부될 수는 없음. 높은 수준의 설계상의 결점 탓일 수도 있기 때문
- 나쁜 설계는 분명한 이유 없이 수많은 여분의 데이터를 정렬하는 등의 오류
- 오래된 것들을 바꾸는 것에 두려워하지 말 것
- 설계시점에는 기존에 있는 라이브러리에 이미 구현되어있는지 확인할 것 이름값 하는 라이브러리는 강건하고 확장성도 있고 자주 이용됨



## 공백

- 공백은 코드 구조에 도움이 됨



## 그래서 무엇을 해야 할까

- 불쾌한 코드는 고의성을 띠지 않음
- 책임감을 느껴야함. 불필요한 코드를 쓰지 말고, 레ㅐ거시 코드를 작업할 때는 경고 표시에 주의할 것
- 코드 정돈은 다른 기능적 변화와는 별개로 전개되어야 함



## 마치며

- 소프트웨어 기능은 코드의 줄 수나 컴포넌트 수와는 연관이 없음
- 더 많은 줄의 코드가 더 좋은 소프트웨어를 의미하지 않음
- 필요하지 않다면 코딩하지 말 것
- 적게 쓰고 그 대신 더 재미난 것을 찾을 것



# 코드 줄여 개선하기 

- 새로운 코드를 추가해서 시스템을 개선할 수 있음. 반대로 코드를 제거하여 시스템을 개선할 수도 있음



## 제멋대로인 코드

- 제 멋대로인 코드는 프로그래머가 제멋대로 코드를 작성했을 확률이 높음
- 의미가 있을때만 코드를 작성하고 미래에 필요한 기능을 앞당기지 말 것



## 불가피한 결과물

- 언젠가 필요할 것 같다는 코드, 지금 제거되지 않아도 괜찮을 것 같은 코드
- 더는 사용되지 않는 자료형 또는 클래스가 프로젝트에 남아있는 경우
- 기존 제품의 기능들이 거의 제거되지 않은 경우
- 코드에 대한 오랜 기간의 유지 보수로 인해 함수 일부가 실행되지 않는 경우
- 잘 사용되지 않는 이벤트 핸들러가 있는 경우
- 전혀 사용되지 않는 함수 반환 값이 있는 경우
- 디버그 코드가 괴사하는 경우



## 어떻게 해야 하나

- 죽은 코드는 불가피하다는 사실을 받아들이고 프로젝트가 잗공하는 한 지나친 걱정은 하지 말 것
- 불필요한코드의 대가
  - 불필요한 코드 역시 다른 필요한 코드와 마찬가지로 유지보수되어야 한다는 점은 명백함 여기엔 시간과 돈이 듬
  - 여분의 코드는 프로젝트를 파악하기 어렵게 만드는 만큼 추가적인 이해와 검토가 필요함
  - 실제 사용 여부와 상관 없이 백만 개의 메서드를 가진 클래스는 주의 깊게 프로그래밍할 수 없으며 엉성하게 작성할 수 밖에 없음
  - 가장 빠른 장비, 가장 좋은 컴파일러를 사들여도 불필요한 코드는 빌드를 지체시키고 덜 생산적이게 만듦
  - 코드가 좀비 코드로 가득차면 리팩토링이나 간소화, 최적화는 더 어려워짐



## 죽은 코드 탐색

- 가장 좋은 방법은 코드베이스에서 작업할 때 주의를 기울이는 것
- 자신의 행동에 대해 책임을 지고 작업 후에는 확실하게 정리. 
- 정기적인 코드 리뷰는 죽은 코드를 찾는 데 도움이 됨
- ide의 기능을 잘 활용할 것



## 외과적 적출

- 죽은코드, 미래에 필요할지도 모르는 기능을 가진 코드 등등 과감하게 제거할것 그리고 필요하면 버전관리 시스템으로 손쉽게 가져오면됨
- 코드를 정리하는 작업과 개발 작업의 히스토리는 구분되어있어야함



## 마치며

- 가장 훌륭한 코드베이스에도 불필요한 코드는 만들어짐 이것은 실패의 징조가 아님
- 죽은 코드가 있음에도 아무런 조치도 취하지 않는 것은 실패 징조
- 필요하지 않는 기능은 추가하지 말것. 정말 필요할때 추가하면됨





# 코드 베이스의 망령

- 오래된 코드를 다시 살펴보는 것은 코딩 기술 등을 향상시키는데 도움을 줌

## 외관

## 최신 기술

## 관례

## 설계 결정 사항

## 버그

## 마치며

- 기존의 코드를 돌아보는 것은 자신을 위한 코드 리뷰이자 가치있는 행동임
- 더 이상 적절하지 않다고 느껴지는 예전의 코드를 찾아내는 것은 좋은일임 이는 성장했다는 뜻.



# 경로 탐색하기

- 프로젝트에 투입된 최초 시점에서 성과를 낼 수 있는 상태에 빠르게 도달하기 위해 어떻게 해야할지에 대한 고민...
- 하나의 팀에서 영원히 하나의 코드베이스만 다루다가 고인물이 되지 말아야함
- 이미 존재하는 거대한 코드베이스에 적응하는 것은 어려운 일임.
- 적응을 위한 작업
  - 코드의 어느 부분부터 보아야 하는지 파악하기
  - 코드의 부분별 기능을 알아내고 그 기능을 어떻게 수행하는지 살펴보기
  - 코드의 품질을 가늠하기
  - 시스템 내부를 어떻게 탐색할 것인지 계획하기
  - 코딩 관례를 이해하고, 본인의 수정 사항이 그것과 어울리도록 만들기
  - 특정 기능이 있을 법한 위치를 파악하고, 그 기능에 의해 발생하는 버그 찾아보기



## 친구들의 작은 도움

- 코드에 정통한 누군가와 함께 일을 할 수 있다면 그 점을 활용할 것. 질문하기를 주저하지 말 것
- 주변에 없다면 커뮤니티, 오픈소스를 찾아볼 것
- 도움을 요청할 때는 언제나 공손해야 하고 감사해야함. 
- 합리적이고 적절한 질문을 할 것 
- 도움을 받았으면 그에 대한 답례로 다른 이를 도울 준비를 할 것
- 혼자 쉽게 알아낼 수 있는 바보같은 질문을 하지 않는 것은 최소한의 예의



## 단서 찾기

- 도와주는 사람이 없을때는 단서들을 찾아야함

**소스 획득의 용이성**

- 건전한 프로젝트에서는 전체 코드베이스를 얻기 위해 코드를 한 번만 체크아웃 해도됨.
- 빌드 머신의 그 어떤 디렉터리에 두어도 상관 없음 경로를 하드코딩해서는 안됨



**코드 빌드의 용이성**

- 건전한 빌드는 핱나의 단계만으로 수행되고 사용자의 개입을 필요로 하지 않음



**테스트**

- 좋은 테스트를 포함하는 코드는 일반적으로 적절히 분류되고 심사숙고되며 제대로 설계됨

**파일 구조**

- 코드 형태와 어울리는지

**문서**

- 문서가 잘 되어있는지

**정적 분석**

**요구사항**

- 최초 프로젝트 요규사항 문서나 기능 명세서가 있는지

**프로젝트 의존성**

- 코드에서 특정 프레임워크와 서드파티 라이브러리를 사용하는지

**코드 품질**

- 코드의 품질에 대해 살펴보기

**구조**



## 실행을 통해 배우기

- 자전거를 책으로본다고해서 자전거 타는 실력이 늘지 않음. 코드도 만찬가지. 코드도 지속적으로 많이 봐야 실력이 늘 수 있음

### 낮게 매달려 있는 과일

- 간단하고 사소한 일부터 도전해볼것.
- 바로 확인해볼 수 있고 코드와 직접 관련이 있는 작언 버르를 찾아내는 것 등
- 어마어마하게 복잡한 오류보다는 사소하고, 재현 가능하며, 위험성이 적은 오류 보고부터 시작

### 코드 조사하기

- 컴파일러 경고를 확인.
- 기능과 무관한 코드 변경 작업을 통해 코드의 각 요소가 어떻게 서로 들어맞고 어울리는 지 알 수 있음



### 확인한 뒤에 행동하라

- 코드의 작은 부분부터 확인. 테스트. 리팩토링.
- 변수명과 함수명을 적절하게 바꿔볼것
- 코드를 작성하는것이 읽는것보다 쉬움



### 테스트부터 하라

- 테스트를 찾고 새로운 단위테스를 어떻게 추가하는지. 테스트를 어떻게 실행하는지 확인해볼것

### 잡다한 일을 처리하라

- 사용자 ui 개선작업. 소스파일 정리. 디렉터리 구조 변경 등등



### 알아낸 것을 기록하라

- README 문서가 있으면 사용하고 그렇지 않다면 지금까지 알아낸것들에 대한 기록
- 많은 프로그래머들에게 README파일을 리뷰 요청할것



## 마치며

- 경험이 쌓일수록 고통은 줄어들고 이득은 커짐. 코딩도 마찬가지
- 새로운 코드베이스에서 더 많이 작업해볼 수록, 새로운 코드를 더 효과적으로 이해할 수 있음





# 똥통에서 뒹굴기

- 똥 덩어리 코드를 다루기 위한 전략 ...?

## 똥냄새 맡기

- 훌륭한 코드만 만날 수 없음.
- 나쁜 코드를 언제든 만날 수 있다는 마음의 준비를 할것
- 나쁜 코드를 다룰 때 쓸 강력한 도구들을 미리 준비해둘것
- 이상한 코드를 효과적으로 다루기 위해서는 문제 지점을 어떻게 찾고 다룰지 알아야함



## 똥통 헤치고 나아가기

- 더러운 코드를 만들게 된 이유부터 냉정하게 분석해야함
- 충분히 살펴보기 전까지는 코드나 코드를 작성한 사람에 대해 경솔한 판단을 하지 말아야함
- 개인적 이유로 판단하지 말 것 조잡한 코드를 일부러 짜는 사람은 거의 없음
- 나쁜 코드를 만났을 때 느껴지는 혐오감을 참고 대신 그걸 나아지게 할 방법을 찾을 것



## 똥통 조사 결과

- 다음과 같은 평가 기준에 따라 코드의 품질을 측정할 수 있음
  - 외부에 노출하는 api는 깔끔하고 합리적인가?
  - 자료형을 잘 고르고 변수 명을 적절히 지었는가?
  - 코드의 레이아웃을 정돈하여 일관성있게 작성했는가?
  - 객체들의 협업 구조가 보기에 간결하고 명확한가? 아니면 코드베이스 전반에 제어 구조가 예측할 수 없게 얽혀있는가?\
  - 특정 기능을 구현하는 코드 부분이 어디에 있는지 쉽게 찾을 수 있는가?



## 수렁에서 일하기

- 헤어나기 어려운 늪이나 다름없는 코드를 찾아냈다면 긴급상황에 속한것. 적절한 전략이 필요함 적절한 공략 계획은?
  - 나쁜 코드를 고쳐야만 할까?
  - 현재의 문제를 해결할 최소한의 수정만 한 뒤 달아나야 할까? ㅎ...
  - 괴사 부위를 도려내고, 새롭고 더 나은 코드로 바꿔야할까?
- 시간이 없으면 전체를 다 뒤엎을 생각을 하지 말 것
- 시간을 지혜롭게 쓸 것. 코드가 별로여도 별다른 수정없이 몇년동안 적절하게 동작했다면 지금 수정하는 것은 적절하지 않을 수 있음
- 지금 수정하지 않고 이후에 점진적으로 수정해나가면서 코드를 개선할 수 있음



## 똥 치우기

- 어떤 코드를 건드리든 이전보다 나아지도록 할 것. 보이스카웃 규칙
- 간단한 수정이라도 좋음
- 주기적으로 코드 일부라도 확인하고 그때마다 조금씩 나아지게 만들면 머지않아 좋은 결과물을 만들 수 있음



## 수정하기

- **코드 수정은 천천히. 주의깊게. 한번에 하나씩 수정**
  - 기능을 변경하면서 코드의 레이아웃 변경 금지
  - 수정으로 인해 기존 기능에 문제가 생기지 않음을 보장할 수 있는 모든 수단을 사용할 것. 신뢰할만한 자동화 도구, 변경사항에 대한 충분한 검토 .. 
  - 적절한 단위 테스트들로 코드를 충분히 둘러 싸야함. 문제되는 코드 주변에 테스트 코드가 전혀 없다면 먼저 테스트부터 만들것
  - 코드를 감싼 api를 수정하되 내부 로직을 직접 수정하지 말 것. 적절ㄹ한 명칭과 매개 변수 타입, 순서를 가지도록 수정할것. 이는 코드 전벤에 걸쳐 일관되어야함. 아니면 새로운 외부 인터페이스를 만들 수도 있음. 기존 api를 통해 새로운 외부 인터페이스를 작성하고, 이후 내부 구조를 변경할 때 이인터페이스의 내부도 변경하면 됨
- 코드 변경에 대해 할 수 있다는 용기를 가질것. 잘못되면 다시 되돌리면됨



## 나쁜 코드? 나쁜 프로그래머?

- 일부러 잘못된 코드를 작성하려는 사람은 거의 없음. 나쁜 코드에 비난을 퍼부을 필요도 없음
- 가능하다면 코드를 변경할 기회를 즐길것.



## 마치며





# 오류 무시하지 않기

- 코드에서 발생할 수 있는 모든 오류를 무시하지 말 것. 
- 더 늦기 전에 오류 처리를 미루지 말라. 자꾸 미루다보면 처리하기 더 어려워짐



## 메커니즘

- 우리는 아래의 여러 방법으로  코드의 오류를 확인함

**코드 응답**

- 리턴 값은 가장 보편적인 오류 검출 방법. 함수들은 값을 반환하고. 운영체제 프로세스도 값을 반환함

**부수적 작용**

**예외**

- try-catch에서 catch문에 아무런 동작도 하지 않는것.
- 규칙에 맞춰서 예외를 잘 사용해야함



## 광기

- 요류를 적절히 처리하지 않으면 다음과 같은 일이 발생할 수 있음

**불안정한 코드**

- 이러한 유형의 코드는 찾아내기 어려운 충돌로 가득 차 있음

**불안전한 코드**

- 크래커들은 소프트웨어 시스템을 파괴하기 위해 종종 오류 처리 과정의 취약점을 이용함

**나쁜 구조**

- 만약 반복적으로 다루어야 하는 오류로 인해 코드가 지루해진다면. 그것은 좋지 않은 인터페이스 때문임 인터페이스를 개선해야함.



- 코드에서 모든 잠재적인 오류를 확인해야 하는 것처럼. 사용자 인터페이스에서도 모든 잠재적인 잘못된 상황을 노출시켜야함. 숨기지 말고 정상적으로 동작하는것처럼 보이게 만들지 말 것.



## 감형 사유



## 마치며

- 오류를 무시하지 말 것!



# 예상하지 못한 것을 예상하기

- 모든 단계에서 조금이라도 발생할 가능성이 있는 특이 사항들은 모두 고려해야함



## 오류

- 호출되는 어떤 함수도 예상대로 작동하지 않을 수 있음
- 운이 좋다면 오류 코드를 전달받을 수 있음. 무조건 확인할 것
- 함수는 자신의 기능이 제대로 이행되지 않을 때 예외를 던질 수 있음. 코드가 예외 발생에 대해 대처하도록 할 것.
- 항상 오류를 고려한 코드를 작성하여 그로부터 복구할 수 있도록 할 것. 복구하지 못할 오류 역시 고려할 것.



## 스레딩

- 멀티스레드 환경에서 예측 불가능한 수준을 다루기 위해서는 기본적인 동시 실행의 원리와 함께 스레드 간의 결합도를 완화하여 위험하게 상호 작용하지 않도록 하는 방법을 반드시 이해해야함



## 셧다운

- 리소스의 누출이나 데드락, 충돌 없이 코드를 우아하게 중단시킬 수 있는지에 대해서는 잘 확인하지 않음



## 이 이야기의 교훈

- 코드 작성시 가능한 모든 코드 경로를 고려해야함. 나중에 비정상적인 경우에 대응하려 하지 말라. 그렇게 할 일을 미루다보면 이후 그와 같은 경로 자체가 있음을 잊어버리게 되고 코드는 버그로 가득 찰 것.





# 버그 사냥하기

- 버그는 생기기 마련. 피하지 말것



## 경제적 우려

## 대비책

- 버그가 생긴 뒤에 고치기보다는 처음부터 버그가 생기지 않도록 적극적으로 예방하는 편이 훨씬 나음
- 섬세한 설계, 코드 검토, 짝프로그래밍. 심사숙고한 테스트 전략...
- 적절한 공학적 방법론을 채택하여 코드에 버그가 생성되는 것을 막을 것. 빠르게 대충 작성한 코드의 품질이 높을 것이라는 기대는 하지 말라.
- 버그를 피할 수 있는 가장 좋은 충고는 믿기 힘들정도로 영리한(복잡한) 코드를 만들지 말라는 것. 



## 버그 잡기

- 코드 작성법과 상관없이, 유해한 버그 중 일부는 항상 방어막을 뚫고 들어옴
- 버그의 대부분은 쉽게 찾아내고 금방 수정이 가능하지만 아래의 경우는 힘듦
  - 재현 가능성이 얼마나 되는가, 즉 항상 재현 가능한가. 재현하기는 쉬운가.
  - 버그의 원인, 즉 나쁜 코드나 코드 통합 시의 잘못된 가설과 같은 소프트웨어 결함이 코드에 포함된 시점과, 이를 발견한 시점 사이의 간격이 얼마나 되는가.
- 가장 중요한 것은 버그를 체계적으로 조사하고 특징을 잡아내는 것. 
  - 버그 재현 과정을 가능한 한 가장 단순하게 줄일 것. 산만하기만하고 도움이 되지 않는 모든 관련 없는 항목들을 걸러내라
  - 단 하나의 문제에 집중할 수 있도록 함. 서로 관련된 두 버그를 하나로 착각한 채로 이를 깨닫지 못할 경우 코드는 금세 뒤죽박죽이 될 수 있음
  - 해당 문제를 얼마나 반복할 수 있는지 알아볼 것.



### 함정 파기

- assert와 로그는 강력한 디버깅 도구임.
- 진단 로그와 assert는 문제를 발견하고 해결한 이후 코드를 남겨놓는 확실한 방법임



### 이진 탐색 배우기

- 가능한 한 빨리 버그에 포커스를 맞추도록 이진 탐색 전략을 목표로 할 것.
- 문제 공간을 이진 탐색하여 문제의 원인에 더 빨리 도달하라.



### 소프트웨어 고고학을 채택하라

- 소프트웨어 고고학은 과거 이력을 바탕으로 버전 관리 시스템을 뒤져보는 방법에 대해 설명함
- 문제가 되는 코드 변경을 찾아낼 수만 있다면, 그 실패의 원인은 대개 명백해지고 수정 방법도 자명해짐



### 테스트하고 테스트하고 테스트해라

- 소프트웨어를 개발했다면 단위 테스트를 작성하는 데 시간을 투자하라.
- 단위 테스트를 작성하는 것은 전체시스템을 실행하여 버그를 찾는 것보다 버그를 증면하는데 더 바람직함
- 특정 코드가 테스트 범위에 들어가지 않는다면 제대로 작동한다고 신뢰할 수 없다는 것임.
- 테스트하지 않은 코드는 버그의 번식지나 다름 없음.



### 예리한 도구에 투자하라

- 각 작업에 알맞은 도구를 사용하는 것을 두려워하지 말 것.
- 디버거 사용법을 잘 익힌 다음 필요한 때에 사용하라



### 원인 분석 과정에서 제외하기 위해 코드를 제거하라.

- 실패 재현 시 문제가 되는 코드 부분을 해결하는 데 기여하지 않는 모든 부분을 삭제할 것인지 판단 할 것.
- 연관되지 말아야 할 주제들은 서로 엮이지 않도록 할것



### 청결은 감역을 막는다

- 버그가 소프트웨어에 필요 이상으로 오래 머물지 않도록 해야 함
- 깨진 유리창 신드롬을 일으켜서 점차 버그의 행동이 일상적이고 자연스로운 것처럼 느껴지게 만들 수 있음
- 최대한 빨리 버그를 고칠것.



### 간접적 전략

- 아래의 간접적 접근 전략을 시도하여 디버깅 구덩이에 빠져 있는 상황을 벗어날 것

**쉬어가기**

- 작업을 멈추고 코드에서 떨어져 있어야 할 때를 배우는 것은 중요함.
- 휴식을 통해 새로운 관점을 얻을 수 있고 이를 통해 더욱 신중하게 생각할 수 있음

**다른 사람에게 설명해보라**

- 문제를 다른 사람에게 설명해볼것.
- 어떤 문제를 다른 사람에게 설명하다 보면 동시에 자신에게도 설명하게 되고 문제를 해결하게됨



### 도망가지 말라

- 버그에 해당되는 코드 구역에 숨어 있는 또다른 관련된 문제들이 있는지 고려해볼것



## 재현할 수 없는 버그

- 이들 버그를 찾고 수정하는 방법
  - 실패를 유발하는 요소들을 기록해두고 반복하다보면 어떤 패턴을 찾아내는데 도움을 줄 수 있음
  - 베타 버전이나 출시 버전에 더많은 로그와 assert를 추가하여 실제 사용자의 사용 시 정보를 획득하는 방법
  - 매우 힘든 문제일 경우 테스트 팜을 세팅하여 오랫동안 가동하는 스트레스 테스트를 실행할 수 있도록 하라. 만약 대표적인 방식으로 시스템을 자동화하여 가동할 수 있다면 버그 사냥 작업이 더 가속화될 수 있음

- 안정적이지 않은 버그 생성에 기여하는 것들
  - 스레드를 이용하는
  - 네트워크 상호 작용
  - 저장 장치의 다양한 속도
  - 메모리 손상
  - 전역 변수/싱글톤



## 마치며

- 디버깅은 쉽지 않지만 우리 스스로의 실수에서 비롯된 것.
- 버그를 만들어내는 것은 우리 자신임.
- 효과적인 디버깅은 모든 프로그래머들의 필수적 기술!





# 테스트하기

- TDD는 더 나은 소프트웨어를 만들기 위한 중요한 기법중 하나



## 왜 테스트하는가

- 자신의 코드는 자신이 테스트해야함. 



### 피드백 과정 줄이기

- 가능하면 자주 그리고 빨리 피드백 받는것이 좋음.
- 좋은 테스트 전략이란 피드백 절차를 간소화하는 것으로, 이를 통해 더 효율적으로 일할 수 있음
- 피드백 과정이 짧을수록 설계 변경을 더 빠르게 반복할 수 있고 코드에 대해 더 강하게 확신할 수 있음
- 문제를 빨리 알수록 수정은 쉬워지고 비용은 낮아짐 그 이유는 코드를 짜는 시점에 가까운 만큼 코드에 대해 더 명확하게 파악하고 있기 때문임
- 소프트웨어 개발 과정을 개선하려면 빠른 피드백을 통해 문제 파악에 소모되는 시간을 줄여야함. 좋은 테스트 전략이란 바로 피드백 절차를 줄이는데 있음
- 자동화된 테스트를 통해 피드백 과정을 줄이면 코드 개발 과정에 도움을 주고 재활용 가능하다는 이점도 있음



### 테스트 코드 짜기

- 가장 이상적인 방법은 최대한 많은 개발자가 테스트를 자동화하는 것.
- 서둘러야하는 상황에서는 오히려 더 천천히.



### 누가 테스트 코드를 짜야 할까

- 가장 적절한 방법은 코더 자신이 자신의 코드에 대한 테스트코드를 작성하는 것



## 테스트 유형

**유닛 테스트**

- 가장 작은 단위의 기능에 대한 테스트를 단독으로 수행하는 것. 
- 단일 단위의 코드에 대해 테스트가 수행되지 않는다면, 그것은 유닛테스트가 아님
- 이 단독이라는 말은 그 어떤 외부에 대한 접속도 하지 않는다는 뜻.



**통합 테스트**

- 각각의 단위 모듈을 더 큰 결합체로 통합하여 작동시키는 복합 기능을 검증할 수 있음
- 테스트 대상이 하나 이상의 객체들인 테스트



**시스템 테스트**

- 통합된 소프트웨어 스택 전체에 수행되는 테스트



## 언제 테스트를 작성할까

- 독단적으로 테스트를 먼저 작성하지 않아도 데스트를 통한 피드백을 통해 설계를 개선해 나갈 수 있음 하지만 테스트 작성을 미룰수록 테스트는 덜 효과적.
- 테스트를 우선으로 하는 tdd의 단계
  1. 다음으로 구현해야 하는 기능을 결정한 뒤, 해당 기능에 대한 테스트를 작성. 물론 테스트는 실패함
  2. 테스트를 작성한 뒤 최대한 간단한 방법으로 기능을 구현함. 테스트가 통과했다면 기능이 적절히 구현되었음을 알 수 있음. 각 테스트가 작은 만큼 실행도 빠름
  3. 코드를 정리할것. 이상한 공통분모를 리팩토링할것. 
  4. 첫 단계로 돌아가서. 요구사항에 대한 테스트 케이스 전체를 통과할때까지 테스트를 반복하라.
- 위 단계는 레드 그린 리팩토링 주기로도 불림.
- 코드를 작성하면서 테스트를 같이 작성할 것. 테스트 작성을 미루면 그만큼 테스트 효과가 줄어듦
- 코드 수정에 무작정 달려들기보다는 우선 버그의 원인을 설명하는 실패 유닛 테스트를 작성할 것



## 언제 테스트를 실행하는가

- 테스트코드를 tdd를 사용해 개발하면 각각의 기능을 구현하면서 테스트를 계속 실행할 수 있음
- 버전 관리 도구에 구현 코드와 테스트 코드를 모두 추가할것. 만약 이후에 누군가 코드를 잘못 수정한다면 그에 대한 경고를 받게됨
- 모든 테스트는 지속적 통합 도구의 일부인 빌드 서버에서 실행해야함 실패한 테스트가 있다면 컴파일 자체를 실패함
- 코드 수준의 자동화된 테스트를 하더라도 출시 전 사람에 의한 qa 검수 과정은 필요함. 진정한 테스트 전문가에 의한 탐색적 테스트는 매우 유용함
- 아무리 좋은 개발자 테스트라 해도 qa테스트를 대치할 수는 없음



## 무엇을 테스트할 것인가

- 애플리케이션에서 중요한 부분은 모두 테스트할것.
- 요구사항의 모든것들은 테스트가 되어야함. 성능이 주요 요구사항이라면 코드의 성능을 모니터링하는 테스트도 수행해야함



## 좋은 테스트

- 좋은 테스트 코드를 작성하려면 연습과 경험이 필요함
- 테스트가 쓸모없을까 걱정하지 말고 테스트를 쓰기 시작하고 배워 나가라
- 나쁜 테스트는 짐이 될 수 있음 이로 인해 개발 과정이 지연될 수 있음
- 좋은 테스트의 특징
  - 짧고 명확한 이름을 갖고 있어 실패했을 때 무엇이 문제인지 쉽게 알 수 있음
  - 유지 보수가 가능함 작성은 물론 읽고 수정도 쉬움
  - 수행에 오랜 시간이 걸리지 않음
  - 최신 구현 코드에 맞춰져 있음
  - 특별한 머신 설정이 필요 없음.
  - 다른 테스트에 대한 의존성이 없어서 특정 테스트 전후에 실행할 필요가 없음. 외부 상태나 코드상의 어떤 공유 변수에 대한 의존성이 없음
  - 실제 구현 코드를 테스트함.
- 나쁜 테스트의 특징
  - 때로는 성공하고 떄로는 실패하는 테스트
  - 이상해보이고 읽거나 수정하기 힘든 테스트
  - 지나치게 큰 테스트
  - 하나의 테스트 케이스에서 둘 이상을 수행하는 테스트
  - 클래스 api에 대해 개별 형태를 확인하는 것이 아닌 함수마다 공격을 하는 테스트
  - 직접 작성하지 않은 서드파티 코드에 대한 테스트
  - 클래스의 주요 기능이나 행태에 대해 실제로 테스트를 하지 않는데다 별다른 필요없는 테스트들로 상황을 숨기는 테스트
  - 지나치게 상세하여 중구난방인 테스트
  - 단 하나의 머신에서만 수행 가능한 테스트



## 테스트는 어떠해야 하는가

- 일반적으로 각 테스트에는 몇가지 준비 과정이 필요하고 준비가되면 실제 실행. 마지막으로 실행 결과를 검증함
- arrange-act-assert 패턴 <= given-when-then



### 테스트 이름

- 하나의 기능 검증에 집중하는 테스트에는 명확한 이름이 붙어 있어서 간단한 문장처럼 읽힘
- 테스트 케이스의 이름을 간단히 붙일 수 없다면 요구사항이 모호하거나 혹은 여러가지를 한꺼번에 테스트하려는 것일 수 있음
- 테스트들이 코드에 대한 명세 사항으로서 읽힌다고 가정할것
- 테스트의 이름을 굳이 구현 코드와 같은 형식으로 지을 필요는 없음



## 테스트 구조

- 테스트가 코드의 중요 기능을 모두 다룬점을 보장하라
- 테스트는 중복해서 수행하지 않음
- 각 테스트 케이스는 하나의 정의만을 검증해야함



### 테스트 유지 보수

- 테스트 코드도 유지보수할 것
- 테스트를 막아버리고 도망쳐서는 안됨. 서두르는 과정에서 세심하지 못하면 결국 뒷통수맞음



### 테스트 프레임워크 고르기

- 너무 복잡하거나 기능이 많을 필요는 없고 거추장스러운 도구는 고르지 않는 편이 나음
- 그냥 assert 함수 를 사용해도 된다는 점을 기억할것



## 어떤 코드도 혼자가 아니다

- 글로별 변수나 싱글턴 객체는 신뢰할만한 테스트에 대한 저주와 같음. 숨겨진 의존성이 있다면 하나의 유닛을 쉽게 테스트할 수 없음
- 하나의 클래스와 상호 작동하는 객체들은 생성자의 매개 변수로서 전달되어야함. 상위로부터의 매개 변수화
- 클래스와 상호 작동하는 객체들의 자료형에 대해 직접적으로 의존하기보다 객체들이 특정 인터페이스를 통해 간접적으로 연결됨으로써, 클래스와 객체들 간의 상호 작동에 대한 테스트를 수행할 수 있음
- 특정 상호 작동을 정의하는 인터페이스를 최소화하는 훌륭한 일례로서, 작동이 전체 클래스에 의존하기보다 간단한 인터페이스에 의존하도록 할 수 있음
- 테스트 대역의 일반적인 형태

**견본(Dummies)**

- 견본 객체는 보통 빈껍데기. 테스트에서 견본을 실행하지는 않지만 인자 목록을 채우기 위해 필요함

**짝(Stubs)**

- 짝 객체는 인터페이스의 단순화된 구현체로서, 미리 정의된 응답을 반환하고 자신에 대한 호출과 관련된 정보를 저장하곤함

**모조(Mocks)**

- 목 객체를 적절히 사용하면 테스트가 더 간단하고 쉬워짐
- 너무 많은 목 객체들을 복합적으로 사용하여 테스트가 엉켜버리면 문제를 파악하기 어렵고 유지보수도 쉽지 않음





## 마치며

- 테스트는 코드 작성에 도움을 줌. 테스트를 통해 좋은 코드를 작성할 수 있고 코드의 품질을 유지할 수 있음.
- 테스트를 통해 코드의 설계를 개선할 수 있고 코드가 구현하는 기능을 어떻게 사용할지 문서화할 수 있음
- 하지만 소프트웨어 개발 과정에서 발생하는 모든 문제를 해결할 수는 없음
- 어떤 테스트도 오나벽하지는 않지만, 테스트의 존재를 통해 작성중인 코드나 유지보수하는 코드에 대한 확신을 키울 수는 있음
- 반드시 테스트할것!





# 복잡도 다루기



## 블럽

- 소프트웨어 복잡도에서 고려해야 할 첫번째 요소, 즉 컴포넌트는 블럽과 관련이 있음
- 블럽의 크기와 수가 복잡도를 결정함
- 문제는 코드를 어떻게 구성하는가 하는 점, 크기를 어떻게 배분할지에 대한 문제
- 거대한 덩어리보다 작고 수많은 일을 잘 해내는 응집도가 높은 클래스를 선호
- 되도록이면 하나의 일만 처리하도록



## 케이스 스터디 : 블럽 복잡도 줄이기

## 라인

- 더많은 블럽들을 추가하고 그 블럽들 사이에 연결을 추가하면서 더욱 복잡한 시스템을 만드는것.
- 객체들이 상호 종속적 관계일 경우, 구들의 구조는 융통성이 없고 쉽게 변하지도 않으며 작업하기도 어려움





## 마지막 요소, 사람

- 소프트웨어의 복잡도는 블럽과 라인의 구조에 따라 달라짐
- 책임은 코드를 작성하는 사람에게 있음
- 복잡도를 줄일 수 있는 유일한 방법은 소프트웨어에 책임감을 가지고, 업무 압박으로 인해 적절하지 않은 구조로 코드를 밀어넣는 상황을 피하고자 노력하는 것



## 마치며

- 복잡도는 블럽과 라인에서 비롯되지만 대부분은 소프트웨어를 만든 사람이 그원인임





# 두 개의 시스템에 대한 이야기

- 직접적인 경험이야 말로 가장 위대한 선생이지만, 다른 사람들의 경험도 꽤 괜찮은 선생이 될 수 있음



## 지저분한 대도시

- 소프트웨어는 건강하지 못한 회사 구조와 개발 절차로 인해 잘못 설계될 수 있음

### 이해 불가

- 소프트웨어 설계의 품질을 유지보수해야함. 나쁜 설계는 더 나쁜 설계를 불러들임 



### 응집도의 부족

- 개발팀의 작업자들 간의 관계가 얼마나 건강하지는 소프트웨어 설계의 품질에 직접적 영향을 끼침. 부적절한 관계와 자만심은 잘못된 소프트웨어를 만듦



> **응집도와 결합도**
>
> - 강력한 응집도: 응집도는 기능적으로 연관된 것끼리 얼마나 모여 있고 하나의 모듈 내에서 내부 부분들이 얼마나 유기적으로 작동하는지에 대한 척도임. 응집도는 모듈을 단단하게 뭉쳐 놓는 접착제에 비유할 수 있음. 한편 빈약한 응집도를 가진 모듈은 잘못된 기능 분해의 징후임. 각 모듈은 명확하게 정의된 역할을 가져야 하며, 관련 없는 기능을 마구잡이로 모아 놓은 덩어리여서는 안됨
> - 느슨한 결합도: 결합도는 모듈 상호 간의 의존성에 대한 지표임. 서로 얼마나 얼기설기 엮여 있는가에 대한 것임. 간결한 설계에서는 모듈 간 결합도가 낮아 상호 독립적임. 물론 모듈들이 완전히 독립적일 수는 없고, 완전히 독자적으로 작동한다는 건 말이 되지 않음. 상호 작용하는 모듈들은 직접적 혹은 간접적으로 서로에 대해 의존성을 가짐. 하나의 모듈은 다른 모듈의 함수를 호출할 수 있고, 다른 모듈에 의해 하나의 모듈 내 함수가 호출될 수 있음. 웹 서비스를 사용하거나 다른 모듈에 의해 공개된 기능을 이용할 수도 있음. 아니면 다른 모듈의 자료형을 사용하거나 어떤 데이터를 공유할 수도 있음. 여기서 데이터란 변수나 파일 같은것



### 불필요한 결합

- 좋은 설계는 상호 연결 구조나 컴포넌트 간 연결의 분량을 검토함.
- 시스템의 개별 부분은 단독으로 작동할 수 있어야 함. 밀착 결합은 테스트를 하기 어렵게 만듦



### 코드 문제

- 나쁜 설계로 인한 문제는 코드에 까지 영향을 미침
- 방만하고 명확하지 않은 구조는 각가의 컴포넌트가 잘못 작성되고 서로 들어맞지 않는 결과를 낳음. 코드 본제와 반복된 작업 또한 가져옴



### 코드 외부 문제

- 신규 직원들이 힘들어함
- 유지보수 힘듦
- 지원 엔지니어도 힘들어함
- 서드 파티 엔지니어들도 힘들어함
- 회사 전반적으로 모든팀들과 안좋아짐



### 대도시로부터의 엽서

- 지저분한 대도시의 설계는 거의 돌이킬 수 없었음
- 나쁜 설계로 회사 자체가 힘들어짐



## 디자인 타운

- 디자인타운은 잘 짜여진 프로젝트임

### 기능 위치 선정

#### 일관성

- 명확한 구조 설계를 통해 일관된 시스템을 구성할 수 있음. 모든 설계 결정은 전체 구조 설계의 관점에서 수행해야함
- 명확한 구조를 통해 기능 복제를 줄일 수 있음



### 구조 확장

- 소프트웨어의 구조는 불변의 것이 아님. 필요하다면 변경할 것. 변경 가능하게 만들려면 구조를 간결하게 유지해야함



### 설계 관련 결정 연기하기

- Don't do anything if You Aren't Going to Need It!
- 필요하지 않다면 아무것도 하지 말라!
- 발생할 수 이쓴ㄴ 가장 나쁜 상황 중 하나는 아직 모르는 것을 설계하는 경우
- 필요해질때까지 설계상의 결정을 미룰것. 요구사항을 파악하기 전까지 구조 설계를 하지 말라. 추측하지 말라.



### 품질 유지

- 설계 품질을 반드시 유지해야함. 이는 개발자들이 의무감을 가지고 진지하게 대할 때에만 가능



### 기술 부채 관리

- 기술 부채는 리팩토링이나 설계 조정의 지연, 다음 업데이트까지 라이브러리나 빌드 도구의 업데이트를 미루는 것. 합리화
- 의식적으로 기술 부채를 다룬다면 개발팀에게는 강력한 무기가 될 수 있음 부채가 쌓이지 않도록 하되 항상 그것을 가시화하라.
- 실제 부채처럼 최대한 빨리 갚아서 과도한 이자와 비용이 들지 않도록 하라 <= 굿 ..



### 설계 방향을 잡는 테스트

- 유닛테스트, 통합테스트, 인수테스트가 되어있는 프로젝트는 어떤것도 망가뜨릴 걱정 없이 소프트웨어를 변경할 수 있음
- 훌륭한 자동화 테스트를 시스템에 적용하면 최소한의 위험만으로 근본적인 구조 변경을 수행할 수 있음. 이는 작엽에 여유를 보장해줌
- 유닛 테스트를 작성함으로써, 각 모듈이 내부적으로는 응집도가 높으면서도 시스템의 나머지 부분과는 결합도가 낮도록 만들 수 있음



### 설계를 위한 시간

- 좋은 프로젝트 계획을 통해 훌륭한 설계를 얻을 수 있음. 구조적인 완성은 순식간에 만들어낼 수 없으며 충분한 시간을 들여야만 함.



### 설계를 가지고 작업하기

- 팀 구성은 작성하는 코드에 피할 수 없는 영향을 미침. 시간이 지나면 반대로 소프트웨어의 구조가 팀이 일을 얼마나 잘하는지에 영향을 줌
- 팀이 분열되어 있다면 코드도 어색하게 엮임 반면 팀이 서로 긴밀하게 작업한다면 구조 역시 적절히 통합됨





## 마치며

- 구조가 소프트웨어 프로젝트에 얼마나 심대한 영향을 끼치는지 알아야함
- 좋은 소프트웨어 구조는 프로젝트 참여자들에게 번영과 성공을 가져올 수 있음
- 좋은 구조는 다음과 같은 요소들의 산물
  - 코드 작성에 앞서 계획적으로 설계하기: 많은 프로젝트가 일을 시작하기도 전에 이 과정에서실패함. 적절한 긴장감이 필요함 알맞게 설계!
  - 설계자들의 역량과 경험; 약간의 실수를 미리 경험해두면 이후 적절한 결정을 내릴 수 있음. 
  - 개발 진행에 맞춰 설계 명확하게 유지하기
  - 소프트웨어의 전체 설계에 대한 책임감을 팀 단위로 모두에게 지우기
  - 설계 변경을 두려워하지 않기: 변하지 않는 것은 없음
  - 적절한 구성원으로 팀 짜기: 디자이너, 프로그래머, 관리자... 건전한 업무 관계는 코드 구조에 영향을 미침
  - 적절한 시점에 설계에 대해 결정하기: 아직 만들 수 없다면 설게에 대한 결정 미루
  - 적절한 프로젝트의 관리와 적절한 일정






# 소프트웨어 개발이란



## 소프트웨어(음식) 성분

- 양심적인 소프트웨어 개발자로서, 우리는 적절한 방식으로 적절한 제품을 작성하길 갈망해야 함.
- 훌륭한 프로그래머의 주요 특징 중 하나는 작성한 소프트웨어와 그 작성법에 대해 진슴으로 주의를 기울이는것



## 소프트웨어 개발은 예술이다

- 뛰어난 코드를 작성하고자 하는 프로그래머는 좋은 취향과 미적 감각을 지녀야함
- 창조적: 상성력이 필요함. 소프트웨어는 능숙하게 구축하고 정확하게 설계해야함. 프로그래머는 자신이 만들고자 하는 코드에 대한 비전, 그리고 만드는 방법에 대한 계획이 있어야함.
- 미학적: 좋은 코드의 특징은 우아함, 아름다움, 그리고 균형에서 찾을 수 있음. 
- 기계적, 수동적: 예술가에 비유하자면, 지정된 매개물을 가지고 지정된 도구와 절차, 기법으로 작업하는 것이나 마찬가지
- 팀기반: 수많은 형태의 예쑬은 한 사람이 아닌 여러 사람의 노고에서 비롯된 결과물.



## 소프트웨어 개발은 과학이다

- 엄격함: 좋은 소프트웨어는 정확하고, 입증되고, 측정되고, 실험되며, 검증되어야함. 좋은 테스트가 있어야함
- 체계화: 계획을 세우고 설계를 하며, 예산 계획은 세우고 체계적으로 구성할 필요가 있음
- 통찰력: 소프트웨어 개발에는 지적 노력과 더불어 기민한 분석력이 필요함



## 소프트웨어 개발은 스포츠다

- 팀워크: 서로 다른 기술을 보유한 채 한데 어우러지는 많은 사람의 협업이 필요함
- 훈련: 각 구성원은 자신의 팀에 전념해야 하고 기꺼이 최선을 다해야함
- 규칙: 일련의 규칙과 특정 팀 문화를 기반으로 개발을 진행함



## 소프트웨어 개발은 아이들 놀이다

- 학습: 겸손, 자신이 모든것을 알고 있다는 사람은 협업하기 힘듦. 더 나아지기를 원한다면 더 배워야 함을 깨달아야함. 아는것과 모르는 것을 받아들이고 새로운 것을 배우고 찾는 것을 즐길것
- 단순함: 끊임없이 질문해야함. 지금 무엇을 하고 있는지, 그렇게 하는 이유는 무엇인지에 대한 질문을 해야함. 
- 즐기기:



## 소프트웨어 개발은 집안일이다

- 청소하기: 문제를 찾아내 해결해야 함. 넘기지말고 책임져야함
- 보이지 않는 곳에서 작업하기: 청소부는 각광받으면서 일하지 않음
- 유지보수: 죽은 코드를 제거하고, 망가진 코드를 수정함



## 은유 과부하



## 마치며









