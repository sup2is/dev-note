

# Clean Architecture



# 1부 소개

- 동작하는 프로그램을 만들기 쉽지만 제대로, 올바르게 만들기는 어려움
- 제대로된 소프트웨어를 만들면 아주 적은 인력만으로도 새로운 기능을 추가하거나 유지보수를 추가할 수 있음. 변경은 단순해지고 빠르게 반영할 수 있음

## #1 설계와 아키텍처란?

- 설계와 아키텍처 둘 사이에는 아무런 차이가 없음.
- 소프트웨어 설계에서 저수준의 세부사항과 고수준의 구조는 모두 고스프트웨어 전체 설계 구성 요소임

### 목표는?

- 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는데 있음
- 새로운 기능을 출시할 때마다 비용이 증가한다면 나쁜 설계



### 사례 연구

- 인력은 늘어가지만 개발의 생산성은 점점 떨어지는 현상이 나타나는 A사의 이야기

**엉망진창이 되어가는 신호**

- 개발자의 노력은 기능 개발보다는 엉망이 된 상황에 대처하는 데 소모됨

**경영자의 시각**

- 생산성은 그대로인데 인건비는 지속적으로 늘어나서 얻는게 없어짐

**무엇이 잘못되었나?**

-  토끼가 자신의 빠르기를 과신한 것과 마찬가지로 개발자도 생산성을 유지할 수 있다고 자신의 능력을 과신함. 하지만 엉망진창인 코드가 서서히 쌓이면 개발자 생산성은 차츰낮아지고 절대 멈추거나 수그러들지 않음
- 엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다는게 팩트임
- 빨리가는 유일한 방법은 제대로 가는 것
- 생산성이 감소되고 비용이 증가하는 현상을 되돌릴 수 있는 유일한 방법은 개발자로 하여금 토끼처럼 과신하려는 믿음을 버리고, 만들어 낸 엉망진창인 코드를 개발자가 책임지도록 하는 것 뿐
- 자신을 과신한다면 재설계하더라도 원래의 프로젝트와 똑같이 엉망으로 내몰림



### 결론

- 개발조직이 할 수 있는 최고의 선택지는 과신하지 않고 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것
- 비용은 최소화하고 생산성은 최대화할 수 있는 설계와 아키텍처를 가진 시스템을 만들려면 이러한 결과로 이끌어줄 시스템 아키텍처가 지닌 속성을 알고 있어야함





## #2 두 가지 가치에 대한 이야기

- 모든 소프트웨어 시스템은 이해관계자에게 행위와 구조라는 두가지 가치를 제공함
- 개발자는 두 가치를 모두 반드시 높게 유지해야하는 책임을 짐

### 행위

- 이해관계자는 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해 프로그래머를 고용함
- 프로그래머는 기계가 요구사항을 만족하고 문제가 있으면 디버깅함 이것을 행위라부름
- 많은 프로그래머가 이러한 활동이 자신이 해야 할 일의 전부라고 생각하지만 잘못된 생각임

### 아키텍처

- 소프트웨어를 만든 이유는 기계의 행위를 쉽게 변경할 수 있도록 하기 위해서임
- 소프트웨어는 반드시 변경하기 쉬워야함
- 소프트웨어 개발 비용의 증가를 결정짓는 주된 요인은 바로 이 변경사항의 범위와 형태에 있음
- 변경하기 어려운 문제는 아키텍처, 아키텍처는 형태에 독립적이어야하고 그럴수록 더 실용적임

### 더 높은 가치

- 위에서 말한 행위(기능)과 아키텍처는 둘 다 중요함
- 극단적으로 놓고 봤을때 똑바로 동작하지만 변경이 불가능한 프로그램과 제대로 동작하지 않지만 변경하기 쉬운 프로그램 중 후자가 나을 수 있음

### 아이젠하워 매트릭스

| **중요하고 긴급한일**    | **중요하지만 긴급하지 않은일**    |
| ------------------------ | --------------------------------- |
| **중요하지 않고 긴급한** | **중요하지 않고 긴급하지 않은일** |

- 소프트웨어의 첫 번째 가치인 행위는 긴급하지만 매번 높은 중요도를 가지는 것은 아님
- 소프트웨어의 두 번째 가치인 아키텍처는 중요하지만 즉각적인 긴급성을 필요로 하는 경우는 절대 없음
- 우선순위
  - 긴급하고 중요한일 (아키텍처, 행위)
  - 긴급하지는 않지만 중요한 일 (아키텍처)
  - 긴급하지만 중요하지 않은 일 (행위)
  - 긴급하지도 않고 중요하지도 않은 일
- 업무 관리자와 개발자가 흔하게 저지르는 실수는 긴급하지만 중요하지 않은 기능과 긴급하면서 중요한 기능을 구분하지 못함
- 기능의 긴급성이 아닌 아키텍처의 중요성을 설득하는 일은 소프트웨어 개발팀이 마땅히 책임져야함



### 아키텍처를 위해 투쟁하라

- 개발팀은 회사에서 가장 중요하다고 스스로 믿는 가치를 위해 항상 투쟁해야함
- 소프트웨어를 안전하게 보호해야 할 책임이 있으므로 소프트웨어 개발팀들도 이해관계자임을 명심할것
- 소프트웨어 아키텍트는 시스템이 제공하는 특성이나 기능보다 시스템 구조에 더 중점을 둬서 기능 개발하기 쉽고 간편하게 수정이 가능하며 확장하기 쉬운 아키텍처를 만들어야함
- 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해짐. 이런 결과는 소프트웨어 개발팀의 투쟁이 충분하지 않았다는 결과





# 2부 벽돌부터 시작하기: 프로그래밍 패러다임

## #3 패러다임 개요

### 구조적 프로그래밍

- 구조적 프로그래밍은 다익스트라가 발견함
- 구조적 프로그래밍 패러다임은 아래와 같이 요약할 수 있음
  - **구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.**

### 객체지향 프로그래밍

- 요한 달과 크리스텐 니가드에 의해 등장
- 객체지향 프로그래밍 패러다임은 아래와 같이 요약할 수 있음
  - **객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.**

### 함수형 프로그래밍

- 알론조 처치가 람다 계산법을 발명했음
- 람다계산법
  - 기초가 되는 개념은 불변성으로, 심볼의 값이 변경되지 않는다는 개념
- 함수형 프로그래밍 패러다임은 아래와 같이 요약할 수 있음
  - **함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.**

### 생각할 거리

- 각 패러다임은 프로그래머에게서 권한을 박탈함. 즉 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안되는지를 말해줌

### 결론

- 세가지 패러다임은 모두 아키텍처와 연관이 있음
- 세 가지 패러다임과 아키텍처의 세가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목할 것



## #4 구조적 프로그래밍

### 증명

- 다익스트라, 뵘, 야코피니가 모든 프로그램은 goto 없이 순차, 분기, 반복이라는 세가지 구조만으로 표현할 수 있다는 사실을 증명했음

### 해로운 성명서

- 다익스트라가 "goto문의 해로움" 이라는 편지를 출판사에 보내고 10년동안 논쟁후 다익스트라가 승리함
- 그로인해 대다수의 현대적언어는 goto 문장을 포함하지 않음
- 현재의 우리는 모두 구조적프로그래머임. 제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않음

### 기능적 분해

- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있었고 이는 결국 모둘

### 엄밀한 증명은 없었다

### 과학이 구출하다

- 수학은 증명 가능한 서술이 참임을 입증하는 원리이고 과학은 증명 가능한 서술이 거짓임을 입증하는 원리임

### 테스트

- "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다" - 다익스트라
- 소프트웨어 구조는 수학적인 구조가 아닌 과학적 구조.
- 제약 없는 goto문은 테스트를 아무리 많이 수행하더라도 절대 올바르다고 볼 수 없음
- 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요하고 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도함. 만약 거짓임을 증명하려는 테스트가 실패한다면 이 기능들은 목표에 부합할만큼 충분히 참이라고 여기게됨

### 결론

- 구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어낼 수 있기 때문임
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 테스트하기 쉽도록 만들기 위해 분주히 노력해야함



## #5 객체 지향 프로그래밍

- 좋은 아키텍처를 만드는 일은 객체지향 설계 원칙을 이해하고 응용하는데서 출발함

### 캡슐화?

- 캡슐화는 테이터와 함수가 응집력있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있음
- C언어에서 완벽한 캡슐화를 지원했지만 시간이 지나면서 언어 자체에서 캡슐화를 거의 강제하지 않게되었음

### 상속?

- 상속이라는 개념이 있기 이전에도 상속과 비슷하게 사용하는 방법이 C++에 있었음

### 다형성?

- 기존에 함수를 가리키는 포인터를 응용한 것이 다형성임 하지만 함수 포인터를 사용하는 방식은 위험하고 지켜야할 관례가 많았음
- 객체지향 언어는 이러한 관례를 없애주고 실수할 위험이 없음

**다형성이 가진 힘**

- 프로그램은 장치에 독립적이어야함. 플러그인 아키텍처는 입출력 장치 독립성을 지원하기 위해 만들어졌고 등장 이후 거의 모든 운영체제에서 구현되었음

**의존성 역전**

- 다형성을 사용하지 않는다면 제어흐름은 시스템의 행위에 따라 결정되고 소스코드 의존성도 제어 흐름에 따라 결정됨
- 인터페이스를 사용하는 방식으로 의존성 역전을 구현할 수 있음
- 객체지향 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 가짐. 즉 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않음. 호출하는 모듈이든 아니면 호출 받는 모듈이든 관계 없이 소프트웨어 아키텍트는 소스코드 의존성을 원하는 방향으로 설정할 수 있음
- 배포 단위들의 의존성 역시 소스 코드 사이의 의존성과 동일하기 때문에 이들 컴포넌트는 개별적이며 독립적으로 배포가 가능해짐 특정 컴포넌트의 소스 코드가 변경되면 해당 코드가 포함된 컴포넌트만 다시 배포하면 됨. 이것이 바로 배포 독립성임
- 시스템의 모듈을 독립적으로 배포할 수 있게 되면 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있음. 이것이 개발 독립성임



### 결론

- 객체지향 프로그래밍은 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력임
- 다형성을 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있음
- 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있음



## #6 함수형 프로그래밍

- 함수형 패러다임에서 핵심이 되는 기반은 람다 계산법으로 알론조 처치가 1930년대에 발명했음

### 정수를 제곱하기

- 자바의 0부터 25까지 정수 제곱을 출력하는 프로그램

```java
public class Squint {
  public static void main(String args[]) {
    for (int i = 0; i < 25; i ++) {
      System.out.println(i * i);
    }
  }
}
```

- LISP에서 클로저를 이용하는 프로그램

```lisp
(println (take 25 (map (fn [x] (* x x)) (range))))
```

- 가장 안쪽부터 호출 함수 설명
  - range함수는 0부터 시작해서 끝이 없는 정수 리스트를 반환
  - 반환된 정수 리스트는 map 함수로 전달되고, 각 정수에 대해 제곱을 계싼하는 익명 함수를 호출하여, 모든 정수의 제곱에 대해 끝이 없는 리스트를 생성
  - 제곱된 리스트는 take 함수로 전달되고, 이 함수는 앞의 25개까지의 항목으로 구성된 새로운 리스트를 반환
  - println함수는 입력 값을 출력하는데 이 경우 입력은 앞의 25개의 정수에 대한 제곱 값으로 구성된 리스트
- 끝이 없는 리스트라고 표현했지만 실제로 접근하기 전까지는 생성하지 않음



- 자바에서는 가변 변수를 사용하지만 클로저 프로그램에서는 불변 변수만 사용함
- 함수형 언어에서 변수는 변경되지 않음

### 불변성과 아키텍처

- race condition, deadlock, concurrent update 문제는 모두 가변 변수로 인해 발생함
- 만약 어떠한 변수도 갱신되지 않는다면 race condition, concurrent update 은 일어나지 않고 lock도 가변이 아니라면 deadlock이 일어나지 않음
- 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변변수가 없다면 절대로 생기지 않음
- 아키텍트라면 동시성 문제에 지대한 관심을 가져야만 함
- 불변성은 저장 공간이 무한하고 프로세서의 속도가 무한히 빠를때 실현 가능함. 만약 아니라면 어느정도 타협을해서 불변성을 실현할 수 있음

### 가변성의 분리

- 불변성과 관련해서 가장 주요한 타협중 하나는 서비스 내부의 가변 컴포넌트와 불변 컴포넌트로 분리하는 일임
- 불변 컴포넌트는 가변 변수를 사용하지 않고 1개 이상의 다른 컴포넌트와 서로 통신함
- 상태변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로 흔히 트랜잭션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호함

> 트랜잭션 메모리
>
> **트랜잭셔널 메모리**(transactional memory)는 불러오기와 저장하기 명령의 집합이 [원자적](https://ko.wikipedia.org/wiki/원자성) 방법으로 실행할 수 있게 함으로써 [병행성 프로그래밍](https://ko.wikipedia.org/wiki/병행성_프로그래밍)을 단순하게 하는 방식이다. [병행 컴퓨팅](https://ko.wikipedia.org/wiki/병행_컴퓨팅)에서 [공유 메모리](https://ko.wikipedia.org/wiki/공유_메모리)로의 접근을 제어하기 위한 병행성 제어 방식으로, [데이터베이스 트랜잭션](https://ko.wikipedia.org/wiki/데이터베이스_트랜잭션)과 유사한 [동시성 제어](https://ko.wikipedia.org/w/index.php?title=동시성_제어&action=edit&redlink=1) 구조이다.
>
> [https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%94%EB%84%90_%EB%A9%94%EB%AA%A8%EB%A6%AC](https://ko.wikipedia.org/wiki/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%94%EB%84%90_%EB%A9%94%EB%AA%A8%EB%A6%AC)
>
> 예제
>
> ```
> // 이중 연결 리스트에 새 노드를 원자적으로 추가함
> atomic {
>     newNode->prev = node;
>     newNode->next = node->next;
>     node->next->prev = newNode;
>     node->next = newNode;
> }
> ```
>
> **atomic**(원자적)으로 표시된 구역이 끝나면 트랜잭션이 완료된다. 이때 충돌이 없었다면 커밋되고, 있었다면 재시작될것이다. 임계 구역 문법은 또한 종료 조건을 명시할 수도 있다.
>
> [https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%94%EB%84%90_%EB%A9%94%EB%AA%A8%EB%A6%AC](https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%94%EB%84%90_%EB%A9%94%EB%AA%A8%EB%A6%AC)

- 불변, 가변 컴포넌트를 분리하고 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야함
- 현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야함



### 이벤트 소싱

- 이벤트 소싱에 깔려 있는 기본 발상은 상태가 아닌 트랜잭션을 저장하자는 전략임. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리하면됨
  - 고객 잔고를 관리하는 은행 애플리케이션의 경우 상태가아닌 계좌의 모든 트랜잭션을 저장(write)하고 특정 고객이 잔고를 요청할때마다 저장한 트랜잭션을 모두 처리(read)하면 해당 고객의 잔고를 알 수 있음. but 무한한 저장공간과 무한한 처리능력이 있어야하기 때문에 이런 방식은 불가능함
- 결과적으로 애플리케이션은 CRUD가 아니라 C or R로만 이루어짐 변경과 삭제가 없다면 동시성 문제가 일어나지 않음

> git의 commit은 불변임 --amend나 rebase로 커밋을 수정하거나 합치는것처럼 보일 수 있지만 git reflog로 확인해보면 실제로 커밋을 수정하는 것이 아닌 새로운 commit을 만들어내는 것을 확인할 수 있음
>
> [https://wiki.emulab.net/wiki/everything-you-need-to-unlearn-about-git](https://wiki.emulab.net/wiki/everything-you-need-to-unlearn-about-git)
>
> [https://blog.jayway.com/2013/03/03/git-is-a-purely-functional-data-structure/](https://blog.jayway.com/2013/03/03/git-is-a-purely-functional-data-structure/)

### 결론

- 2부 요약
  - 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율
  - 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율
  - 함수형 프로그래밍은 변수 할당에 부과되는 규율
- 각 패러다임은 코드를 작성하는 방식의 형태를 한정시킴
- 지난 반 세기동안 우리가 배운것은 해서는 안되는 것에 대해서임.
- 소프트웨어는 순차, 분기, 반복, 참조로만 구성됨



# 3부 설계 원칙

## #7장 SRP: 단일 책임 원칙

### 징후 1: 우발적 중복

### 징후 2: 병합

### 해결책

### 결론



## #8 OCP: 개방-폐쇄 원칙

### 사고 실험

### 방향성 제어

### 정보 은닉

### 결론



## #9 LSP: 리스코프 치환 원칙

###  상속을 사용하도록 가이드하기

### 정사각형/직사각형 문제

### LSP와 아키텍처

### LSP위배 사례

### 결론



## #10 ISP: 인터페이스 분리 원칙

### ISP와 언어

### ISP와 아키텍처

### 결론



## #11 DIP: 의존성 역전 원칙

### 안정된 추상화 

### 팩토리

### 구체 컴포넌트

### 결론









