



# Blocking vs Non-Blocking

- 호출되는 함수가 바로 리턴하느냐 마냐가 관심사
- 호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고 호출한 함수가 다른일을 할 수 있는 기회를 줄 수 있으면 non blocking
- 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 blocking



# Synchronous/ Asynchronous

- 호출되는 함수의 작업 완료 여부를 누가 신경쓰냐가 관심사
- 호출되는 함수에게 callback을 전달해서, 호출되는 함수의 작업이 완료되면 호출되는 함수가 전달받은 callback을 실행하고, 호출하는 함수는 작업 완료 여부를 신경쓰지 않으면 async
- 호출하는 함수가 호출되는 함수의 작업 완료후 리턴을 기다리거나 또는 호출되는 함수로부터 바로 리턴 받더라도 작업 완료 여부를 호출하는 함수 스스로 계혹 확인하며 신경쓰면 sync
=======
# SOAP와 REST의 차이



# 테스트 코드란?

- 테스트코드는 코드의 품질을 높여주고 버그에 대해 방어적일 수 있음
- 이와 관련된 개발 방법론으로 tdd가있음
- tdd는 테스트 주도 개발이라는 뜻을 갖고 있고 비지니스 로직을 작성하기 이전에 실패하는 테스트 스텁을 만든 후 테스트를 기반으로 비지니스 로직을 작성하는 개발 방법론임
- 테스트 없는 리팩터링은 불가능함



# Spring과 Spring Boot의 차이

- 과거에 Spring 개발 환경 구축에만 꽤 많은 시간이 소요 되었기때문에 이 단점을 보완하기위해서 나온 프로젝트가 spring boot
- spring boot를 사용하면 독립 실행형으로 프로덕션급의 spring 애플리케이션을 매우 손쉽게 구축할수 있음



# POJO

- Plain Old Java Object
- 말그대로 퓨어한 자바 오브젝트를 뜻함
- 과거 ejb 컨테이너에 의존하는 객체처럼 복잡하지 않고 개발자가 쓰기 편한 간단한 Object를 만들어 쓰자는 간단한 Object의 개념



# DFS, BFS

- dfs는 깁이 우선 탐색
- bfs 너비 우선 탐색
- 트리 자료구조에서 사용하는 탐색 방법
- 우리가 알고있는 in-order, preorder, post-order는 dfs의 한 방법이고
- bfs는 말그대로 같은 깊이를 가진 노드를 순차적으로 방문하는 방법





# 프로젝트 설계 내용



# 프로세스와 스레드

## 프로세스

- 프로세스는 cpu가 작업을 할당하는 단위
- 독립적이고 기본적으로 다른 프로세스의 변수나 자료구조에 접근하지 못함
- 다른 프로세스에 접근하려면 inter process communication (ipc)을 사용해야함 ex 파이프, 파일 소켓
- 기본적으로 1개 이상의 스레드를 갖고 있음

## 멀티 프로세스

- 하나의 애플리케이션에 여러 개의 프로세스를 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것
- 장점 : 여러 개의 자식 프로세스중 하나가 장애가 난다면 그 자식 프로세스만 영향이 있고 다른부분엔 영향이 없음
- 단점: context switching에서의 오버헤드
  - 프로세스는 공유할 수 있는 메모리공간이 없기 때문에 context switching이 발생하면 캐싱된 모든 데이터들을 다시 불러들어와야해서 오버헤드가 발생함

**Context Switching**

- cpu에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정을 context switching이라함

## 스레드

- 스레드는 프로세스 내에서 실행되는 작업의 단위
- 스레드는 한 프로세스 내부에서 존재하기 때문에 프로세스 내의 주소 공간 이나 자원들을 서로 공유함
- 스레드들은 각각 별도의 레지스터와 스택을 갖고 있지만 힙 메모리는 서로 읽고 쓸 수 있음
- 싱글스레드와 멀티스레드로 나뉨
- 싱글스레드는 프로세스가 하나의 작업단위만 존재하는것
- 멀티스레드는 두개이상의 작업을 처리함으로써 병렬처리의 효과를 얻을 수 있음
- 예를들어 윈도우 애플리케이션인 크롬의 경우 크롬 자체는 프로세스로 동작하지만 그 내부에 크롬 탭같은경우는 스레드로 동작함
- 따라서 크롬은 멀티 스레드임

## 멀티 스레드

- 하나의 프로세스 내부에서 두 개 이상의 스레드를 활용해서 각각의 작업을 처리하도록 하는 것
- 웹서버는 대표적인 멀티 스레드 응용 프로그램

**장점**

- 시스템 자원 소모 감소
  - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리 가능
- 시스템 처리량 증가
  - 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어듦, 스레드 사이의 작업량이 작아 context switching이 빠름
- 간단한 통신 방법으로 인한 프로그램 응답 시간 단축 
  - 스레드는 프로세는 내의 자원을 공유하기때문에 비교적 통신의 부담이 적음

**단점**

- 주의 깊은 설계가 필요함
- 디버깅이 까다로움
- 멀티 스레드의 경우 동기화 문제를 겪을 수 있음 레이스 컨디션
- 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받음

### 자바의 스레드

- 일반 스레드와 거의 차이가 없고 os가 아닌 jvm에서 관리함
- 자바에서 스레드 스케줄링은 jvm이 담당함



# PriorityQueue에 대한 설명

- 우선순위 큐
- 최소힙과 최대힙을 알아야함

## 힙

- 완전 이진트리의 일종
- 여러개의 값들 중에서 최대값이나 최소값을 가장 빠르게 찾아낼 수 있도록 만들어진 자료구조
- 힙은 일종의 반정렬 상태를 유지함
  - 큰 값이 사우이 레벨에 있고 작은 값이 하위 레벨이 있는 정도
  - 부모 노드의 키값이 자식노드보다 항상 큰 이진트리를 말함 <- 최대힙
- 힙트리에서는 중복된 값을 허용함 bst에서는 허용 x

### 최대힙

- 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진트리

### 최소힙

- 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진트리

## 힙 구현

- 힙을 저장하는 표준적인 자료구조는 배열임
- 구현을 쉽게 하기 위하여 배열의 첫번째 인덱스인 0은 사용하지 않음
- 힙에서의 부모 노드와 자식 노드의 관계
  - 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
  - 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1
  - 부모의 인덱스 = (자식의 인덱스) / 2

```java
/* 최대힙 삭제 */
int delete_max_heap(){
if (heapSize == 0) // 배열이 빈 경우
  return 0;

int item = maxHeap[1]; // 루트 노드의 값을 저장한다.
maxHeap[1] = maxHeap[heapSize]; // 마지막 노드의 값을 루트 노드에 둔다.
maxHeap[heapSize--] = 0; // 힙 크기를 하나 줄이고 마지막 노드를 0으로 초기화한다.

for (int i=1; i*2<=heapSize;) {
  // 마지막 노드가 왼쪽 노드와 오른쪽 노드보다 크면 반복문을 나간다.
  if (maxHeap[i] > maxHeap[i*2] && maxHeap[i] > maxHeap[i*2+1]) {
    break;
  }
  // 왼쪽 노드가 더 큰 경우, 왼쪽 노드와 마지막 노드를 swap
  else if (maxHeap[i*2] > maxHeap[i*2+1]) {
    swap(i, i*2);
    i = i*2;
  }
  // 오른쪽 노드가 더 큰 경우, 오른쪽 노드와 마지막 노드를 swap
  else {
    swap(i, i*2+1);
    i = i*2+1;
  }
}
return item;
}
https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html
```



# SQL 인젝션 방어 코드

## sql 인젝션 방어 코드

- 코드인젝션의 한 기법
- 클라이언트의 입력값을 조작하여 서버의 데이터베이스를 공격하는 방식

## 방어방법

- 유저에게 받은 값을 직접적으로 쿼리에 담아서 보내면 안됨
- 예를들어 db 매핑 라이브러리인 마이바티스의 경우 파라미터 바인딩에서 #과 $를 사용할 수 있는데
- #의 경우 sql로 변환시 파라미터로 동작하는데 $를 사용할 경우 바로 출력되기때문에 추가적인 sql을 전송할 수 있는 여력이 있음



# 스프링 MVC

- model, view, controller의 약자
- 웹 애플리케이션에서는 model, view, controller라는 추상적인 계층 만들어서 레이어드시켜놓음
- 이런식으로 관리하면 유지보수를 극대화시킬 수 있기 때문임
- model은 데이터 계층, 리포지터리 계층에서 동작하며 실제로 db액세스와 관련된 데이터 crud에 해당하는 역할을 함 
- view는 유저에게 응답할 수 있는 화면을 나타내고 화면의 렌더링, 데이터를 어떤식으로 표출할지에 대한 방법을 담당함
- controller는 http에서 요청 또는 응답에 해당하는 부분을 담당함



# 디스패처 서블릿이란?

- 서블릿 컨테이너에서 http 프로토콜을 통해 들어오는 모든 요청을 프레젠테이션 계층의 제일 앞에 둬서 중앙집중형으로 처리해주는 프론트 컨트롤러 
- spring에서 정의함

# 서블릿 컨테이너란?

- 서블릿 컨테이너는 개발자가 웹서버와 통신하기 위하여 소켓을 생성하고 특정 포트에 리스닝하는 등의 복잡한 일들을 처리해주는 컨테이너
- 웹 클라이언트로부터 http 요청이 전달되면 해당 http요청을 해석함
- 컨테이너는 servlet의 라이프사이클을 관리해줌 서블릿 컨테이너는 요청이들어올때마다 새로운 자바 스레드를 만듦
- 대표적인 servlet container는 tomcat 



# VO와 DAO+ DTO

## ValueObject

- 말그대로 값 객체임

## Data Access Object

- 데이터 계층에 엑세스하는 오브젝트

## Data Transfer Object

- 데이터의 전송 과정에 있어서 사용하는 1회성 객체
- 나같은 경우엔 주로 request나 response에 dto 객체를 많이 사용함

# 알고있는 정렬 알고리즘과 그 중에 좋아하는 정렬 알고리즘-> 퀵소트 머지소트 힙소트

- 버블소트 On2
- 삽입정렬 On2
- 선택정렬 On2 ~ On 성능좋으면 n차에끝남

## 퀵소트

- 퀵정렬 O n log n 최악은 On2
- 피벗의 개념이 꼭 필요함
- 분할정복

### 동작방법

1. 리스트 안에 있는 요소중에 한개의 요소를 결정함 (피벗)
2. 피벗(값)을 기준으로 피벗보다 작은 요소를 왼쪽으로 피벗보다 큰 요소들을 오른쪽으로 옮김
3. 피벗을 제외하고 왼쪽 리스트와 오른쪽 리스트를 다시 1번과 같은 방법으로 정렬 함
4. 왼쪽, 오른쪽 리스트들의 크기가 0이나 1이될 때까지 반복함

## 머지소트

- 머지소트 O n log n 
- stable함
- 분할정복

### 과정

- 리스트를 반으로 전부 나누고 분할 시킴
- 더이상 쪼개질 수 없을 때 병합하면서 리스트를 합침



## 힙소트



## stable 정렬과 unstable정렬

- 소팅을할때 같은 key값을 가진 node들의 순서가 바뀌지 않으면 stable, 만약 바뀐다면 unstable 정렬임

## stable정렬

- 버블, 삽입, 머지

## unstable정렬

- 퀵, 선택, 힙

# SOLID 원칙

## Single Responsibility Principle 단일 책임 원칙

- 소프트웨어의 설계 부품은 단 하나의 책임만을 가져야하고 변경되는 이유도 단 하나여야만 함

## Open-Closed Principle 개방 폐쇄 원칙

- 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야함
- 인터페이스를 기반으로 작성하거나 전략패턴을 사용할 것

## Liskov Substitution Principle 리스코프 치환 법칙

- 부모 클래스와 자식 클래스의 행위에는 일관성이 있어야 함 
- 객체지향 프로그래밍에서 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용해도 문제가 없어야 함

## Dependency Inversion Principle

- 의존 관계를 맺을 때 변화하기 쉬운것 보단 변화하기 어려운 것에 의존해야 함

## Interface Segregation Principle

- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 함
- 하나의 일반적인 인터페이스보다는 여러개의 구체적인 인터페이스가 나음



# 인터페이스와 추상클래스와의 차이

https://yaboong.github.io/java/2018/09/25/interface-vs-abstract-in-java8/

- 자바8에서 interface에 default 메서드를 추가할 수 있음으로써 사실 분류가 조금 더 모호해졌다고 생각함
- 추상클래스는 필드 나 메서드의 접근제어자를 public, protected, private 을 가질 수 있는 반면 인터페이스의 필드는 기본적으로 public static 임. 메서드도 기본적으로 public 을가짐
- 자바에서는 다중상속이 안되기때문에 기본적으로 추상클래스는 중첩하지 않는 이상 한개의 부모만 가질 수 있으나 인터페이스는 다중 구현이 가능함

















# 스택과 큐 설명

## 스택

- 스택은 LIFO, Last in first out 으로써 마지막에 들어온것이 가장 처음에 나가는 자료구조
- 웹브라우저 방문기록, 수식의 괄호검사 등

## 큐

- 큐는 FIFO, First in fist out 으로서 처음들어온 것이 가장 처음에 나가는 자료구죠
- 일반적인 선형 프로세스



# 톰캣은 멀티 프로세스인가  멀티 스레드인가?

- 멀티스레드임
- was로 사용하고 정적인 데이터는 apache가 더 빠름

# 아파치는 멀티 프로세스인가 멀티 스레드인가?

- 멀티스레드임
- web 서버로 사용하고 정적인 데이터 단순 html, css ,js 파일들을 제공함

# 오버라이딩 오버로딩

- 오버라이딩은 구현체 또는 상속관계에 있어서 상위 메서드를 자식메서드가 새롭게 구현하는 것을 뜻함
- 오버로딩은 메서드명은 같지만 메서드 인자의 개수나 매서드 인자의 위치에 따라 같은 메서드 명이라도 다른 인터페이스를 갖도록 해줌 ex Arrays.sort는 같은메서드명이라도 다른 인터페이스를 갖도록 해줌



# http에 대한 모든것

- tcp/ip를 사용하는 응용 프로토콜
- method는 get과 post가 있고
- get은 일반적으로 url 파라미터를 사용해서 데이터를 전송하고 정보를 조회하는 개념으로 사용함
- 반면 post는 리소스를 생성 및 변경하기위해 설계되었고  body라는 스펙을 활용해서 데이터를 전송함
- 가장 중요한 개념으로 요청과 응답이 있음
- 비연결성 프로토콜
- 서버와 클라이언트가 있음



# 알고있는 암호화 방식



# REST API에 대한 모든것

## Representitional State Transfer

- 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미함

- 모든 자원에 고유한 uri를 부여해 활용하는 방법

- rest는 http 프로토콜을 그대로 사용하기 떄문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일

- 무상태성, 캐시처리 가능, 계층화, Code-on-demand 등의 특징이 있음

- 3가지 구성 요소

  - 자원: 모든 자원은 고유한 id를 가짐
  - 행위: 자원에 대한 행위를 나타냄으로써 get, post, put, delete 등이 있음
  - 표현: 클라이언트가 서버에 요청했을때 응답, json xml 등이 있음

  

# 웹서비스에 접속할때 어떠한 from - to 에 대한 설명



- 사용자가 브라우저 탐색기에 도메인주소를를 입력하면 해당 스위치 라우터 등등 물리적인 장비를 지나서 도메인서버에 도착함
- 도메인서버는 os에 입력된 dns 서버인데 여기에서 해당 도메인에 맞는 ip를 제공받음
- 이후에 다시 물리적인 장비를 거쳐서 도착지 ip에 도착하게되면
- 웹서버나 와스서버에 도착하게되고 이후에 우리가 기본적으로 알고 있는 서블릿컨테이너가 서블릿을 생성함
- 

















# OSI 7 계층

## 물리

## 데이터

## 네트워크

## 전송

## 세션

## 표현

## 애플리케이션



# TCP / IP 4계층

osi7계층에 비해 조금 더 단순한 구조

## 네트워크 계층

- 물리적인 주소로 mac주소를 사용함
- osi 7계층에서 물리계층과 데이터링크 계층의역할을 함

## 인터넷 계층

- 통신 노드간의 ip 패킷을 전송하는 기능과 라우팅을담당

## 전송 계층

- 통신 노드간의 연결을 제어하고 신뢰 또는 비신뢰성 데이터를 전송함
- tcp udp

## 애플리케이션 계층

- 응용프로그램계층 smtp ,ftp, http 등등





# HTTPS 동작 방식

- 기본 http에 secure가 들어간 방식임
- ssl 인증서를 사용함



# TCP와 UDP

- tcp와 udp는 osi 7계층에서 전송계층에 해당하는 프로토콜임

## TCP

- 신뢰성 있는 데이터 전송

- tcp는 전이중방식을 사용하고 3way handshaking 을 통해 연결을 수립함

- 신뢰성 있는 데이터 전송을 위해 패킷 내부에 관련된 필드들이 있음 따라서 패킷의 크기가 udp 보다 큼 -> 속도에서는 udp한테 안됨

## UDP

- 비신뢰성 데이터 전송
- 비연결형 프로토콜
- 빠른 전송을 기대할 수 있으나 데이터의 순서는 신뢰할 수 없음

# nginx의 upstream

- 



# reverse proxy란 ?

- 클라이언트로부터의 요청을 받아서 적절한 웹 서버로 요청을 전송함 웹 서버는 요청을 받아서 평소처럼 처리를 하지만 응답은 클라이언트로 보내지 않고 reverse proxy로 반환 -> 반환ㄷ


# 3way hand shake


![](https://t1.daumcdn.net/cfile/tistory/99087C405C18E3CD28)

- tcp 연결수립시에 클라이언트 서버측에서 하는 행위
- syn -> syn + ack -> ack





# 4way hand shake


![](https://t1.daumcdn.net/cfile/tistory/2152353F52F1C02835)

- tcp 연결 종료시에 클라이언트 서버에서 하는 행위
- FIN -> ACK -> FIN -> ACK
=======



# 서버에 트래픽이 몰릴때 어떻게 응답속도를 개선시킬지 ?

- 병목지점을 모니터링한 후에 만약 네트워크 지연으로 인한 병목이라면 스케일 아웃을 통해서 응답속도를 개선
- 병목지점이 만약 코드, 즉 애플리케이션 단에 있는 문제라면 쿼리 최적화나 알고리즘 변경을통해 응답속도를 개선

# JAVA 8의 변경점

- 펑셔널 인터페이스를 도입하고 람다를 도입해서 별도의 익명 클래스를 생성하지 않고 메서드 몸체만 넘길 수 있는 문법을 들임
- 스트림을 도입해서 파이프라인 프로그래밍을 가능하게함
- 옵셔널
- 날짜 관련 기능
- 인터페이스 default 메서드 기능



# JVM 구조

![](https://media.vlpt.us/images/litien/post/a65da4a8-5dc4-422b-b91e-cafeafe464d3/image.png)





## runtime data area

- method 영역: 클래스 멤버 변수, 메서드 정보, 타입정보등이 생성됨
- heap 영역: 동적으로 생성된 오브젝트와 배열이 저장되느 gc의 대상이 되는 곳
- stack 영역: 지역변수 파라미터 등이 생성되고 실제 객체는 heal에 있지만 해당 레퍼런스만 stack에 있음 스레드별로 개별적인 stack을 가짐
- pc register: 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장함
- native method stack: 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역
- 

# JVM GC 동작 방식

https://johngrib.github.io/wiki/jvm-memory/



- java는 기본적으로 매니지드 언어임 메모리 관리를 jvm이 담당해서함
- 그렇다면 사용되지 않는, 더이상 참조가 null인 객체를 정리해주는애가 필요한데 그게 바로 GC임
- GC 개발자들은 모든 객체들은 대부분 생성 이후 사라진다 라는 사실을 알고 있음
- 따라서 매 순간 모든 객체들을 탐색해서 이 객체의 참조가 null인지 체크하는것은 매우 비효율적인 방식임 따라서 객체의 공간을 논리적으로 나뉘어 young generation, tenured generation으로 분리함
- young generation엔 eden영역과 두개의 survivor 영역이 있음 객체가 처음 생성될때는 eden 영역에 있고 객체가 참조될때마다 aging 시켜서 어느정도 객체가 참조되면 survivor영역으로 이동시킴
- 이런식으로 객체를 관리하는데 young generation에 지정한 메모리가 어느정도 찼을때는 minor gc를 동작시킴
- 객체가 어느정도 aging 되면 tenured 영역으로 이동되고 메모리가 어느정도 찼을때 major gc가 동작함





# GC의 종류

- serial gc: 싱글 스레드 기반으로 동작하고 아무래도 싱글 스래드인 만큼 아주 소형 애플리케이션에 적합함

- parallel gc: 멀티 스레드 기반으로 동작하고 minor gc와 major gc 옵션이 별도로 존재함 parallel gc는 기본적으로 minor gc와 major gc 모두 병렬로 실행하지만 만약 major gc를 싱글로 하고싶다면 parallel compaction 기능을 끄면 됨 <- 안좋음

- concurrent gc: 전체 처리량보다 응답 시간이 더 중요한 경우에 사용할 것 프로세서가 gc와 처리역할을 나누어 일하기 때문에 일시정지가 짧아짐

- cms: 가비지 컬렉션 일시 정지가 짧은 것을 선호하는 애플리케이션을 위한 컬렉터, 프로세서 리소스를 가비지 컬렉션과 공유함. heap 메모리 영역의 크기가 클 때 적합하고 gc의 일시정지 시간을 줄이는 것이 목적이며 크기가 큰 오래된 객체가 있는 경우에 적합함, compact를 하지 않음

- g1gc: 서버스타일 컬렉터, 큰 메모리를 가진 멀티 프로세서 머신을 위한 컬렉터, 높은 확률로 일시 정지 시간에 대한 목표와 높은 처리량을 달성함

- mark-sweep-compact: 대상들을 체크하고 대상들을지우고 살아남은 객체들을 한곳으로 조각모음하는 알고리즘

  



## G1gc

- g1gc는 generational gc가 아님

- g1gc는 전체 heap을 1mb 단위의 리전들로 다룸

- g1이라는 이름은 가비지로 가득찬 리전부터 컬렉션을 시작한다는 의미

  - 가바지로 꽉 찬 리전이 발견되면 바로 컬렉션을 돌림

- old리전의 살아있는 객체는 다른 old 리전으로 옮겨지며 compaction이 이뤄짐

- g1에서 youn, old 영역 개념은 고정됨 개념이 아님

  - 객체가 새로 할당되는 리전들의 집합이 young generation
  - 프로모션이 일어나는 리전의 집합이 old generation

  

**동작**

- 비어있는 영역에만 새로운 객체가 들어감
- 쓰레기가 쌓여 꽉 찬 영역을 우선적으로 청소함
- 꽉 찬 영역에서 라이브 객체를 다른 영역으로 옮기고, 꽉 찬 영역은 깨끗하게 비움
- 이렇게 옮기는 과정이 조각 모음의 역할 도함











# DB에서 index에 대한 설명

- 기본적으로 데이터베이스 테이블에서 특정 레코드를 기반으로 검색할때는 full scan을 함
- 이 경우 검색의 속도가 저하되기 때문에 index라는 개념을 도입할 수 있음
- index는 책에서 목차와 같은 개념으로 사용되고 우리가 특정 원하는 내용에 도달하기위해서 목차를 기반으로 검색하는것과 개념이 비슷함
- index는 b-tree를 사용함
- 검색의 효율은 증가하나 로우의 추가 삭제의 경우 실행속도가 저하됨





# 쿼리문 실행 순서

- from -> where -> group by -> having -> seleect -> order by

# Active-Active , Active-Standby



# spring triangle architecture

## PSA

- Portable Service Abstract라는 뜻으로 직역하면 편한 추상화 서비스인데 환경의 변화와 관계 없이 일관된 방식의 기술 접근환경을 추상화 시킨것이다.
- 예를들어 어떤 서블릿 컨테이너를 사용하던지 단지 스프링을 사용하는 개발자들은 @GetMapping과 같은 추상화된 애너테이션을 사용함으로써 어떤 was 엔진에도 사용할 수 있음을 나타냄
- datasouce와 @transactional 애너테이션도 마찬가지임 각종 dbms들은 트랜잭션방식이 각각 전부 다르나 스프링을 사용하는 개발자들은 단순히 @transaction 애너테이션을 통해 트랜잭션 효과를 얻을 수 있음

## IoC / DI

- ioc는 제어의 역행이라는 뜻을 가졌음 과거에는 개발자들이 객체들의 라이프사이클을 관리했으나 spring에서 이 개념을 도입함으로써 개발자들이 더이상 객체들의 라이프사이클을 관리하지않고 스프링에서 관리하도록 함
- di는 ioc를 구현할 수 있는 방법인데 실제 객체를 사용할때는 spring이 객체 라이프사이클을 관리하는 빈 컨테이너에서 주입을 받아서 사용하는 개념임



## AOP

- aop는 관점지향 프로그래밍의 약자임 객체지향 프로그래밍과는 조금 다르게 관점을 기반으로 프로그래밍함 예를 들어 인증, 로그같이 공통되게 사용되는 기능적인 역할을 하는 코드를 재활용하여 사용할 수 있도록 만들어줌
- aop는 주로 proxy와 cglib을 활용한 바이트코드기반 방식이 있음
- proxy 방식은 기존 코드에 변경이 없고 해당 기능을 추가할 수 있는 프록시 객체를 별도로 생성함 이 방식은 interface가 정의되어 있고 interface에 대한 명세를 기반으로 프록시 객체를 생성함
- cglib 방식은 dynamic proxy 방식에서 interface가 반드시 필요하다는 제약이 없음 cglib은 target class를 상속받아서 생성되는데 바이트코드를 조작하여 동작함 이방식에서는 final, private과 같이 override가 불가능한 경우 해당 메서드에 대한 aspect를 제공할 수 없다는 단점





# java에서 singleton을 사용하는 이유

- 싱글턴을 사용하면 인스턴스가 한개 임을 보장하기때문에 메모리상 이점이 있음
- 생성된 인스턴스가 전역 인스턴스이기 때문에 공유하기 쉬움
- 객체가 초기화된 이후에는 미리 메모리에 로딩된 객체를 사용하기 때문에 성능상 이점이 있음
- 단점은 역할이 너무 많을 경우에 다른 인스턴스들간의 결합도가 높아질 수 있음
- 멀티스레드 환경에서 동시성에 대한 각별한 주의가 필요함
- 동시성에 대해서 민감한 애플리케이션이라면 애초에 private static final 멤버변수에서 바로 초기화시키는 방법이 있음
- 이럴 경우 인스턴스가 2개 생기는 일에 대해서 걱정하지 않아도됨



# 10칸짜리 배열로 thread safe한 queue를 만들어보세요

- 10칸짜리 배열로 .. thread safe한 배열
- final int[] arr = new int[];
- set 부분을 sychronized로 걸듯 ...
- 음 .. 그리고 first와 last idx를 멤버변수로 갖고
- add시 last를 한개씩 넣고
- pollFirst 시 0 번째 리턴 후
- idx 라는 변수를 두고 할 듯
- 









# 뮤텍스와 세마포어

- 동시성과 관련된 용어인데
- 공유된 자원을 다른 프로세스가 함께 사용하지 못하도록 하는 것
- 뮤텍스는 오직 0과 1로만 이루어져있고 오직 한개의 프로세스만이 자원에접근 가능하고
- 세마포어는 세마포어의 변수만큼의  프로세스가 접근할 수 있음



# db 클러스터링과 리플리케이션의 차이점

## 클러스터

- 하나의 db를 여러개의 서버상에 구축되어있는 형태
- 동기화 방식 -> 데이터를 복제한 후 결과를 확인하기 때문에 데이터 누락이 바생하지 않음
- replication보다는 느림
- 한 서버가 죽어도 계속 운용 가능

## replication

- db를 master/slave로 나너서 동일한 데이터를 저장하는 방식
- 비동기화 방식 -> master에 수정사항을 반영하면 slave가 데이터를 복사함
- 데이터 누락이 발생할 수 있으므로 서버와 클라이언트 간에 데이터 무결성 작업이 필요함
- master가 죽으면 복구 및 대처가 까다로움
- 



# 카프카



# 레디스





# ssl 동작방식

## 대칭키 암호화 방식

- 하나의 키를 기반으로 암호화, 복호화를 함
- 이 경우 암호가 유출될 경우 그 키로 암호화 되었던 데이터는 모두 유출됨



## 공개키 암호화 방식

- 공개키와 개인키로 나눔
- 공개키로 암호화하면 개인키로 복호화할 수 있고
- 개인키로 암호화하면 공개키로 복호화가능함
- 공개키는 유출되어도 개인키로 복호화하기 때문에 상관없음



## CA와 인증서

- https 통신에는 제 3자의 인증을 받아야함 이 인증기관을 ca라고함
- 여기에 자신의 정보와 공개키를 제출하고 검증 후에 인증서를 발급함
- 인증기관은 웹 브라우저에게 자신의 공개키를 제공함





## ssl 동작 방식

- 사용자가 웹 브라우저로 사이트에 접속하면 해당 웹서버는 자신의 인증서를 웹 브라우저에게 보냄
- 웹 브라우저는 미리 받았던 인증기관의 공개키로 인증서를 해독하여 검증함 그러면 사이트의 정보와 공개키를 알 수 있음
- 이렇게얻은 서버 공개키로 대칭키를 암호화해서 다시 서버로 보냄 
- 서버는 개인키로 복호화한 뒤 대칭키를 얻고 이 대칭키로 데이터를 주고 받음
- 세션이 종료되면 대칭키는 폐기함

![](https://t1.daumcdn.net/cfile/tistory/993364345C457AED30)

# 페이지 캐싱 방법

## LRU Least Resently Used

- 가장 오랫동안 참조되지 않은 페이지를 교체하는 방법
- 자바에서 linkedhashmap을 사용해서 구현 가능함

## LFU Least  Frequently Used

- 가장 적은 참조 횟수를 가진 페이지를 교체하는 방법



# 페이지 폴트



# 허프만 코드



# 해밍 코드



# 데드락

- 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로 교착 상태라고도 하며 시스템적으로 한정된 자원을 여러곳에서 사용하려고 할 떄 발생함
- 대기상태로 들어간 프로세스가 다시 실행상태로 변경될 수 없을때 교착상태 데드락이라고함

## 데드락을 피하는 방법

1. 상호배제 : 자원은 한 번에 한 프로세스만이 사용할 수 있어야함
2. 점유 대기 : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함
3. 비선점 : 다른 프로세스에 할당된 자원은 사용이 끝날떄까지 강제로 빼앗을 수 없어야함
4. 순환 대기 : 선형으로 대기한 형태를 유지해야함



# 트랜잭션 acid

- 원자성: 전부 실패 or 전부 성공
- 일관성: 항상 데이터는 무결성 일관성을 갖고 있어야함
- 격리성: 트랜잭션 수행 시 다른 트랜잭션이 연산 적업이 끼어들지 못하도록 보장하는 것 이 격리성은 성능에 직결적으로 영향을 주기때문에 대부분 유연하게 변형이 가능함
- 영속성: 성공된 트랜잭션은 반드시 영구적으로 반영되어야함

# 힙과 스택





# 인상깊었던 개발자 세미나



# 피보나치 수열 재귀/반복문



```
function int fibonaci(int i) {
	if(i == 0) {
	  return 0
	}
	if(i == 1) {
	  return 1
	}
	return fibonacci(i - 2) + fibonacci(i - 1);
}
```







# 퀵소트와 힙소트를 그림으로 설명

# swap 메모리

- ram에 용량이 부족할 경우 프로세스가 임시 저장되는 공간



# 진수변환 프로그래밍



# String과 StringBuilder, String Buffer



- String은 java에서 불변임 따라서 "abc"라는 문자열에 "d"라는 문자열을 붙여서 "abcd" 라는 문자열을 만들때 기존에 "abc" 가 있는 메모리 주소값의 값을 "abcd"로 변경하는게 아니라 기존에 있던 "abc"와는 별개로 "abcd"를 만들어냄 이런 결과는 string을 +연산자로 대량연산한다면 성능에 안좋을 수 있음
- 따라서 +연산의 경우 string builder나 string buffer를 사용해야 하는데 string buffer와 string builder의 차이는 thread-safe에 있음 string buffer가 thread safe함





# jvm에서 static 변수와 class 변수

https://www.linkedin.com/pulse/static-variables-methods-java-where-jvm-stores-them-kotlin-malisciuc/



# ConcurrentHashMap

https://highlyscalable.blogspot.com/2014/06/java-concurrenthashmap.html



# ReentrantLock

https://www.crocus.co.kr/1558



# Synchronized

https://coding-start.tistory.com/68

https://limkydev.tistory.com/64

https://www.baeldung.com/java-synchronized

# mybatis # $ 차이

https://rh-cp.tistory.com/71

https://java119.tistory.com/39



# AtomicInteger

https://codechacha.com/ko/java-atomic-integer/



# OSIV

https://kingbbode.tistory.com/27




# 네이버



# 자신이 했던 프로젝트 설명



# MSA 질문



## www.naver.com 누르면 생기는 일

- naver.com을 치면 local dns에게 해당 서버의 도메인 주소에 대한 ip주소를 질의하고 없으면 다른 dns 서버 의 정보를 받아냅니다. 만약 있다면 바로 끝냄
- 없을 경우 root dns 에게 정보를 물어봄
- root dns도 없을 경우 tld 에게 물어봄
- tld는 naver.com을 관리하는 dns를 알려줌
- local dns는 해당 dns에 naver.com을 질의하고 ip를 받아냄
- 받아낸 ip는 캐싱하고 ip주소 정보 전달



##  공유하고 싶은 프로젝트나 문서, 작성한 부분에 대해서 설명해보세요. 프로젝트에서 어려웠던 점은?

## BST 손코딩



## ELK 스택에 대해 

## 트리 문제



## 대용량 트래픽이 발생하는 시스템을 운영할 때 어떻게 시스템을 구축해야할지



## MSA에서 트랜잭션



## CORS Cross origin resource sharing

- 동일 출처 정책 same orogin policy 때문에 cors 같은 상황이 발생하면 외부 서버에서 요청한 데이터를 브라우저 보안 목적으로 차단함 
- 도메인 또는 포트가 다른 서버의 자원을 요청하는 매커니즘

## 기술을 적용할때 피드백을 어떻게 받을건지 





## 어떠한 서비스를 만들고 싶은데 무슨 기술이 필요한지 





## 10년후 나의 모습



## http header 종류



## 엘라스틱서치가 왜 검색쪽에서 주로 사용하고 빠른지 원리 설명 

## 디비 인덱스 원리 설명, 대표적인 인덱스 설명, 왜 인덱스를 사용하는가 설명 

## msa의 장점과 단점, 본인의 견해 설명



## 단어 거꾸로 알고리즘






# Stable Sort의 의미

같은 키값을 가진 원소들이 정렬이후에도 같은 순서로 되어있으면 stable sort ex : merge sort, bubble sort uns





# 프로세스의 생성 과정

1. 새로운 프로세스에 프로세스 식별자를 할당
2. 프로세스의 모든 구성요소를 포함할 수 있는 주소 공간과 프로세스 제어 블록공간 할당
3. 프로세스 제어 블록을 초기화
4. 링크



# HTTP1과 HTTP2의 차이

- http1은 기본적으로 연결당 하나의 요청과 응답을 처리하기 떄문에 동시전송 문제와 다수의 리소스를 처리하기에 속도와 성능이슈를 갖고 있음
- 그래서 http2가등장함 multiplexed Streams 한 커넥션에 여러개의 메세지를 동시에 주고 받을 수 있고
- stream prioritization 요청 리소스간 의존관계 설정
- server push html문서상에 필요한 리소스를 클라이언트 요청 없이 보내줄 수 있음
- header compression header정보를 hpack압축방식을 이용하여 압축전송





# PeparedStatement와 Statement의 차이

## Statement

- 단일로 사용될 때 빠른 속도를 지님
- 쿼리에 인자를 부여할 수 없음
- 매번 컴파일 수행
- mybatis에서 ${} 사용시 일반 statement

## PreparedStatement

- 쿼리에 인자 부여 가능
- 처음 프리컴파일 된 후 이후에는 컴파일 수행 X
- 여러번 수행될 때 빠른 속도
- mybatis에서 #{} 사용시 preparedstatement로 생성됨
- preparedstatement로 생성되면 들어오는 데이터를 문자열로 인식하기 때문에 자동 따옴표 붙음





# Context Swiching

- 멀티프로세스 환경에서 cpu가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선순위의 프로세스가 실행되어야 할 때  기존 프로세스의 상태를 저장하고 cpu가 다음 프로세스를 수행하도록 새로운 프로세스의 상태를 교체하는 작업





# Keep-alive 헤더

- http header는 비연결성이라 매번 연결을 해야함
- 만약 이값이 true라면 소켓을 열어두고 열려있는 소켓을 통해 통신함

# 