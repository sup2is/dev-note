



# 테스트 코드란?

- 테스트코드는 코드의 품질을 높여주고 버그에 대해 방어적일 수 있음
- 이와 관련된 개발 방법론으로 tdd가있음
- tdd는 테스트 주도 개발이라는 뜻을 갖고 있고 비지니스 로직을 작성하기 이전에 실패하는 테스트 스텁을 만든 후 테스트를 기반으로 비지니스 로직을 작성하는 개발 방법론임
- 테스트 없는 리팩터링은 불가능함





# 프로젝트 설계 내용



# 프로세스와 스레드

## 프로세스

- 프로세스는 cpu가 작업을 할당하는 단위
- 독립적이고 기본적으로 다른 프로세스의 변수나 자료구조에 접근하지 못함
- 다른 프로세스에 접근하려면 inter process communication (ipc)을 사용해야함 ex 파이프, 파일 소켓
- 기본적으로 1개 이상의 스레드를 갖고 있음

## 멀티 프로세스

- 하나의 애플리케이션에 여러 개의 프로세스를 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것
- 장점 : 여러 개의 자식 프로세스중 하나가 장애가 난다면 그 자식 프로세스만 영향이 있고 다른부분엔 영향이 없음
- 단점: context switching에서의 오버헤드
  - 프로세스는 공유할 수 있는 메모리공간이 없기 때문에 context switching이 발생하면 캐싱된 모든 데이터들을 다시 불러들어와야해서 오버헤드가 발생함

**Context Switching**

- cpu에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정을 context switching이라함

## 스레드

- 스레드는 프로세스 내에서 실행되는 작업의 단위
- 스레드는 한 프로세스 내부에서 존재하기 때문에 프로세스 내의 주소 공간 이나 자원들을 서로 공유함
- 스레드들은 각각 별도의 레지스터와 스택을 갖고 있지만 힙 메모리는 서로 읽고 쓸 수 있음
- 싱글스레드와 멀티스레드로 나뉨
- 싱글스레드는 프로세스가 하나의 작업단위만 존재하는것
- 멀티스레드는 두개이상의 작업을 처리함으로써 병렬처리의 효과를 얻을 수 있음
- 예를들어 윈도우 애플리케이션인 크롬의 경우 크롬 자체는 프로세스로 동작하지만 그 내부에 크롬 탭같은경우는 스레드로 동작함
- 따라서 크롬은 멀티 스레드임

## 멀티 스레드

- 하나의 프로세스 내부에서 두 개 이상의 스레드를 활용해서 각각의 작업을 처리하도록 하는 것
- 웹서버는 대표적인 멀티 스레드 응용 프로그램

**장점**

- 시스템 자원 소모 감소
  - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리 가능
- 시스템 처리량 증가
  - 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어듦, 스레드 사이의 작업량이 작아 context switching이 빠름
- 간단한 통신 방법으로 인한 프로그램 응답 시간 단축 
  - 스레드는 프로세는 내의 자원을 공유하기때문에 비교적 통신의 부담이 적음

**단점**

- 주의 깊은 설계가 필요함
- 디버깅이 까다로움
- 멀티 스레드의 경우 동기화 문제를 겪을 수 있음 레이스 컨디션
- 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받음

### 자바의 스레드

- 일반 스레드와 거의 차이가 없고 os가 아닌 jvm에서 관리함
- 자바에서 스레드 스케줄링은 jvm이 담당함



# PriorityQueue에 대한 설명

- 우선순위 큐
- 최소힙과 최대힙을 알아야함

## 힙

- 완전 이진트리의 일종
- 여러개의 값들 중에서 최대값이나 최소값을 가장 빠르게 찾아낼 수 있도록 만들어진 자료구조
- 힙은 일종의 반정렬 상태를 유지함
  - 큰 값이 사우이 레벨에 있고 작은 값이 하위 레벨이 있는 정도
  - 부모 노드의 키값이 자식노드보다 항상 큰 이진트리를 말함 <- 최대힙
- 힙트리에서는 중복된 값을 허용함 bst에서는 허용 x

### 최대힙

- 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진트리

### 최소힙

- 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진트리

## 힙 구현

- 힙을 저장하는 표준적인 자료구조는 배열임
- 구현을 쉽게 하기 위하여 배열의 첫번째 인덱스인 0은 사용하지 않음
- 힙에서의 부모 노드와 자식 노드의 관계
  - 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
  - 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1
  - 부모의 인덱스 = (자식의 인덱스) / 2

```java
/* 최대힙 삭제 */
int delete_max_heap(){
if (heapSize == 0) // 배열이 빈 경우
  return 0;

int item = maxHeap[1]; // 루트 노드의 값을 저장한다.
maxHeap[1] = maxHeap[heapSize]; // 마지막 노드의 값을 루트 노드에 둔다.
maxHeap[heapSize--] = 0; // 힙 크기를 하나 줄이고 마지막 노드를 0으로 초기화한다.

for (int i=1; i*2<=heapSize;) {
  // 마지막 노드가 왼쪽 노드와 오른쪽 노드보다 크면 반복문을 나간다.
  if (maxHeap[i] > maxHeap[i*2] && maxHeap[i] > maxHeap[i*2+1]) {
    break;
  }
  // 왼쪽 노드가 더 큰 경우, 왼쪽 노드와 마지막 노드를 swap
  else if (maxHeap[i*2] > maxHeap[i*2+1]) {
    swap(i, i*2);
    i = i*2;
  }
  // 오른쪽 노드가 더 큰 경우, 오른쪽 노드와 마지막 노드를 swap
  else {
    swap(i, i*2+1);
    i = i*2+1;
  }
}
return item;
}
https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html
```



# SQL 인젝션 방어 코드

## sql 인젝션 방어 코드

- 코드인젝션의 한 기법
- 클라이언트의 입력값을 조작하여 서버의 데이터베이스를 공격하는 방식

## 방어방법

- 유저에게 받은 값을 직접적으로 쿼리에 담아서 보내면 안됨
- 예를들어 db 매핑 라이브러리인 마이바티스의 경우 파라미터 바인딩에서 #과 $를 사용할 수 있는데
- #의 경우 sql로 변환시 파라미터로 동작하는데 $를 사용할 경우 바로 출력되기때문에 추가적인 sql을 전송할 수 있는 여력이 있음



# 스프링 MVC

- model, view, controller의 약자
- 웹 애플리케이션에서는 model, view, controller라는 추상적인 계층 만들어서 레이어드시켜놓음
- 이런식으로 관리하면 유지보수를 극대화시킬 수 있기 때문임
- model은 데이터 계층, 리포지터리 계층에서 동작하며 실제로 db액세스와 관련된 데이터 crud에 해당하는 역할을 함 
- view는 유저에게 응답할 수 있는 화면을 나타내고 화면의 렌더링, 데이터를 어떤식으로 표출할지에 대한 방법을 담당함
- controller는 http에서 요청 또는 응답에 해당하는 부분을 담당함



# 디스패처 서블릿이란?

- 서블릿 컨테이너에서 http 프로토콜을 통해 들어오는 모든 요청을 프레젠테이션 계층의 제일 앞에 둬서 중앙집중형으로 처리해주는 프론트 컨트롤러 
- spring에서 정의함

# 서블릿 컨테이너란?

- 서블릿 컨테이너는 개발자가 웹서버와 통신하기 위하여 소켓을 생성하고 특정 포트에 리스닝하는 등의 복잡한 일들을 처리해주는 컨테이너
- 웹 클라이언트로부터 http 요청이 전달되면 해당 http요청을 해석함
- 컨테이너는 servlet의 라이프사이클을 관리해줌 서블릿 컨테이너는 요청이들어올때마다 새로운 자바 스레드를 만듦
- 대표적인 servlet container는 tomcat 



# VO와 DAO+ DTO

## ValueObject

- 말그대로 값 객체임

## Data Access Object

- 데이터 계층에 엑세스하는 오브젝트

## Data Transfer Object

- 데이터의 전송 과정에 있어서 사용하는 1회성 객체
- 나같은 경우엔 주로 request나 response에 dto 객체를 많이 사용함

# 알고있는 정렬 알고리즘과 그 중에 좋아하는 정렬 알고리즘-> 퀵소트 머지소트 힙소트

- 버블소트 On2
- 삽입정렬 On2
- 선택정렬 On2 ~ On 성능좋으면 n차에끝남

## 퀵소트

- 퀵정렬 O n log n 최악은 On2
- 피벗의 개념이 꼭 필요함
- 분할정복

### 동작방법

1. 리스트 안에 있는 요소중에 한개의 요소를 결정함 (피벗)
2. 피벗(값)을 기준으로 피벗보다 작은 요소를 왼쪽으로 피벗보다 큰 요소들을 오른쪽으로 옮김
3. 피벗을 제외하고 왼쪽 리스트와 오른쪽 리스트를 다시 1번과 같은 방법으로 정렬 함
4. 왼쪽, 오른쪽 리스트들의 크기가 0이나 1이될 때까지 반복함

## 머지소트

- 머지소트 O n log n 
- stable함
- 분할정복

### 과정

- 리스트를 반으로 전부 나누고 분할 시킴
- 더이상 쪼개질 수 없을 때 병합하면서 리스트를 합침



## 힙소트



## stable 정렬과 unstable정렬

- 소팅을할때 같은 key값을 가진 node들의 순서가 바뀌지 않으면 stable, 만약 바뀐다면 unstable 정렬임

## stable정렬

- 버블, 삽입, 머지

## unstable정렬

- 퀵, 선택, 힙

# SOLID 원칙

## Single Responsibility Principle 단일 책임 원칙

- 소프트웨어의 설계 부품은 단 하나의 책임만을 가져야하고 변경되는 이유도 단 하나여야만 함

## Open-Closed Principle 개방 폐쇄 원칙

- 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야함
- 인터페이스를 기반으로 작성하거나 전략패턴을 사용할 것

## Liskov Substitution Principle 리스코프 치환 법칙

- 부모 클래스와 자식 클래스의 행위에는 일관성이 있어야 함 
- 객체지향 프로그래밍에서 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용해도 문제가 없어야 함

## Dependency Inversion Principle

- 의존 관계를 맺을 때 변화하기 쉬운것 보단 변화하기 어려운 것에 의존해야 함

## Interface Segregation Principle

- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 함
- 하나의 일반적인 인터페이스보다는 여러개의 구체적인 인터페이스가 나음



# 인터페이스와 추상클래스와의 차이

https://yaboong.github.io/java/2018/09/25/interface-vs-abstract-in-java8/





# 스택과 큐 설명

## 스택

- 스택은 LIFO, Last in first out 으로써 마지막에 들어온것이 가장 처음에 나가는 자료구조
- 웹브라우저 방문기록, 수식의 괄호검사 등

## 큐

- 큐는 FIFO, First in fist out 으로서 처음들어온 것이 가장 처음에 나가는 자료구죠
- 일반적인 선형 프로세스



# 톰캣은 멀티 프로세스인가  멀티 스레드인가?

- 멀티스레드임
- was로 사용하고 정적인 데이터는 apache가 더 빠름

# 아파치는 멀티 프로세스인가 멀티 스레드인가?

- 멀티스레드임
- web 서버로 사용하고 정적인 데이터 단순 html, css ,js 파일들을 제공함

# 오버라이딩 오버로딩

- 오버라이딩은 구현체 또는 상속관계에 있어서 상위 메서드를 자식메서드가 새롭게 구현하는 것을 뜻함
- 오버로딩은 메서드명은 같지만 메서드 인자의 개수나 매서드 인자의 위치에 따라 같은 메서드 명이라도 다른 인터페이스를 갖도록 해줌 ex Arrays.sort는 같은메서드명이라도 다른 인터페이스를 갖도록 해줌



# http에 대한 모든것

- tcp/ip를 사용하는 응용 프로토콜
- method는 get과 post가 있고
- get은 일반적으로 url 파라미터를 사용해서 데이터를 전송하는 반면 post는 body라는 스펙을 활용해서 데이터를 전송함
- 가장 중요한 개념으로 요청과 응답이 있음
- 비연결성 프로토콜
- 서버와 클라이언트가 있음



# 알고있는 암호화 방식



# REST API에 대한 모든것



# 웹서비스에 접속할때 어떠한 from - to 에 대한 설명



# OSI 7 계층



# TCP / IP 4계층



# TCP와 UDP



# 서버에 트래픽이 몰릴때 어떻게 응답속도를 개선시킬지 ?



# JAVA 8의 변경점





# JVM 구조



# JVM GC 동작 방식

https://johngrib.github.io/wiki/jvm-memory/





# GC의 종류



# DB에서 index에 대한 설명



# spring aop와 ioc



# spring triangle architecture



# java에서 singleton을 사용하는 이유



# 10칸짜리 배열로 thread safe한 queue를 만들어보세요





# 비동기와 동기, 블락킹과 넌블락킹





# db 클러스터링과 리플리케이션의 차이점



# 카프카



# 레디스















# ssl 처리방식



# 페이지 캐싱 방법



# 페이지 폴트



# 허프만 코드



# 해밍 코드



# 데드락



# 가비지 컬렉션



# 힙과 스택





# 인상깊었던 개발자 세미나



# 피보나치 수열 재귀/반복문



# 퀵소트와 힙소트를 그림으로 설명



# 진수변환 프로그래밍



# 