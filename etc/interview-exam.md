



# 테스트 코드란?

- 테스트코드는 코드의 품질을 높여주고 버그에 대해 방어적일 수 있음
- 이와 관련된 개발 방법론으로 tdd가있음
- tdd는 테스트 주도 개발이라는 뜻을 갖고 있고 비지니스 로직을 작성하기 이전에 실패하는 테스트 스텁을 만든 후 테스트를 기반으로 비지니스 로직을 작성하는 개발 방법론임
- 테스트 없는 리팩터링은 불가능함



# Spring과 Spring Boot의 차이

- 과거에 Spring 개발 환경 구축에만 꽤 많은 시간이 소요 되었기때문에 이 단점을 보완하기위해서 나온 프로젝트가 spring boot
- spring boot를 사용하면 독립 실행형으로 프로덕션급의 spring 애플리케이션을 매우 손쉽게 구축할수 있음



# POJO

- Plain Old Java Object
- 말그대로 퓨어한 자바 오브젝트를 뜻함
- 과거 ejb 컨테이너에 의존하는 객체처럼 복잡하지 않고 개발자가 쓰기 편한 간단한 Object를 만들어 쓰자는 간단한 Object의 개념



# DFS, BFS

- dfs는 깁이 우선 탐색
- bfs 너비 우선 탐색
- 트리 자료구조에서 사용하는 탐색 방법
- 우리가 알고있는 in-order, preorder, post-order는 dfs의 한 방법이고
- bfs는 말그대로 같은 깊이를 가진 노드를 순차적으로 방문하는 방법





# 프로젝트 설계 내용



# 프로세스와 스레드

## 프로세스

- 프로세스는 cpu가 작업을 할당하는 단위
- 독립적이고 기본적으로 다른 프로세스의 변수나 자료구조에 접근하지 못함
- 다른 프로세스에 접근하려면 inter process communication (ipc)을 사용해야함 ex 파이프, 파일 소켓
- 기본적으로 1개 이상의 스레드를 갖고 있음

## 멀티 프로세스

- 하나의 애플리케이션에 여러 개의 프로세스를 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것
- 장점 : 여러 개의 자식 프로세스중 하나가 장애가 난다면 그 자식 프로세스만 영향이 있고 다른부분엔 영향이 없음
- 단점: context switching에서의 오버헤드
  - 프로세스는 공유할 수 있는 메모리공간이 없기 때문에 context switching이 발생하면 캐싱된 모든 데이터들을 다시 불러들어와야해서 오버헤드가 발생함

**Context Switching**

- cpu에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정을 context switching이라함

## 스레드

- 스레드는 프로세스 내에서 실행되는 작업의 단위
- 스레드는 한 프로세스 내부에서 존재하기 때문에 프로세스 내의 주소 공간 이나 자원들을 서로 공유함
- 스레드들은 각각 별도의 레지스터와 스택을 갖고 있지만 힙 메모리는 서로 읽고 쓸 수 있음
- 싱글스레드와 멀티스레드로 나뉨
- 싱글스레드는 프로세스가 하나의 작업단위만 존재하는것
- 멀티스레드는 두개이상의 작업을 처리함으로써 병렬처리의 효과를 얻을 수 있음
- 예를들어 윈도우 애플리케이션인 크롬의 경우 크롬 자체는 프로세스로 동작하지만 그 내부에 크롬 탭같은경우는 스레드로 동작함
- 따라서 크롬은 멀티 스레드임

## 멀티 스레드

- 하나의 프로세스 내부에서 두 개 이상의 스레드를 활용해서 각각의 작업을 처리하도록 하는 것
- 웹서버는 대표적인 멀티 스레드 응용 프로그램

**장점**

- 시스템 자원 소모 감소
  - 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리 가능
- 시스템 처리량 증가
  - 스레드 간 데이터를 주고 받는 것이 간단해지고 시스템 자원 소모가 줄어듦, 스레드 사이의 작업량이 작아 context switching이 빠름
- 간단한 통신 방법으로 인한 프로그램 응답 시간 단축 
  - 스레드는 프로세는 내의 자원을 공유하기때문에 비교적 통신의 부담이 적음

**단점**

- 주의 깊은 설계가 필요함
- 디버깅이 까다로움
- 멀티 스레드의 경우 동기화 문제를 겪을 수 있음 레이스 컨디션
- 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받음

### 자바의 스레드

- 일반 스레드와 거의 차이가 없고 os가 아닌 jvm에서 관리함
- 자바에서 스레드 스케줄링은 jvm이 담당함



# PriorityQueue에 대한 설명

- 우선순위 큐
- 최소힙과 최대힙을 알아야함

## 힙

- 완전 이진트리의 일종
- 여러개의 값들 중에서 최대값이나 최소값을 가장 빠르게 찾아낼 수 있도록 만들어진 자료구조
- 힙은 일종의 반정렬 상태를 유지함
  - 큰 값이 사우이 레벨에 있고 작은 값이 하위 레벨이 있는 정도
  - 부모 노드의 키값이 자식노드보다 항상 큰 이진트리를 말함 <- 최대힙
- 힙트리에서는 중복된 값을 허용함 bst에서는 허용 x

### 최대힙

- 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진트리

### 최소힙

- 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진트리

## 힙 구현

- 힙을 저장하는 표준적인 자료구조는 배열임
- 구현을 쉽게 하기 위하여 배열의 첫번째 인덱스인 0은 사용하지 않음
- 힙에서의 부모 노드와 자식 노드의 관계
  - 왼쪽 자식의 인덱스 = (부모의 인덱스) * 2
  - 오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1
  - 부모의 인덱스 = (자식의 인덱스) / 2

```java
/* 최대힙 삭제 */
int delete_max_heap(){
if (heapSize == 0) // 배열이 빈 경우
  return 0;

int item = maxHeap[1]; // 루트 노드의 값을 저장한다.
maxHeap[1] = maxHeap[heapSize]; // 마지막 노드의 값을 루트 노드에 둔다.
maxHeap[heapSize--] = 0; // 힙 크기를 하나 줄이고 마지막 노드를 0으로 초기화한다.

for (int i=1; i*2<=heapSize;) {
  // 마지막 노드가 왼쪽 노드와 오른쪽 노드보다 크면 반복문을 나간다.
  if (maxHeap[i] > maxHeap[i*2] && maxHeap[i] > maxHeap[i*2+1]) {
    break;
  }
  // 왼쪽 노드가 더 큰 경우, 왼쪽 노드와 마지막 노드를 swap
  else if (maxHeap[i*2] > maxHeap[i*2+1]) {
    swap(i, i*2);
    i = i*2;
  }
  // 오른쪽 노드가 더 큰 경우, 오른쪽 노드와 마지막 노드를 swap
  else {
    swap(i, i*2+1);
    i = i*2+1;
  }
}
return item;
}
https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html
```



# SQL 인젝션 방어 코드

## sql 인젝션 방어 코드

- 코드인젝션의 한 기법
- 클라이언트의 입력값을 조작하여 서버의 데이터베이스를 공격하는 방식

## 방어방법

- 유저에게 받은 값을 직접적으로 쿼리에 담아서 보내면 안됨
- 예를들어 db 매핑 라이브러리인 마이바티스의 경우 파라미터 바인딩에서 #과 $를 사용할 수 있는데
- #의 경우 sql로 변환시 파라미터로 동작하는데 $를 사용할 경우 바로 출력되기때문에 추가적인 sql을 전송할 수 있는 여력이 있음



# 스프링 MVC

- model, view, controller의 약자
- 웹 애플리케이션에서는 model, view, controller라는 추상적인 계층 만들어서 레이어드시켜놓음
- 이런식으로 관리하면 유지보수를 극대화시킬 수 있기 때문임
- model은 데이터 계층, 리포지터리 계층에서 동작하며 실제로 db액세스와 관련된 데이터 crud에 해당하는 역할을 함 
- view는 유저에게 응답할 수 있는 화면을 나타내고 화면의 렌더링, 데이터를 어떤식으로 표출할지에 대한 방법을 담당함
- controller는 http에서 요청 또는 응답에 해당하는 부분을 담당함



# 디스패처 서블릿이란?

- 서블릿 컨테이너에서 http 프로토콜을 통해 들어오는 모든 요청을 프레젠테이션 계층의 제일 앞에 둬서 중앙집중형으로 처리해주는 프론트 컨트롤러 
- spring에서 정의함

# 서블릿 컨테이너란?

- 서블릿 컨테이너는 개발자가 웹서버와 통신하기 위하여 소켓을 생성하고 특정 포트에 리스닝하는 등의 복잡한 일들을 처리해주는 컨테이너
- 웹 클라이언트로부터 http 요청이 전달되면 해당 http요청을 해석함
- 컨테이너는 servlet의 라이프사이클을 관리해줌 서블릿 컨테이너는 요청이들어올때마다 새로운 자바 스레드를 만듦
- 대표적인 servlet container는 tomcat 



# VO와 DAO+ DTO

## ValueObject

- 말그대로 값 객체임

## Data Access Object

- 데이터 계층에 엑세스하는 오브젝트

## Data Transfer Object

- 데이터의 전송 과정에 있어서 사용하는 1회성 객체
- 나같은 경우엔 주로 request나 response에 dto 객체를 많이 사용함

# 알고있는 정렬 알고리즘과 그 중에 좋아하는 정렬 알고리즘-> 퀵소트 머지소트 힙소트

- 버블소트 On2
- 삽입정렬 On2
- 선택정렬 On2 ~ On 성능좋으면 n차에끝남

## 퀵소트

- 퀵정렬 O n log n 최악은 On2
- 피벗의 개념이 꼭 필요함
- 분할정복

### 동작방법

1. 리스트 안에 있는 요소중에 한개의 요소를 결정함 (피벗)
2. 피벗(값)을 기준으로 피벗보다 작은 요소를 왼쪽으로 피벗보다 큰 요소들을 오른쪽으로 옮김
3. 피벗을 제외하고 왼쪽 리스트와 오른쪽 리스트를 다시 1번과 같은 방법으로 정렬 함
4. 왼쪽, 오른쪽 리스트들의 크기가 0이나 1이될 때까지 반복함

## 머지소트

- 머지소트 O n log n 
- stable함
- 분할정복

### 과정

- 리스트를 반으로 전부 나누고 분할 시킴
- 더이상 쪼개질 수 없을 때 병합하면서 리스트를 합침



## 힙소트



## stable 정렬과 unstable정렬

- 소팅을할때 같은 key값을 가진 node들의 순서가 바뀌지 않으면 stable, 만약 바뀐다면 unstable 정렬임

## stable정렬

- 버블, 삽입, 머지

## unstable정렬

- 퀵, 선택, 힙

# SOLID 원칙

## Single Responsibility Principle 단일 책임 원칙

- 소프트웨어의 설계 부품은 단 하나의 책임만을 가져야하고 변경되는 이유도 단 하나여야만 함

## Open-Closed Principle 개방 폐쇄 원칙

- 기존의 코드를 변경하지 않고 기능을 수정하거나 추가할 수 있도록 설계해야함
- 인터페이스를 기반으로 작성하거나 전략패턴을 사용할 것

## Liskov Substitution Principle 리스코프 치환 법칙

- 부모 클래스와 자식 클래스의 행위에는 일관성이 있어야 함 
- 객체지향 프로그래밍에서 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용해도 문제가 없어야 함

## Dependency Inversion Principle

- 의존 관계를 맺을 때 변화하기 쉬운것 보단 변화하기 어려운 것에 의존해야 함

## Interface Segregation Principle

- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 함
- 하나의 일반적인 인터페이스보다는 여러개의 구체적인 인터페이스가 나음



# 인터페이스와 추상클래스와의 차이

https://yaboong.github.io/java/2018/09/25/interface-vs-abstract-in-java8/





# 스택과 큐 설명

## 스택

- 스택은 LIFO, Last in first out 으로써 마지막에 들어온것이 가장 처음에 나가는 자료구조
- 웹브라우저 방문기록, 수식의 괄호검사 등

## 큐

- 큐는 FIFO, First in fist out 으로서 처음들어온 것이 가장 처음에 나가는 자료구죠
- 일반적인 선형 프로세스



# 톰캣은 멀티 프로세스인가  멀티 스레드인가?

- 멀티스레드임
- was로 사용하고 정적인 데이터는 apache가 더 빠름

# 아파치는 멀티 프로세스인가 멀티 스레드인가?

- 멀티스레드임
- web 서버로 사용하고 정적인 데이터 단순 html, css ,js 파일들을 제공함

# 오버라이딩 오버로딩

- 오버라이딩은 구현체 또는 상속관계에 있어서 상위 메서드를 자식메서드가 새롭게 구현하는 것을 뜻함
- 오버로딩은 메서드명은 같지만 메서드 인자의 개수나 매서드 인자의 위치에 따라 같은 메서드 명이라도 다른 인터페이스를 갖도록 해줌 ex Arrays.sort는 같은메서드명이라도 다른 인터페이스를 갖도록 해줌



# http에 대한 모든것

- tcp/ip를 사용하는 응용 프로토콜
- method는 get과 post가 있고
- get은 일반적으로 url 파라미터를 사용해서 데이터를 전송하는 반면 post는 body라는 스펙을 활용해서 데이터를 전송함
- 가장 중요한 개념으로 요청과 응답이 있음
- 비연결성 프로토콜
- 서버와 클라이언트가 있음



# 알고있는 암호화 방식



# REST API에 대한 모든것

## Representitional State Transfer

- 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 모든 것을 의미함
- rest는 http 프로토콜을 그대로 사용하기 떄문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일
- 무상태성, 캐시처리 가능, 계층화, Code-on-demand 등의 특징이 있음

# 웹서비스에 접속할때 어떠한 from - to 에 대한 설명



# OSI 7 계층

## 물리

## 데이터

## 네트워크

## 전송

## 세션

## 표현

## 애플리케이션



# TCP / IP 4계층

osi7계층에 비해 조금 더 단순한 구조

## 네트워크 계층

- 물리적인 주소로 mac주소를 사용함
- osi 7계층에서 물리계층과 데이터링크 계층의역할을 함

## 인터넷 계층

- 통신 노드간의 ip 패킷을 전송하는 기능과 라우팅을담당

## 전송 계층

- 통신 노드간의 연결을 제어하고 신뢰 또는 비신뢰성 데이터를 전송함
- tcp udp

## 애플리케이션 계층

- 응용프로그램계층 smtp ,ftp, http 등등





# HTTPS 동작 방식



# TCP와 UDP

- tcp와 udp는 osi 7계층에서 전송계층에 해당하는 프로토콜임

## TCP

- 신뢰성 있는 데이터 전송

- tcp는 전이중방식을 사용하고 3way handshaking 을 통해 연결을 수립함

- 신뢰성 있는 데이터 전송을 위해 패킷 내부에 관련된 필드들이 있음 따라서 패킷의 크기가 udp 보다 큼 -> 속도에서는 udp한테 안됨

## UDP

- 비신뢰성 데이터 전송
- 비연결형 프로토콜
- 빠른 전송을 기대할 수 있으나 데이터의 순서는 신뢰할 수 없음

# 서버에 트래픽이 몰릴때 어떻게 응답속도를 개선시킬지 ?

- 병목지점을 모니터링한 후에 만약 네트워크 지연으로 인한 병목이라면 스케일 아웃을 통해서 응답속도를 개선
- 병목지점이 만약 코드, 즉 애플리케이션 단에 있는 문제라면 쿼리 최적화나 알고리즘 변경을통해 응답속도를 개선

# JAVA 8의 변경점

- 펑셔널 인터페이스를 도입하고 람다를 도입해서 별도의 익명 클래스를 생성하지 않고 메서드 몸체만 넘길 수 있는 문법을 들임
- 스트림을 도입해서 파이프라인 프로그래밍을 가능하게함



# JVM 구조



# JVM GC 동작 방식

https://johngrib.github.io/wiki/jvm-memory/





# GC의 종류



# DB에서 index에 대한 설명





# Active-Active , Active-Standby



# spring triangle architecture

## PSA

- Portab

## IoC / DI



## AOP





# java에서 singleton을 사용하는 이유

- 싱글턴을 사용하면 인스턴스가 한개 임을 보장하기때문에 메모리상 이점이 있음
- 생성된 인스턴스가 전역 인스턴스이기 때문에 공유하기 쉬움
- 객체가 초기화된 이후에는 미리 메모리에 로딩된 객체를 사용하기 때문에 성능상 이점이 있음
- 단점은 역할이 너무 많을 경우에 다른 인스턴스들간의 결합도가 높아질 수 있음
- 멀티스레드 환경에서 동시성에 대한 각별한 주의가 필요함
- 동시성에 대해서 민감한 애플리케이션이라면 애초에 private static final 멤버변수에서 바로 초기화시키는 방법이 있음
- 이럴 경우 인스턴스가 2개 생기는 일에 대해서 걱정하지 않아도됨



# 10칸짜리 배열로 thread safe한 queue를 만들어보세요

- 10칸짜리 배열로 .. thread safe한 배열
- final int[] arr = new int[];
- set 부분을 sychronized로 걸듯 ...



# 비동기와 동기, 블락킹과 넌블락킹





# db 클러스터링과 리플리케이션의 차이점

## 클러스터

- 하나의 db를 여러개의 서버상에 구축되어있는 형태
- 동기화 방식 -> 데이터를 복제한 후 결과를 확인하기 때문에 데이터 누락이 바생하지 않음
- replication보다는 느림
- 한 서버가 죽어도 계속 운용 가능

## replication

- db를 master/slave로 나너서 동일한 데이터를 저장하는 방식
- 비동기화 방식 -> master에 수정사항을 반영하면 slave가 데이터를 복사함
- 데이터 누락이 발생할 수 있으므로 서버와 클라이언트 간에 데이터 무결성 작업이 필요함
- master가 죽으면 복구 및 대처가 까다로움
- 



# 카프카



# 레디스





# ssl 동작방식





## 대칭키 암호화 방식

- 하나의 키를 기반으로 암호화, 복호화를 함
- 이 경우 암호가 유출될 경우 그 키로 암호화 되었던 데이터는 모두 유출됨



## 공개키 암호화 방식

- 공개키와 개인키로 나눔
- 공개키로 암호화하면 개인키로 복호화할 수 있고
- 개인키로 암호화하면 공개키로 복호화가능함
- 공개키는 유출되어도 개인키로 복호화하기 때문에 상관없음



## CA와 인증서

- https 통신에는 제 3자의 인증을 받아야함 이 인증기관을 ca라고함
- 여기에 자신의 정보와 공개키를 제출하고 검증 후에 인증서를 발급함
- 인증기관은 웹 브라우저에게 자신의 공개키를 제공함





## ssl 동작 방식

- 사용자가 웹 브라우저로 사이트에 접속하면 해당 웹서버는 자신의 인증서를 웹 브라우저에게 보냄
- 웹 브라우저는 미리 받았던 인증기관의 공개키로 인증서를 해독하여 검증함 그러면 사이트의 정보와 공개키를 알 수 있음
- 이렇게얻은 서버 공개키로 대칭키를 암호화해서 다시 서버로 보냄 
- 서버는 개인키로 복호화한 뒤 대칭키를 얻고 이 대칭키로 데이터를 주고 받음
- 세션이 종료되면 대칭키는 폐기함

![](https://t1.daumcdn.net/cfile/tistory/993364345C457AED30)

# 페이지 캐싱 방법

## LRU

## LFU



# 페이지 폴트



# 허프만 코드



# 해밍 코드



# 데드락

- 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로 교착 상태라고도 하며 시스템적으로 한정된 자원을 여러곳에서 사용하려고 할 떄 발생함
- 대기상태로 들어간 프로세스가 다시 실행상태로 변경될 수 없을때 교착상태 데드락이라고함

## 데드락을 피하는 방법

1. 상호배제 : 자원은 한 번에 한 프로세스만이 사용할 수 있어야함
2. 점유 대기 : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함
3. 비선점 : 다른 프로세스에 할당된 자원은 사용이 끝날떄까지 강제로 빼앗을 수 없어야함
4. 순환 대기 : 선형으로 대기한 형태를 유지해야함



# 트랜잭션 acid

- 원자성: 전부 실패 or 전부 성공
- 일관성: 항상 데이터는 무결성 일관성을 갖고 있어야함
- 격리성: 트랜잭션 수행 시 다른 트랜잭션이 연산 적업이 끼어들지 못하도록 보장하는 것 이 격리성은 성능에 직결적으로 영향을 주기때문에 대부분 유연하게 변형이 가능함
- 영속성: 성공된 트랜잭션은 반드시 영구적으로 반영되어야함

# 힙과 스택





# 인상깊었던 개발자 세미나



# 피보나치 수열 재귀/반복문



# 퀵소트와 힙소트를 그림으로 설명



# 진수변환 프로그래밍
