http://www.hanbit.co.kr/src/10280





# #1 아파치 카프카 개요

## 아파치 카프카

- 아파치 카프카는 여러 대의 분산 서버에서 대량의 데이터를 처리하는 분산 메시징 시스템
- 메시지를 받고, 받은 메시지를 다른 시스템이나 장치에 보내기 위해 사용
- 카프카의 실현 4가지
  1. **확장성:** 여러 서버로 확장 구성할 수 있기 때문에 데이터 양에 따라 시스템 확장 가능
  2. **영속성:** 수신한 데이터를 '디스크에 유지'할 수 있기 때문에 언제라도 데이터를 읽을 수 있음
  3. **유연성:** '연계할 수 있는 제품이 많기' 때문에 제품이나 시스템을 연결하는 허브 역할을함
  4. **신뢰성:** ''메시지 전달 보증''을 하므로 데이터 분시을 걱정하지 않아도 됨

- 카프카 자체가 높은 처리량으로 데이터를 실시간 처리하는 처리 성능에 초점을 두었음

## 카프카 탄생 배경

### 링크드인의 시스템 요구사항

- 카프카는 2011년 링크드인에서 출발, 웹사이트에서 생성되는 로그를 처리하여 웹사이트 활동을 추적하는 것을 목적으로 개발
- 링크드인의 실현 목표
  1. **높은 처리량으로 실시간 처리**
     - 전 세계 사용자의 방대한 엑세스 데이터를 처리하기 위해 우수한 처리량 필수
  2. **임의의 타임이에 데이터를 읽기**
     - 실시간처리 뿐만아니라 기존에 있는 데이터를 처리할 버퍼 역할 포함
  3. **다양한 제품과 시스템에 쉽게 연동**
     - 이용 목적에 따라 DB, 데이터웨어하우스, 하둡 등의 다른 제품과의 쉬운 연결
  4. **메시지를 잃지 않음**
     - 취급하는 메시지가 방대하더라도 메시지를 잃어서는 안됨.

### 카프카 이전 제품

#### 메시지큐

- IBM WebSphere MQ, RabbitMQ, ActiveMQ 등이 있음
- 링크드인에서 요구하는 사항과 일치하지 않는 사항들
  - **강력한 전달 보증이 오버스펙:** IBM WebSphere MQ는 메시지 단위로 트랜잭션을 지원하는 기능이 있음 이런 기능은 하나의 메시지가 정확하게 한번만 전송되는 것을 보장할 수 있지만 링크드인에서 다루는 로그의 성질을 고려하면 오버스펙이였음. 높은 처리량이 우선이여서 배제
  - **스케일 아웃이 용이한 제품이 아님:** 대량의 메시지를 처리하는데 1대의 서버로만 대응하는 것은 한계가 있음 기존 제품들도 클러스터 구성이 가능한것이 있었지만 실제로는 가용성을 위한 중복 구성에 주안점을 두고 있었음. 단순히 처리량을 높이는 목적으로 스케일 아웃 기능을 한 제품은 없었음
  - **메시지가 대량으로 쌓이는 것을 예상하지 않음:** 기존의 메시지 큐는 즉시 이용되는것을 예상했지만 장시간 대량을 축척하는 것을 예상하지 않았음 링크드인에서는 실시간뿐만아니라 대량의 배치처리도 가정하고 있었으므로 시존 메시지 큐로 감당 불가능

#### 로그 수집 시스템

- 페이스북의 Scribe, 클라우데라의 Flume
- 각 프론트엔드 서버가 중계용 서버에 로그를 전달하고 거기서 로그를 수집하여 데이터베이스와 분산파일 시스템 HDFS(Hadoop Distributed File System)에 축적함
- 링크드인에서 요구하는 사항과 일치하지 않는 사항들
  - **HDFS로 데이터 축적과 배치 처리만 고려함**: 링크드인에서도 하둡을 사용했지만 데이터 웨어하우스를 이용한 데이터 분석도 실시하고 있어서 배제, 또한 데이터를 배치 뿐만아니라 실시간으로 처리하고자 하는 요구가 있었음
  - **알기 쉬운 API가 없음:** 카프카 이전의 제품은 미들웨어 내의 구현 사양을 모르면 사용하기 힘들다는 지적이 있었음 데이터 송신 수신에 있어서 이용하기 쉬운 API가 필요했음
  - **수신하는 쪽이 임의로 메시지를 수신하기 어려움:** 기존제품들은 송신시스템에 push에 의존했지만 수신시스템이 pull 하는 방식이 오히려 더 사용하기 쉽다고 생각함

## 카프카로 링크드인 요구 사항 실현하기

- 요구사항
  1. 높은 처리량으로 실시간 처리를 한다
  2. 임의의 타이밍에 데이터를 읽는다
  3. 다양한 제품과 시스템에 쉽게 연동한다
  4. 메시지를 잃지 않는다.
- 실현 수단
  1. 메시징 모델과 스케일 아웃형 아키텍처
  2. 디스크로의 데이터 영속화
  3. 이해하기 쉬운 api 제공
  4. 전달 보증

### 메시징 모델과 스케일 아웃

- 여기에 해당하는 요구사항
  1. 높은 처리량으로 실시간 처리를 한다
  2. 임의의 타이밍에 데이터를 읽는다
  3. 다양한 제품과 시스템에 쉽게 연동한다

- 이러한 요구사항을 해걸하기 위해 카프카는 메시징 모델을 채용함
- 일반적으로 메시징 모델은 다음 세가지 요소로 구성됨
  1. **Producer:** 메시지 생산자
  2. **Broker:** 메시지 수집/전달 역할
  3. **Consumer:** 메시지 소비자

- Producer -> Broker -> Consumer

#### 큐잉 모델

- 브로커 안에 큐를 준비해 프로듀서의 메시지가 큐에 담기고 컨슈머가 큐에서 메시지를 추출함
- 하나의 큐에 대해 컨슈머가 여러개 존재하는 것을 생각할 수 있음
- 메시지는 하나의 컨슈머에게만 보장함
- 큐에서 여러개의 컨슈머가 메시지를 추출할 수 있어 컨슈머에 의한 병렬 처리 가능
- 하나의 메시지는 여러 컨슈머 중 어느 하나에서 처리함

#### 펍/섭 메시징 모델

- 이 모델에서는 프로듀서를 퍼블리셔, 컨슈머를 서브스크라이버 라고함
- 역시 브로커의 개념이 있음
- 퍼블리셔는 누가 그 메시지를 수신하는지 알 수 없고 브로커에 있는 토픽이라고 불리는 카테고리 안에 메시지를 등록함
- 퍼블리셔는 브로커에게 메시지를 보내기만하고 그 메시지를 이용하는건 신경쓰지 않음
- 퍼블리셔의 메세지는 브로커 내의 토픽이라 불리는 부분에 등록함
- 서브스크라이버는 여러개 존재하는 토픽 중 하나를 선택하여 메시지를 받음 여러 서비스크라이버가 동일한 토픽을 구독하기로 결정했다면 이 여러 서브스크라이버는 동일한 메시지를 받게됨 큐잉모델과 다른점

#### 프로듀서/컨슈머 사이에 브로커를 끼우는 장점

- **프로듀서/컨슈머 모두 접속처를 하나로 할 수 있다:** 프로듀서는 메시지를 단순히 브로커로만 보내면되고 컨슈머는 브로커에서 수신만 하면됨.
- **프로듀서/컨슈머 증감에 대응할 수 있음:** 서로의 존재를 모르기때문에 증감에 유연하게 동작 가능

#### 큐잉모델과 펍/섭 메시징 모델

- 큐잉모델과 펍/섭 메시징모델의 가장 큰 차이는 메시지를 소비하는 형식인데 펍/섭 모델의 경우 전부 다 같은 메시지를 소비하기 때문에 병렬로 동작하는 복수의 서브스크라이버에게 메시지를 전달하는 장점이 있지만 처리 능력을 높이는 효과는 없음

### 카프카 메시징 모델

- 카프카는 큐잉모델과 펍/섭모델로 구성되어 있고 이 모델을 실현하기 위해 컨슈머 그룹 이라는 개념을 도입해서 컨슈머를 확장 구성할 수 있도록 설계했음
- 브로커가 1대라면 병목이 될 수 있기때문에 브로커 역시 복수 구성이 가능함

### 디스크로의 데이터 영속화

- 여기에 해당하는 요구사항
  1. 임의의 타이밍에 데이터를 읽는다
  2. 메시지를 잃지 않는다.

- 카프카의 영속화는 디스크에서 이루어짐. 카프카는 **디스크에 영속화함에도 불구하고 높은 처리량을 제공**한다는 특징이 있음
- 카프카는 들어오는 데이터를 받아 한 묶음으로 장기간 영속화 시킬 수 있어서 **스토리지 시스템**으로도 간주할 수 있음



### 이해하기 쉬운 API 제공

- 여기에 해당하는 요구사항
  1. 다양한 제품과 시스템에 쉽게 연동
- 카프카는 프로듀서와 컨슈머를 쉽게 접속할 수 있도록 **Connect API**를 제공함 이 api를 이용하여 각종 외부 시스템과 접속하고 API를 기반으로 카프카에 접속하기 위한 프레임워크로 Kafka Connect도 제공함
- 데이터베이스, 키 밸류 스토어, 검색인덱스 등의 다양한 커넥터가 존재함
- Kafka streams로 입출력에 사용하는 스트림 처리 에플리케이션을 쉽게 구축 가능함

### 전달 보증

- 여기에 해당하는 요구사항
  1. 메시지를 잃지 않음
- 카프카의 전달 보증 수준

| 종류          | 개요                    | 재전송 유무 | 중복 삭제 유무 | 비고                                                         |
| ------------- | ----------------------- | ----------- | -------------- | ------------------------------------------------------------ |
| At Most Once  | 1회는 전달을 시도해본다 | X           | X              | 메시지는 중복되지 않지만 상실될 수 있다                      |
| At Least Once | 적어도 1회는 전달한다   | O           | X              | 메시지가 중복될 가능성은 있지만 상실되지 않는다.             |
| Exactly Once  | 1회만 전달한다.         | O           | O              | 중복되거나 상실되지도 않고 확실하게 메시지가 도달하지만 성능이 나오기가 힘들다. |

- 기존 MQ는 Exactly Once 수준을 주 목적으로 하는 경우가 많았음
- **At Least Once:** At Least Once를 실현하기 위해 Ack와 오프셋 커밋이라는 개념을 도입함 Ack는 브로커가 메시지를 수신했을 때 프로듀서에게 수신 완료 했다는 응답을 뜻함 이것으로 메시지 상실을 판단, 컨슈머가 어디까지 메세지를 받았는지 관리하기 위한 오프셋이 있고 이 전달 범위 보증의 구조를 오프셋 커밋이라고함. 이 오프셋 커밋을 통해서 메시지 재전송시에 어디서부터 재전송하면 되는지 판단 가능
- **Exactly Once:** 구체적으로 쌍방간의 실현이 모두 필요함 프로듀서와 브로커의 상호교환 사이, 컨슈머와 브로커의 상호 교환 사이 자세한 설명은 그림 



## 카프카의 확산

- 2011년 0.7 버전 출시 이후 2018년 7월 2.0 출시, 지속적인 활발한 오픈소스
- 링크드인, 야후, 넷플릭스, 시스코, 골드만삭스, 트위터, 우버, 마이크로소프트 등 굉장히 많은 기업에서 이미 카프카를 사용하고 있음





